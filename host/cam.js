/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let Ly, By;
function Oy() {
  return {
    geminiUrl: Ly,
    vertexUrl: By
  };
}
function Uy(n, e, t, r) {
  var o, i;
  if (!(n != null && n.baseUrl)) {
    const a = Oy();
    return e ? (o = a.vertexUrl) !== null && o !== void 0 ? o : t : (i = a.geminiUrl) !== null && i !== void 0 ? i : r;
  }
  return n.baseUrl;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class go {
}
function Q(n, e) {
  const t = /\{([^}]+)\}/g;
  return n.replace(t, (r, o) => {
    if (Object.prototype.hasOwnProperty.call(e, o)) {
      const i = e[o];
      return i != null ? String(i) : "";
    } else
      throw new Error(`Key '${o}' not found in valueMap.`);
  });
}
function m(n, e, t) {
  for (let i = 0; i < e.length - 1; i++) {
    const a = e[i];
    if (a.endsWith("[]")) {
      const s = a.slice(0, -2);
      if (!(s in n))
        if (Array.isArray(t))
          n[s] = Array.from({ length: t.length }, () => ({}));
        else
          throw new Error(`Value must be a list given an array path ${a}`);
      if (Array.isArray(n[s])) {
        const u = n[s];
        if (Array.isArray(t))
          for (let l = 0; l < u.length; l++) {
            const c = u[l];
            m(c, e.slice(i + 1), t[l]);
          }
        else
          for (const l of u)
            m(l, e.slice(i + 1), t);
      }
      return;
    } else if (a.endsWith("[0]")) {
      const s = a.slice(0, -3);
      s in n || (n[s] = [{}]);
      const u = n[s];
      m(u[0], e.slice(i + 1), t);
      return;
    }
    (!n[a] || typeof n[a] != "object") && (n[a] = {}), n = n[a];
  }
  const r = e[e.length - 1], o = n[r];
  if (o !== void 0) {
    if (!t || typeof t == "object" && Object.keys(t).length === 0 || t === o)
      return;
    if (typeof o == "object" && typeof t == "object" && o !== null && t !== null)
      Object.assign(o, t);
    else
      throw new Error(`Cannot set value for an existing key. Key: ${r}`);
  } else
    r === "_self" && typeof t == "object" && t !== null && !Array.isArray(t) ? Object.assign(n, t) : n[r] = t;
}
function h(n, e, t = void 0) {
  try {
    if (e.length === 1 && e[0] === "_self")
      return n;
    for (let r = 0; r < e.length; r++) {
      if (typeof n != "object" || n === null)
        return t;
      const o = e[r];
      if (o.endsWith("[]")) {
        const i = o.slice(0, -2);
        if (i in n) {
          const a = n[i];
          return Array.isArray(a) ? a.map((s) => h(s, e.slice(r + 1), t)) : t;
        } else
          return t;
      } else
        n = n[o];
    }
    return n;
  } catch (r) {
    if (r instanceof TypeError)
      return t;
    throw r;
  }
}
function Vy(n, e) {
  for (const [t, r] of Object.entries(e)) {
    const o = t.split("."), i = r.split("."), a = /* @__PURE__ */ new Set();
    let s = -1;
    for (let u = 0; u < o.length; u++)
      if (o[u] === "*") {
        s = u;
        break;
      }
    if (s !== -1 && i.length > s)
      for (let u = s; u < i.length; u++) {
        const l = i[u];
        l !== "*" && !l.endsWith("[]") && !l.endsWith("[0]") && a.add(l);
      }
    cl(n, o, i, 0, a);
  }
}
function cl(n, e, t, r, o) {
  if (r >= e.length || typeof n != "object" || n === null)
    return;
  const i = e[r];
  if (i.endsWith("[]")) {
    const a = i.slice(0, -2), s = n;
    if (a in s && Array.isArray(s[a]))
      for (const u of s[a])
        cl(u, e, t, r + 1, o);
  } else if (i === "*") {
    if (typeof n == "object" && n !== null && !Array.isArray(n)) {
      const a = n, s = Object.keys(a).filter((l) => !l.startsWith("_") && !o.has(l)), u = {};
      for (const l of s)
        u[l] = a[l];
      for (const [l, c] of Object.entries(u)) {
        const f = [];
        for (const d of t.slice(r))
          d === "*" ? f.push(l) : f.push(d);
        m(a, f, c);
      }
      for (const l of s)
        delete a[l];
    }
  } else {
    const a = n;
    i in a && cl(a[i], e, t, r + 1, o);
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function lc(n) {
  if (typeof n != "string")
    throw new Error("fromImageBytes must be a string");
  return n;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function Gy(n) {
  const e = {}, t = h(n, [
    "operationName"
  ]);
  t != null && m(e, ["operationName"], t);
  const r = h(n, ["resourceName"]);
  return r != null && m(e, ["_url", "resourceName"], r), e;
}
function Wy(n) {
  const e = {}, t = h(n, ["name"]);
  t != null && m(e, ["name"], t);
  const r = h(n, ["metadata"]);
  r != null && m(e, ["metadata"], r);
  const o = h(n, ["done"]);
  o != null && m(e, ["done"], o);
  const i = h(n, ["error"]);
  i != null && m(e, ["error"], i);
  const a = h(n, [
    "response",
    "generateVideoResponse"
  ]);
  return a != null && m(e, ["response"], $y(a)), e;
}
function Hy(n) {
  const e = {}, t = h(n, ["name"]);
  t != null && m(e, ["name"], t);
  const r = h(n, ["metadata"]);
  r != null && m(e, ["metadata"], r);
  const o = h(n, ["done"]);
  o != null && m(e, ["done"], o);
  const i = h(n, ["error"]);
  i != null && m(e, ["error"], i);
  const a = h(n, ["response"]);
  return a != null && m(e, ["response"], qy(a)), e;
}
function $y(n) {
  const e = {}, t = h(n, [
    "generatedSamples"
  ]);
  if (t != null) {
    let i = t;
    Array.isArray(i) && (i = i.map((a) => zy(a))), m(e, ["generatedVideos"], i);
  }
  const r = h(n, [
    "raiMediaFilteredCount"
  ]);
  r != null && m(e, ["raiMediaFilteredCount"], r);
  const o = h(n, [
    "raiMediaFilteredReasons"
  ]);
  return o != null && m(e, ["raiMediaFilteredReasons"], o), e;
}
function qy(n) {
  const e = {}, t = h(n, ["videos"]);
  if (t != null) {
    let i = t;
    Array.isArray(i) && (i = i.map((a) => Ky(a))), m(e, ["generatedVideos"], i);
  }
  const r = h(n, [
    "raiMediaFilteredCount"
  ]);
  r != null && m(e, ["raiMediaFilteredCount"], r);
  const o = h(n, [
    "raiMediaFilteredReasons"
  ]);
  return o != null && m(e, ["raiMediaFilteredReasons"], o), e;
}
function zy(n) {
  const e = {}, t = h(n, ["video"]);
  return t != null && m(e, ["video"], Yy(t)), e;
}
function Ky(n) {
  const e = {}, t = h(n, ["_self"]);
  return t != null && m(e, ["video"], Qy(t)), e;
}
function Jy(n) {
  const e = {}, t = h(n, [
    "operationName"
  ]);
  return t != null && m(e, ["_url", "operationName"], t), e;
}
function Xy(n) {
  const e = {}, t = h(n, [
    "operationName"
  ]);
  return t != null && m(e, ["_url", "operationName"], t), e;
}
function Yy(n) {
  const e = {}, t = h(n, ["uri"]);
  t != null && m(e, ["uri"], t);
  const r = h(n, ["encodedVideo"]);
  r != null && m(e, ["videoBytes"], lc(r));
  const o = h(n, ["encoding"]);
  return o != null && m(e, ["mimeType"], o), e;
}
function Qy(n) {
  const e = {}, t = h(n, ["gcsUri"]);
  t != null && m(e, ["uri"], t);
  const r = h(n, [
    "bytesBase64Encoded"
  ]);
  r != null && m(e, ["videoBytes"], lc(r));
  const o = h(n, ["mimeType"]);
  return o != null && m(e, ["mimeType"], o), e;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var wd;
(function(n) {
  n.OUTCOME_UNSPECIFIED = "OUTCOME_UNSPECIFIED", n.OUTCOME_OK = "OUTCOME_OK", n.OUTCOME_FAILED = "OUTCOME_FAILED", n.OUTCOME_DEADLINE_EXCEEDED = "OUTCOME_DEADLINE_EXCEEDED";
})(wd || (wd = {}));
var _d;
(function(n) {
  n.LANGUAGE_UNSPECIFIED = "LANGUAGE_UNSPECIFIED", n.PYTHON = "PYTHON";
})(_d || (_d = {}));
var bd;
(function(n) {
  n.SCHEDULING_UNSPECIFIED = "SCHEDULING_UNSPECIFIED", n.SILENT = "SILENT", n.WHEN_IDLE = "WHEN_IDLE", n.INTERRUPT = "INTERRUPT";
})(bd || (bd = {}));
var Pr;
(function(n) {
  n.TYPE_UNSPECIFIED = "TYPE_UNSPECIFIED", n.STRING = "STRING", n.NUMBER = "NUMBER", n.INTEGER = "INTEGER", n.BOOLEAN = "BOOLEAN", n.ARRAY = "ARRAY", n.OBJECT = "OBJECT", n.NULL = "NULL";
})(Pr || (Pr = {}));
var Ed;
(function(n) {
  n.MODE_UNSPECIFIED = "MODE_UNSPECIFIED", n.MODE_DYNAMIC = "MODE_DYNAMIC";
})(Ed || (Ed = {}));
var Cd;
(function(n) {
  n.AUTH_TYPE_UNSPECIFIED = "AUTH_TYPE_UNSPECIFIED", n.NO_AUTH = "NO_AUTH", n.API_KEY_AUTH = "API_KEY_AUTH", n.HTTP_BASIC_AUTH = "HTTP_BASIC_AUTH", n.GOOGLE_SERVICE_ACCOUNT_AUTH = "GOOGLE_SERVICE_ACCOUNT_AUTH", n.OAUTH = "OAUTH", n.OIDC_AUTH = "OIDC_AUTH";
})(Cd || (Cd = {}));
var Td;
(function(n) {
  n.API_SPEC_UNSPECIFIED = "API_SPEC_UNSPECIFIED", n.SIMPLE_SEARCH = "SIMPLE_SEARCH", n.ELASTIC_SEARCH = "ELASTIC_SEARCH";
})(Td || (Td = {}));
var Id;
(function(n) {
  n.HARM_CATEGORY_UNSPECIFIED = "HARM_CATEGORY_UNSPECIFIED", n.HARM_CATEGORY_HARASSMENT = "HARM_CATEGORY_HARASSMENT", n.HARM_CATEGORY_HATE_SPEECH = "HARM_CATEGORY_HATE_SPEECH", n.HARM_CATEGORY_SEXUALLY_EXPLICIT = "HARM_CATEGORY_SEXUALLY_EXPLICIT", n.HARM_CATEGORY_DANGEROUS_CONTENT = "HARM_CATEGORY_DANGEROUS_CONTENT", n.HARM_CATEGORY_CIVIC_INTEGRITY = "HARM_CATEGORY_CIVIC_INTEGRITY", n.HARM_CATEGORY_IMAGE_HATE = "HARM_CATEGORY_IMAGE_HATE", n.HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT = "HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT", n.HARM_CATEGORY_IMAGE_HARASSMENT = "HARM_CATEGORY_IMAGE_HARASSMENT", n.HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT = "HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT", n.HARM_CATEGORY_JAILBREAK = "HARM_CATEGORY_JAILBREAK";
})(Id || (Id = {}));
var Sd;
(function(n) {
  n.HARM_BLOCK_METHOD_UNSPECIFIED = "HARM_BLOCK_METHOD_UNSPECIFIED", n.SEVERITY = "SEVERITY", n.PROBABILITY = "PROBABILITY";
})(Sd || (Sd = {}));
var Ad;
(function(n) {
  n.HARM_BLOCK_THRESHOLD_UNSPECIFIED = "HARM_BLOCK_THRESHOLD_UNSPECIFIED", n.BLOCK_LOW_AND_ABOVE = "BLOCK_LOW_AND_ABOVE", n.BLOCK_MEDIUM_AND_ABOVE = "BLOCK_MEDIUM_AND_ABOVE", n.BLOCK_ONLY_HIGH = "BLOCK_ONLY_HIGH", n.BLOCK_NONE = "BLOCK_NONE", n.OFF = "OFF";
})(Ad || (Ad = {}));
var Rd;
(function(n) {
  n.FINISH_REASON_UNSPECIFIED = "FINISH_REASON_UNSPECIFIED", n.STOP = "STOP", n.MAX_TOKENS = "MAX_TOKENS", n.SAFETY = "SAFETY", n.RECITATION = "RECITATION", n.LANGUAGE = "LANGUAGE", n.OTHER = "OTHER", n.BLOCKLIST = "BLOCKLIST", n.PROHIBITED_CONTENT = "PROHIBITED_CONTENT", n.SPII = "SPII", n.MALFORMED_FUNCTION_CALL = "MALFORMED_FUNCTION_CALL", n.IMAGE_SAFETY = "IMAGE_SAFETY", n.UNEXPECTED_TOOL_CALL = "UNEXPECTED_TOOL_CALL", n.IMAGE_PROHIBITED_CONTENT = "IMAGE_PROHIBITED_CONTENT", n.NO_IMAGE = "NO_IMAGE";
})(Rd || (Rd = {}));
var kd;
(function(n) {
  n.HARM_PROBABILITY_UNSPECIFIED = "HARM_PROBABILITY_UNSPECIFIED", n.NEGLIGIBLE = "NEGLIGIBLE", n.LOW = "LOW", n.MEDIUM = "MEDIUM", n.HIGH = "HIGH";
})(kd || (kd = {}));
var Pd;
(function(n) {
  n.HARM_SEVERITY_UNSPECIFIED = "HARM_SEVERITY_UNSPECIFIED", n.HARM_SEVERITY_NEGLIGIBLE = "HARM_SEVERITY_NEGLIGIBLE", n.HARM_SEVERITY_LOW = "HARM_SEVERITY_LOW", n.HARM_SEVERITY_MEDIUM = "HARM_SEVERITY_MEDIUM", n.HARM_SEVERITY_HIGH = "HARM_SEVERITY_HIGH";
})(Pd || (Pd = {}));
var Nd;
(function(n) {
  n.URL_RETRIEVAL_STATUS_UNSPECIFIED = "URL_RETRIEVAL_STATUS_UNSPECIFIED", n.URL_RETRIEVAL_STATUS_SUCCESS = "URL_RETRIEVAL_STATUS_SUCCESS", n.URL_RETRIEVAL_STATUS_ERROR = "URL_RETRIEVAL_STATUS_ERROR", n.URL_RETRIEVAL_STATUS_PAYWALL = "URL_RETRIEVAL_STATUS_PAYWALL", n.URL_RETRIEVAL_STATUS_UNSAFE = "URL_RETRIEVAL_STATUS_UNSAFE";
})(Nd || (Nd = {}));
var Md;
(function(n) {
  n.BLOCKED_REASON_UNSPECIFIED = "BLOCKED_REASON_UNSPECIFIED", n.SAFETY = "SAFETY", n.OTHER = "OTHER", n.BLOCKLIST = "BLOCKLIST", n.PROHIBITED_CONTENT = "PROHIBITED_CONTENT", n.IMAGE_SAFETY = "IMAGE_SAFETY", n.MODEL_ARMOR = "MODEL_ARMOR", n.JAILBREAK = "JAILBREAK";
})(Md || (Md = {}));
var Dd;
(function(n) {
  n.TRAFFIC_TYPE_UNSPECIFIED = "TRAFFIC_TYPE_UNSPECIFIED", n.ON_DEMAND = "ON_DEMAND", n.PROVISIONED_THROUGHPUT = "PROVISIONED_THROUGHPUT";
})(Dd || (Dd = {}));
var $i;
(function(n) {
  n.MODALITY_UNSPECIFIED = "MODALITY_UNSPECIFIED", n.TEXT = "TEXT", n.IMAGE = "IMAGE", n.AUDIO = "AUDIO";
})($i || ($i = {}));
var Fd;
(function(n) {
  n.MEDIA_RESOLUTION_UNSPECIFIED = "MEDIA_RESOLUTION_UNSPECIFIED", n.MEDIA_RESOLUTION_LOW = "MEDIA_RESOLUTION_LOW", n.MEDIA_RESOLUTION_MEDIUM = "MEDIA_RESOLUTION_MEDIUM", n.MEDIA_RESOLUTION_HIGH = "MEDIA_RESOLUTION_HIGH";
})(Fd || (Fd = {}));
var Ld;
(function(n) {
  n.TUNING_MODE_UNSPECIFIED = "TUNING_MODE_UNSPECIFIED", n.TUNING_MODE_FULL = "TUNING_MODE_FULL", n.TUNING_MODE_PEFT_ADAPTER = "TUNING_MODE_PEFT_ADAPTER";
})(Ld || (Ld = {}));
var Bd;
(function(n) {
  n.ADAPTER_SIZE_UNSPECIFIED = "ADAPTER_SIZE_UNSPECIFIED", n.ADAPTER_SIZE_ONE = "ADAPTER_SIZE_ONE", n.ADAPTER_SIZE_TWO = "ADAPTER_SIZE_TWO", n.ADAPTER_SIZE_FOUR = "ADAPTER_SIZE_FOUR", n.ADAPTER_SIZE_EIGHT = "ADAPTER_SIZE_EIGHT", n.ADAPTER_SIZE_SIXTEEN = "ADAPTER_SIZE_SIXTEEN", n.ADAPTER_SIZE_THIRTY_TWO = "ADAPTER_SIZE_THIRTY_TWO";
})(Bd || (Bd = {}));
var fl;
(function(n) {
  n.JOB_STATE_UNSPECIFIED = "JOB_STATE_UNSPECIFIED", n.JOB_STATE_QUEUED = "JOB_STATE_QUEUED", n.JOB_STATE_PENDING = "JOB_STATE_PENDING", n.JOB_STATE_RUNNING = "JOB_STATE_RUNNING", n.JOB_STATE_SUCCEEDED = "JOB_STATE_SUCCEEDED", n.JOB_STATE_FAILED = "JOB_STATE_FAILED", n.JOB_STATE_CANCELLING = "JOB_STATE_CANCELLING", n.JOB_STATE_CANCELLED = "JOB_STATE_CANCELLED", n.JOB_STATE_PAUSED = "JOB_STATE_PAUSED", n.JOB_STATE_EXPIRED = "JOB_STATE_EXPIRED", n.JOB_STATE_UPDATING = "JOB_STATE_UPDATING", n.JOB_STATE_PARTIALLY_SUCCEEDED = "JOB_STATE_PARTIALLY_SUCCEEDED";
})(fl || (fl = {}));
var Od;
(function(n) {
  n.TUNING_TASK_UNSPECIFIED = "TUNING_TASK_UNSPECIFIED", n.TUNING_TASK_I2V = "TUNING_TASK_I2V", n.TUNING_TASK_T2V = "TUNING_TASK_T2V";
})(Od || (Od = {}));
var Ud;
(function(n) {
  n.FEATURE_SELECTION_PREFERENCE_UNSPECIFIED = "FEATURE_SELECTION_PREFERENCE_UNSPECIFIED", n.PRIORITIZE_QUALITY = "PRIORITIZE_QUALITY", n.BALANCED = "BALANCED", n.PRIORITIZE_COST = "PRIORITIZE_COST";
})(Ud || (Ud = {}));
var Vd;
(function(n) {
  n.UNSPECIFIED = "UNSPECIFIED", n.BLOCKING = "BLOCKING", n.NON_BLOCKING = "NON_BLOCKING";
})(Vd || (Vd = {}));
var Gd;
(function(n) {
  n.MODE_UNSPECIFIED = "MODE_UNSPECIFIED", n.MODE_DYNAMIC = "MODE_DYNAMIC";
})(Gd || (Gd = {}));
var Wd;
(function(n) {
  n.ENVIRONMENT_UNSPECIFIED = "ENVIRONMENT_UNSPECIFIED", n.ENVIRONMENT_BROWSER = "ENVIRONMENT_BROWSER";
})(Wd || (Wd = {}));
var Hd;
(function(n) {
  n.MODE_UNSPECIFIED = "MODE_UNSPECIFIED", n.AUTO = "AUTO", n.ANY = "ANY", n.NONE = "NONE", n.VALIDATED = "VALIDATED";
})(Hd || (Hd = {}));
var $d;
(function(n) {
  n.BLOCK_LOW_AND_ABOVE = "BLOCK_LOW_AND_ABOVE", n.BLOCK_MEDIUM_AND_ABOVE = "BLOCK_MEDIUM_AND_ABOVE", n.BLOCK_ONLY_HIGH = "BLOCK_ONLY_HIGH", n.BLOCK_NONE = "BLOCK_NONE";
})($d || ($d = {}));
var qd;
(function(n) {
  n.DONT_ALLOW = "DONT_ALLOW", n.ALLOW_ADULT = "ALLOW_ADULT", n.ALLOW_ALL = "ALLOW_ALL";
})(qd || (qd = {}));
var zd;
(function(n) {
  n.auto = "auto", n.en = "en", n.ja = "ja", n.ko = "ko", n.hi = "hi", n.zh = "zh", n.pt = "pt", n.es = "es";
})(zd || (zd = {}));
var Kd;
(function(n) {
  n.MASK_MODE_DEFAULT = "MASK_MODE_DEFAULT", n.MASK_MODE_USER_PROVIDED = "MASK_MODE_USER_PROVIDED", n.MASK_MODE_BACKGROUND = "MASK_MODE_BACKGROUND", n.MASK_MODE_FOREGROUND = "MASK_MODE_FOREGROUND", n.MASK_MODE_SEMANTIC = "MASK_MODE_SEMANTIC";
})(Kd || (Kd = {}));
var Jd;
(function(n) {
  n.CONTROL_TYPE_DEFAULT = "CONTROL_TYPE_DEFAULT", n.CONTROL_TYPE_CANNY = "CONTROL_TYPE_CANNY", n.CONTROL_TYPE_SCRIBBLE = "CONTROL_TYPE_SCRIBBLE", n.CONTROL_TYPE_FACE_MESH = "CONTROL_TYPE_FACE_MESH";
})(Jd || (Jd = {}));
var Xd;
(function(n) {
  n.SUBJECT_TYPE_DEFAULT = "SUBJECT_TYPE_DEFAULT", n.SUBJECT_TYPE_PERSON = "SUBJECT_TYPE_PERSON", n.SUBJECT_TYPE_ANIMAL = "SUBJECT_TYPE_ANIMAL", n.SUBJECT_TYPE_PRODUCT = "SUBJECT_TYPE_PRODUCT";
})(Xd || (Xd = {}));
var Yd;
(function(n) {
  n.EDIT_MODE_DEFAULT = "EDIT_MODE_DEFAULT", n.EDIT_MODE_INPAINT_REMOVAL = "EDIT_MODE_INPAINT_REMOVAL", n.EDIT_MODE_INPAINT_INSERTION = "EDIT_MODE_INPAINT_INSERTION", n.EDIT_MODE_OUTPAINT = "EDIT_MODE_OUTPAINT", n.EDIT_MODE_CONTROLLED_EDITING = "EDIT_MODE_CONTROLLED_EDITING", n.EDIT_MODE_STYLE = "EDIT_MODE_STYLE", n.EDIT_MODE_BGSWAP = "EDIT_MODE_BGSWAP", n.EDIT_MODE_PRODUCT_IMAGE = "EDIT_MODE_PRODUCT_IMAGE";
})(Yd || (Yd = {}));
var Qd;
(function(n) {
  n.FOREGROUND = "FOREGROUND", n.BACKGROUND = "BACKGROUND", n.PROMPT = "PROMPT", n.SEMANTIC = "SEMANTIC", n.INTERACTIVE = "INTERACTIVE";
})(Qd || (Qd = {}));
var Zd;
(function(n) {
  n.ASSET = "ASSET", n.STYLE = "STYLE";
})(Zd || (Zd = {}));
var jd;
(function(n) {
  n.INSERT = "INSERT", n.REMOVE = "REMOVE", n.REMOVE_STATIC = "REMOVE_STATIC", n.OUTPAINT = "OUTPAINT";
})(jd || (jd = {}));
var eh;
(function(n) {
  n.OPTIMIZED = "OPTIMIZED", n.LOSSLESS = "LOSSLESS";
})(eh || (eh = {}));
var th;
(function(n) {
  n.SUPERVISED_FINE_TUNING = "SUPERVISED_FINE_TUNING", n.PREFERENCE_TUNING = "PREFERENCE_TUNING";
})(th || (th = {}));
var nh;
(function(n) {
  n.STATE_UNSPECIFIED = "STATE_UNSPECIFIED", n.PROCESSING = "PROCESSING", n.ACTIVE = "ACTIVE", n.FAILED = "FAILED";
})(nh || (nh = {}));
var rh;
(function(n) {
  n.SOURCE_UNSPECIFIED = "SOURCE_UNSPECIFIED", n.UPLOADED = "UPLOADED", n.GENERATED = "GENERATED";
})(rh || (rh = {}));
var oh;
(function(n) {
  n.TURN_COMPLETE_REASON_UNSPECIFIED = "TURN_COMPLETE_REASON_UNSPECIFIED", n.MALFORMED_FUNCTION_CALL = "MALFORMED_FUNCTION_CALL", n.RESPONSE_REJECTED = "RESPONSE_REJECTED", n.NEED_MORE_INPUT = "NEED_MORE_INPUT";
})(oh || (oh = {}));
var ih;
(function(n) {
  n.MODALITY_UNSPECIFIED = "MODALITY_UNSPECIFIED", n.TEXT = "TEXT", n.IMAGE = "IMAGE", n.VIDEO = "VIDEO", n.AUDIO = "AUDIO", n.DOCUMENT = "DOCUMENT";
})(ih || (ih = {}));
var ah;
(function(n) {
  n.START_SENSITIVITY_UNSPECIFIED = "START_SENSITIVITY_UNSPECIFIED", n.START_SENSITIVITY_HIGH = "START_SENSITIVITY_HIGH", n.START_SENSITIVITY_LOW = "START_SENSITIVITY_LOW";
})(ah || (ah = {}));
var sh;
(function(n) {
  n.END_SENSITIVITY_UNSPECIFIED = "END_SENSITIVITY_UNSPECIFIED", n.END_SENSITIVITY_HIGH = "END_SENSITIVITY_HIGH", n.END_SENSITIVITY_LOW = "END_SENSITIVITY_LOW";
})(sh || (sh = {}));
var uh;
(function(n) {
  n.ACTIVITY_HANDLING_UNSPECIFIED = "ACTIVITY_HANDLING_UNSPECIFIED", n.START_OF_ACTIVITY_INTERRUPTS = "START_OF_ACTIVITY_INTERRUPTS", n.NO_INTERRUPTION = "NO_INTERRUPTION";
})(uh || (uh = {}));
var lh;
(function(n) {
  n.TURN_COVERAGE_UNSPECIFIED = "TURN_COVERAGE_UNSPECIFIED", n.TURN_INCLUDES_ONLY_ACTIVITY = "TURN_INCLUDES_ONLY_ACTIVITY", n.TURN_INCLUDES_ALL_INPUT = "TURN_INCLUDES_ALL_INPUT";
})(lh || (lh = {}));
var ch;
(function(n) {
  n.SCALE_UNSPECIFIED = "SCALE_UNSPECIFIED", n.C_MAJOR_A_MINOR = "C_MAJOR_A_MINOR", n.D_FLAT_MAJOR_B_FLAT_MINOR = "D_FLAT_MAJOR_B_FLAT_MINOR", n.D_MAJOR_B_MINOR = "D_MAJOR_B_MINOR", n.E_FLAT_MAJOR_C_MINOR = "E_FLAT_MAJOR_C_MINOR", n.E_MAJOR_D_FLAT_MINOR = "E_MAJOR_D_FLAT_MINOR", n.F_MAJOR_D_MINOR = "F_MAJOR_D_MINOR", n.G_FLAT_MAJOR_E_FLAT_MINOR = "G_FLAT_MAJOR_E_FLAT_MINOR", n.G_MAJOR_E_MINOR = "G_MAJOR_E_MINOR", n.A_FLAT_MAJOR_F_MINOR = "A_FLAT_MAJOR_F_MINOR", n.A_MAJOR_G_FLAT_MINOR = "A_MAJOR_G_FLAT_MINOR", n.B_FLAT_MAJOR_G_MINOR = "B_FLAT_MAJOR_G_MINOR", n.B_MAJOR_A_FLAT_MINOR = "B_MAJOR_A_FLAT_MINOR";
})(ch || (ch = {}));
var fh;
(function(n) {
  n.MUSIC_GENERATION_MODE_UNSPECIFIED = "MUSIC_GENERATION_MODE_UNSPECIFIED", n.QUALITY = "QUALITY", n.DIVERSITY = "DIVERSITY", n.VOCALIZATION = "VOCALIZATION";
})(fh || (fh = {}));
var Bo;
(function(n) {
  n.PLAYBACK_CONTROL_UNSPECIFIED = "PLAYBACK_CONTROL_UNSPECIFIED", n.PLAY = "PLAY", n.PAUSE = "PAUSE", n.STOP = "STOP", n.RESET_CONTEXT = "RESET_CONTEXT";
})(Bo || (Bo = {}));
class dl {
  constructor(e) {
    const t = {};
    for (const r of e.headers.entries())
      t[r[0]] = r[1];
    this.headers = t, this.responseInternal = e;
  }
  json() {
    return this.responseInternal.json();
  }
}
class Ai {
  /**
   * Returns the concatenation of all text parts from the first candidate in the response.
   *
   * @remarks
   * If there are multiple candidates in the response, the text from the first
   * one will be returned.
   * If there are non-text parts in the response, the concatenation of all text
   * parts will be returned, and a warning will be logged.
   * If there are thought parts in the response, the concatenation of all text
   * parts excluding the thought parts will be returned.
   *
   * @example
   * ```ts
   * const response = await ai.models.generateContent({
   *   model: 'gemini-2.0-flash',
   *   contents:
   *     'Why is the sky blue?',
   * });
   *
   * console.debug(response.text);
   * ```
   */
  get text() {
    var e, t, r, o, i, a, s, u;
    if (((o = (r = (t = (e = this.candidates) === null || e === void 0 ? void 0 : e[0]) === null || t === void 0 ? void 0 : t.content) === null || r === void 0 ? void 0 : r.parts) === null || o === void 0 ? void 0 : o.length) === 0)
      return;
    this.candidates && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning text from the first one.");
    let l = "", c = !1;
    const f = [];
    for (const d of (u = (s = (a = (i = this.candidates) === null || i === void 0 ? void 0 : i[0]) === null || a === void 0 ? void 0 : a.content) === null || s === void 0 ? void 0 : s.parts) !== null && u !== void 0 ? u : []) {
      for (const [p, v] of Object.entries(d))
        p !== "text" && p !== "thought" && (v !== null || v !== void 0) && f.push(p);
      if (typeof d.text == "string") {
        if (typeof d.thought == "boolean" && d.thought)
          continue;
        c = !0, l += d.text;
      }
    }
    return f.length > 0 && console.warn(`there are non-text parts ${f} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`), c ? l : void 0;
  }
  /**
   * Returns the concatenation of all inline data parts from the first candidate
   * in the response.
   *
   * @remarks
   * If there are multiple candidates in the response, the inline data from the
   * first one will be returned. If there are non-inline data parts in the
   * response, the concatenation of all inline data parts will be returned, and
   * a warning will be logged.
   */
  get data() {
    var e, t, r, o, i, a, s, u;
    if (((o = (r = (t = (e = this.candidates) === null || e === void 0 ? void 0 : e[0]) === null || t === void 0 ? void 0 : t.content) === null || r === void 0 ? void 0 : r.parts) === null || o === void 0 ? void 0 : o.length) === 0)
      return;
    this.candidates && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning data from the first one.");
    let l = "";
    const c = [];
    for (const f of (u = (s = (a = (i = this.candidates) === null || i === void 0 ? void 0 : i[0]) === null || a === void 0 ? void 0 : a.content) === null || s === void 0 ? void 0 : s.parts) !== null && u !== void 0 ? u : []) {
      for (const [d, p] of Object.entries(f))
        d !== "inlineData" && (p !== null || p !== void 0) && c.push(d);
      f.inlineData && typeof f.inlineData.data == "string" && (l += atob(f.inlineData.data));
    }
    return c.length > 0 && console.warn(`there are non-data parts ${c} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`), l.length > 0 ? btoa(l) : void 0;
  }
  /**
   * Returns the function calls from the first candidate in the response.
   *
   * @remarks
   * If there are multiple candidates in the response, the function calls from
   * the first one will be returned.
   * If there are no function calls in the response, undefined will be returned.
   *
   * @example
   * ```ts
   * const controlLightFunctionDeclaration: FunctionDeclaration = {
   *   name: 'controlLight',
   *   parameters: {
   *   type: Type.OBJECT,
   *   description: 'Set the brightness and color temperature of a room light.',
   *   properties: {
   *     brightness: {
   *       type: Type.NUMBER,
   *       description:
   *         'Light level from 0 to 100. Zero is off and 100 is full brightness.',
   *     },
   *     colorTemperature: {
   *       type: Type.STRING,
   *       description:
   *         'Color temperature of the light fixture which can be `daylight`, `cool` or `warm`.',
   *     },
   *   },
   *   required: ['brightness', 'colorTemperature'],
   *  };
   *  const response = await ai.models.generateContent({
   *     model: 'gemini-2.0-flash',
   *     contents: 'Dim the lights so the room feels cozy and warm.',
   *     config: {
   *       tools: [{functionDeclarations: [controlLightFunctionDeclaration]}],
   *       toolConfig: {
   *         functionCallingConfig: {
   *           mode: FunctionCallingConfigMode.ANY,
   *           allowedFunctionNames: ['controlLight'],
   *         },
   *       },
   *     },
   *   });
   *  console.debug(JSON.stringify(response.functionCalls));
   * ```
   */
  get functionCalls() {
    var e, t, r, o, i, a, s, u;
    if (((o = (r = (t = (e = this.candidates) === null || e === void 0 ? void 0 : e[0]) === null || t === void 0 ? void 0 : t.content) === null || r === void 0 ? void 0 : r.parts) === null || o === void 0 ? void 0 : o.length) === 0)
      return;
    this.candidates && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning function calls from the first one.");
    const l = (u = (s = (a = (i = this.candidates) === null || i === void 0 ? void 0 : i[0]) === null || a === void 0 ? void 0 : a.content) === null || s === void 0 ? void 0 : s.parts) === null || u === void 0 ? void 0 : u.filter((c) => c.functionCall).map((c) => c.functionCall).filter((c) => c !== void 0);
    if ((l == null ? void 0 : l.length) !== 0)
      return l;
  }
  /**
   * Returns the first executable code from the first candidate in the response.
   *
   * @remarks
   * If there are multiple candidates in the response, the executable code from
   * the first one will be returned.
   * If there are no executable code in the response, undefined will be
   * returned.
   *
   * @example
   * ```ts
   * const response = await ai.models.generateContent({
   *   model: 'gemini-2.0-flash',
   *   contents:
   *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'
   *   config: {
   *     tools: [{codeExecution: {}}],
   *   },
   * });
   *
   * console.debug(response.executableCode);
   * ```
   */
  get executableCode() {
    var e, t, r, o, i, a, s, u, l;
    if (((o = (r = (t = (e = this.candidates) === null || e === void 0 ? void 0 : e[0]) === null || t === void 0 ? void 0 : t.content) === null || r === void 0 ? void 0 : r.parts) === null || o === void 0 ? void 0 : o.length) === 0)
      return;
    this.candidates && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning executable code from the first one.");
    const c = (u = (s = (a = (i = this.candidates) === null || i === void 0 ? void 0 : i[0]) === null || a === void 0 ? void 0 : a.content) === null || s === void 0 ? void 0 : s.parts) === null || u === void 0 ? void 0 : u.filter((f) => f.executableCode).map((f) => f.executableCode).filter((f) => f !== void 0);
    if ((c == null ? void 0 : c.length) !== 0)
      return (l = c == null ? void 0 : c[0]) === null || l === void 0 ? void 0 : l.code;
  }
  /**
   * Returns the first code execution result from the first candidate in the response.
   *
   * @remarks
   * If there are multiple candidates in the response, the code execution result from
   * the first one will be returned.
   * If there are no code execution result in the response, undefined will be returned.
   *
   * @example
   * ```ts
   * const response = await ai.models.generateContent({
   *   model: 'gemini-2.0-flash',
   *   contents:
   *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'
   *   config: {
   *     tools: [{codeExecution: {}}],
   *   },
   * });
   *
   * console.debug(response.codeExecutionResult);
   * ```
   */
  get codeExecutionResult() {
    var e, t, r, o, i, a, s, u, l;
    if (((o = (r = (t = (e = this.candidates) === null || e === void 0 ? void 0 : e[0]) === null || t === void 0 ? void 0 : t.content) === null || r === void 0 ? void 0 : r.parts) === null || o === void 0 ? void 0 : o.length) === 0)
      return;
    this.candidates && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning code execution result from the first one.");
    const c = (u = (s = (a = (i = this.candidates) === null || i === void 0 ? void 0 : i[0]) === null || a === void 0 ? void 0 : a.content) === null || s === void 0 ? void 0 : s.parts) === null || u === void 0 ? void 0 : u.filter((f) => f.codeExecutionResult).map((f) => f.codeExecutionResult).filter((f) => f !== void 0);
    if ((c == null ? void 0 : c.length) !== 0)
      return (l = c == null ? void 0 : c[0]) === null || l === void 0 ? void 0 : l.output;
  }
}
class dh {
}
class hh {
}
class Zy {
}
class jy {
}
class e2 {
}
class t2 {
}
class ph {
}
class mh {
}
class vh {
}
class n2 {
}
class qa {
  /**
   * Instantiates an Operation of the same type as the one being called with the fields set from the API response.
   * @internal
   */
  _fromAPIResponse({ apiResponse: e, isVertexAI: t }) {
    const r = new qa();
    let o;
    const i = e;
    return t ? o = Hy(i) : o = Wy(i), Object.assign(r, o), r;
  }
}
class gh {
}
class yh {
}
class xh {
}
class r2 {
}
class o2 {
}
class i2 {
}
class wh {
}
class a2 {
  /**
   * Returns the concatenation of all text parts from the server content if present.
   *
   * @remarks
   * If there are non-text parts in the response, the concatenation of all text
   * parts will be returned, and a warning will be logged.
   */
  get text() {
    var e, t, r;
    let o = "", i = !1;
    const a = [];
    for (const s of (r = (t = (e = this.serverContent) === null || e === void 0 ? void 0 : e.modelTurn) === null || t === void 0 ? void 0 : t.parts) !== null && r !== void 0 ? r : []) {
      for (const [u, l] of Object.entries(s))
        u !== "text" && u !== "thought" && l !== null && a.push(u);
      if (typeof s.text == "string") {
        if (typeof s.thought == "boolean" && s.thought)
          continue;
        i = !0, o += s.text;
      }
    }
    return a.length > 0 && console.warn(`there are non-text parts ${a} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`), i ? o : void 0;
  }
  /**
   * Returns the concatenation of all inline data parts from the server content if present.
   *
   * @remarks
   * If there are non-inline data parts in the
   * response, the concatenation of all inline data parts will be returned, and
   * a warning will be logged.
   */
  get data() {
    var e, t, r;
    let o = "";
    const i = [];
    for (const a of (r = (t = (e = this.serverContent) === null || e === void 0 ? void 0 : e.modelTurn) === null || t === void 0 ? void 0 : t.parts) !== null && r !== void 0 ? r : []) {
      for (const [s, u] of Object.entries(a))
        s !== "inlineData" && u !== null && i.push(s);
      a.inlineData && typeof a.inlineData.data == "string" && (o += atob(a.inlineData.data));
    }
    return i.length > 0 && console.warn(`there are non-data parts ${i} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`), o.length > 0 ? btoa(o) : void 0;
  }
}
class s2 {
  /**
   * Returns the first audio chunk from the server content, if present.
   *
   * @remarks
   * If there are no audio chunks in the response, undefined will be returned.
   */
  get audioChunk() {
    if (this.serverContent && this.serverContent.audioChunks && this.serverContent.audioChunks.length > 0)
      return this.serverContent.audioChunks[0];
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function Re(n, e) {
  if (!e || typeof e != "string")
    throw new Error("model is required and must be a string");
  if (n.isVertexAI()) {
    if (e.startsWith("publishers/") || e.startsWith("projects/") || e.startsWith("models/"))
      return e;
    if (e.indexOf("/") >= 0) {
      const t = e.split("/", 2);
      return `publishers/${t[0]}/models/${t[1]}`;
    } else
      return `publishers/google/models/${e}`;
  } else
    return e.startsWith("models/") || e.startsWith("tunedModels/") ? e : `models/${e}`;
}
function Xm(n, e) {
  const t = Re(n, e);
  return t ? t.startsWith("publishers/") && n.isVertexAI() ? `projects/${n.getProject()}/locations/${n.getLocation()}/${t}` : t.startsWith("models/") && n.isVertexAI() ? `projects/${n.getProject()}/locations/${n.getLocation()}/publishers/google/${t}` : t : "";
}
function Ym(n) {
  return Array.isArray(n) ? n.map((e) => za(e)) : [za(n)];
}
function za(n) {
  if (typeof n == "object" && n !== null)
    return n;
  throw new Error(`Could not parse input as Blob. Unsupported blob type: ${typeof n}`);
}
function Qm(n) {
  const e = za(n);
  if (e.mimeType && e.mimeType.startsWith("image/"))
    return e;
  throw new Error(`Unsupported mime type: ${e.mimeType}`);
}
function Zm(n) {
  const e = za(n);
  if (e.mimeType && e.mimeType.startsWith("audio/"))
    return e;
  throw new Error(`Unsupported mime type: ${e.mimeType}`);
}
function _h(n) {
  if (n == null)
    throw new Error("PartUnion is required");
  if (typeof n == "object")
    return n;
  if (typeof n == "string")
    return { text: n };
  throw new Error(`Unsupported part type: ${typeof n}`);
}
function jm(n) {
  if (n == null || Array.isArray(n) && n.length === 0)
    throw new Error("PartListUnion is required");
  return Array.isArray(n) ? n.map((e) => _h(e)) : [_h(n)];
}
function hl(n) {
  return n != null && typeof n == "object" && "parts" in n && Array.isArray(n.parts);
}
function bh(n) {
  return n != null && typeof n == "object" && "functionCall" in n;
}
function Eh(n) {
  return n != null && typeof n == "object" && "functionResponse" in n;
}
function Pt(n) {
  if (n == null)
    throw new Error("ContentUnion is required");
  return hl(n) ? n : {
    role: "user",
    parts: jm(n)
  };
}
function cc(n, e) {
  if (!e)
    return [];
  if (n.isVertexAI() && Array.isArray(e))
    return e.flatMap((t) => {
      const r = Pt(t);
      return r.parts && r.parts.length > 0 && r.parts[0].text !== void 0 ? [r.parts[0].text] : [];
    });
  if (n.isVertexAI()) {
    const t = Pt(e);
    return t.parts && t.parts.length > 0 && t.parts[0].text !== void 0 ? [t.parts[0].text] : [];
  }
  return Array.isArray(e) ? e.map((t) => Pt(t)) : [Pt(e)];
}
function yn(n) {
  if (n == null || Array.isArray(n) && n.length === 0)
    throw new Error("contents are required");
  if (!Array.isArray(n)) {
    if (bh(n) || Eh(n))
      throw new Error("To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them");
    return [Pt(n)];
  }
  const e = [], t = [], r = hl(n[0]);
  for (const o of n) {
    const i = hl(o);
    if (i != r)
      throw new Error("Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them");
    if (i)
      e.push(o);
    else {
      if (bh(o) || Eh(o))
        throw new Error("To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them");
      t.push(o);
    }
  }
  return r || e.push({ role: "user", parts: jm(t) }), e;
}
function u2(n, e) {
  n.includes("null") && (e.nullable = !0);
  const t = n.filter((r) => r !== "null");
  if (t.length === 1)
    e.type = Object.values(Pr).includes(t[0].toUpperCase()) ? t[0].toUpperCase() : Pr.TYPE_UNSPECIFIED;
  else {
    e.anyOf = [];
    for (const r of t)
      e.anyOf.push({
        type: Object.values(Pr).includes(r.toUpperCase()) ? r.toUpperCase() : Pr.TYPE_UNSPECIFIED
      });
  }
}
function Uo(n) {
  const e = {}, t = ["items"], r = ["anyOf"], o = ["properties"];
  if (n.type && n.anyOf)
    throw new Error("type and anyOf cannot be both populated.");
  const i = n.anyOf;
  i != null && i.length == 2 && (i[0].type === "null" ? (e.nullable = !0, n = i[1]) : i[1].type === "null" && (e.nullable = !0, n = i[0])), n.type instanceof Array && u2(n.type, e);
  for (const [a, s] of Object.entries(n))
    if (s != null)
      if (a == "type") {
        if (s === "null")
          throw new Error("type: null can not be the only possible type for the field.");
        if (s instanceof Array)
          continue;
        e.type = Object.values(Pr).includes(s.toUpperCase()) ? s.toUpperCase() : Pr.TYPE_UNSPECIFIED;
      } else if (t.includes(a))
        e[a] = Uo(s);
      else if (r.includes(a)) {
        const u = [];
        for (const l of s) {
          if (l.type == "null") {
            e.nullable = !0;
            continue;
          }
          u.push(Uo(l));
        }
        e[a] = u;
      } else if (o.includes(a)) {
        const u = {};
        for (const [l, c] of Object.entries(s))
          u[l] = Uo(c);
        e[a] = u;
      } else {
        if (a === "additionalProperties")
          continue;
        e[a] = s;
      }
  return e;
}
function fc(n) {
  return Uo(n);
}
function dc(n) {
  if (typeof n == "object")
    return n;
  if (typeof n == "string")
    return {
      voiceConfig: {
        prebuiltVoiceConfig: {
          voiceName: n
        }
      }
    };
  throw new Error(`Unsupported speechConfig type: ${typeof n}`);
}
function hc(n) {
  if ("multiSpeakerVoiceConfig" in n)
    throw new Error("multiSpeakerVoiceConfig is not supported in the live API.");
  return n;
}
function pi(n) {
  if (n.functionDeclarations)
    for (const e of n.functionDeclarations)
      e.parameters && (Object.keys(e.parameters).includes("$schema") ? e.parametersJsonSchema || (e.parametersJsonSchema = e.parameters, delete e.parameters) : e.parameters = Uo(e.parameters)), e.response && (Object.keys(e.response).includes("$schema") ? e.responseJsonSchema || (e.responseJsonSchema = e.response, delete e.response) : e.response = Uo(e.response));
  return n;
}
function mi(n) {
  if (n == null)
    throw new Error("tools is required");
  if (!Array.isArray(n))
    throw new Error("tools is required and must be an array of Tools");
  const e = [];
  for (const t of n)
    e.push(t);
  return e;
}
function l2(n, e, t, r = 1) {
  const o = !e.startsWith(`${t}/`) && e.split("/").length === r;
  return n.isVertexAI() ? e.startsWith("projects/") ? e : e.startsWith("locations/") ? `projects/${n.getProject()}/${e}` : e.startsWith(`${t}/`) ? `projects/${n.getProject()}/locations/${n.getLocation()}/${e}` : o ? `projects/${n.getProject()}/locations/${n.getLocation()}/${t}/${e}` : e : o ? `${t}/${e}` : e;
}
function gr(n, e) {
  if (typeof e != "string")
    throw new Error("name must be a string");
  return l2(n, e, "cachedContents");
}
function ev(n) {
  switch (n) {
    case "STATE_UNSPECIFIED":
      return "JOB_STATE_UNSPECIFIED";
    case "CREATING":
      return "JOB_STATE_RUNNING";
    case "ACTIVE":
      return "JOB_STATE_SUCCEEDED";
    case "FAILED":
      return "JOB_STATE_FAILED";
    default:
      return n;
  }
}
function qr(n) {
  return lc(n);
}
function c2(n) {
  return n != null && typeof n == "object" && "name" in n;
}
function f2(n) {
  return n != null && typeof n == "object" && "video" in n;
}
function d2(n) {
  return n != null && typeof n == "object" && "uri" in n;
}
function tv(n) {
  var e;
  let t;
  if (c2(n) && (t = n.name), !(d2(n) && (t = n.uri, t === void 0)) && !(f2(n) && (t = (e = n.video) === null || e === void 0 ? void 0 : e.uri, t === void 0))) {
    if (typeof n == "string" && (t = n), t === void 0)
      throw new Error("Could not extract file name from the provided input.");
    if (t.startsWith("https://")) {
      const o = t.split("files/")[1].match(/[a-z0-9]+/);
      if (o === null)
        throw new Error(`Could not extract file name from URI ${t}`);
      t = o[0];
    } else t.startsWith("files/") && (t = t.split("files/")[1]);
    return t;
  }
}
function nv(n, e) {
  let t;
  return n.isVertexAI() ? t = e ? "publishers/google/models" : "models" : t = e ? "models" : "tunedModels", t;
}
function rv(n) {
  for (const e of ["models", "tunedModels", "publisherModels"])
    if (h2(n, e))
      return n[e];
  return [];
}
function h2(n, e) {
  return n !== null && typeof n == "object" && e in n;
}
function p2(n, e = {}) {
  const t = n, r = {
    name: t.name,
    description: t.description,
    parametersJsonSchema: t.inputSchema
  };
  return t.outputSchema && (r.responseJsonSchema = t.outputSchema), e.behavior && (r.behavior = e.behavior), {
    functionDeclarations: [
      r
    ]
  };
}
function m2(n, e = {}) {
  const t = [], r = /* @__PURE__ */ new Set();
  for (const o of n) {
    const i = o.name;
    if (r.has(i))
      throw new Error(`Duplicate function name ${i} found in MCP tools. Please ensure function names are unique.`);
    r.add(i);
    const a = p2(o, e);
    a.functionDeclarations && t.push(...a.functionDeclarations);
  }
  return { functionDeclarations: t };
}
function ov(n, e) {
  let t;
  if (typeof e == "string")
    if (n.isVertexAI())
      if (e.startsWith("gs://"))
        t = { format: "jsonl", gcsUri: [e] };
      else if (e.startsWith("bq://"))
        t = { format: "bigquery", bigqueryUri: e };
      else
        throw new Error(`Unsupported string source for Vertex AI: ${e}`);
    else if (e.startsWith("files/"))
      t = { fileName: e };
    else
      throw new Error(`Unsupported string source for Gemini API: ${e}`);
  else if (Array.isArray(e)) {
    if (n.isVertexAI())
      throw new Error("InlinedRequest[] is not supported in Vertex AI.");
    t = { inlinedRequests: e };
  } else
    t = e;
  const r = [t.gcsUri, t.bigqueryUri].filter(Boolean).length, o = [
    t.inlinedRequests,
    t.fileName
  ].filter(Boolean).length;
  if (n.isVertexAI()) {
    if (o > 0 || r !== 1)
      throw new Error("Exactly one of `gcsUri` or `bigqueryUri` must be set for Vertex AI.");
  } else if (r > 0 || o !== 1)
    throw new Error("Exactly one of `inlinedRequests`, `fileName`, must be set for Gemini API.");
  return t;
}
function v2(n) {
  if (typeof n != "string")
    return n;
  const e = n;
  if (e.startsWith("gs://"))
    return {
      format: "jsonl",
      gcsUri: e
    };
  if (e.startsWith("bq://"))
    return {
      format: "bigquery",
      bigqueryUri: e
    };
  throw new Error(`Unsupported destination: ${e}`);
}
function iv(n) {
  if (typeof n != "object" || n === null)
    return {};
  const e = n, t = e.inlinedResponses;
  if (typeof t != "object" || t === null)
    return n;
  const o = t.inlinedResponses;
  if (!Array.isArray(o) || o.length === 0)
    return n;
  let i = !1;
  for (const a of o) {
    if (typeof a != "object" || a === null)
      continue;
    const u = a.response;
    if (typeof u != "object" || u === null)
      continue;
    if (u.embedding !== void 0) {
      i = !0;
      break;
    }
  }
  return i && (e.inlinedEmbedContentResponses = e.inlinedResponses, delete e.inlinedResponses), n;
}
function vi(n, e) {
  const t = e;
  if (!n.isVertexAI()) {
    if (/batches\/[^/]+$/.test(t))
      return t.split("/").pop();
    throw new Error(`Invalid batch job name: ${t}.`);
  }
  if (/^projects\/[^/]+\/locations\/[^/]+\/batchPredictionJobs\/[^/]+$/.test(t))
    return t.split("/").pop();
  if (/^\d+$/.test(t))
    return t;
  throw new Error(`Invalid batch job name: ${t}.`);
}
function av(n) {
  const e = n;
  return e === "BATCH_STATE_UNSPECIFIED" ? "JOB_STATE_UNSPECIFIED" : e === "BATCH_STATE_PENDING" ? "JOB_STATE_PENDING" : e === "BATCH_STATE_RUNNING" ? "JOB_STATE_RUNNING" : e === "BATCH_STATE_SUCCEEDED" ? "JOB_STATE_SUCCEEDED" : e === "BATCH_STATE_FAILED" ? "JOB_STATE_FAILED" : e === "BATCH_STATE_CANCELLED" ? "JOB_STATE_CANCELLED" : e === "BATCH_STATE_EXPIRED" ? "JOB_STATE_EXPIRED" : e;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function g2(n) {
  const e = {}, t = h(n, ["responsesFile"]);
  t != null && m(e, ["fileName"], t);
  const r = h(n, [
    "inlinedResponses",
    "inlinedResponses"
  ]);
  if (r != null) {
    let i = r;
    Array.isArray(i) && (i = i.map((a) => J2(a))), m(e, ["inlinedResponses"], i);
  }
  const o = h(n, [
    "inlinedEmbedContentResponses",
    "inlinedResponses"
  ]);
  if (o != null) {
    let i = o;
    Array.isArray(i) && (i = i.map((a) => a)), m(e, ["inlinedEmbedContentResponses"], i);
  }
  return e;
}
function y2(n) {
  const e = {}, t = h(n, ["predictionsFormat"]);
  t != null && m(e, ["format"], t);
  const r = h(n, [
    "gcsDestination",
    "outputUriPrefix"
  ]);
  r != null && m(e, ["gcsUri"], r);
  const o = h(n, [
    "bigqueryDestination",
    "outputUri"
  ]);
  return o != null && m(e, ["bigqueryUri"], o), e;
}
function x2(n) {
  const e = {}, t = h(n, ["format"]);
  t != null && m(e, ["predictionsFormat"], t);
  const r = h(n, ["gcsUri"]);
  r != null && m(e, ["gcsDestination", "outputUriPrefix"], r);
  const o = h(n, ["bigqueryUri"]);
  if (o != null && m(e, ["bigqueryDestination", "outputUri"], o), h(n, ["fileName"]) !== void 0)
    throw new Error("fileName parameter is not supported in Vertex AI.");
  if (h(n, ["inlinedResponses"]) !== void 0)
    throw new Error("inlinedResponses parameter is not supported in Vertex AI.");
  if (h(n, ["inlinedEmbedContentResponses"]) !== void 0)
    throw new Error("inlinedEmbedContentResponses parameter is not supported in Vertex AI.");
  return e;
}
function Ba(n) {
  const e = {}, t = h(n, ["name"]);
  t != null && m(e, ["name"], t);
  const r = h(n, [
    "metadata",
    "displayName"
  ]);
  r != null && m(e, ["displayName"], r);
  const o = h(n, ["metadata", "state"]);
  o != null && m(e, ["state"], av(o));
  const i = h(n, [
    "metadata",
    "createTime"
  ]);
  i != null && m(e, ["createTime"], i);
  const a = h(n, [
    "metadata",
    "endTime"
  ]);
  a != null && m(e, ["endTime"], a);
  const s = h(n, [
    "metadata",
    "updateTime"
  ]);
  s != null && m(e, ["updateTime"], s);
  const u = h(n, ["metadata", "model"]);
  u != null && m(e, ["model"], u);
  const l = h(n, ["metadata", "output"]);
  return l != null && m(e, ["dest"], g2(iv(l))), e;
}
function pl(n) {
  const e = {}, t = h(n, ["name"]);
  t != null && m(e, ["name"], t);
  const r = h(n, ["displayName"]);
  r != null && m(e, ["displayName"], r);
  const o = h(n, ["state"]);
  o != null && m(e, ["state"], av(o));
  const i = h(n, ["error"]);
  i != null && m(e, ["error"], i);
  const a = h(n, ["createTime"]);
  a != null && m(e, ["createTime"], a);
  const s = h(n, ["startTime"]);
  s != null && m(e, ["startTime"], s);
  const u = h(n, ["endTime"]);
  u != null && m(e, ["endTime"], u);
  const l = h(n, ["updateTime"]);
  l != null && m(e, ["updateTime"], l);
  const c = h(n, ["model"]);
  c != null && m(e, ["model"], c);
  const f = h(n, ["inputConfig"]);
  f != null && m(e, ["src"], w2(f));
  const d = h(n, ["outputConfig"]);
  return d != null && m(e, ["dest"], y2(iv(d))), e;
}
function w2(n) {
  const e = {}, t = h(n, ["instancesFormat"]);
  t != null && m(e, ["format"], t);
  const r = h(n, ["gcsSource", "uris"]);
  r != null && m(e, ["gcsUri"], r);
  const o = h(n, [
    "bigquerySource",
    "inputUri"
  ]);
  return o != null && m(e, ["bigqueryUri"], o), e;
}
function _2(n, e) {
  const t = {};
  if (h(e, ["format"]) !== void 0)
    throw new Error("format parameter is not supported in Gemini API.");
  if (h(e, ["gcsUri"]) !== void 0)
    throw new Error("gcsUri parameter is not supported in Gemini API.");
  if (h(e, ["bigqueryUri"]) !== void 0)
    throw new Error("bigqueryUri parameter is not supported in Gemini API.");
  const r = h(e, ["fileName"]);
  r != null && m(t, ["fileName"], r);
  const o = h(e, [
    "inlinedRequests"
  ]);
  if (o != null) {
    let i = o;
    Array.isArray(i) && (i = i.map((a) => K2(n, a))), m(t, ["requests", "requests"], i);
  }
  return t;
}
function b2(n) {
  const e = {}, t = h(n, ["format"]);
  t != null && m(e, ["instancesFormat"], t);
  const r = h(n, ["gcsUri"]);
  r != null && m(e, ["gcsSource", "uris"], r);
  const o = h(n, ["bigqueryUri"]);
  if (o != null && m(e, ["bigquerySource", "inputUri"], o), h(n, ["fileName"]) !== void 0)
    throw new Error("fileName parameter is not supported in Vertex AI.");
  if (h(n, ["inlinedRequests"]) !== void 0)
    throw new Error("inlinedRequests parameter is not supported in Vertex AI.");
  return e;
}
function E2(n) {
  const e = {}, t = h(n, ["data"]);
  if (t != null && m(e, ["data"], t), h(n, ["displayName"]) !== void 0)
    throw new Error("displayName parameter is not supported in Gemini API.");
  const r = h(n, ["mimeType"]);
  return r != null && m(e, ["mimeType"], r), e;
}
function C2(n, e) {
  const t = {}, r = h(e, ["name"]);
  return r != null && m(t, ["_url", "name"], vi(n, r)), t;
}
function T2(n, e) {
  const t = {}, r = h(e, ["name"]);
  return r != null && m(t, ["_url", "name"], vi(n, r)), t;
}
function I2(n) {
  const e = {}, t = h(n, ["content"]);
  t != null && m(e, ["content"], t);
  const r = h(n, [
    "citationMetadata"
  ]);
  r != null && m(e, ["citationMetadata"], S2(r));
  const o = h(n, ["tokenCount"]);
  o != null && m(e, ["tokenCount"], o);
  const i = h(n, ["finishReason"]);
  i != null && m(e, ["finishReason"], i);
  const a = h(n, ["avgLogprobs"]);
  a != null && m(e, ["avgLogprobs"], a);
  const s = h(n, [
    "groundingMetadata"
  ]);
  s != null && m(e, ["groundingMetadata"], s);
  const u = h(n, ["index"]);
  u != null && m(e, ["index"], u);
  const l = h(n, [
    "logprobsResult"
  ]);
  l != null && m(e, ["logprobsResult"], l);
  const c = h(n, [
    "safetyRatings"
  ]);
  if (c != null) {
    let d = c;
    Array.isArray(d) && (d = d.map((p) => p)), m(e, ["safetyRatings"], d);
  }
  const f = h(n, [
    "urlContextMetadata"
  ]);
  return f != null && m(e, ["urlContextMetadata"], f), e;
}
function S2(n) {
  const e = {}, t = h(n, ["citationSources"]);
  if (t != null) {
    let r = t;
    Array.isArray(r) && (r = r.map((o) => o)), m(e, ["citations"], r);
  }
  return e;
}
function sv(n) {
  const e = {}, t = h(n, ["parts"]);
  if (t != null) {
    let o = t;
    Array.isArray(o) && (o = o.map((i) => tx(i))), m(e, ["parts"], o);
  }
  const r = h(n, ["role"]);
  return r != null && m(e, ["role"], r), e;
}
function A2(n, e) {
  const t = {}, r = h(n, ["displayName"]);
  if (e !== void 0 && r != null && m(e, ["batch", "displayName"], r), h(n, ["dest"]) !== void 0)
    throw new Error("dest parameter is not supported in Gemini API.");
  return t;
}
function R2(n, e) {
  const t = {}, r = h(n, ["displayName"]);
  e !== void 0 && r != null && m(e, ["displayName"], r);
  const o = h(n, ["dest"]);
  return e !== void 0 && o != null && m(e, ["outputConfig"], x2(v2(o))), t;
}
function Ch(n, e) {
  const t = {}, r = h(e, ["model"]);
  r != null && m(t, ["_url", "model"], Re(n, r));
  const o = h(e, ["src"]);
  o != null && m(t, ["batch", "inputConfig"], _2(n, ov(n, o)));
  const i = h(e, ["config"]);
  return i != null && A2(i, t), t;
}
function k2(n, e) {
  const t = {}, r = h(e, ["model"]);
  r != null && m(t, ["model"], Re(n, r));
  const o = h(e, ["src"]);
  o != null && m(t, ["inputConfig"], b2(ov(n, o)));
  const i = h(e, ["config"]);
  return i != null && R2(i, t), t;
}
function P2(n, e) {
  const t = {}, r = h(n, ["displayName"]);
  return e !== void 0 && r != null && m(e, ["batch", "displayName"], r), t;
}
function N2(n, e) {
  const t = {}, r = h(e, ["model"]);
  r != null && m(t, ["_url", "model"], Re(n, r));
  const o = h(e, ["src"]);
  o != null && m(t, ["batch", "inputConfig"], U2(n, o));
  const i = h(e, ["config"]);
  return i != null && P2(i, t), t;
}
function M2(n, e) {
  const t = {}, r = h(e, ["name"]);
  return r != null && m(t, ["_url", "name"], vi(n, r)), t;
}
function D2(n, e) {
  const t = {}, r = h(e, ["name"]);
  return r != null && m(t, ["_url", "name"], vi(n, r)), t;
}
function F2(n) {
  const e = {}, t = h(n, [
    "sdkHttpResponse"
  ]);
  t != null && m(e, ["sdkHttpResponse"], t);
  const r = h(n, ["name"]);
  r != null && m(e, ["name"], r);
  const o = h(n, ["done"]);
  o != null && m(e, ["done"], o);
  const i = h(n, ["error"]);
  return i != null && m(e, ["error"], i), e;
}
function L2(n) {
  const e = {}, t = h(n, [
    "sdkHttpResponse"
  ]);
  t != null && m(e, ["sdkHttpResponse"], t);
  const r = h(n, ["name"]);
  r != null && m(e, ["name"], r);
  const o = h(n, ["done"]);
  o != null && m(e, ["done"], o);
  const i = h(n, ["error"]);
  return i != null && m(e, ["error"], i), e;
}
function B2(n, e) {
  const t = {}, r = h(e, ["contents"]);
  if (r != null) {
    let i = cc(n, r);
    Array.isArray(i) && (i = i.map((a) => a)), m(t, ["requests[]", "request", "content"], i);
  }
  const o = h(e, ["config"]);
  return o != null && (m(t, ["_self"], O2(o, t)), Vy(t, { "requests[].*": "requests[].request.*" })), t;
}
function O2(n, e) {
  const t = {}, r = h(n, ["taskType"]);
  e !== void 0 && r != null && m(e, ["requests[]", "taskType"], r);
  const o = h(n, ["title"]);
  e !== void 0 && o != null && m(e, ["requests[]", "title"], o);
  const i = h(n, [
    "outputDimensionality"
  ]);
  if (e !== void 0 && i != null && m(e, ["requests[]", "outputDimensionality"], i), h(n, ["mimeType"]) !== void 0)
    throw new Error("mimeType parameter is not supported in Gemini API.");
  if (h(n, ["autoTruncate"]) !== void 0)
    throw new Error("autoTruncate parameter is not supported in Gemini API.");
  return t;
}
function U2(n, e) {
  const t = {}, r = h(e, ["fileName"]);
  r != null && m(t, ["file_name"], r);
  const o = h(e, [
    "inlinedRequests"
  ]);
  return o != null && m(t, ["requests"], B2(n, o)), t;
}
function V2(n) {
  const e = {};
  if (h(n, ["displayName"]) !== void 0)
    throw new Error("displayName parameter is not supported in Gemini API.");
  const t = h(n, ["fileUri"]);
  t != null && m(e, ["fileUri"], t);
  const r = h(n, ["mimeType"]);
  return r != null && m(e, ["mimeType"], r), e;
}
function G2(n, e, t) {
  const r = {}, o = h(e, [
    "systemInstruction"
  ]);
  t !== void 0 && o != null && m(t, ["systemInstruction"], sv(Pt(o)));
  const i = h(e, ["temperature"]);
  i != null && m(r, ["temperature"], i);
  const a = h(e, ["topP"]);
  a != null && m(r, ["topP"], a);
  const s = h(e, ["topK"]);
  s != null && m(r, ["topK"], s);
  const u = h(e, [
    "candidateCount"
  ]);
  u != null && m(r, ["candidateCount"], u);
  const l = h(e, [
    "maxOutputTokens"
  ]);
  l != null && m(r, ["maxOutputTokens"], l);
  const c = h(e, [
    "stopSequences"
  ]);
  c != null && m(r, ["stopSequences"], c);
  const f = h(e, [
    "responseLogprobs"
  ]);
  f != null && m(r, ["responseLogprobs"], f);
  const d = h(e, ["logprobs"]);
  d != null && m(r, ["logprobs"], d);
  const p = h(e, [
    "presencePenalty"
  ]);
  p != null && m(r, ["presencePenalty"], p);
  const v = h(e, [
    "frequencyPenalty"
  ]);
  v != null && m(r, ["frequencyPenalty"], v);
  const g = h(e, ["seed"]);
  g != null && m(r, ["seed"], g);
  const y = h(e, [
    "responseMimeType"
  ]);
  y != null && m(r, ["responseMimeType"], y);
  const x = h(e, [
    "responseSchema"
  ]);
  x != null && m(r, ["responseSchema"], fc(x));
  const w = h(e, [
    "responseJsonSchema"
  ]);
  if (w != null && m(r, ["responseJsonSchema"], w), h(e, ["routingConfig"]) !== void 0)
    throw new Error("routingConfig parameter is not supported in Gemini API.");
  if (h(e, ["modelSelectionConfig"]) !== void 0)
    throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");
  const b = h(e, [
    "safetySettings"
  ]);
  if (t !== void 0 && b != null) {
    let P = b;
    Array.isArray(P) && (P = P.map((B) => nx(B))), m(t, ["safetySettings"], P);
  }
  const _ = h(e, ["tools"]);
  if (t !== void 0 && _ != null) {
    let P = mi(_);
    Array.isArray(P) && (P = P.map((B) => rx(pi(B)))), m(t, ["tools"], P);
  }
  const E = h(e, ["toolConfig"]);
  if (t !== void 0 && E != null && m(t, ["toolConfig"], E), h(e, ["labels"]) !== void 0)
    throw new Error("labels parameter is not supported in Gemini API.");
  const C = h(e, [
    "cachedContent"
  ]);
  t !== void 0 && C != null && m(t, ["cachedContent"], gr(n, C));
  const A = h(e, [
    "responseModalities"
  ]);
  A != null && m(r, ["responseModalities"], A);
  const R = h(e, [
    "mediaResolution"
  ]);
  R != null && m(r, ["mediaResolution"], R);
  const I = h(e, ["speechConfig"]);
  if (I != null && m(r, ["speechConfig"], dc(I)), h(e, ["audioTimestamp"]) !== void 0)
    throw new Error("audioTimestamp parameter is not supported in Gemini API.");
  const S = h(e, [
    "thinkingConfig"
  ]);
  S != null && m(r, ["thinkingConfig"], S);
  const M = h(e, ["imageConfig"]);
  return M != null && m(r, ["imageConfig"], M), r;
}
function W2(n) {
  const e = {}, t = h(n, [
    "sdkHttpResponse"
  ]);
  t != null && m(e, ["sdkHttpResponse"], t);
  const r = h(n, ["candidates"]);
  if (r != null) {
    let u = r;
    Array.isArray(u) && (u = u.map((l) => I2(l))), m(e, ["candidates"], u);
  }
  const o = h(n, ["modelVersion"]);
  o != null && m(e, ["modelVersion"], o);
  const i = h(n, [
    "promptFeedback"
  ]);
  i != null && m(e, ["promptFeedback"], i);
  const a = h(n, ["responseId"]);
  a != null && m(e, ["responseId"], a);
  const s = h(n, [
    "usageMetadata"
  ]);
  return s != null && m(e, ["usageMetadata"], s), e;
}
function H2(n, e) {
  const t = {}, r = h(e, ["name"]);
  return r != null && m(t, ["_url", "name"], vi(n, r)), t;
}
function $2(n, e) {
  const t = {}, r = h(e, ["name"]);
  return r != null && m(t, ["_url", "name"], vi(n, r)), t;
}
function q2(n) {
  const e = {};
  if (h(n, ["authConfig"]) !== void 0)
    throw new Error("authConfig parameter is not supported in Gemini API.");
  const t = h(n, ["enableWidget"]);
  return t != null && m(e, ["enableWidget"], t), e;
}
function z2(n) {
  const e = {};
  if (h(n, ["excludeDomains"]) !== void 0)
    throw new Error("excludeDomains parameter is not supported in Gemini API.");
  const t = h(n, [
    "timeRangeFilter"
  ]);
  return t != null && m(e, ["timeRangeFilter"], t), e;
}
function K2(n, e) {
  const t = {}, r = h(e, ["model"]);
  r != null && m(t, ["request", "model"], Re(n, r));
  const o = h(e, ["contents"]);
  if (o != null) {
    let s = yn(o);
    Array.isArray(s) && (s = s.map((u) => sv(u))), m(t, ["request", "contents"], s);
  }
  const i = h(e, ["metadata"]);
  i != null && m(t, ["metadata"], i);
  const a = h(e, ["config"]);
  return a != null && m(t, ["request", "generationConfig"], G2(n, a, h(t, ["request"], {}))), t;
}
function J2(n) {
  const e = {}, t = h(n, ["response"]);
  t != null && m(e, ["response"], W2(t));
  const r = h(n, ["error"]);
  return r != null && m(e, ["error"], r), e;
}
function X2(n, e) {
  const t = {}, r = h(n, ["pageSize"]);
  e !== void 0 && r != null && m(e, ["_query", "pageSize"], r);
  const o = h(n, ["pageToken"]);
  if (e !== void 0 && o != null && m(e, ["_query", "pageToken"], o), h(n, ["filter"]) !== void 0)
    throw new Error("filter parameter is not supported in Gemini API.");
  return t;
}
function Y2(n, e) {
  const t = {}, r = h(n, ["pageSize"]);
  e !== void 0 && r != null && m(e, ["_query", "pageSize"], r);
  const o = h(n, ["pageToken"]);
  e !== void 0 && o != null && m(e, ["_query", "pageToken"], o);
  const i = h(n, ["filter"]);
  return e !== void 0 && i != null && m(e, ["_query", "filter"], i), t;
}
function Q2(n) {
  const e = {}, t = h(n, ["config"]);
  return t != null && X2(t, e), e;
}
function Z2(n) {
  const e = {}, t = h(n, ["config"]);
  return t != null && Y2(t, e), e;
}
function j2(n) {
  const e = {}, t = h(n, [
    "sdkHttpResponse"
  ]);
  t != null && m(e, ["sdkHttpResponse"], t);
  const r = h(n, [
    "nextPageToken"
  ]);
  r != null && m(e, ["nextPageToken"], r);
  const o = h(n, ["operations"]);
  if (o != null) {
    let i = o;
    Array.isArray(i) && (i = i.map((a) => Ba(a))), m(e, ["batchJobs"], i);
  }
  return e;
}
function ex(n) {
  const e = {}, t = h(n, [
    "sdkHttpResponse"
  ]);
  t != null && m(e, ["sdkHttpResponse"], t);
  const r = h(n, [
    "nextPageToken"
  ]);
  r != null && m(e, ["nextPageToken"], r);
  const o = h(n, [
    "batchPredictionJobs"
  ]);
  if (o != null) {
    let i = o;
    Array.isArray(i) && (i = i.map((a) => pl(a))), m(e, ["batchJobs"], i);
  }
  return e;
}
function tx(n) {
  const e = {}, t = h(n, ["functionCall"]);
  t != null && m(e, ["functionCall"], t);
  const r = h(n, [
    "codeExecutionResult"
  ]);
  r != null && m(e, ["codeExecutionResult"], r);
  const o = h(n, [
    "executableCode"
  ]);
  o != null && m(e, ["executableCode"], o);
  const i = h(n, ["fileData"]);
  i != null && m(e, ["fileData"], V2(i));
  const a = h(n, [
    "functionResponse"
  ]);
  a != null && m(e, ["functionResponse"], a);
  const s = h(n, ["inlineData"]);
  s != null && m(e, ["inlineData"], E2(s));
  const u = h(n, ["text"]);
  u != null && m(e, ["text"], u);
  const l = h(n, ["thought"]);
  l != null && m(e, ["thought"], l);
  const c = h(n, [
    "thoughtSignature"
  ]);
  c != null && m(e, ["thoughtSignature"], c);
  const f = h(n, [
    "videoMetadata"
  ]);
  return f != null && m(e, ["videoMetadata"], f), e;
}
function nx(n) {
  const e = {}, t = h(n, ["category"]);
  if (t != null && m(e, ["category"], t), h(n, ["method"]) !== void 0)
    throw new Error("method parameter is not supported in Gemini API.");
  const r = h(n, ["threshold"]);
  return r != null && m(e, ["threshold"], r), e;
}
function rx(n) {
  const e = {}, t = h(n, [
    "functionDeclarations"
  ]);
  if (t != null) {
    let l = t;
    Array.isArray(l) && (l = l.map((c) => c)), m(e, ["functionDeclarations"], l);
  }
  if (h(n, ["retrieval"]) !== void 0)
    throw new Error("retrieval parameter is not supported in Gemini API.");
  const r = h(n, [
    "googleSearchRetrieval"
  ]);
  r != null && m(e, ["googleSearchRetrieval"], r);
  const o = h(n, ["googleMaps"]);
  o != null && m(e, ["googleMaps"], q2(o));
  const i = h(n, ["computerUse"]);
  i != null && m(e, ["computerUse"], i);
  const a = h(n, [
    "codeExecution"
  ]);
  if (a != null && m(e, ["codeExecution"], a), h(n, ["enterpriseWebSearch"]) !== void 0)
    throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
  const s = h(n, ["googleSearch"]);
  s != null && m(e, ["googleSearch"], z2(s));
  const u = h(n, ["urlContext"]);
  return u != null && m(e, ["urlContext"], u), e;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var co;
(function(n) {
  n.PAGED_ITEM_BATCH_JOBS = "batchJobs", n.PAGED_ITEM_MODELS = "models", n.PAGED_ITEM_TUNING_JOBS = "tuningJobs", n.PAGED_ITEM_FILES = "files", n.PAGED_ITEM_CACHED_CONTENTS = "cachedContents", n.PAGED_ITEM_RAG_STORES = "ragStores", n.PAGED_ITEM_DOCUMENTS = "documents";
})(co || (co = {}));
class oa {
  constructor(e, t, r, o) {
    this.pageInternal = [], this.paramsInternal = {}, this.requestInternal = t, this.init(e, r, o);
  }
  init(e, t, r) {
    var o, i;
    this.nameInternal = e, this.pageInternal = t[this.nameInternal] || [], this.sdkHttpResponseInternal = t == null ? void 0 : t.sdkHttpResponse, this.idxInternal = 0;
    let a = { config: {} };
    !r || Object.keys(r).length === 0 ? a = { config: {} } : typeof r == "object" ? a = Object.assign({}, r) : a = r, a.config && (a.config.pageToken = t.nextPageToken), this.paramsInternal = a, this.pageInternalSize = (i = (o = a.config) === null || o === void 0 ? void 0 : o.pageSize) !== null && i !== void 0 ? i : this.pageInternal.length;
  }
  initNextPage(e) {
    this.init(this.nameInternal, e, this.paramsInternal);
  }
  /**
   * Returns the current page, which is a list of items.
   *
   * @remarks
   * The first page is retrieved when the pager is created. The returned list of
   * items could be a subset of the entire list.
   */
  get page() {
    return this.pageInternal;
  }
  /**
   * Returns the type of paged item (for example, ``batch_jobs``).
   */
  get name() {
    return this.nameInternal;
  }
  /**
   * Returns the length of the page fetched each time by this pager.
   *
   * @remarks
   * The number of items in the page is less than or equal to the page length.
   */
  get pageSize() {
    return this.pageInternalSize;
  }
  /**
   * Returns the headers of the API response.
   */
  get sdkHttpResponse() {
    return this.sdkHttpResponseInternal;
  }
  /**
   * Returns the parameters when making the API request for the next page.
   *
   * @remarks
   * Parameters contain a set of optional configs that can be
   * used to customize the API request. For example, the `pageToken` parameter
   * contains the token to request the next page.
   */
  get params() {
    return this.paramsInternal;
  }
  /**
   * Returns the total number of items in the current page.
   */
  get pageLength() {
    return this.pageInternal.length;
  }
  /**
   * Returns the item at the given index.
   */
  getItem(e) {
    return this.pageInternal[e];
  }
  /**
   * Returns an async iterator that support iterating through all items
   * retrieved from the API.
   *
   * @remarks
   * The iterator will automatically fetch the next page if there are more items
   * to fetch from the API.
   *
   * @example
   *
   * ```ts
   * const pager = await ai.files.list({config: {pageSize: 10}});
   * for await (const file of pager) {
   *   console.log(file.name);
   * }
   * ```
   */
  [Symbol.asyncIterator]() {
    return {
      next: async () => {
        if (this.idxInternal >= this.pageLength)
          if (this.hasNextPage())
            await this.nextPage();
          else
            return { value: void 0, done: !0 };
        const e = this.getItem(this.idxInternal);
        return this.idxInternal += 1, { value: e, done: !1 };
      },
      return: async () => ({ value: void 0, done: !0 })
    };
  }
  /**
   * Fetches the next page of items. This makes a new API request.
   *
   * @throws {Error} If there are no more pages to fetch.
   *
   * @example
   *
   * ```ts
   * const pager = await ai.files.list({config: {pageSize: 10}});
   * let page = pager.page;
   * while (true) {
   *   for (const file of page) {
   *     console.log(file.name);
   *   }
   *   if (!pager.hasNextPage()) {
   *     break;
   *   }
   *   page = await pager.nextPage();
   * }
   * ```
   */
  async nextPage() {
    if (!this.hasNextPage())
      throw new Error("No more pages to fetch.");
    const e = await this.requestInternal(this.params);
    return this.initNextPage(e), this.page;
  }
  /**
   * Returns true if there are more pages to fetch from the API.
   */
  hasNextPage() {
    var e;
    return ((e = this.params.config) === null || e === void 0 ? void 0 : e.pageToken) !== void 0;
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class ox extends go {
  constructor(e) {
    super(), this.apiClient = e, this.create = async (t) => (this.apiClient.isVertexAI() && (t.config = this.formatDestination(t.src, t.config)), this.createInternal(t)), this.createEmbeddings = async (t) => {
      if (console.warn("batches.createEmbeddings() is experimental and may change without notice."), this.apiClient.isVertexAI())
        throw new Error("Vertex AI does not support batches.createEmbeddings.");
      return this.createEmbeddingsInternal(t);
    }, this.list = async (t = {}) => new oa(co.PAGED_ITEM_BATCH_JOBS, (r) => this.listInternal(r), await this.listInternal(t), t);
  }
  // Helper function to handle inlined generate content requests
  createInlinedGenerateContentRequest(e) {
    const t = Ch(
      this.apiClient,
      // Use instance apiClient
      e
    ), r = t._url, o = Q("{model}:batchGenerateContent", r), s = t.batch.inputConfig.requests, u = s.requests, l = [];
    for (const c of u) {
      const f = Object.assign({}, c);
      if (f.systemInstruction) {
        const d = f.systemInstruction;
        delete f.systemInstruction;
        const p = f.request;
        p.systemInstruction = d, f.request = p;
      }
      l.push(f);
    }
    return s.requests = l, delete t.config, delete t._url, delete t._query, { path: o, body: t };
  }
  // Helper function to get the first GCS URI
  getGcsUri(e) {
    if (typeof e == "string")
      return e.startsWith("gs://") ? e : void 0;
    if (!Array.isArray(e) && e.gcsUri && e.gcsUri.length > 0)
      return e.gcsUri[0];
  }
  // Helper function to get the BigQuery URI
  getBigqueryUri(e) {
    if (typeof e == "string")
      return e.startsWith("bq://") ? e : void 0;
    if (!Array.isArray(e))
      return e.bigqueryUri;
  }
  // Function to format the destination configuration for Vertex AI
  formatDestination(e, t) {
    const r = t ? Object.assign({}, t) : {}, o = Date.now().toString();
    if (r.displayName || (r.displayName = `genaiBatchJob_${o}`), r.dest === void 0) {
      const i = this.getGcsUri(e), a = this.getBigqueryUri(e);
      if (i)
        i.endsWith(".jsonl") ? r.dest = `${i.slice(0, -6)}/dest` : r.dest = `${i}_dest_${o}`;
      else if (a)
        r.dest = `${a}_dest_${o}`;
      else
        throw new Error("Unsupported source for Vertex AI: No GCS or BigQuery URI found.");
    }
    return r;
  }
  /**
   * Internal method to create batch job.
   *
   * @param params - The parameters for create batch job request.
   * @return The created batch job.
   *
   */
  async createInternal(e) {
    var t, r, o, i;
    let a, s = "", u = {};
    if (this.apiClient.isVertexAI()) {
      const l = k2(this.apiClient, e);
      return s = Q("batchPredictionJobs", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "POST",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((c) => c.json()), a.then((c) => pl(c));
    } else {
      const l = Ch(this.apiClient, e);
      return s = Q("{model}:batchGenerateContent", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "POST",
        httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
        abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal
      }).then((c) => c.json()), a.then((c) => Ba(c));
    }
  }
  /**
   * Internal method to create batch job.
   *
   * @param params - The parameters for create batch job request.
   * @return The created batch job.
   *
   */
  async createEmbeddingsInternal(e) {
    var t, r;
    let o, i = "", a = {};
    if (this.apiClient.isVertexAI())
      throw new Error("This method is only supported by the Gemini Developer API.");
    {
      const s = N2(this.apiClient, e);
      return i = Q("{model}:asyncBatchEmbedContent", s._url), a = s._query, delete s._url, delete s._query, o = this.apiClient.request({
        path: i,
        queryParams: a,
        body: JSON.stringify(s),
        httpMethod: "POST",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((u) => u.json()), o.then((u) => Ba(u));
    }
  }
  /**
   * Gets batch job configurations.
   *
   * @param params - The parameters for the get request.
   * @return The batch job.
   *
   * @example
   * ```ts
   * await ai.batches.get({name: '...'}); // The server-generated resource name.
   * ```
   */
  async get(e) {
    var t, r, o, i;
    let a, s = "", u = {};
    if (this.apiClient.isVertexAI()) {
      const l = $2(this.apiClient, e);
      return s = Q("batchPredictionJobs/{name}", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "GET",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((c) => c.json()), a.then((c) => pl(c));
    } else {
      const l = H2(this.apiClient, e);
      return s = Q("batches/{name}", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "GET",
        httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
        abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal
      }).then((c) => c.json()), a.then((c) => Ba(c));
    }
  }
  /**
   * Cancels a batch job.
   *
   * @param params - The parameters for the cancel request.
   * @return The empty response returned by the API.
   *
   * @example
   * ```ts
   * await ai.batches.cancel({name: '...'}); // The server-generated resource name.
   * ```
   */
  async cancel(e) {
    var t, r, o, i;
    let a = "", s = {};
    if (this.apiClient.isVertexAI()) {
      const u = T2(this.apiClient, e);
      a = Q("batchPredictionJobs/{name}:cancel", u._url), s = u._query, delete u._url, delete u._query, await this.apiClient.request({
        path: a,
        queryParams: s,
        body: JSON.stringify(u),
        httpMethod: "POST",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      });
    } else {
      const u = C2(this.apiClient, e);
      a = Q("batches/{name}:cancel", u._url), s = u._query, delete u._url, delete u._query, await this.apiClient.request({
        path: a,
        queryParams: s,
        body: JSON.stringify(u),
        httpMethod: "POST",
        httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
        abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal
      });
    }
  }
  async listInternal(e) {
    var t, r, o, i;
    let a, s = "", u = {};
    if (this.apiClient.isVertexAI()) {
      const l = Z2(e);
      return s = Q("batchPredictionJobs", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "GET",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((c) => c.json().then((f) => {
        const d = f;
        return d.sdkHttpResponse = {
          headers: c.headers
        }, d;
      })), a.then((c) => {
        const f = ex(c), d = new wh();
        return Object.assign(d, f), d;
      });
    } else {
      const l = Q2(e);
      return s = Q("batches", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "GET",
        httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
        abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal
      }).then((c) => c.json().then((f) => {
        const d = f;
        return d.sdkHttpResponse = {
          headers: c.headers
        }, d;
      })), a.then((c) => {
        const f = j2(c), d = new wh();
        return Object.assign(d, f), d;
      });
    }
  }
  /**
   * Deletes a batch job.
   *
   * @param params - The parameters for the delete request.
   * @return The empty response returned by the API.
   *
   * @example
   * ```ts
   * await ai.batches.delete({name: '...'}); // The server-generated resource name.
   * ```
   */
  async delete(e) {
    var t, r, o, i;
    let a, s = "", u = {};
    if (this.apiClient.isVertexAI()) {
      const l = D2(this.apiClient, e);
      return s = Q("batchPredictionJobs/{name}", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "DELETE",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((c) => c.json().then((f) => {
        const d = f;
        return d.sdkHttpResponse = {
          headers: c.headers
        }, d;
      })), a.then((c) => L2(c));
    } else {
      const l = M2(this.apiClient, e);
      return s = Q("batches/{name}", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "DELETE",
        httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
        abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal
      }).then((c) => c.json().then((f) => {
        const d = f;
        return d.sdkHttpResponse = {
          headers: c.headers
        }, d;
      })), a.then((c) => F2(c));
    }
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function ix(n) {
  const e = {}, t = h(n, ["data"]);
  if (t != null && m(e, ["data"], t), h(n, ["displayName"]) !== void 0)
    throw new Error("displayName parameter is not supported in Gemini API.");
  const r = h(n, ["mimeType"]);
  return r != null && m(e, ["mimeType"], r), e;
}
function Th(n) {
  const e = {}, t = h(n, ["parts"]);
  if (t != null) {
    let o = t;
    Array.isArray(o) && (o = o.map((i) => Ix(i))), m(e, ["parts"], o);
  }
  const r = h(n, ["role"]);
  return r != null && m(e, ["role"], r), e;
}
function ax(n, e) {
  const t = {}, r = h(n, ["ttl"]);
  e !== void 0 && r != null && m(e, ["ttl"], r);
  const o = h(n, ["expireTime"]);
  e !== void 0 && o != null && m(e, ["expireTime"], o);
  const i = h(n, ["displayName"]);
  e !== void 0 && i != null && m(e, ["displayName"], i);
  const a = h(n, ["contents"]);
  if (e !== void 0 && a != null) {
    let c = yn(a);
    Array.isArray(c) && (c = c.map((f) => Th(f))), m(e, ["contents"], c);
  }
  const s = h(n, [
    "systemInstruction"
  ]);
  e !== void 0 && s != null && m(e, ["systemInstruction"], Th(Pt(s)));
  const u = h(n, ["tools"]);
  if (e !== void 0 && u != null) {
    let c = u;
    Array.isArray(c) && (c = c.map((f) => Sx(f))), m(e, ["tools"], c);
  }
  const l = h(n, ["toolConfig"]);
  if (e !== void 0 && l != null && m(e, ["toolConfig"], l), h(n, ["kmsKeyName"]) !== void 0)
    throw new Error("kmsKeyName parameter is not supported in Gemini API.");
  return t;
}
function sx(n, e) {
  const t = {}, r = h(n, ["ttl"]);
  e !== void 0 && r != null && m(e, ["ttl"], r);
  const o = h(n, ["expireTime"]);
  e !== void 0 && o != null && m(e, ["expireTime"], o);
  const i = h(n, ["displayName"]);
  e !== void 0 && i != null && m(e, ["displayName"], i);
  const a = h(n, ["contents"]);
  if (e !== void 0 && a != null) {
    let f = yn(a);
    Array.isArray(f) && (f = f.map((d) => d)), m(e, ["contents"], f);
  }
  const s = h(n, [
    "systemInstruction"
  ]);
  e !== void 0 && s != null && m(e, ["systemInstruction"], Pt(s));
  const u = h(n, ["tools"]);
  if (e !== void 0 && u != null) {
    let f = u;
    Array.isArray(f) && (f = f.map((d) => Ax(d))), m(e, ["tools"], f);
  }
  const l = h(n, ["toolConfig"]);
  e !== void 0 && l != null && m(e, ["toolConfig"], l);
  const c = h(n, ["kmsKeyName"]);
  return e !== void 0 && c != null && m(e, ["encryption_spec", "kmsKeyName"], c), t;
}
function ux(n, e) {
  const t = {}, r = h(e, ["model"]);
  r != null && m(t, ["model"], Xm(n, r));
  const o = h(e, ["config"]);
  return o != null && ax(o, t), t;
}
function lx(n, e) {
  const t = {}, r = h(e, ["model"]);
  r != null && m(t, ["model"], Xm(n, r));
  const o = h(e, ["config"]);
  return o != null && sx(o, t), t;
}
function cx(n, e) {
  const t = {}, r = h(e, ["name"]);
  return r != null && m(t, ["_url", "name"], gr(n, r)), t;
}
function fx(n, e) {
  const t = {}, r = h(e, ["name"]);
  return r != null && m(t, ["_url", "name"], gr(n, r)), t;
}
function dx(n) {
  const e = {}, t = h(n, [
    "sdkHttpResponse"
  ]);
  return t != null && m(e, ["sdkHttpResponse"], t), e;
}
function hx(n) {
  const e = {}, t = h(n, [
    "sdkHttpResponse"
  ]);
  return t != null && m(e, ["sdkHttpResponse"], t), e;
}
function px(n) {
  const e = {};
  if (h(n, ["displayName"]) !== void 0)
    throw new Error("displayName parameter is not supported in Gemini API.");
  const t = h(n, ["fileUri"]);
  t != null && m(e, ["fileUri"], t);
  const r = h(n, ["mimeType"]);
  return r != null && m(e, ["mimeType"], r), e;
}
function mx(n) {
  const e = {};
  if (h(n, ["behavior"]) !== void 0)
    throw new Error("behavior parameter is not supported in Vertex AI.");
  const t = h(n, ["description"]);
  t != null && m(e, ["description"], t);
  const r = h(n, ["name"]);
  r != null && m(e, ["name"], r);
  const o = h(n, ["parameters"]);
  o != null && m(e, ["parameters"], o);
  const i = h(n, [
    "parametersJsonSchema"
  ]);
  i != null && m(e, ["parametersJsonSchema"], i);
  const a = h(n, ["response"]);
  a != null && m(e, ["response"], a);
  const s = h(n, [
    "responseJsonSchema"
  ]);
  return s != null && m(e, ["responseJsonSchema"], s), e;
}
function vx(n, e) {
  const t = {}, r = h(e, ["name"]);
  return r != null && m(t, ["_url", "name"], gr(n, r)), t;
}
function gx(n, e) {
  const t = {}, r = h(e, ["name"]);
  return r != null && m(t, ["_url", "name"], gr(n, r)), t;
}
function yx(n) {
  const e = {};
  if (h(n, ["authConfig"]) !== void 0)
    throw new Error("authConfig parameter is not supported in Gemini API.");
  const t = h(n, ["enableWidget"]);
  return t != null && m(e, ["enableWidget"], t), e;
}
function xx(n) {
  const e = {};
  if (h(n, ["excludeDomains"]) !== void 0)
    throw new Error("excludeDomains parameter is not supported in Gemini API.");
  const t = h(n, [
    "timeRangeFilter"
  ]);
  return t != null && m(e, ["timeRangeFilter"], t), e;
}
function wx(n, e) {
  const t = {}, r = h(n, ["pageSize"]);
  e !== void 0 && r != null && m(e, ["_query", "pageSize"], r);
  const o = h(n, ["pageToken"]);
  return e !== void 0 && o != null && m(e, ["_query", "pageToken"], o), t;
}
function _x(n, e) {
  const t = {}, r = h(n, ["pageSize"]);
  e !== void 0 && r != null && m(e, ["_query", "pageSize"], r);
  const o = h(n, ["pageToken"]);
  return e !== void 0 && o != null && m(e, ["_query", "pageToken"], o), t;
}
function bx(n) {
  const e = {}, t = h(n, ["config"]);
  return t != null && wx(t, e), e;
}
function Ex(n) {
  const e = {}, t = h(n, ["config"]);
  return t != null && _x(t, e), e;
}
function Cx(n) {
  const e = {}, t = h(n, [
    "sdkHttpResponse"
  ]);
  t != null && m(e, ["sdkHttpResponse"], t);
  const r = h(n, [
    "nextPageToken"
  ]);
  r != null && m(e, ["nextPageToken"], r);
  const o = h(n, [
    "cachedContents"
  ]);
  if (o != null) {
    let i = o;
    Array.isArray(i) && (i = i.map((a) => a)), m(e, ["cachedContents"], i);
  }
  return e;
}
function Tx(n) {
  const e = {}, t = h(n, [
    "sdkHttpResponse"
  ]);
  t != null && m(e, ["sdkHttpResponse"], t);
  const r = h(n, [
    "nextPageToken"
  ]);
  r != null && m(e, ["nextPageToken"], r);
  const o = h(n, [
    "cachedContents"
  ]);
  if (o != null) {
    let i = o;
    Array.isArray(i) && (i = i.map((a) => a)), m(e, ["cachedContents"], i);
  }
  return e;
}
function Ix(n) {
  const e = {}, t = h(n, ["functionCall"]);
  t != null && m(e, ["functionCall"], t);
  const r = h(n, [
    "codeExecutionResult"
  ]);
  r != null && m(e, ["codeExecutionResult"], r);
  const o = h(n, [
    "executableCode"
  ]);
  o != null && m(e, ["executableCode"], o);
  const i = h(n, ["fileData"]);
  i != null && m(e, ["fileData"], px(i));
  const a = h(n, [
    "functionResponse"
  ]);
  a != null && m(e, ["functionResponse"], a);
  const s = h(n, ["inlineData"]);
  s != null && m(e, ["inlineData"], ix(s));
  const u = h(n, ["text"]);
  u != null && m(e, ["text"], u);
  const l = h(n, ["thought"]);
  l != null && m(e, ["thought"], l);
  const c = h(n, [
    "thoughtSignature"
  ]);
  c != null && m(e, ["thoughtSignature"], c);
  const f = h(n, [
    "videoMetadata"
  ]);
  return f != null && m(e, ["videoMetadata"], f), e;
}
function Sx(n) {
  const e = {}, t = h(n, [
    "functionDeclarations"
  ]);
  if (t != null) {
    let l = t;
    Array.isArray(l) && (l = l.map((c) => c)), m(e, ["functionDeclarations"], l);
  }
  if (h(n, ["retrieval"]) !== void 0)
    throw new Error("retrieval parameter is not supported in Gemini API.");
  const r = h(n, [
    "googleSearchRetrieval"
  ]);
  r != null && m(e, ["googleSearchRetrieval"], r);
  const o = h(n, ["googleMaps"]);
  o != null && m(e, ["googleMaps"], yx(o));
  const i = h(n, ["computerUse"]);
  i != null && m(e, ["computerUse"], i);
  const a = h(n, [
    "codeExecution"
  ]);
  if (a != null && m(e, ["codeExecution"], a), h(n, ["enterpriseWebSearch"]) !== void 0)
    throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
  const s = h(n, ["googleSearch"]);
  s != null && m(e, ["googleSearch"], xx(s));
  const u = h(n, ["urlContext"]);
  return u != null && m(e, ["urlContext"], u), e;
}
function Ax(n) {
  const e = {}, t = h(n, [
    "functionDeclarations"
  ]);
  if (t != null) {
    let f = t;
    Array.isArray(f) && (f = f.map((d) => mx(d))), m(e, ["functionDeclarations"], f);
  }
  const r = h(n, ["retrieval"]);
  r != null && m(e, ["retrieval"], r);
  const o = h(n, [
    "googleSearchRetrieval"
  ]);
  o != null && m(e, ["googleSearchRetrieval"], o);
  const i = h(n, ["googleMaps"]);
  i != null && m(e, ["googleMaps"], i);
  const a = h(n, ["computerUse"]);
  a != null && m(e, ["computerUse"], a);
  const s = h(n, [
    "codeExecution"
  ]);
  s != null && m(e, ["codeExecution"], s);
  const u = h(n, [
    "enterpriseWebSearch"
  ]);
  u != null && m(e, ["enterpriseWebSearch"], u);
  const l = h(n, ["googleSearch"]);
  l != null && m(e, ["googleSearch"], l);
  const c = h(n, ["urlContext"]);
  return c != null && m(e, ["urlContext"], c), e;
}
function Rx(n, e) {
  const t = {}, r = h(n, ["ttl"]);
  e !== void 0 && r != null && m(e, ["ttl"], r);
  const o = h(n, ["expireTime"]);
  return e !== void 0 && o != null && m(e, ["expireTime"], o), t;
}
function kx(n, e) {
  const t = {}, r = h(n, ["ttl"]);
  e !== void 0 && r != null && m(e, ["ttl"], r);
  const o = h(n, ["expireTime"]);
  return e !== void 0 && o != null && m(e, ["expireTime"], o), t;
}
function Px(n, e) {
  const t = {}, r = h(e, ["name"]);
  r != null && m(t, ["_url", "name"], gr(n, r));
  const o = h(e, ["config"]);
  return o != null && Rx(o, t), t;
}
function Nx(n, e) {
  const t = {}, r = h(e, ["name"]);
  r != null && m(t, ["_url", "name"], gr(n, r));
  const o = h(e, ["config"]);
  return o != null && kx(o, t), t;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class Mx extends go {
  constructor(e) {
    super(), this.apiClient = e, this.list = async (t = {}) => new oa(co.PAGED_ITEM_CACHED_CONTENTS, (r) => this.listInternal(r), await this.listInternal(t), t);
  }
  /**
   * Creates a cached contents resource.
   *
   * @remarks
   * Context caching is only supported for specific models. See [Gemini
   * Developer API reference](https://ai.google.dev/gemini-api/docs/caching?lang=node/context-cac)
   * and [Vertex AI reference](https://cloud.google.com/vertex-ai/generative-ai/docs/context-cache/context-cache-overview#supported_models)
   * for more information.
   *
   * @param params - The parameters for the create request.
   * @return The created cached content.
   *
   * @example
   * ```ts
   * const contents = ...; // Initialize the content to cache.
   * const response = await ai.caches.create({
   *   model: 'gemini-2.0-flash-001',
   *   config: {
   *    'contents': contents,
   *    'displayName': 'test cache',
   *    'systemInstruction': 'What is the sum of the two pdfs?',
   *    'ttl': '86400s',
   *  }
   * });
   * ```
   */
  async create(e) {
    var t, r, o, i;
    let a, s = "", u = {};
    if (this.apiClient.isVertexAI()) {
      const l = lx(this.apiClient, e);
      return s = Q("cachedContents", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "POST",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((c) => c.json()), a.then((c) => c);
    } else {
      const l = ux(this.apiClient, e);
      return s = Q("cachedContents", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "POST",
        httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
        abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal
      }).then((c) => c.json()), a.then((c) => c);
    }
  }
  /**
   * Gets cached content configurations.
   *
   * @param params - The parameters for the get request.
   * @return The cached content.
   *
   * @example
   * ```ts
   * await ai.caches.get({name: '...'}); // The server-generated resource name.
   * ```
   */
  async get(e) {
    var t, r, o, i;
    let a, s = "", u = {};
    if (this.apiClient.isVertexAI()) {
      const l = gx(this.apiClient, e);
      return s = Q("{name}", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "GET",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((c) => c.json()), a.then((c) => c);
    } else {
      const l = vx(this.apiClient, e);
      return s = Q("{name}", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "GET",
        httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
        abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal
      }).then((c) => c.json()), a.then((c) => c);
    }
  }
  /**
   * Deletes cached content.
   *
   * @param params - The parameters for the delete request.
   * @return The empty response returned by the API.
   *
   * @example
   * ```ts
   * await ai.caches.delete({name: '...'}); // The server-generated resource name.
   * ```
   */
  async delete(e) {
    var t, r, o, i;
    let a, s = "", u = {};
    if (this.apiClient.isVertexAI()) {
      const l = fx(this.apiClient, e);
      return s = Q("{name}", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "DELETE",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((c) => c.json().then((f) => {
        const d = f;
        return d.sdkHttpResponse = {
          headers: c.headers
        }, d;
      })), a.then((c) => {
        const f = hx(c), d = new yh();
        return Object.assign(d, f), d;
      });
    } else {
      const l = cx(this.apiClient, e);
      return s = Q("{name}", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "DELETE",
        httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
        abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal
      }).then((c) => c.json().then((f) => {
        const d = f;
        return d.sdkHttpResponse = {
          headers: c.headers
        }, d;
      })), a.then((c) => {
        const f = dx(c), d = new yh();
        return Object.assign(d, f), d;
      });
    }
  }
  /**
   * Updates cached content configurations.
   *
   * @param params - The parameters for the update request.
   * @return The updated cached content.
   *
   * @example
   * ```ts
   * const response = await ai.caches.update({
   *   name: '...',  // The server-generated resource name.
   *   config: {'ttl': '7600s'}
   * });
   * ```
   */
  async update(e) {
    var t, r, o, i;
    let a, s = "", u = {};
    if (this.apiClient.isVertexAI()) {
      const l = Nx(this.apiClient, e);
      return s = Q("{name}", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "PATCH",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((c) => c.json()), a.then((c) => c);
    } else {
      const l = Px(this.apiClient, e);
      return s = Q("{name}", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "PATCH",
        httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
        abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal
      }).then((c) => c.json()), a.then((c) => c);
    }
  }
  async listInternal(e) {
    var t, r, o, i;
    let a, s = "", u = {};
    if (this.apiClient.isVertexAI()) {
      const l = Ex(e);
      return s = Q("cachedContents", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "GET",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((c) => c.json().then((f) => {
        const d = f;
        return d.sdkHttpResponse = {
          headers: c.headers
        }, d;
      })), a.then((c) => {
        const f = Tx(c), d = new xh();
        return Object.assign(d, f), d;
      });
    } else {
      const l = bx(e);
      return s = Q("cachedContents", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "GET",
        httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
        abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal
      }).then((c) => c.json().then((f) => {
        const d = f;
        return d.sdkHttpResponse = {
          headers: c.headers
        }, d;
      })), a.then((c) => {
        const f = Cx(c), d = new xh();
        return Object.assign(d, f), d;
      });
    }
  }
}
function Ih(n) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && n[e], r = 0;
  if (t) return t.call(n);
  if (n && typeof n.length == "number") return {
    next: function() {
      return n && r >= n.length && (n = void 0), { value: n && n[r++], done: !n };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Ve(n) {
  return this instanceof Ve ? (this.v = n, this) : new Ve(n);
}
function Vo(n, e, t) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = t.apply(n, e || []), o, i = [];
  return o = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), s("next"), s("throw"), s("return", a), o[Symbol.asyncIterator] = function() {
    return this;
  }, o;
  function a(p) {
    return function(v) {
      return Promise.resolve(v).then(p, f);
    };
  }
  function s(p, v) {
    r[p] && (o[p] = function(g) {
      return new Promise(function(y, x) {
        i.push([p, g, y, x]) > 1 || u(p, g);
      });
    }, v && (o[p] = v(o[p])));
  }
  function u(p, v) {
    try {
      l(r[p](v));
    } catch (g) {
      d(i[0][3], g);
    }
  }
  function l(p) {
    p.value instanceof Ve ? Promise.resolve(p.value.v).then(c, f) : d(i[0][2], p);
  }
  function c(p) {
    u("next", p);
  }
  function f(p) {
    u("throw", p);
  }
  function d(p, v) {
    p(v), i.shift(), i.length && u(i[0][0], i[0][1]);
  }
}
function Bi(n) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = n[Symbol.asyncIterator], t;
  return e ? e.call(n) : (n = typeof Ih == "function" ? Ih(n) : n[Symbol.iterator](), t = {}, r("next"), r("throw"), r("return"), t[Symbol.asyncIterator] = function() {
    return this;
  }, t);
  function r(i) {
    t[i] = n[i] && function(a) {
      return new Promise(function(s, u) {
        a = n[i](a), o(s, u, a.done, a.value);
      });
    };
  }
  function o(i, a, s, u) {
    Promise.resolve(u).then(function(l) {
      i({ value: l, done: s });
    }, a);
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function Dx(n) {
  var e;
  if (n.candidates == null || n.candidates.length === 0)
    return !1;
  const t = (e = n.candidates[0]) === null || e === void 0 ? void 0 : e.content;
  return t === void 0 ? !1 : uv(t);
}
function uv(n) {
  if (n.parts === void 0 || n.parts.length === 0)
    return !1;
  for (const e of n.parts)
    if (e === void 0 || Object.keys(e).length === 0)
      return !1;
  return !0;
}
function Fx(n) {
  if (n.length !== 0) {
    for (const e of n)
      if (e.role !== "user" && e.role !== "model")
        throw new Error(`Role must be user or model, but got ${e.role}.`);
  }
}
function Sh(n) {
  if (n === void 0 || n.length === 0)
    return [];
  const e = [], t = n.length;
  let r = 0;
  for (; r < t; )
    if (n[r].role === "user")
      e.push(n[r]), r++;
    else {
      const o = [];
      let i = !0;
      for (; r < t && n[r].role === "model"; )
        o.push(n[r]), i && !uv(n[r]) && (i = !1), r++;
      i ? e.push(...o) : e.pop();
    }
  return e;
}
class Lx {
  constructor(e, t) {
    this.modelsModule = e, this.apiClient = t;
  }
  /**
   * Creates a new chat session.
   *
   * @remarks
   * The config in the params will be used for all requests within the chat
   * session unless overridden by a per-request `config` in
   * @see {@link types.SendMessageParameters#config}.
   *
   * @param params - Parameters for creating a chat session.
   * @returns A new chat session.
   *
   * @example
   * ```ts
   * const chat = ai.chats.create({
   *   model: 'gemini-2.0-flash'
   *   config: {
   *     temperature: 0.5,
   *     maxOutputTokens: 1024,
   *   }
   * });
   * ```
   */
  create(e) {
    return new Bx(
      this.apiClient,
      this.modelsModule,
      e.model,
      e.config,
      // Deep copy the history to avoid mutating the history outside of the
      // chat session.
      structuredClone(e.history)
    );
  }
}
class Bx {
  constructor(e, t, r, o = {}, i = []) {
    this.apiClient = e, this.modelsModule = t, this.model = r, this.config = o, this.history = i, this.sendPromise = Promise.resolve(), Fx(i);
  }
  /**
   * Sends a message to the model and returns the response.
   *
   * @remarks
   * This method will wait for the previous message to be processed before
   * sending the next message.
   *
   * @see {@link Chat#sendMessageStream} for streaming method.
   * @param params - parameters for sending messages within a chat session.
   * @returns The model's response.
   *
   * @example
   * ```ts
   * const chat = ai.chats.create({model: 'gemini-2.0-flash'});
   * const response = await chat.sendMessage({
   *   message: 'Why is the sky blue?'
   * });
   * console.log(response.text);
   * ```
   */
  async sendMessage(e) {
    var t;
    await this.sendPromise;
    const r = Pt(e.message), o = this.modelsModule.generateContent({
      model: this.model,
      contents: this.getHistory(!0).concat(r),
      config: (t = e.config) !== null && t !== void 0 ? t : this.config
    });
    return this.sendPromise = (async () => {
      var i, a, s;
      const u = await o, l = (a = (i = u.candidates) === null || i === void 0 ? void 0 : i[0]) === null || a === void 0 ? void 0 : a.content, c = u.automaticFunctionCallingHistory, f = this.getHistory(!0).length;
      let d = [];
      c != null && (d = (s = c.slice(f)) !== null && s !== void 0 ? s : []);
      const p = l ? [l] : [];
      this.recordHistory(r, p, d);
    })(), await this.sendPromise.catch(() => {
      this.sendPromise = Promise.resolve();
    }), o;
  }
  /**
   * Sends a message to the model and returns the response in chunks.
   *
   * @remarks
   * This method will wait for the previous message to be processed before
   * sending the next message.
   *
   * @see {@link Chat#sendMessage} for non-streaming method.
   * @param params - parameters for sending the message.
   * @return The model's response.
   *
   * @example
   * ```ts
   * const chat = ai.chats.create({model: 'gemini-2.0-flash'});
   * const response = await chat.sendMessageStream({
   *   message: 'Why is the sky blue?'
   * });
   * for await (const chunk of response) {
   *   console.log(chunk.text);
   * }
   * ```
   */
  async sendMessageStream(e) {
    var t;
    await this.sendPromise;
    const r = Pt(e.message), o = this.modelsModule.generateContentStream({
      model: this.model,
      contents: this.getHistory(!0).concat(r),
      config: (t = e.config) !== null && t !== void 0 ? t : this.config
    });
    this.sendPromise = o.then(() => {
    }).catch(() => {
    });
    const i = await o;
    return this.processStreamResponse(i, r);
  }
  /**
   * Returns the chat history.
   *
   * @remarks
   * The history is a list of contents alternating between user and model.
   *
   * There are two types of history:
   * - The `curated history` contains only the valid turns between user and
   * model, which will be included in the subsequent requests sent to the model.
   * - The `comprehensive history` contains all turns, including invalid or
   *   empty model outputs, providing a complete record of the history.
   *
   * The history is updated after receiving the response from the model,
   * for streaming response, it means receiving the last chunk of the response.
   *
   * The `comprehensive history` is returned by default. To get the `curated
   * history`, set the `curated` parameter to `true`.
   *
   * @param curated - whether to return the curated history or the comprehensive
   *     history.
   * @return History contents alternating between user and model for the entire
   *     chat session.
   */
  getHistory(e = !1) {
    const t = e ? Sh(this.history) : this.history;
    return structuredClone(t);
  }
  processStreamResponse(e, t) {
    var r, o;
    return Vo(this, arguments, function* () {
      var a, s, u, l;
      const c = [];
      try {
        for (var f = !0, d = Bi(e), p; p = yield Ve(d.next()), a = p.done, !a; f = !0) {
          l = p.value, f = !1;
          const v = l;
          if (Dx(v)) {
            const g = (o = (r = v.candidates) === null || r === void 0 ? void 0 : r[0]) === null || o === void 0 ? void 0 : o.content;
            g !== void 0 && c.push(g);
          }
          yield yield Ve(v);
        }
      } catch (v) {
        s = { error: v };
      } finally {
        try {
          !f && !a && (u = d.return) && (yield Ve(u.call(d)));
        } finally {
          if (s) throw s.error;
        }
      }
      this.recordHistory(t, c);
    });
  }
  recordHistory(e, t, r) {
    let o = [];
    t.length > 0 && t.every((i) => i.role !== void 0) ? o = t : o.push({
      role: "model",
      parts: []
    }), r && r.length > 0 ? this.history.push(...Sh(r)) : this.history.push(e), this.history.push(...o);
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class bs extends Error {
  constructor(e) {
    super(e.message), this.name = "ApiError", this.status = e.status, Object.setPrototypeOf(this, bs.prototype);
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function Ox(n) {
  const e = {}, t = h(n, ["file"]);
  return t != null && m(e, ["file"], t), e;
}
function Ux(n) {
  const e = {}, t = h(n, [
    "sdkHttpResponse"
  ]);
  return t != null && m(e, ["sdkHttpResponse"], t), e;
}
function Vx(n) {
  const e = {}, t = h(n, ["name"]);
  return t != null && m(e, ["_url", "file"], tv(t)), e;
}
function Gx(n) {
  const e = {}, t = h(n, [
    "sdkHttpResponse"
  ]);
  return t != null && m(e, ["sdkHttpResponse"], t), e;
}
function Wx(n) {
  const e = {}, t = h(n, ["name"]);
  return t != null && m(e, ["_url", "file"], tv(t)), e;
}
function Hx(n, e) {
  const t = {}, r = h(n, ["pageSize"]);
  e !== void 0 && r != null && m(e, ["_query", "pageSize"], r);
  const o = h(n, ["pageToken"]);
  return e !== void 0 && o != null && m(e, ["_query", "pageToken"], o), t;
}
function $x(n) {
  const e = {}, t = h(n, ["config"]);
  return t != null && Hx(t, e), e;
}
function qx(n) {
  const e = {}, t = h(n, [
    "sdkHttpResponse"
  ]);
  t != null && m(e, ["sdkHttpResponse"], t);
  const r = h(n, [
    "nextPageToken"
  ]);
  r != null && m(e, ["nextPageToken"], r);
  const o = h(n, ["files"]);
  if (o != null) {
    let i = o;
    Array.isArray(i) && (i = i.map((a) => a)), m(e, ["files"], i);
  }
  return e;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class zx extends go {
  constructor(e) {
    super(), this.apiClient = e, this.list = async (t = {}) => new oa(co.PAGED_ITEM_FILES, (r) => this.listInternal(r), await this.listInternal(t), t);
  }
  /**
   * Uploads a file asynchronously to the Gemini API.
   * This method is not available in Vertex AI.
   * Supported upload sources:
   * - Node.js: File path (string) or Blob object.
   * - Browser: Blob object (e.g., File).
   *
   * @remarks
   * The `mimeType` can be specified in the `config` parameter. If omitted:
   *  - For file path (string) inputs, the `mimeType` will be inferred from the
   *     file extension.
   *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`
   *     property.
   * Somex eamples for file extension to mimeType mapping:
   * .txt -> text/plain
   * .json -> application/json
   * .jpg  -> image/jpeg
   * .png -> image/png
   * .mp3 -> audio/mpeg
   * .mp4 -> video/mp4
   *
   * This section can contain multiple paragraphs and code examples.
   *
   * @param params - Optional parameters specified in the
   *        `types.UploadFileParameters` interface.
   *         @see {@link types.UploadFileParameters#config} for the optional
   *         config in the parameters.
   * @return A promise that resolves to a `types.File` object.
   * @throws An error if called on a Vertex AI client.
   * @throws An error if the `mimeType` is not provided and can not be inferred,
   * the `mimeType` can be provided in the `params.config` parameter.
   * @throws An error occurs if a suitable upload location cannot be established.
   *
   * @example
   * The following code uploads a file to Gemini API.
   *
   * ```ts
   * const file = await ai.files.upload({file: 'file.txt', config: {
   *   mimeType: 'text/plain',
   * }});
   * console.log(file.name);
   * ```
   */
  async upload(e) {
    if (this.apiClient.isVertexAI())
      throw new Error("Vertex AI does not support uploading files. You can share files through a GCS bucket.");
    return this.apiClient.uploadFile(e.file, e.config).then((t) => t);
  }
  /**
   * Downloads a remotely stored file asynchronously to a location specified in
   * the `params` object. This method only works on Node environment, to
   * download files in the browser, use a browser compliant method like an <a>
   * tag.
   *
   * @param params - The parameters for the download request.
   *
   * @example
   * The following code downloads an example file named "files/mehozpxf877d" as
   * "file.txt".
   *
   * ```ts
   * await ai.files.download({file: file.name, downloadPath: 'file.txt'});
   * ```
   */
  async download(e) {
    await this.apiClient.downloadFile(e);
  }
  async listInternal(e) {
    var t, r;
    let o, i = "", a = {};
    if (this.apiClient.isVertexAI())
      throw new Error("This method is only supported by the Gemini Developer API.");
    {
      const s = $x(e);
      return i = Q("files", s._url), a = s._query, delete s._url, delete s._query, o = this.apiClient.request({
        path: i,
        queryParams: a,
        body: JSON.stringify(s),
        httpMethod: "GET",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((u) => u.json().then((l) => {
        const c = l;
        return c.sdkHttpResponse = {
          headers: u.headers
        }, c;
      })), o.then((u) => {
        const l = qx(u), c = new r2();
        return Object.assign(c, l), c;
      });
    }
  }
  async createInternal(e) {
    var t, r;
    let o, i = "", a = {};
    if (this.apiClient.isVertexAI())
      throw new Error("This method is only supported by the Gemini Developer API.");
    {
      const s = Ox(e);
      return i = Q("upload/v1beta/files", s._url), a = s._query, delete s._url, delete s._query, o = this.apiClient.request({
        path: i,
        queryParams: a,
        body: JSON.stringify(s),
        httpMethod: "POST",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((u) => u.json()), o.then((u) => {
        const l = Ux(u), c = new o2();
        return Object.assign(c, l), c;
      });
    }
  }
  /**
   * Retrieves the file information from the service.
   *
   * @param params - The parameters for the get request
   * @return The Promise that resolves to the types.File object requested.
   *
   * @example
   * ```ts
   * const config: GetFileParameters = {
   *   name: fileName,
   * };
   * file = await ai.files.get(config);
   * console.log(file.name);
   * ```
   */
  async get(e) {
    var t, r;
    let o, i = "", a = {};
    if (this.apiClient.isVertexAI())
      throw new Error("This method is only supported by the Gemini Developer API.");
    {
      const s = Wx(e);
      return i = Q("files/{file}", s._url), a = s._query, delete s._url, delete s._query, o = this.apiClient.request({
        path: i,
        queryParams: a,
        body: JSON.stringify(s),
        httpMethod: "GET",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((u) => u.json()), o.then((u) => u);
    }
  }
  /**
   * Deletes a remotely stored file.
   *
   * @param params - The parameters for the delete request.
   * @return The DeleteFileResponse, the response for the delete method.
   *
   * @example
   * The following code deletes an example file named "files/mehozpxf877d".
   *
   * ```ts
   * await ai.files.delete({name: file.name});
   * ```
   */
  async delete(e) {
    var t, r;
    let o, i = "", a = {};
    if (this.apiClient.isVertexAI())
      throw new Error("This method is only supported by the Gemini Developer API.");
    {
      const s = Vx(e);
      return i = Q("files/{file}", s._url), a = s._query, delete s._url, delete s._query, o = this.apiClient.request({
        path: i,
        queryParams: a,
        body: JSON.stringify(s),
        httpMethod: "DELETE",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((u) => u.json().then((l) => {
        const c = l;
        return c.sdkHttpResponse = {
          headers: u.headers
        }, c;
      })), o.then((u) => {
        const l = Gx(u), c = new i2();
        return Object.assign(c, l), c;
      });
    }
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function Oa(n) {
  const e = {}, t = h(n, ["data"]);
  if (t != null && m(e, ["data"], t), h(n, ["displayName"]) !== void 0)
    throw new Error("displayName parameter is not supported in Gemini API.");
  const r = h(n, ["mimeType"]);
  return r != null && m(e, ["mimeType"], r), e;
}
function Kx(n) {
  const e = {}, t = h(n, ["parts"]);
  if (t != null) {
    let o = t;
    Array.isArray(o) && (o = o.map((i) => uw(i))), m(e, ["parts"], o);
  }
  const r = h(n, ["role"]);
  return r != null && m(e, ["role"], r), e;
}
function Jx(n) {
  const e = {};
  if (h(n, ["displayName"]) !== void 0)
    throw new Error("displayName parameter is not supported in Gemini API.");
  const t = h(n, ["fileUri"]);
  t != null && m(e, ["fileUri"], t);
  const r = h(n, ["mimeType"]);
  return r != null && m(e, ["mimeType"], r), e;
}
function Xx(n) {
  const e = {};
  if (h(n, ["behavior"]) !== void 0)
    throw new Error("behavior parameter is not supported in Vertex AI.");
  const t = h(n, ["description"]);
  t != null && m(e, ["description"], t);
  const r = h(n, ["name"]);
  r != null && m(e, ["name"], r);
  const o = h(n, ["parameters"]);
  o != null && m(e, ["parameters"], o);
  const i = h(n, [
    "parametersJsonSchema"
  ]);
  i != null && m(e, ["parametersJsonSchema"], i);
  const a = h(n, ["response"]);
  a != null && m(e, ["response"], a);
  const s = h(n, [
    "responseJsonSchema"
  ]);
  return s != null && m(e, ["responseJsonSchema"], s), e;
}
function Yx(n) {
  const e = {}, t = h(n, [
    "modelSelectionConfig"
  ]);
  t != null && m(e, ["modelConfig"], t);
  const r = h(n, [
    "audioTimestamp"
  ]);
  r != null && m(e, ["audioTimestamp"], r);
  const o = h(n, [
    "candidateCount"
  ]);
  o != null && m(e, ["candidateCount"], o);
  const i = h(n, [
    "enableAffectiveDialog"
  ]);
  i != null && m(e, ["enableAffectiveDialog"], i);
  const a = h(n, [
    "frequencyPenalty"
  ]);
  a != null && m(e, ["frequencyPenalty"], a);
  const s = h(n, ["logprobs"]);
  s != null && m(e, ["logprobs"], s);
  const u = h(n, [
    "maxOutputTokens"
  ]);
  u != null && m(e, ["maxOutputTokens"], u);
  const l = h(n, [
    "mediaResolution"
  ]);
  l != null && m(e, ["mediaResolution"], l);
  const c = h(n, [
    "presencePenalty"
  ]);
  c != null && m(e, ["presencePenalty"], c);
  const f = h(n, [
    "responseJsonSchema"
  ]);
  f != null && m(e, ["responseJsonSchema"], f);
  const d = h(n, [
    "responseLogprobs"
  ]);
  d != null && m(e, ["responseLogprobs"], d);
  const p = h(n, [
    "responseMimeType"
  ]);
  p != null && m(e, ["responseMimeType"], p);
  const v = h(n, [
    "responseModalities"
  ]);
  v != null && m(e, ["responseModalities"], v);
  const g = h(n, [
    "responseSchema"
  ]);
  g != null && m(e, ["responseSchema"], g);
  const y = h(n, [
    "routingConfig"
  ]);
  y != null && m(e, ["routingConfig"], y);
  const x = h(n, ["seed"]);
  x != null && m(e, ["seed"], x);
  const w = h(n, ["speechConfig"]);
  w != null && m(e, ["speechConfig"], lv(w));
  const b = h(n, [
    "stopSequences"
  ]);
  b != null && m(e, ["stopSequences"], b);
  const _ = h(n, ["temperature"]);
  _ != null && m(e, ["temperature"], _);
  const E = h(n, [
    "thinkingConfig"
  ]);
  E != null && m(e, ["thinkingConfig"], E);
  const C = h(n, ["topK"]);
  C != null && m(e, ["topK"], C);
  const A = h(n, ["topP"]);
  if (A != null && m(e, ["topP"], A), h(n, ["enableEnhancedCivicAnswers"]) !== void 0)
    throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI.");
  return e;
}
function Qx(n) {
  const e = {};
  if (h(n, ["authConfig"]) !== void 0)
    throw new Error("authConfig parameter is not supported in Gemini API.");
  const t = h(n, ["enableWidget"]);
  return t != null && m(e, ["enableWidget"], t), e;
}
function Zx(n) {
  const e = {};
  if (h(n, ["excludeDomains"]) !== void 0)
    throw new Error("excludeDomains parameter is not supported in Gemini API.");
  const t = h(n, [
    "timeRangeFilter"
  ]);
  return t != null && m(e, ["timeRangeFilter"], t), e;
}
function jx(n, e) {
  const t = {}, r = h(n, [
    "generationConfig"
  ]);
  e !== void 0 && r != null && m(e, ["setup", "generationConfig"], r);
  const o = h(n, [
    "responseModalities"
  ]);
  e !== void 0 && o != null && m(e, ["setup", "generationConfig", "responseModalities"], o);
  const i = h(n, ["temperature"]);
  e !== void 0 && i != null && m(e, ["setup", "generationConfig", "temperature"], i);
  const a = h(n, ["topP"]);
  e !== void 0 && a != null && m(e, ["setup", "generationConfig", "topP"], a);
  const s = h(n, ["topK"]);
  e !== void 0 && s != null && m(e, ["setup", "generationConfig", "topK"], s);
  const u = h(n, [
    "maxOutputTokens"
  ]);
  e !== void 0 && u != null && m(e, ["setup", "generationConfig", "maxOutputTokens"], u);
  const l = h(n, [
    "mediaResolution"
  ]);
  e !== void 0 && l != null && m(e, ["setup", "generationConfig", "mediaResolution"], l);
  const c = h(n, ["seed"]);
  e !== void 0 && c != null && m(e, ["setup", "generationConfig", "seed"], c);
  const f = h(n, ["speechConfig"]);
  e !== void 0 && f != null && m(e, ["setup", "generationConfig", "speechConfig"], hc(f));
  const d = h(n, [
    "thinkingConfig"
  ]);
  e !== void 0 && d != null && m(e, ["setup", "generationConfig", "thinkingConfig"], d);
  const p = h(n, [
    "enableAffectiveDialog"
  ]);
  e !== void 0 && p != null && m(e, ["setup", "generationConfig", "enableAffectiveDialog"], p);
  const v = h(n, [
    "systemInstruction"
  ]);
  e !== void 0 && v != null && m(e, ["setup", "systemInstruction"], Kx(Pt(v)));
  const g = h(n, ["tools"]);
  if (e !== void 0 && g != null) {
    let C = mi(g);
    Array.isArray(C) && (C = C.map((A) => cw(pi(A)))), m(e, ["setup", "tools"], C);
  }
  const y = h(n, [
    "sessionResumption"
  ]);
  e !== void 0 && y != null && m(e, ["setup", "sessionResumption"], lw(y));
  const x = h(n, [
    "inputAudioTranscription"
  ]);
  e !== void 0 && x != null && m(e, ["setup", "inputAudioTranscription"], x);
  const w = h(n, [
    "outputAudioTranscription"
  ]);
  e !== void 0 && w != null && m(e, ["setup", "outputAudioTranscription"], w);
  const b = h(n, [
    "realtimeInputConfig"
  ]);
  e !== void 0 && b != null && m(e, ["setup", "realtimeInputConfig"], b);
  const _ = h(n, [
    "contextWindowCompression"
  ]);
  e !== void 0 && _ != null && m(e, ["setup", "contextWindowCompression"], _);
  const E = h(n, ["proactivity"]);
  return e !== void 0 && E != null && m(e, ["setup", "proactivity"], E), t;
}
function ew(n, e) {
  const t = {}, r = h(n, [
    "generationConfig"
  ]);
  e !== void 0 && r != null && m(e, ["setup", "generationConfig"], Yx(r));
  const o = h(n, [
    "responseModalities"
  ]);
  e !== void 0 && o != null && m(e, ["setup", "generationConfig", "responseModalities"], o);
  const i = h(n, ["temperature"]);
  e !== void 0 && i != null && m(e, ["setup", "generationConfig", "temperature"], i);
  const a = h(n, ["topP"]);
  e !== void 0 && a != null && m(e, ["setup", "generationConfig", "topP"], a);
  const s = h(n, ["topK"]);
  e !== void 0 && s != null && m(e, ["setup", "generationConfig", "topK"], s);
  const u = h(n, [
    "maxOutputTokens"
  ]);
  e !== void 0 && u != null && m(e, ["setup", "generationConfig", "maxOutputTokens"], u);
  const l = h(n, [
    "mediaResolution"
  ]);
  e !== void 0 && l != null && m(e, ["setup", "generationConfig", "mediaResolution"], l);
  const c = h(n, ["seed"]);
  e !== void 0 && c != null && m(e, ["setup", "generationConfig", "seed"], c);
  const f = h(n, ["speechConfig"]);
  e !== void 0 && f != null && m(e, ["setup", "generationConfig", "speechConfig"], lv(hc(f)));
  const d = h(n, [
    "thinkingConfig"
  ]);
  e !== void 0 && d != null && m(e, ["setup", "generationConfig", "thinkingConfig"], d);
  const p = h(n, [
    "enableAffectiveDialog"
  ]);
  e !== void 0 && p != null && m(e, ["setup", "generationConfig", "enableAffectiveDialog"], p);
  const v = h(n, [
    "systemInstruction"
  ]);
  e !== void 0 && v != null && m(e, ["setup", "systemInstruction"], Pt(v));
  const g = h(n, ["tools"]);
  if (e !== void 0 && g != null) {
    let C = mi(g);
    Array.isArray(C) && (C = C.map((A) => fw(pi(A)))), m(e, ["setup", "tools"], C);
  }
  const y = h(n, [
    "sessionResumption"
  ]);
  e !== void 0 && y != null && m(e, ["setup", "sessionResumption"], y);
  const x = h(n, [
    "inputAudioTranscription"
  ]);
  e !== void 0 && x != null && m(e, ["setup", "inputAudioTranscription"], x);
  const w = h(n, [
    "outputAudioTranscription"
  ]);
  e !== void 0 && w != null && m(e, ["setup", "outputAudioTranscription"], w);
  const b = h(n, [
    "realtimeInputConfig"
  ]);
  e !== void 0 && b != null && m(e, ["setup", "realtimeInputConfig"], b);
  const _ = h(n, [
    "contextWindowCompression"
  ]);
  e !== void 0 && _ != null && m(e, ["setup", "contextWindowCompression"], _);
  const E = h(n, ["proactivity"]);
  return e !== void 0 && E != null && m(e, ["setup", "proactivity"], E), t;
}
function tw(n, e) {
  const t = {}, r = h(e, ["model"]);
  r != null && m(t, ["setup", "model"], Re(n, r));
  const o = h(e, ["config"]);
  return o != null && m(t, ["config"], jx(o, t)), t;
}
function nw(n, e) {
  const t = {}, r = h(e, ["model"]);
  r != null && m(t, ["setup", "model"], Re(n, r));
  const o = h(e, ["config"]);
  return o != null && m(t, ["config"], ew(o, t)), t;
}
function rw(n) {
  const e = {}, t = h(n, [
    "musicGenerationConfig"
  ]);
  return t != null && m(e, ["musicGenerationConfig"], t), e;
}
function ow(n) {
  const e = {}, t = h(n, [
    "weightedPrompts"
  ]);
  if (t != null) {
    let r = t;
    Array.isArray(r) && (r = r.map((o) => o)), m(e, ["weightedPrompts"], r);
  }
  return e;
}
function iw(n) {
  const e = {}, t = h(n, ["media"]);
  if (t != null) {
    let l = Ym(t);
    Array.isArray(l) && (l = l.map((c) => Oa(c))), m(e, ["mediaChunks"], l);
  }
  const r = h(n, ["audio"]);
  r != null && m(e, ["audio"], Oa(Zm(r)));
  const o = h(n, [
    "audioStreamEnd"
  ]);
  o != null && m(e, ["audioStreamEnd"], o);
  const i = h(n, ["video"]);
  i != null && m(e, ["video"], Oa(Qm(i)));
  const a = h(n, ["text"]);
  a != null && m(e, ["text"], a);
  const s = h(n, [
    "activityStart"
  ]);
  s != null && m(e, ["activityStart"], s);
  const u = h(n, ["activityEnd"]);
  return u != null && m(e, ["activityEnd"], u), e;
}
function aw(n) {
  const e = {}, t = h(n, ["media"]);
  if (t != null) {
    let l = Ym(t);
    Array.isArray(l) && (l = l.map((c) => c)), m(e, ["mediaChunks"], l);
  }
  const r = h(n, ["audio"]);
  r != null && m(e, ["audio"], Zm(r));
  const o = h(n, [
    "audioStreamEnd"
  ]);
  o != null && m(e, ["audioStreamEnd"], o);
  const i = h(n, ["video"]);
  i != null && m(e, ["video"], Qm(i));
  const a = h(n, ["text"]);
  a != null && m(e, ["text"], a);
  const s = h(n, [
    "activityStart"
  ]);
  s != null && m(e, ["activityStart"], s);
  const u = h(n, ["activityEnd"]);
  return u != null && m(e, ["activityEnd"], u), e;
}
function sw(n) {
  const e = {}, t = h(n, [
    "setupComplete"
  ]);
  t != null && m(e, ["setupComplete"], t);
  const r = h(n, [
    "serverContent"
  ]);
  r != null && m(e, ["serverContent"], r);
  const o = h(n, ["toolCall"]);
  o != null && m(e, ["toolCall"], o);
  const i = h(n, [
    "toolCallCancellation"
  ]);
  i != null && m(e, ["toolCallCancellation"], i);
  const a = h(n, [
    "usageMetadata"
  ]);
  a != null && m(e, ["usageMetadata"], dw(a));
  const s = h(n, ["goAway"]);
  s != null && m(e, ["goAway"], s);
  const u = h(n, [
    "sessionResumptionUpdate"
  ]);
  return u != null && m(e, ["sessionResumptionUpdate"], u), e;
}
function uw(n) {
  const e = {}, t = h(n, ["functionCall"]);
  t != null && m(e, ["functionCall"], t);
  const r = h(n, [
    "codeExecutionResult"
  ]);
  r != null && m(e, ["codeExecutionResult"], r);
  const o = h(n, [
    "executableCode"
  ]);
  o != null && m(e, ["executableCode"], o);
  const i = h(n, ["fileData"]);
  i != null && m(e, ["fileData"], Jx(i));
  const a = h(n, [
    "functionResponse"
  ]);
  a != null && m(e, ["functionResponse"], a);
  const s = h(n, ["inlineData"]);
  s != null && m(e, ["inlineData"], Oa(s));
  const u = h(n, ["text"]);
  u != null && m(e, ["text"], u);
  const l = h(n, ["thought"]);
  l != null && m(e, ["thought"], l);
  const c = h(n, [
    "thoughtSignature"
  ]);
  c != null && m(e, ["thoughtSignature"], c);
  const f = h(n, [
    "videoMetadata"
  ]);
  return f != null && m(e, ["videoMetadata"], f), e;
}
function lw(n) {
  const e = {}, t = h(n, ["handle"]);
  if (t != null && m(e, ["handle"], t), h(n, ["transparent"]) !== void 0)
    throw new Error("transparent parameter is not supported in Gemini API.");
  return e;
}
function lv(n) {
  const e = {}, t = h(n, ["languageCode"]);
  t != null && m(e, ["languageCode"], t);
  const r = h(n, ["voiceConfig"]);
  if (r != null && m(e, ["voiceConfig"], r), h(n, ["multiSpeakerVoiceConfig"]) !== void 0)
    throw new Error("multiSpeakerVoiceConfig parameter is not supported in Vertex AI.");
  return e;
}
function cw(n) {
  const e = {}, t = h(n, [
    "functionDeclarations"
  ]);
  if (t != null) {
    let l = t;
    Array.isArray(l) && (l = l.map((c) => c)), m(e, ["functionDeclarations"], l);
  }
  if (h(n, ["retrieval"]) !== void 0)
    throw new Error("retrieval parameter is not supported in Gemini API.");
  const r = h(n, [
    "googleSearchRetrieval"
  ]);
  r != null && m(e, ["googleSearchRetrieval"], r);
  const o = h(n, ["googleMaps"]);
  o != null && m(e, ["googleMaps"], Qx(o));
  const i = h(n, ["computerUse"]);
  i != null && m(e, ["computerUse"], i);
  const a = h(n, [
    "codeExecution"
  ]);
  if (a != null && m(e, ["codeExecution"], a), h(n, ["enterpriseWebSearch"]) !== void 0)
    throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
  const s = h(n, ["googleSearch"]);
  s != null && m(e, ["googleSearch"], Zx(s));
  const u = h(n, ["urlContext"]);
  return u != null && m(e, ["urlContext"], u), e;
}
function fw(n) {
  const e = {}, t = h(n, [
    "functionDeclarations"
  ]);
  if (t != null) {
    let f = t;
    Array.isArray(f) && (f = f.map((d) => Xx(d))), m(e, ["functionDeclarations"], f);
  }
  const r = h(n, ["retrieval"]);
  r != null && m(e, ["retrieval"], r);
  const o = h(n, [
    "googleSearchRetrieval"
  ]);
  o != null && m(e, ["googleSearchRetrieval"], o);
  const i = h(n, ["googleMaps"]);
  i != null && m(e, ["googleMaps"], i);
  const a = h(n, ["computerUse"]);
  a != null && m(e, ["computerUse"], a);
  const s = h(n, [
    "codeExecution"
  ]);
  s != null && m(e, ["codeExecution"], s);
  const u = h(n, [
    "enterpriseWebSearch"
  ]);
  u != null && m(e, ["enterpriseWebSearch"], u);
  const l = h(n, ["googleSearch"]);
  l != null && m(e, ["googleSearch"], l);
  const c = h(n, ["urlContext"]);
  return c != null && m(e, ["urlContext"], c), e;
}
function dw(n) {
  const e = {}, t = h(n, [
    "promptTokenCount"
  ]);
  t != null && m(e, ["promptTokenCount"], t);
  const r = h(n, [
    "cachedContentTokenCount"
  ]);
  r != null && m(e, ["cachedContentTokenCount"], r);
  const o = h(n, [
    "candidatesTokenCount"
  ]);
  o != null && m(e, ["responseTokenCount"], o);
  const i = h(n, [
    "toolUsePromptTokenCount"
  ]);
  i != null && m(e, ["toolUsePromptTokenCount"], i);
  const a = h(n, [
    "thoughtsTokenCount"
  ]);
  a != null && m(e, ["thoughtsTokenCount"], a);
  const s = h(n, [
    "totalTokenCount"
  ]);
  s != null && m(e, ["totalTokenCount"], s);
  const u = h(n, [
    "promptTokensDetails"
  ]);
  if (u != null) {
    let p = u;
    Array.isArray(p) && (p = p.map((v) => v)), m(e, ["promptTokensDetails"], p);
  }
  const l = h(n, [
    "cacheTokensDetails"
  ]);
  if (l != null) {
    let p = l;
    Array.isArray(p) && (p = p.map((v) => v)), m(e, ["cacheTokensDetails"], p);
  }
  const c = h(n, [
    "candidatesTokensDetails"
  ]);
  if (c != null) {
    let p = c;
    Array.isArray(p) && (p = p.map((v) => v)), m(e, ["responseTokensDetails"], p);
  }
  const f = h(n, [
    "toolUsePromptTokensDetails"
  ]);
  if (f != null) {
    let p = f;
    Array.isArray(p) && (p = p.map((v) => v)), m(e, ["toolUsePromptTokensDetails"], p);
  }
  const d = h(n, ["trafficType"]);
  return d != null && m(e, ["trafficType"], d), e;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function hw(n) {
  const e = {}, t = h(n, ["data"]);
  if (t != null && m(e, ["data"], t), h(n, ["displayName"]) !== void 0)
    throw new Error("displayName parameter is not supported in Gemini API.");
  const r = h(n, ["mimeType"]);
  return r != null && m(e, ["mimeType"], r), e;
}
function pw(n) {
  const e = {}, t = h(n, ["content"]);
  t != null && m(e, ["content"], t);
  const r = h(n, [
    "citationMetadata"
  ]);
  r != null && m(e, ["citationMetadata"], mw(r));
  const o = h(n, ["tokenCount"]);
  o != null && m(e, ["tokenCount"], o);
  const i = h(n, ["finishReason"]);
  i != null && m(e, ["finishReason"], i);
  const a = h(n, ["avgLogprobs"]);
  a != null && m(e, ["avgLogprobs"], a);
  const s = h(n, [
    "groundingMetadata"
  ]);
  s != null && m(e, ["groundingMetadata"], s);
  const u = h(n, ["index"]);
  u != null && m(e, ["index"], u);
  const l = h(n, [
    "logprobsResult"
  ]);
  l != null && m(e, ["logprobsResult"], l);
  const c = h(n, [
    "safetyRatings"
  ]);
  if (c != null) {
    let d = c;
    Array.isArray(d) && (d = d.map((p) => p)), m(e, ["safetyRatings"], d);
  }
  const f = h(n, [
    "urlContextMetadata"
  ]);
  return f != null && m(e, ["urlContextMetadata"], f), e;
}
function mw(n) {
  const e = {}, t = h(n, ["citationSources"]);
  if (t != null) {
    let r = t;
    Array.isArray(r) && (r = r.map((o) => o)), m(e, ["citations"], r);
  }
  return e;
}
function vw(n, e) {
  const t = {}, r = h(e, ["model"]);
  r != null && m(t, ["_url", "model"], Re(n, r));
  const o = h(e, ["contents"]);
  if (o != null) {
    let i = yn(o);
    Array.isArray(i) && (i = i.map((a) => a)), m(t, ["contents"], i);
  }
  return t;
}
function gw(n) {
  const e = {}, t = h(n, [
    "sdkHttpResponse"
  ]);
  t != null && m(e, ["sdkHttpResponse"], t);
  const r = h(n, ["tokensInfo"]);
  if (r != null) {
    let o = r;
    Array.isArray(o) && (o = o.map((i) => i)), m(e, ["tokensInfo"], o);
  }
  return e;
}
function yw(n) {
  const e = {}, t = h(n, ["values"]);
  t != null && m(e, ["values"], t);
  const r = h(n, ["statistics"]);
  return r != null && m(e, ["statistics"], xw(r)), e;
}
function xw(n) {
  const e = {}, t = h(n, ["truncated"]);
  t != null && m(e, ["truncated"], t);
  const r = h(n, ["token_count"]);
  return r != null && m(e, ["tokenCount"], r), e;
}
function Es(n) {
  const e = {}, t = h(n, ["parts"]);
  if (t != null) {
    let o = t;
    Array.isArray(o) && (o = o.map((i) => C_(i))), m(e, ["parts"], o);
  }
  const r = h(n, ["role"]);
  return r != null && m(e, ["role"], r), e;
}
function ww(n) {
  const e = {}, t = h(n, ["controlType"]);
  t != null && m(e, ["controlType"], t);
  const r = h(n, [
    "enableControlImageComputation"
  ]);
  return r != null && m(e, ["computeControl"], r), e;
}
function _w(n) {
  const e = {};
  if (h(n, ["systemInstruction"]) !== void 0)
    throw new Error("systemInstruction parameter is not supported in Gemini API.");
  if (h(n, ["tools"]) !== void 0)
    throw new Error("tools parameter is not supported in Gemini API.");
  if (h(n, ["generationConfig"]) !== void 0)
    throw new Error("generationConfig parameter is not supported in Gemini API.");
  return e;
}
function bw(n, e) {
  const t = {}, r = h(n, [
    "systemInstruction"
  ]);
  e !== void 0 && r != null && m(e, ["systemInstruction"], Pt(r));
  const o = h(n, ["tools"]);
  if (e !== void 0 && o != null) {
    let a = o;
    Array.isArray(a) && (a = a.map((s) => pv(s))), m(e, ["tools"], a);
  }
  const i = h(n, [
    "generationConfig"
  ]);
  return e !== void 0 && i != null && m(e, ["generationConfig"], f_(i)), t;
}
function Ew(n, e) {
  const t = {}, r = h(e, ["model"]);
  r != null && m(t, ["_url", "model"], Re(n, r));
  const o = h(e, ["contents"]);
  if (o != null) {
    let a = yn(o);
    Array.isArray(a) && (a = a.map((s) => Es(s))), m(t, ["contents"], a);
  }
  const i = h(e, ["config"]);
  return i != null && _w(i), t;
}
function Cw(n, e) {
  const t = {}, r = h(e, ["model"]);
  r != null && m(t, ["_url", "model"], Re(n, r));
  const o = h(e, ["contents"]);
  if (o != null) {
    let a = yn(o);
    Array.isArray(a) && (a = a.map((s) => s)), m(t, ["contents"], a);
  }
  const i = h(e, ["config"]);
  return i != null && bw(i, t), t;
}
function Tw(n) {
  const e = {}, t = h(n, [
    "sdkHttpResponse"
  ]);
  t != null && m(e, ["sdkHttpResponse"], t);
  const r = h(n, ["totalTokens"]);
  r != null && m(e, ["totalTokens"], r);
  const o = h(n, [
    "cachedContentTokenCount"
  ]);
  return o != null && m(e, ["cachedContentTokenCount"], o), e;
}
function Iw(n) {
  const e = {}, t = h(n, [
    "sdkHttpResponse"
  ]);
  t != null && m(e, ["sdkHttpResponse"], t);
  const r = h(n, ["totalTokens"]);
  return r != null && m(e, ["totalTokens"], r), e;
}
function Sw(n, e) {
  const t = {}, r = h(e, ["model"]);
  return r != null && m(t, ["_url", "name"], Re(n, r)), t;
}
function Aw(n, e) {
  const t = {}, r = h(e, ["model"]);
  return r != null && m(t, ["_url", "name"], Re(n, r)), t;
}
function Rw(n) {
  const e = {}, t = h(n, [
    "sdkHttpResponse"
  ]);
  return t != null && m(e, ["sdkHttpResponse"], t), e;
}
function kw(n) {
  const e = {}, t = h(n, [
    "sdkHttpResponse"
  ]);
  return t != null && m(e, ["sdkHttpResponse"], t), e;
}
function Pw(n, e) {
  const t = {}, r = h(n, ["outputGcsUri"]);
  e !== void 0 && r != null && m(e, ["parameters", "storageUri"], r);
  const o = h(n, [
    "negativePrompt"
  ]);
  e !== void 0 && o != null && m(e, ["parameters", "negativePrompt"], o);
  const i = h(n, [
    "numberOfImages"
  ]);
  e !== void 0 && i != null && m(e, ["parameters", "sampleCount"], i);
  const a = h(n, ["aspectRatio"]);
  e !== void 0 && a != null && m(e, ["parameters", "aspectRatio"], a);
  const s = h(n, [
    "guidanceScale"
  ]);
  e !== void 0 && s != null && m(e, ["parameters", "guidanceScale"], s);
  const u = h(n, ["seed"]);
  e !== void 0 && u != null && m(e, ["parameters", "seed"], u);
  const l = h(n, [
    "safetyFilterLevel"
  ]);
  e !== void 0 && l != null && m(e, ["parameters", "safetySetting"], l);
  const c = h(n, [
    "personGeneration"
  ]);
  e !== void 0 && c != null && m(e, ["parameters", "personGeneration"], c);
  const f = h(n, [
    "includeSafetyAttributes"
  ]);
  e !== void 0 && f != null && m(e, ["parameters", "includeSafetyAttributes"], f);
  const d = h(n, [
    "includeRaiReason"
  ]);
  e !== void 0 && d != null && m(e, ["parameters", "includeRaiReason"], d);
  const p = h(n, ["language"]);
  e !== void 0 && p != null && m(e, ["parameters", "language"], p);
  const v = h(n, [
    "outputMimeType"
  ]);
  e !== void 0 && v != null && m(e, ["parameters", "outputOptions", "mimeType"], v);
  const g = h(n, [
    "outputCompressionQuality"
  ]);
  e !== void 0 && g != null && m(e, ["parameters", "outputOptions", "compressionQuality"], g);
  const y = h(n, ["addWatermark"]);
  e !== void 0 && y != null && m(e, ["parameters", "addWatermark"], y);
  const x = h(n, ["labels"]);
  e !== void 0 && x != null && m(e, ["labels"], x);
  const w = h(n, ["editMode"]);
  e !== void 0 && w != null && m(e, ["parameters", "editMode"], w);
  const b = h(n, ["baseSteps"]);
  return e !== void 0 && b != null && m(e, ["parameters", "editConfig", "baseSteps"], b), t;
}
function Nw(n, e) {
  const t = {}, r = h(e, ["model"]);
  r != null && m(t, ["_url", "model"], Re(n, r));
  const o = h(e, ["prompt"]);
  o != null && m(t, ["instances[0]", "prompt"], o);
  const i = h(e, [
    "referenceImages"
  ]);
  if (i != null) {
    let s = i;
    Array.isArray(s) && (s = s.map((u) => k_(u))), m(t, ["instances[0]", "referenceImages"], s);
  }
  const a = h(e, ["config"]);
  return a != null && Pw(a, t), t;
}
function Mw(n) {
  const e = {}, t = h(n, [
    "sdkHttpResponse"
  ]);
  t != null && m(e, ["sdkHttpResponse"], t);
  const r = h(n, [
    "predictions"
  ]);
  if (r != null) {
    let o = r;
    Array.isArray(o) && (o = o.map((i) => Cs(i))), m(e, ["generatedImages"], o);
  }
  return e;
}
function Dw(n, e) {
  const t = {}, r = h(n, ["taskType"]);
  e !== void 0 && r != null && m(e, ["requests[]", "taskType"], r);
  const o = h(n, ["title"]);
  e !== void 0 && o != null && m(e, ["requests[]", "title"], o);
  const i = h(n, [
    "outputDimensionality"
  ]);
  if (e !== void 0 && i != null && m(e, ["requests[]", "outputDimensionality"], i), h(n, ["mimeType"]) !== void 0)
    throw new Error("mimeType parameter is not supported in Gemini API.");
  if (h(n, ["autoTruncate"]) !== void 0)
    throw new Error("autoTruncate parameter is not supported in Gemini API.");
  return t;
}
function Fw(n, e) {
  const t = {}, r = h(n, ["taskType"]);
  e !== void 0 && r != null && m(e, ["instances[]", "task_type"], r);
  const o = h(n, ["title"]);
  e !== void 0 && o != null && m(e, ["instances[]", "title"], o);
  const i = h(n, [
    "outputDimensionality"
  ]);
  e !== void 0 && i != null && m(e, ["parameters", "outputDimensionality"], i);
  const a = h(n, ["mimeType"]);
  e !== void 0 && a != null && m(e, ["instances[]", "mimeType"], a);
  const s = h(n, ["autoTruncate"]);
  return e !== void 0 && s != null && m(e, ["parameters", "autoTruncate"], s), t;
}
function Lw(n, e) {
  const t = {}, r = h(e, ["model"]);
  r != null && m(t, ["_url", "model"], Re(n, r));
  const o = h(e, ["contents"]);
  if (o != null) {
    let s = cc(n, o);
    Array.isArray(s) && (s = s.map((u) => u)), m(t, ["requests[]", "content"], s);
  }
  const i = h(e, ["config"]);
  i != null && Dw(i, t);
  const a = h(e, ["model"]);
  return a !== void 0 && m(t, ["requests[]", "model"], Re(n, a)), t;
}
function Bw(n, e) {
  const t = {}, r = h(e, ["model"]);
  r != null && m(t, ["_url", "model"], Re(n, r));
  const o = h(e, ["contents"]);
  if (o != null) {
    let a = cc(n, o);
    Array.isArray(a) && (a = a.map((s) => s)), m(t, ["instances[]", "content"], a);
  }
  const i = h(e, ["config"]);
  return i != null && Fw(i, t), t;
}
function Ow(n) {
  const e = {}, t = h(n, [
    "sdkHttpResponse"
  ]);
  t != null && m(e, ["sdkHttpResponse"], t);
  const r = h(n, ["embeddings"]);
  if (r != null) {
    let i = r;
    Array.isArray(i) && (i = i.map((a) => a)), m(e, ["embeddings"], i);
  }
  const o = h(n, ["metadata"]);
  return o != null && m(e, ["metadata"], o), e;
}
function Uw(n) {
  const e = {}, t = h(n, [
    "sdkHttpResponse"
  ]);
  t != null && m(e, ["sdkHttpResponse"], t);
  const r = h(n, [
    "predictions[]",
    "embeddings"
  ]);
  if (r != null) {
    let i = r;
    Array.isArray(i) && (i = i.map((a) => yw(a))), m(e, ["embeddings"], i);
  }
  const o = h(n, ["metadata"]);
  return o != null && m(e, ["metadata"], o), e;
}
function Vw(n) {
  const e = {}, t = h(n, ["endpoint"]);
  t != null && m(e, ["name"], t);
  const r = h(n, [
    "deployedModelId"
  ]);
  return r != null && m(e, ["deployedModelId"], r), e;
}
function Gw(n) {
  const e = {};
  if (h(n, ["displayName"]) !== void 0)
    throw new Error("displayName parameter is not supported in Gemini API.");
  const t = h(n, ["fileUri"]);
  t != null && m(e, ["fileUri"], t);
  const r = h(n, ["mimeType"]);
  return r != null && m(e, ["mimeType"], r), e;
}
function Ww(n) {
  const e = {};
  if (h(n, ["behavior"]) !== void 0)
    throw new Error("behavior parameter is not supported in Vertex AI.");
  const t = h(n, ["description"]);
  t != null && m(e, ["description"], t);
  const r = h(n, ["name"]);
  r != null && m(e, ["name"], r);
  const o = h(n, ["parameters"]);
  o != null && m(e, ["parameters"], o);
  const i = h(n, [
    "parametersJsonSchema"
  ]);
  i != null && m(e, ["parametersJsonSchema"], i);
  const a = h(n, ["response"]);
  a != null && m(e, ["response"], a);
  const s = h(n, [
    "responseJsonSchema"
  ]);
  return s != null && m(e, ["responseJsonSchema"], s), e;
}
function Hw(n, e, t) {
  const r = {}, o = h(e, [
    "systemInstruction"
  ]);
  t !== void 0 && o != null && m(t, ["systemInstruction"], Es(Pt(o)));
  const i = h(e, ["temperature"]);
  i != null && m(r, ["temperature"], i);
  const a = h(e, ["topP"]);
  a != null && m(r, ["topP"], a);
  const s = h(e, ["topK"]);
  s != null && m(r, ["topK"], s);
  const u = h(e, [
    "candidateCount"
  ]);
  u != null && m(r, ["candidateCount"], u);
  const l = h(e, [
    "maxOutputTokens"
  ]);
  l != null && m(r, ["maxOutputTokens"], l);
  const c = h(e, [
    "stopSequences"
  ]);
  c != null && m(r, ["stopSequences"], c);
  const f = h(e, [
    "responseLogprobs"
  ]);
  f != null && m(r, ["responseLogprobs"], f);
  const d = h(e, ["logprobs"]);
  d != null && m(r, ["logprobs"], d);
  const p = h(e, [
    "presencePenalty"
  ]);
  p != null && m(r, ["presencePenalty"], p);
  const v = h(e, [
    "frequencyPenalty"
  ]);
  v != null && m(r, ["frequencyPenalty"], v);
  const g = h(e, ["seed"]);
  g != null && m(r, ["seed"], g);
  const y = h(e, [
    "responseMimeType"
  ]);
  y != null && m(r, ["responseMimeType"], y);
  const x = h(e, [
    "responseSchema"
  ]);
  x != null && m(r, ["responseSchema"], fc(x));
  const w = h(e, [
    "responseJsonSchema"
  ]);
  if (w != null && m(r, ["responseJsonSchema"], w), h(e, ["routingConfig"]) !== void 0)
    throw new Error("routingConfig parameter is not supported in Gemini API.");
  if (h(e, ["modelSelectionConfig"]) !== void 0)
    throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");
  const b = h(e, [
    "safetySettings"
  ]);
  if (t !== void 0 && b != null) {
    let P = b;
    Array.isArray(P) && (P = P.map((B) => P_(B))), m(t, ["safetySettings"], P);
  }
  const _ = h(e, ["tools"]);
  if (t !== void 0 && _ != null) {
    let P = mi(_);
    Array.isArray(P) && (P = P.map((B) => B_(pi(B)))), m(t, ["tools"], P);
  }
  const E = h(e, ["toolConfig"]);
  if (t !== void 0 && E != null && m(t, ["toolConfig"], E), h(e, ["labels"]) !== void 0)
    throw new Error("labels parameter is not supported in Gemini API.");
  const C = h(e, [
    "cachedContent"
  ]);
  t !== void 0 && C != null && m(t, ["cachedContent"], gr(n, C));
  const A = h(e, [
    "responseModalities"
  ]);
  A != null && m(r, ["responseModalities"], A);
  const R = h(e, [
    "mediaResolution"
  ]);
  R != null && m(r, ["mediaResolution"], R);
  const I = h(e, ["speechConfig"]);
  if (I != null && m(r, ["speechConfig"], dc(I)), h(e, ["audioTimestamp"]) !== void 0)
    throw new Error("audioTimestamp parameter is not supported in Gemini API.");
  const S = h(e, [
    "thinkingConfig"
  ]);
  S != null && m(r, ["thinkingConfig"], S);
  const M = h(e, ["imageConfig"]);
  return M != null && m(r, ["imageConfig"], M), r;
}
function $w(n, e, t) {
  const r = {}, o = h(e, [
    "systemInstruction"
  ]);
  t !== void 0 && o != null && m(t, ["systemInstruction"], Pt(o));
  const i = h(e, ["temperature"]);
  i != null && m(r, ["temperature"], i);
  const a = h(e, ["topP"]);
  a != null && m(r, ["topP"], a);
  const s = h(e, ["topK"]);
  s != null && m(r, ["topK"], s);
  const u = h(e, [
    "candidateCount"
  ]);
  u != null && m(r, ["candidateCount"], u);
  const l = h(e, [
    "maxOutputTokens"
  ]);
  l != null && m(r, ["maxOutputTokens"], l);
  const c = h(e, [
    "stopSequences"
  ]);
  c != null && m(r, ["stopSequences"], c);
  const f = h(e, [
    "responseLogprobs"
  ]);
  f != null && m(r, ["responseLogprobs"], f);
  const d = h(e, ["logprobs"]);
  d != null && m(r, ["logprobs"], d);
  const p = h(e, [
    "presencePenalty"
  ]);
  p != null && m(r, ["presencePenalty"], p);
  const v = h(e, [
    "frequencyPenalty"
  ]);
  v != null && m(r, ["frequencyPenalty"], v);
  const g = h(e, ["seed"]);
  g != null && m(r, ["seed"], g);
  const y = h(e, [
    "responseMimeType"
  ]);
  y != null && m(r, ["responseMimeType"], y);
  const x = h(e, [
    "responseSchema"
  ]);
  x != null && m(r, ["responseSchema"], fc(x));
  const w = h(e, [
    "responseJsonSchema"
  ]);
  w != null && m(r, ["responseJsonSchema"], w);
  const b = h(e, [
    "routingConfig"
  ]);
  b != null && m(r, ["routingConfig"], b);
  const _ = h(e, [
    "modelSelectionConfig"
  ]);
  _ != null && m(r, ["modelConfig"], _);
  const E = h(e, [
    "safetySettings"
  ]);
  if (t !== void 0 && E != null) {
    let G = E;
    Array.isArray(G) && (G = G.map((H) => H)), m(t, ["safetySettings"], G);
  }
  const C = h(e, ["tools"]);
  if (t !== void 0 && C != null) {
    let G = mi(C);
    Array.isArray(G) && (G = G.map((H) => pv(pi(H)))), m(t, ["tools"], G);
  }
  const A = h(e, ["toolConfig"]);
  t !== void 0 && A != null && m(t, ["toolConfig"], A);
  const R = h(e, ["labels"]);
  t !== void 0 && R != null && m(t, ["labels"], R);
  const I = h(e, [
    "cachedContent"
  ]);
  t !== void 0 && I != null && m(t, ["cachedContent"], gr(n, I));
  const S = h(e, [
    "responseModalities"
  ]);
  S != null && m(r, ["responseModalities"], S);
  const M = h(e, [
    "mediaResolution"
  ]);
  M != null && m(r, ["mediaResolution"], M);
  const P = h(e, ["speechConfig"]);
  P != null && m(r, ["speechConfig"], hv(dc(P)));
  const B = h(e, [
    "audioTimestamp"
  ]);
  B != null && m(r, ["audioTimestamp"], B);
  const O = h(e, [
    "thinkingConfig"
  ]);
  O != null && m(r, ["thinkingConfig"], O);
  const U = h(e, ["imageConfig"]);
  return U != null && m(r, ["imageConfig"], U), r;
}
function Ah(n, e) {
  const t = {}, r = h(e, ["model"]);
  r != null && m(t, ["_url", "model"], Re(n, r));
  const o = h(e, ["contents"]);
  if (o != null) {
    let a = yn(o);
    Array.isArray(a) && (a = a.map((s) => Es(s))), m(t, ["contents"], a);
  }
  const i = h(e, ["config"]);
  return i != null && m(t, ["generationConfig"], Hw(n, i, t)), t;
}
function Rh(n, e) {
  const t = {}, r = h(e, ["model"]);
  r != null && m(t, ["_url", "model"], Re(n, r));
  const o = h(e, ["contents"]);
  if (o != null) {
    let a = yn(o);
    Array.isArray(a) && (a = a.map((s) => s)), m(t, ["contents"], a);
  }
  const i = h(e, ["config"]);
  return i != null && m(t, ["generationConfig"], $w(n, i, t)), t;
}
function kh(n) {
  const e = {}, t = h(n, [
    "sdkHttpResponse"
  ]);
  t != null && m(e, ["sdkHttpResponse"], t);
  const r = h(n, ["candidates"]);
  if (r != null) {
    let u = r;
    Array.isArray(u) && (u = u.map((l) => pw(l))), m(e, ["candidates"], u);
  }
  const o = h(n, ["modelVersion"]);
  o != null && m(e, ["modelVersion"], o);
  const i = h(n, [
    "promptFeedback"
  ]);
  i != null && m(e, ["promptFeedback"], i);
  const a = h(n, ["responseId"]);
  a != null && m(e, ["responseId"], a);
  const s = h(n, [
    "usageMetadata"
  ]);
  return s != null && m(e, ["usageMetadata"], s), e;
}
function Ph(n) {
  const e = {}, t = h(n, [
    "sdkHttpResponse"
  ]);
  t != null && m(e, ["sdkHttpResponse"], t);
  const r = h(n, ["candidates"]);
  if (r != null) {
    let l = r;
    Array.isArray(l) && (l = l.map((c) => c)), m(e, ["candidates"], l);
  }
  const o = h(n, ["createTime"]);
  o != null && m(e, ["createTime"], o);
  const i = h(n, ["modelVersion"]);
  i != null && m(e, ["modelVersion"], i);
  const a = h(n, [
    "promptFeedback"
  ]);
  a != null && m(e, ["promptFeedback"], a);
  const s = h(n, ["responseId"]);
  s != null && m(e, ["responseId"], s);
  const u = h(n, [
    "usageMetadata"
  ]);
  return u != null && m(e, ["usageMetadata"], u), e;
}
function qw(n, e) {
  const t = {};
  if (h(n, ["outputGcsUri"]) !== void 0)
    throw new Error("outputGcsUri parameter is not supported in Gemini API.");
  if (h(n, ["negativePrompt"]) !== void 0)
    throw new Error("negativePrompt parameter is not supported in Gemini API.");
  const r = h(n, [
    "numberOfImages"
  ]);
  e !== void 0 && r != null && m(e, ["parameters", "sampleCount"], r);
  const o = h(n, ["aspectRatio"]);
  e !== void 0 && o != null && m(e, ["parameters", "aspectRatio"], o);
  const i = h(n, [
    "guidanceScale"
  ]);
  if (e !== void 0 && i != null && m(e, ["parameters", "guidanceScale"], i), h(n, ["seed"]) !== void 0)
    throw new Error("seed parameter is not supported in Gemini API.");
  const a = h(n, [
    "safetyFilterLevel"
  ]);
  e !== void 0 && a != null && m(e, ["parameters", "safetySetting"], a);
  const s = h(n, [
    "personGeneration"
  ]);
  e !== void 0 && s != null && m(e, ["parameters", "personGeneration"], s);
  const u = h(n, [
    "includeSafetyAttributes"
  ]);
  e !== void 0 && u != null && m(e, ["parameters", "includeSafetyAttributes"], u);
  const l = h(n, [
    "includeRaiReason"
  ]);
  e !== void 0 && l != null && m(e, ["parameters", "includeRaiReason"], l);
  const c = h(n, ["language"]);
  e !== void 0 && c != null && m(e, ["parameters", "language"], c);
  const f = h(n, [
    "outputMimeType"
  ]);
  e !== void 0 && f != null && m(e, ["parameters", "outputOptions", "mimeType"], f);
  const d = h(n, [
    "outputCompressionQuality"
  ]);
  if (e !== void 0 && d != null && m(e, ["parameters", "outputOptions", "compressionQuality"], d), h(n, ["addWatermark"]) !== void 0)
    throw new Error("addWatermark parameter is not supported in Gemini API.");
  if (h(n, ["labels"]) !== void 0)
    throw new Error("labels parameter is not supported in Gemini API.");
  const p = h(n, ["imageSize"]);
  if (e !== void 0 && p != null && m(e, ["parameters", "sampleImageSize"], p), h(n, ["enhancePrompt"]) !== void 0)
    throw new Error("enhancePrompt parameter is not supported in Gemini API.");
  return t;
}
function zw(n, e) {
  const t = {}, r = h(n, ["outputGcsUri"]);
  e !== void 0 && r != null && m(e, ["parameters", "storageUri"], r);
  const o = h(n, [
    "negativePrompt"
  ]);
  e !== void 0 && o != null && m(e, ["parameters", "negativePrompt"], o);
  const i = h(n, [
    "numberOfImages"
  ]);
  e !== void 0 && i != null && m(e, ["parameters", "sampleCount"], i);
  const a = h(n, ["aspectRatio"]);
  e !== void 0 && a != null && m(e, ["parameters", "aspectRatio"], a);
  const s = h(n, [
    "guidanceScale"
  ]);
  e !== void 0 && s != null && m(e, ["parameters", "guidanceScale"], s);
  const u = h(n, ["seed"]);
  e !== void 0 && u != null && m(e, ["parameters", "seed"], u);
  const l = h(n, [
    "safetyFilterLevel"
  ]);
  e !== void 0 && l != null && m(e, ["parameters", "safetySetting"], l);
  const c = h(n, [
    "personGeneration"
  ]);
  e !== void 0 && c != null && m(e, ["parameters", "personGeneration"], c);
  const f = h(n, [
    "includeSafetyAttributes"
  ]);
  e !== void 0 && f != null && m(e, ["parameters", "includeSafetyAttributes"], f);
  const d = h(n, [
    "includeRaiReason"
  ]);
  e !== void 0 && d != null && m(e, ["parameters", "includeRaiReason"], d);
  const p = h(n, ["language"]);
  e !== void 0 && p != null && m(e, ["parameters", "language"], p);
  const v = h(n, [
    "outputMimeType"
  ]);
  e !== void 0 && v != null && m(e, ["parameters", "outputOptions", "mimeType"], v);
  const g = h(n, [
    "outputCompressionQuality"
  ]);
  e !== void 0 && g != null && m(e, ["parameters", "outputOptions", "compressionQuality"], g);
  const y = h(n, ["addWatermark"]);
  e !== void 0 && y != null && m(e, ["parameters", "addWatermark"], y);
  const x = h(n, ["labels"]);
  e !== void 0 && x != null && m(e, ["labels"], x);
  const w = h(n, ["imageSize"]);
  e !== void 0 && w != null && m(e, ["parameters", "sampleImageSize"], w);
  const b = h(n, [
    "enhancePrompt"
  ]);
  return e !== void 0 && b != null && m(e, ["parameters", "enhancePrompt"], b), t;
}
function Kw(n, e) {
  const t = {}, r = h(e, ["model"]);
  r != null && m(t, ["_url", "model"], Re(n, r));
  const o = h(e, ["prompt"]);
  o != null && m(t, ["instances[0]", "prompt"], o);
  const i = h(e, ["config"]);
  return i != null && qw(i, t), t;
}
function Jw(n, e) {
  const t = {}, r = h(e, ["model"]);
  r != null && m(t, ["_url", "model"], Re(n, r));
  const o = h(e, ["prompt"]);
  o != null && m(t, ["instances[0]", "prompt"], o);
  const i = h(e, ["config"]);
  return i != null && zw(i, t), t;
}
function Xw(n) {
  const e = {}, t = h(n, [
    "sdkHttpResponse"
  ]);
  t != null && m(e, ["sdkHttpResponse"], t);
  const r = h(n, [
    "predictions"
  ]);
  if (r != null) {
    let i = r;
    Array.isArray(i) && (i = i.map((a) => s_(a))), m(e, ["generatedImages"], i);
  }
  const o = h(n, [
    "positivePromptSafetyAttributes"
  ]);
  return o != null && m(e, ["positivePromptSafetyAttributes"], fv(o)), e;
}
function Yw(n) {
  const e = {}, t = h(n, [
    "sdkHttpResponse"
  ]);
  t != null && m(e, ["sdkHttpResponse"], t);
  const r = h(n, [
    "predictions"
  ]);
  if (r != null) {
    let i = r;
    Array.isArray(i) && (i = i.map((a) => Cs(a))), m(e, ["generatedImages"], i);
  }
  const o = h(n, [
    "positivePromptSafetyAttributes"
  ]);
  return o != null && m(e, ["positivePromptSafetyAttributes"], dv(o)), e;
}
function Qw(n, e) {
  const t = {}, r = h(n, [
    "numberOfVideos"
  ]);
  if (e !== void 0 && r != null && m(e, ["parameters", "sampleCount"], r), h(n, ["outputGcsUri"]) !== void 0)
    throw new Error("outputGcsUri parameter is not supported in Gemini API.");
  if (h(n, ["fps"]) !== void 0)
    throw new Error("fps parameter is not supported in Gemini API.");
  const o = h(n, [
    "durationSeconds"
  ]);
  if (e !== void 0 && o != null && m(e, ["parameters", "durationSeconds"], o), h(n, ["seed"]) !== void 0)
    throw new Error("seed parameter is not supported in Gemini API.");
  const i = h(n, ["aspectRatio"]);
  e !== void 0 && i != null && m(e, ["parameters", "aspectRatio"], i);
  const a = h(n, ["resolution"]);
  e !== void 0 && a != null && m(e, ["parameters", "resolution"], a);
  const s = h(n, [
    "personGeneration"
  ]);
  if (e !== void 0 && s != null && m(e, ["parameters", "personGeneration"], s), h(n, ["pubsubTopic"]) !== void 0)
    throw new Error("pubsubTopic parameter is not supported in Gemini API.");
  const u = h(n, [
    "negativePrompt"
  ]);
  e !== void 0 && u != null && m(e, ["parameters", "negativePrompt"], u);
  const l = h(n, [
    "enhancePrompt"
  ]);
  if (e !== void 0 && l != null && m(e, ["parameters", "enhancePrompt"], l), h(n, ["generateAudio"]) !== void 0)
    throw new Error("generateAudio parameter is not supported in Gemini API.");
  const c = h(n, ["lastFrame"]);
  e !== void 0 && c != null && m(e, ["instances[0]", "lastFrame"], Ts(c));
  const f = h(n, [
    "referenceImages"
  ]);
  if (e !== void 0 && f != null) {
    let d = f;
    Array.isArray(d) && (d = d.map((p) => Y_(p))), m(e, ["instances[0]", "referenceImages"], d);
  }
  if (h(n, ["mask"]) !== void 0)
    throw new Error("mask parameter is not supported in Gemini API.");
  if (h(n, ["compressionQuality"]) !== void 0)
    throw new Error("compressionQuality parameter is not supported in Gemini API.");
  return t;
}
function Zw(n, e) {
  const t = {}, r = h(n, [
    "numberOfVideos"
  ]);
  e !== void 0 && r != null && m(e, ["parameters", "sampleCount"], r);
  const o = h(n, ["outputGcsUri"]);
  e !== void 0 && o != null && m(e, ["parameters", "storageUri"], o);
  const i = h(n, ["fps"]);
  e !== void 0 && i != null && m(e, ["parameters", "fps"], i);
  const a = h(n, [
    "durationSeconds"
  ]);
  e !== void 0 && a != null && m(e, ["parameters", "durationSeconds"], a);
  const s = h(n, ["seed"]);
  e !== void 0 && s != null && m(e, ["parameters", "seed"], s);
  const u = h(n, ["aspectRatio"]);
  e !== void 0 && u != null && m(e, ["parameters", "aspectRatio"], u);
  const l = h(n, ["resolution"]);
  e !== void 0 && l != null && m(e, ["parameters", "resolution"], l);
  const c = h(n, [
    "personGeneration"
  ]);
  e !== void 0 && c != null && m(e, ["parameters", "personGeneration"], c);
  const f = h(n, ["pubsubTopic"]);
  e !== void 0 && f != null && m(e, ["parameters", "pubsubTopic"], f);
  const d = h(n, [
    "negativePrompt"
  ]);
  e !== void 0 && d != null && m(e, ["parameters", "negativePrompt"], d);
  const p = h(n, [
    "enhancePrompt"
  ]);
  e !== void 0 && p != null && m(e, ["parameters", "enhancePrompt"], p);
  const v = h(n, [
    "generateAudio"
  ]);
  e !== void 0 && v != null && m(e, ["parameters", "generateAudio"], v);
  const g = h(n, ["lastFrame"]);
  e !== void 0 && g != null && m(e, ["instances[0]", "lastFrame"], In(g));
  const y = h(n, [
    "referenceImages"
  ]);
  if (e !== void 0 && y != null) {
    let b = y;
    Array.isArray(b) && (b = b.map((_) => Q_(_))), m(e, ["instances[0]", "referenceImages"], b);
  }
  const x = h(n, ["mask"]);
  e !== void 0 && x != null && m(e, ["instances[0]", "mask"], X_(x));
  const w = h(n, [
    "compressionQuality"
  ]);
  return e !== void 0 && w != null && m(e, ["parameters", "compressionQuality"], w), t;
}
function jw(n) {
  const e = {}, t = h(n, ["name"]);
  t != null && m(e, ["name"], t);
  const r = h(n, ["metadata"]);
  r != null && m(e, ["metadata"], r);
  const o = h(n, ["done"]);
  o != null && m(e, ["done"], o);
  const i = h(n, ["error"]);
  i != null && m(e, ["error"], i);
  const a = h(n, [
    "response",
    "generateVideoResponse"
  ]);
  return a != null && m(e, ["response"], r_(a)), e;
}
function e_(n) {
  const e = {}, t = h(n, ["name"]);
  t != null && m(e, ["name"], t);
  const r = h(n, ["metadata"]);
  r != null && m(e, ["metadata"], r);
  const o = h(n, ["done"]);
  o != null && m(e, ["done"], o);
  const i = h(n, ["error"]);
  i != null && m(e, ["error"], i);
  const a = h(n, ["response"]);
  return a != null && m(e, ["response"], o_(a)), e;
}
function t_(n, e) {
  const t = {}, r = h(e, ["model"]);
  r != null && m(t, ["_url", "model"], Re(n, r));
  const o = h(e, ["prompt"]);
  o != null && m(t, ["instances[0]", "prompt"], o);
  const i = h(e, ["image"]);
  i != null && m(t, ["instances[0]", "image"], Ts(i));
  const a = h(e, ["video"]);
  a != null && m(t, ["instances[0]", "video"], mv(a));
  const s = h(e, ["source"]);
  s != null && i_(s, t);
  const u = h(e, ["config"]);
  return u != null && Qw(u, t), t;
}
function n_(n, e) {
  const t = {}, r = h(e, ["model"]);
  r != null && m(t, ["_url", "model"], Re(n, r));
  const o = h(e, ["prompt"]);
  o != null && m(t, ["instances[0]", "prompt"], o);
  const i = h(e, ["image"]);
  i != null && m(t, ["instances[0]", "image"], In(i));
  const a = h(e, ["video"]);
  a != null && m(t, ["instances[0]", "video"], vv(a));
  const s = h(e, ["source"]);
  s != null && a_(s, t);
  const u = h(e, ["config"]);
  return u != null && Zw(u, t), t;
}
function r_(n) {
  const e = {}, t = h(n, [
    "generatedSamples"
  ]);
  if (t != null) {
    let i = t;
    Array.isArray(i) && (i = i.map((a) => l_(a))), m(e, ["generatedVideos"], i);
  }
  const r = h(n, [
    "raiMediaFilteredCount"
  ]);
  r != null && m(e, ["raiMediaFilteredCount"], r);
  const o = h(n, [
    "raiMediaFilteredReasons"
  ]);
  return o != null && m(e, ["raiMediaFilteredReasons"], o), e;
}
function o_(n) {
  const e = {}, t = h(n, ["videos"]);
  if (t != null) {
    let i = t;
    Array.isArray(i) && (i = i.map((a) => c_(a))), m(e, ["generatedVideos"], i);
  }
  const r = h(n, [
    "raiMediaFilteredCount"
  ]);
  r != null && m(e, ["raiMediaFilteredCount"], r);
  const o = h(n, [
    "raiMediaFilteredReasons"
  ]);
  return o != null && m(e, ["raiMediaFilteredReasons"], o), e;
}
function i_(n, e) {
  const t = {}, r = h(n, ["prompt"]);
  e !== void 0 && r != null && m(e, ["instances[0]", "prompt"], r);
  const o = h(n, ["image"]);
  e !== void 0 && o != null && m(e, ["instances[0]", "image"], Ts(o));
  const i = h(n, ["video"]);
  return e !== void 0 && i != null && m(e, ["instances[0]", "video"], mv(i)), t;
}
function a_(n, e) {
  const t = {}, r = h(n, ["prompt"]);
  e !== void 0 && r != null && m(e, ["instances[0]", "prompt"], r);
  const o = h(n, ["image"]);
  e !== void 0 && o != null && m(e, ["instances[0]", "image"], In(o));
  const i = h(n, ["video"]);
  return e !== void 0 && i != null && m(e, ["instances[0]", "video"], vv(i)), t;
}
function s_(n) {
  const e = {}, t = h(n, ["_self"]);
  t != null && m(e, ["image"], v_(t));
  const r = h(n, [
    "raiFilteredReason"
  ]);
  r != null && m(e, ["raiFilteredReason"], r);
  const o = h(n, ["_self"]);
  return o != null && m(e, ["safetyAttributes"], fv(o)), e;
}
function Cs(n) {
  const e = {}, t = h(n, ["_self"]);
  t != null && m(e, ["image"], cv(t));
  const r = h(n, [
    "raiFilteredReason"
  ]);
  r != null && m(e, ["raiFilteredReason"], r);
  const o = h(n, ["_self"]);
  o != null && m(e, ["safetyAttributes"], dv(o));
  const i = h(n, ["prompt"]);
  return i != null && m(e, ["enhancedPrompt"], i), e;
}
function u_(n) {
  const e = {}, t = h(n, ["_self"]);
  t != null && m(e, ["mask"], cv(t));
  const r = h(n, ["labels"]);
  if (r != null) {
    let o = r;
    Array.isArray(o) && (o = o.map((i) => i)), m(e, ["labels"], o);
  }
  return e;
}
function l_(n) {
  const e = {}, t = h(n, ["video"]);
  return t != null && m(e, ["video"], K_(t)), e;
}
function c_(n) {
  const e = {}, t = h(n, ["_self"]);
  return t != null && m(e, ["video"], J_(t)), e;
}
function f_(n) {
  const e = {}, t = h(n, [
    "modelSelectionConfig"
  ]);
  t != null && m(e, ["modelConfig"], t);
  const r = h(n, [
    "audioTimestamp"
  ]);
  r != null && m(e, ["audioTimestamp"], r);
  const o = h(n, [
    "candidateCount"
  ]);
  o != null && m(e, ["candidateCount"], o);
  const i = h(n, [
    "enableAffectiveDialog"
  ]);
  i != null && m(e, ["enableAffectiveDialog"], i);
  const a = h(n, [
    "frequencyPenalty"
  ]);
  a != null && m(e, ["frequencyPenalty"], a);
  const s = h(n, ["logprobs"]);
  s != null && m(e, ["logprobs"], s);
  const u = h(n, [
    "maxOutputTokens"
  ]);
  u != null && m(e, ["maxOutputTokens"], u);
  const l = h(n, [
    "mediaResolution"
  ]);
  l != null && m(e, ["mediaResolution"], l);
  const c = h(n, [
    "presencePenalty"
  ]);
  c != null && m(e, ["presencePenalty"], c);
  const f = h(n, [
    "responseJsonSchema"
  ]);
  f != null && m(e, ["responseJsonSchema"], f);
  const d = h(n, [
    "responseLogprobs"
  ]);
  d != null && m(e, ["responseLogprobs"], d);
  const p = h(n, [
    "responseMimeType"
  ]);
  p != null && m(e, ["responseMimeType"], p);
  const v = h(n, [
    "responseModalities"
  ]);
  v != null && m(e, ["responseModalities"], v);
  const g = h(n, [
    "responseSchema"
  ]);
  g != null && m(e, ["responseSchema"], g);
  const y = h(n, [
    "routingConfig"
  ]);
  y != null && m(e, ["routingConfig"], y);
  const x = h(n, ["seed"]);
  x != null && m(e, ["seed"], x);
  const w = h(n, ["speechConfig"]);
  w != null && m(e, ["speechConfig"], hv(w));
  const b = h(n, [
    "stopSequences"
  ]);
  b != null && m(e, ["stopSequences"], b);
  const _ = h(n, ["temperature"]);
  _ != null && m(e, ["temperature"], _);
  const E = h(n, [
    "thinkingConfig"
  ]);
  E != null && m(e, ["thinkingConfig"], E);
  const C = h(n, ["topK"]);
  C != null && m(e, ["topK"], C);
  const A = h(n, ["topP"]);
  if (A != null && m(e, ["topP"], A), h(n, ["enableEnhancedCivicAnswers"]) !== void 0)
    throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI.");
  return e;
}
function d_(n, e) {
  const t = {}, r = h(e, ["model"]);
  return r != null && m(t, ["_url", "name"], Re(n, r)), t;
}
function h_(n, e) {
  const t = {}, r = h(e, ["model"]);
  return r != null && m(t, ["_url", "name"], Re(n, r)), t;
}
function p_(n) {
  const e = {};
  if (h(n, ["authConfig"]) !== void 0)
    throw new Error("authConfig parameter is not supported in Gemini API.");
  const t = h(n, ["enableWidget"]);
  return t != null && m(e, ["enableWidget"], t), e;
}
function m_(n) {
  const e = {};
  if (h(n, ["excludeDomains"]) !== void 0)
    throw new Error("excludeDomains parameter is not supported in Gemini API.");
  const t = h(n, [
    "timeRangeFilter"
  ]);
  return t != null && m(e, ["timeRangeFilter"], t), e;
}
function v_(n) {
  const e = {}, t = h(n, [
    "bytesBase64Encoded"
  ]);
  t != null && m(e, ["imageBytes"], qr(t));
  const r = h(n, ["mimeType"]);
  return r != null && m(e, ["mimeType"], r), e;
}
function cv(n) {
  const e = {}, t = h(n, ["gcsUri"]);
  t != null && m(e, ["gcsUri"], t);
  const r = h(n, [
    "bytesBase64Encoded"
  ]);
  r != null && m(e, ["imageBytes"], qr(r));
  const o = h(n, ["mimeType"]);
  return o != null && m(e, ["mimeType"], o), e;
}
function Ts(n) {
  const e = {};
  if (h(n, ["gcsUri"]) !== void 0)
    throw new Error("gcsUri parameter is not supported in Gemini API.");
  const t = h(n, ["imageBytes"]);
  t != null && m(e, ["bytesBase64Encoded"], qr(t));
  const r = h(n, ["mimeType"]);
  return r != null && m(e, ["mimeType"], r), e;
}
function In(n) {
  const e = {}, t = h(n, ["gcsUri"]);
  t != null && m(e, ["gcsUri"], t);
  const r = h(n, ["imageBytes"]);
  r != null && m(e, ["bytesBase64Encoded"], qr(r));
  const o = h(n, ["mimeType"]);
  return o != null && m(e, ["mimeType"], o), e;
}
function g_(n, e, t) {
  const r = {}, o = h(e, ["pageSize"]);
  t !== void 0 && o != null && m(t, ["_query", "pageSize"], o);
  const i = h(e, ["pageToken"]);
  t !== void 0 && i != null && m(t, ["_query", "pageToken"], i);
  const a = h(e, ["filter"]);
  t !== void 0 && a != null && m(t, ["_query", "filter"], a);
  const s = h(e, ["queryBase"]);
  return t !== void 0 && s != null && m(t, ["_url", "models_url"], nv(n, s)), r;
}
function y_(n, e, t) {
  const r = {}, o = h(e, ["pageSize"]);
  t !== void 0 && o != null && m(t, ["_query", "pageSize"], o);
  const i = h(e, ["pageToken"]);
  t !== void 0 && i != null && m(t, ["_query", "pageToken"], i);
  const a = h(e, ["filter"]);
  t !== void 0 && a != null && m(t, ["_query", "filter"], a);
  const s = h(e, ["queryBase"]);
  return t !== void 0 && s != null && m(t, ["_url", "models_url"], nv(n, s)), r;
}
function x_(n, e) {
  const t = {}, r = h(e, ["config"]);
  return r != null && g_(n, r, t), t;
}
function w_(n, e) {
  const t = {}, r = h(e, ["config"]);
  return r != null && y_(n, r, t), t;
}
function __(n) {
  const e = {}, t = h(n, [
    "sdkHttpResponse"
  ]);
  t != null && m(e, ["sdkHttpResponse"], t);
  const r = h(n, [
    "nextPageToken"
  ]);
  r != null && m(e, ["nextPageToken"], r);
  const o = h(n, ["_self"]);
  if (o != null) {
    let i = rv(o);
    Array.isArray(i) && (i = i.map((a) => ml(a))), m(e, ["models"], i);
  }
  return e;
}
function b_(n) {
  const e = {}, t = h(n, [
    "sdkHttpResponse"
  ]);
  t != null && m(e, ["sdkHttpResponse"], t);
  const r = h(n, [
    "nextPageToken"
  ]);
  r != null && m(e, ["nextPageToken"], r);
  const o = h(n, ["_self"]);
  if (o != null) {
    let i = rv(o);
    Array.isArray(i) && (i = i.map((a) => vl(a))), m(e, ["models"], i);
  }
  return e;
}
function E_(n) {
  const e = {}, t = h(n, ["maskMode"]);
  t != null && m(e, ["maskMode"], t);
  const r = h(n, [
    "segmentationClasses"
  ]);
  r != null && m(e, ["maskClasses"], r);
  const o = h(n, ["maskDilation"]);
  return o != null && m(e, ["dilation"], o), e;
}
function ml(n) {
  const e = {}, t = h(n, ["name"]);
  t != null && m(e, ["name"], t);
  const r = h(n, ["displayName"]);
  r != null && m(e, ["displayName"], r);
  const o = h(n, ["description"]);
  o != null && m(e, ["description"], o);
  const i = h(n, ["version"]);
  i != null && m(e, ["version"], i);
  const a = h(n, ["_self"]);
  a != null && m(e, ["tunedModelInfo"], O_(a));
  const s = h(n, [
    "inputTokenLimit"
  ]);
  s != null && m(e, ["inputTokenLimit"], s);
  const u = h(n, [
    "outputTokenLimit"
  ]);
  u != null && m(e, ["outputTokenLimit"], u);
  const l = h(n, [
    "supportedGenerationMethods"
  ]);
  return l != null && m(e, ["supportedActions"], l), e;
}
function vl(n) {
  const e = {}, t = h(n, ["name"]);
  t != null && m(e, ["name"], t);
  const r = h(n, ["displayName"]);
  r != null && m(e, ["displayName"], r);
  const o = h(n, ["description"]);
  o != null && m(e, ["description"], o);
  const i = h(n, ["versionId"]);
  i != null && m(e, ["version"], i);
  const a = h(n, ["deployedModels"]);
  if (a != null) {
    let f = a;
    Array.isArray(f) && (f = f.map((d) => Vw(d))), m(e, ["endpoints"], f);
  }
  const s = h(n, ["labels"]);
  s != null && m(e, ["labels"], s);
  const u = h(n, ["_self"]);
  u != null && m(e, ["tunedModelInfo"], U_(u));
  const l = h(n, [
    "defaultCheckpointId"
  ]);
  l != null && m(e, ["defaultCheckpointId"], l);
  const c = h(n, ["checkpoints"]);
  if (c != null) {
    let f = c;
    Array.isArray(f) && (f = f.map((d) => d)), m(e, ["checkpoints"], f);
  }
  return e;
}
function C_(n) {
  const e = {}, t = h(n, ["functionCall"]);
  t != null && m(e, ["functionCall"], t);
  const r = h(n, [
    "codeExecutionResult"
  ]);
  r != null && m(e, ["codeExecutionResult"], r);
  const o = h(n, [
    "executableCode"
  ]);
  o != null && m(e, ["executableCode"], o);
  const i = h(n, ["fileData"]);
  i != null && m(e, ["fileData"], Gw(i));
  const a = h(n, [
    "functionResponse"
  ]);
  a != null && m(e, ["functionResponse"], a);
  const s = h(n, ["inlineData"]);
  s != null && m(e, ["inlineData"], hw(s));
  const u = h(n, ["text"]);
  u != null && m(e, ["text"], u);
  const l = h(n, ["thought"]);
  l != null && m(e, ["thought"], l);
  const c = h(n, [
    "thoughtSignature"
  ]);
  c != null && m(e, ["thoughtSignature"], c);
  const f = h(n, [
    "videoMetadata"
  ]);
  return f != null && m(e, ["videoMetadata"], f), e;
}
function T_(n) {
  const e = {}, t = h(n, ["productImage"]);
  return t != null && m(e, ["image"], In(t)), e;
}
function I_(n, e) {
  const t = {}, r = h(n, [
    "numberOfImages"
  ]);
  e !== void 0 && r != null && m(e, ["parameters", "sampleCount"], r);
  const o = h(n, ["baseSteps"]);
  e !== void 0 && o != null && m(e, ["parameters", "editConfig", "baseSteps"], o);
  const i = h(n, ["outputGcsUri"]);
  e !== void 0 && i != null && m(e, ["parameters", "storageUri"], i);
  const a = h(n, ["seed"]);
  e !== void 0 && a != null && m(e, ["parameters", "seed"], a);
  const s = h(n, [
    "safetyFilterLevel"
  ]);
  e !== void 0 && s != null && m(e, ["parameters", "safetySetting"], s);
  const u = h(n, [
    "personGeneration"
  ]);
  e !== void 0 && u != null && m(e, ["parameters", "personGeneration"], u);
  const l = h(n, ["addWatermark"]);
  e !== void 0 && l != null && m(e, ["parameters", "addWatermark"], l);
  const c = h(n, [
    "outputMimeType"
  ]);
  e !== void 0 && c != null && m(e, ["parameters", "outputOptions", "mimeType"], c);
  const f = h(n, [
    "outputCompressionQuality"
  ]);
  e !== void 0 && f != null && m(e, ["parameters", "outputOptions", "compressionQuality"], f);
  const d = h(n, [
    "enhancePrompt"
  ]);
  e !== void 0 && d != null && m(e, ["parameters", "enhancePrompt"], d);
  const p = h(n, ["labels"]);
  return e !== void 0 && p != null && m(e, ["labels"], p), t;
}
function S_(n, e) {
  const t = {}, r = h(e, ["model"]);
  r != null && m(t, ["_url", "model"], Re(n, r));
  const o = h(e, ["source"]);
  o != null && R_(o, t);
  const i = h(e, ["config"]);
  return i != null && I_(i, t), t;
}
function A_(n) {
  const e = {}, t = h(n, [
    "predictions"
  ]);
  if (t != null) {
    let r = t;
    Array.isArray(r) && (r = r.map((o) => Cs(o))), m(e, ["generatedImages"], r);
  }
  return e;
}
function R_(n, e) {
  const t = {}, r = h(n, ["prompt"]);
  e !== void 0 && r != null && m(e, ["instances[0]", "prompt"], r);
  const o = h(n, ["personImage"]);
  e !== void 0 && o != null && m(e, ["instances[0]", "personImage", "image"], In(o));
  const i = h(n, [
    "productImages"
  ]);
  if (e !== void 0 && i != null) {
    let a = i;
    Array.isArray(a) && (a = a.map((s) => T_(s))), m(e, ["instances[0]", "productImages"], a);
  }
  return t;
}
function k_(n) {
  const e = {}, t = h(n, [
    "referenceImage"
  ]);
  t != null && m(e, ["referenceImage"], In(t));
  const r = h(n, ["referenceId"]);
  r != null && m(e, ["referenceId"], r);
  const o = h(n, [
    "referenceType"
  ]);
  o != null && m(e, ["referenceType"], o);
  const i = h(n, [
    "maskImageConfig"
  ]);
  i != null && m(e, ["maskImageConfig"], E_(i));
  const a = h(n, [
    "controlImageConfig"
  ]);
  a != null && m(e, ["controlImageConfig"], ww(a));
  const s = h(n, [
    "styleImageConfig"
  ]);
  s != null && m(e, ["styleImageConfig"], s);
  const u = h(n, [
    "subjectImageConfig"
  ]);
  return u != null && m(e, ["subjectImageConfig"], u), e;
}
function fv(n) {
  const e = {}, t = h(n, [
    "safetyAttributes",
    "categories"
  ]);
  t != null && m(e, ["categories"], t);
  const r = h(n, [
    "safetyAttributes",
    "scores"
  ]);
  r != null && m(e, ["scores"], r);
  const o = h(n, ["contentType"]);
  return o != null && m(e, ["contentType"], o), e;
}
function dv(n) {
  const e = {}, t = h(n, [
    "safetyAttributes",
    "categories"
  ]);
  t != null && m(e, ["categories"], t);
  const r = h(n, [
    "safetyAttributes",
    "scores"
  ]);
  r != null && m(e, ["scores"], r);
  const o = h(n, ["contentType"]);
  return o != null && m(e, ["contentType"], o), e;
}
function P_(n) {
  const e = {}, t = h(n, ["category"]);
  if (t != null && m(e, ["category"], t), h(n, ["method"]) !== void 0)
    throw new Error("method parameter is not supported in Gemini API.");
  const r = h(n, ["threshold"]);
  return r != null && m(e, ["threshold"], r), e;
}
function N_(n) {
  const e = {}, t = h(n, ["image"]);
  return t != null && m(e, ["image"], In(t)), e;
}
function M_(n, e) {
  const t = {}, r = h(n, ["mode"]);
  e !== void 0 && r != null && m(e, ["parameters", "mode"], r);
  const o = h(n, [
    "maxPredictions"
  ]);
  e !== void 0 && o != null && m(e, ["parameters", "maxPredictions"], o);
  const i = h(n, [
    "confidenceThreshold"
  ]);
  e !== void 0 && i != null && m(e, ["parameters", "confidenceThreshold"], i);
  const a = h(n, ["maskDilation"]);
  e !== void 0 && a != null && m(e, ["parameters", "maskDilation"], a);
  const s = h(n, [
    "binaryColorThreshold"
  ]);
  e !== void 0 && s != null && m(e, ["parameters", "binaryColorThreshold"], s);
  const u = h(n, ["labels"]);
  return e !== void 0 && u != null && m(e, ["labels"], u), t;
}
function D_(n, e) {
  const t = {}, r = h(e, ["model"]);
  r != null && m(t, ["_url", "model"], Re(n, r));
  const o = h(e, ["source"]);
  o != null && L_(o, t);
  const i = h(e, ["config"]);
  return i != null && M_(i, t), t;
}
function F_(n) {
  const e = {}, t = h(n, ["predictions"]);
  if (t != null) {
    let r = t;
    Array.isArray(r) && (r = r.map((o) => u_(o))), m(e, ["generatedMasks"], r);
  }
  return e;
}
function L_(n, e) {
  const t = {}, r = h(n, ["prompt"]);
  e !== void 0 && r != null && m(e, ["instances[0]", "prompt"], r);
  const o = h(n, ["image"]);
  e !== void 0 && o != null && m(e, ["instances[0]", "image"], In(o));
  const i = h(n, [
    "scribbleImage"
  ]);
  return e !== void 0 && i != null && m(e, ["instances[0]", "scribble"], N_(i)), t;
}
function hv(n) {
  const e = {}, t = h(n, ["languageCode"]);
  t != null && m(e, ["languageCode"], t);
  const r = h(n, ["voiceConfig"]);
  if (r != null && m(e, ["voiceConfig"], r), h(n, ["multiSpeakerVoiceConfig"]) !== void 0)
    throw new Error("multiSpeakerVoiceConfig parameter is not supported in Vertex AI.");
  return e;
}
function B_(n) {
  const e = {}, t = h(n, [
    "functionDeclarations"
  ]);
  if (t != null) {
    let l = t;
    Array.isArray(l) && (l = l.map((c) => c)), m(e, ["functionDeclarations"], l);
  }
  if (h(n, ["retrieval"]) !== void 0)
    throw new Error("retrieval parameter is not supported in Gemini API.");
  const r = h(n, [
    "googleSearchRetrieval"
  ]);
  r != null && m(e, ["googleSearchRetrieval"], r);
  const o = h(n, ["googleMaps"]);
  o != null && m(e, ["googleMaps"], p_(o));
  const i = h(n, ["computerUse"]);
  i != null && m(e, ["computerUse"], i);
  const a = h(n, [
    "codeExecution"
  ]);
  if (a != null && m(e, ["codeExecution"], a), h(n, ["enterpriseWebSearch"]) !== void 0)
    throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
  const s = h(n, ["googleSearch"]);
  s != null && m(e, ["googleSearch"], m_(s));
  const u = h(n, ["urlContext"]);
  return u != null && m(e, ["urlContext"], u), e;
}
function pv(n) {
  const e = {}, t = h(n, [
    "functionDeclarations"
  ]);
  if (t != null) {
    let f = t;
    Array.isArray(f) && (f = f.map((d) => Ww(d))), m(e, ["functionDeclarations"], f);
  }
  const r = h(n, ["retrieval"]);
  r != null && m(e, ["retrieval"], r);
  const o = h(n, [
    "googleSearchRetrieval"
  ]);
  o != null && m(e, ["googleSearchRetrieval"], o);
  const i = h(n, ["googleMaps"]);
  i != null && m(e, ["googleMaps"], i);
  const a = h(n, ["computerUse"]);
  a != null && m(e, ["computerUse"], a);
  const s = h(n, [
    "codeExecution"
  ]);
  s != null && m(e, ["codeExecution"], s);
  const u = h(n, [
    "enterpriseWebSearch"
  ]);
  u != null && m(e, ["enterpriseWebSearch"], u);
  const l = h(n, ["googleSearch"]);
  l != null && m(e, ["googleSearch"], l);
  const c = h(n, ["urlContext"]);
  return c != null && m(e, ["urlContext"], c), e;
}
function O_(n) {
  const e = {}, t = h(n, ["baseModel"]);
  t != null && m(e, ["baseModel"], t);
  const r = h(n, ["createTime"]);
  r != null && m(e, ["createTime"], r);
  const o = h(n, ["updateTime"]);
  return o != null && m(e, ["updateTime"], o), e;
}
function U_(n) {
  const e = {}, t = h(n, [
    "labels",
    "google-vertex-llm-tuning-base-model-id"
  ]);
  t != null && m(e, ["baseModel"], t);
  const r = h(n, ["createTime"]);
  r != null && m(e, ["createTime"], r);
  const o = h(n, ["updateTime"]);
  return o != null && m(e, ["updateTime"], o), e;
}
function V_(n, e) {
  const t = {}, r = h(n, ["displayName"]);
  e !== void 0 && r != null && m(e, ["displayName"], r);
  const o = h(n, ["description"]);
  e !== void 0 && o != null && m(e, ["description"], o);
  const i = h(n, [
    "defaultCheckpointId"
  ]);
  return e !== void 0 && i != null && m(e, ["defaultCheckpointId"], i), t;
}
function G_(n, e) {
  const t = {}, r = h(n, ["displayName"]);
  e !== void 0 && r != null && m(e, ["displayName"], r);
  const o = h(n, ["description"]);
  e !== void 0 && o != null && m(e, ["description"], o);
  const i = h(n, [
    "defaultCheckpointId"
  ]);
  return e !== void 0 && i != null && m(e, ["defaultCheckpointId"], i), t;
}
function W_(n, e) {
  const t = {}, r = h(e, ["model"]);
  r != null && m(t, ["_url", "name"], Re(n, r));
  const o = h(e, ["config"]);
  return o != null && V_(o, t), t;
}
function H_(n, e) {
  const t = {}, r = h(e, ["model"]);
  r != null && m(t, ["_url", "model"], Re(n, r));
  const o = h(e, ["config"]);
  return o != null && G_(o, t), t;
}
function $_(n, e) {
  const t = {}, r = h(n, ["outputGcsUri"]);
  e !== void 0 && r != null && m(e, ["parameters", "storageUri"], r);
  const o = h(n, [
    "safetyFilterLevel"
  ]);
  e !== void 0 && o != null && m(e, ["parameters", "safetySetting"], o);
  const i = h(n, [
    "personGeneration"
  ]);
  e !== void 0 && i != null && m(e, ["parameters", "personGeneration"], i);
  const a = h(n, [
    "includeRaiReason"
  ]);
  e !== void 0 && a != null && m(e, ["parameters", "includeRaiReason"], a);
  const s = h(n, [
    "outputMimeType"
  ]);
  e !== void 0 && s != null && m(e, ["parameters", "outputOptions", "mimeType"], s);
  const u = h(n, [
    "outputCompressionQuality"
  ]);
  e !== void 0 && u != null && m(e, ["parameters", "outputOptions", "compressionQuality"], u);
  const l = h(n, [
    "enhanceInputImage"
  ]);
  e !== void 0 && l != null && m(e, ["parameters", "upscaleConfig", "enhanceInputImage"], l);
  const c = h(n, [
    "imagePreservationFactor"
  ]);
  e !== void 0 && c != null && m(e, ["parameters", "upscaleConfig", "imagePreservationFactor"], c);
  const f = h(n, ["labels"]);
  e !== void 0 && f != null && m(e, ["labels"], f);
  const d = h(n, [
    "numberOfImages"
  ]);
  e !== void 0 && d != null && m(e, ["parameters", "sampleCount"], d);
  const p = h(n, ["mode"]);
  return e !== void 0 && p != null && m(e, ["parameters", "mode"], p), t;
}
function q_(n, e) {
  const t = {}, r = h(e, ["model"]);
  r != null && m(t, ["_url", "model"], Re(n, r));
  const o = h(e, ["image"]);
  o != null && m(t, ["instances[0]", "image"], In(o));
  const i = h(e, [
    "upscaleFactor"
  ]);
  i != null && m(t, ["parameters", "upscaleConfig", "upscaleFactor"], i);
  const a = h(e, ["config"]);
  return a != null && $_(a, t), t;
}
function z_(n) {
  const e = {}, t = h(n, [
    "sdkHttpResponse"
  ]);
  t != null && m(e, ["sdkHttpResponse"], t);
  const r = h(n, [
    "predictions"
  ]);
  if (r != null) {
    let o = r;
    Array.isArray(o) && (o = o.map((i) => Cs(i))), m(e, ["generatedImages"], o);
  }
  return e;
}
function K_(n) {
  const e = {}, t = h(n, ["uri"]);
  t != null && m(e, ["uri"], t);
  const r = h(n, ["encodedVideo"]);
  r != null && m(e, ["videoBytes"], qr(r));
  const o = h(n, ["encoding"]);
  return o != null && m(e, ["mimeType"], o), e;
}
function J_(n) {
  const e = {}, t = h(n, ["gcsUri"]);
  t != null && m(e, ["uri"], t);
  const r = h(n, [
    "bytesBase64Encoded"
  ]);
  r != null && m(e, ["videoBytes"], qr(r));
  const o = h(n, ["mimeType"]);
  return o != null && m(e, ["mimeType"], o), e;
}
function X_(n) {
  const e = {}, t = h(n, ["image"]);
  t != null && m(e, ["_self"], In(t));
  const r = h(n, ["maskMode"]);
  return r != null && m(e, ["maskMode"], r), e;
}
function Y_(n) {
  const e = {}, t = h(n, ["image"]);
  t != null && m(e, ["image"], Ts(t));
  const r = h(n, [
    "referenceType"
  ]);
  return r != null && m(e, ["referenceType"], r), e;
}
function Q_(n) {
  const e = {}, t = h(n, ["image"]);
  t != null && m(e, ["image"], In(t));
  const r = h(n, [
    "referenceType"
  ]);
  return r != null && m(e, ["referenceType"], r), e;
}
function mv(n) {
  const e = {}, t = h(n, ["uri"]);
  t != null && m(e, ["uri"], t);
  const r = h(n, ["videoBytes"]);
  r != null && m(e, ["encodedVideo"], qr(r));
  const o = h(n, ["mimeType"]);
  return o != null && m(e, ["encoding"], o), e;
}
function vv(n) {
  const e = {}, t = h(n, ["uri"]);
  t != null && m(e, ["gcsUri"], t);
  const r = h(n, ["videoBytes"]);
  r != null && m(e, ["bytesBase64Encoded"], qr(r));
  const o = h(n, ["mimeType"]);
  return o != null && m(e, ["mimeType"], o), e;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Z_ = "Content-Type", j_ = "X-Server-Timeout", eb = "User-Agent", gl = "x-goog-api-client", tb = "1.28.0", nb = `google-genai-sdk/${tb}`, rb = "v1beta1", ob = "v1beta", Nh = /^\s*data: (.*)(?:\n\n|\r\r|\r\n\r\n)/;
class ib {
  constructor(e) {
    var t, r;
    this.clientOptions = Object.assign(Object.assign({}, e), { project: e.project, location: e.location, apiKey: e.apiKey, vertexai: e.vertexai });
    const o = {};
    this.clientOptions.vertexai ? (o.apiVersion = (t = this.clientOptions.apiVersion) !== null && t !== void 0 ? t : rb, o.baseUrl = this.baseUrlFromProjectLocation(), this.normalizeAuthParameters()) : (o.apiVersion = (r = this.clientOptions.apiVersion) !== null && r !== void 0 ? r : ob, o.baseUrl = "https://generativelanguage.googleapis.com/"), o.headers = this.getDefaultHeaders(), this.clientOptions.httpOptions = o, e.httpOptions && (this.clientOptions.httpOptions = this.patchHttpOptions(o, e.httpOptions));
  }
  /**
   * Determines the base URL for Vertex AI based on project and location.
   * Uses the global endpoint if location is 'global' or if project/location
   * are not specified (implying API key usage).
   * @private
   */
  baseUrlFromProjectLocation() {
    return this.clientOptions.project && this.clientOptions.location && this.clientOptions.location !== "global" ? `https://${this.clientOptions.location}-aiplatform.googleapis.com/` : "https://aiplatform.googleapis.com/";
  }
  /**
   * Normalizes authentication parameters for Vertex AI.
   * If project and location are provided, API key is cleared.
   * If project and location are not provided (implying API key usage),
   * project and location are cleared.
   * @private
   */
  normalizeAuthParameters() {
    if (this.clientOptions.project && this.clientOptions.location) {
      this.clientOptions.apiKey = void 0;
      return;
    }
    this.clientOptions.project = void 0, this.clientOptions.location = void 0;
  }
  isVertexAI() {
    var e;
    return (e = this.clientOptions.vertexai) !== null && e !== void 0 ? e : !1;
  }
  getProject() {
    return this.clientOptions.project;
  }
  getLocation() {
    return this.clientOptions.location;
  }
  getApiVersion() {
    if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.apiVersion !== void 0)
      return this.clientOptions.httpOptions.apiVersion;
    throw new Error("API version is not set.");
  }
  getBaseUrl() {
    if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.baseUrl !== void 0)
      return this.clientOptions.httpOptions.baseUrl;
    throw new Error("Base URL is not set.");
  }
  getRequestUrl() {
    return this.getRequestUrlInternal(this.clientOptions.httpOptions);
  }
  getHeaders() {
    if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.headers !== void 0)
      return this.clientOptions.httpOptions.headers;
    throw new Error("Headers are not set.");
  }
  getRequestUrlInternal(e) {
    if (!e || e.baseUrl === void 0 || e.apiVersion === void 0)
      throw new Error("HTTP options are not correctly set.");
    const r = [e.baseUrl.endsWith("/") ? e.baseUrl.slice(0, -1) : e.baseUrl];
    return e.apiVersion && e.apiVersion !== "" && r.push(e.apiVersion), r.join("/");
  }
  getBaseResourcePath() {
    return `projects/${this.clientOptions.project}/locations/${this.clientOptions.location}`;
  }
  getApiKey() {
    return this.clientOptions.apiKey;
  }
  getWebsocketBaseUrl() {
    const e = this.getBaseUrl(), t = new URL(e);
    return t.protocol = t.protocol == "http:" ? "ws" : "wss", t.toString();
  }
  setBaseUrl(e) {
    if (this.clientOptions.httpOptions)
      this.clientOptions.httpOptions.baseUrl = e;
    else
      throw new Error("HTTP options are not correctly set.");
  }
  constructUrl(e, t, r) {
    const o = [this.getRequestUrlInternal(t)];
    return r && o.push(this.getBaseResourcePath()), e !== "" && o.push(e), new URL(`${o.join("/")}`);
  }
  shouldPrependVertexProjectPath(e) {
    return !(this.clientOptions.apiKey || !this.clientOptions.vertexai || e.path.startsWith("projects/") || e.httpMethod === "GET" && e.path.startsWith("publishers/google/models"));
  }
  async request(e) {
    let t = this.clientOptions.httpOptions;
    e.httpOptions && (t = this.patchHttpOptions(this.clientOptions.httpOptions, e.httpOptions));
    const r = this.shouldPrependVertexProjectPath(e), o = this.constructUrl(e.path, t, r);
    if (e.queryParams)
      for (const [a, s] of Object.entries(e.queryParams))
        o.searchParams.append(a, String(s));
    let i = {};
    if (e.httpMethod === "GET") {
      if (e.body && e.body !== "{}")
        throw new Error("Request body should be empty for GET request, but got non empty request body");
    } else
      i.body = e.body;
    return i = await this.includeExtraHttpOptionsToRequestInit(i, t, o.toString(), e.abortSignal), this.unaryApiCall(o, i, e.httpMethod);
  }
  patchHttpOptions(e, t) {
    const r = JSON.parse(JSON.stringify(e));
    for (const [o, i] of Object.entries(t))
      typeof i == "object" ? r[o] = Object.assign(Object.assign({}, r[o]), i) : i !== void 0 && (r[o] = i);
    return r;
  }
  async requestStream(e) {
    let t = this.clientOptions.httpOptions;
    e.httpOptions && (t = this.patchHttpOptions(this.clientOptions.httpOptions, e.httpOptions));
    const r = this.shouldPrependVertexProjectPath(e), o = this.constructUrl(e.path, t, r);
    (!o.searchParams.has("alt") || o.searchParams.get("alt") !== "sse") && o.searchParams.set("alt", "sse");
    let i = {};
    return i.body = e.body, i = await this.includeExtraHttpOptionsToRequestInit(i, t, o.toString(), e.abortSignal), this.streamApiCall(o, i, e.httpMethod);
  }
  async includeExtraHttpOptionsToRequestInit(e, t, r, o) {
    if (t && t.timeout || o) {
      const i = new AbortController(), a = i.signal;
      if (t.timeout && (t == null ? void 0 : t.timeout) > 0) {
        const s = setTimeout(() => i.abort(), t.timeout);
        s && typeof s.unref == "function" && s.unref();
      }
      o && o.addEventListener("abort", () => {
        i.abort();
      }), e.signal = a;
    }
    return t && t.extraBody !== null && ab(e, t.extraBody), e.headers = await this.getHeadersInternal(t, r), e;
  }
  async unaryApiCall(e, t, r) {
    return this.apiCall(e.toString(), Object.assign(Object.assign({}, t), { method: r })).then(async (o) => (await Mh(o), new dl(o))).catch((o) => {
      throw o instanceof Error ? o : new Error(JSON.stringify(o));
    });
  }
  async streamApiCall(e, t, r) {
    return this.apiCall(e.toString(), Object.assign(Object.assign({}, t), { method: r })).then(async (o) => (await Mh(o), this.processStreamResponse(o))).catch((o) => {
      throw o instanceof Error ? o : new Error(JSON.stringify(o));
    });
  }
  processStreamResponse(e) {
    var t;
    return Vo(this, arguments, function* () {
      const o = (t = e == null ? void 0 : e.body) === null || t === void 0 ? void 0 : t.getReader(), i = new TextDecoder("utf-8");
      if (!o)
        throw new Error("Response body is empty");
      try {
        let a = "";
        for (; ; ) {
          const { done: s, value: u } = yield Ve(o.read());
          if (s) {
            if (a.trim().length > 0)
              throw new Error("Incomplete JSON segment at the end");
            break;
          }
          const l = i.decode(u, { stream: !0 });
          try {
            const f = JSON.parse(l);
            if ("error" in f) {
              const d = JSON.parse(JSON.stringify(f.error)), p = d.status, v = d.code, g = `got status: ${p}. ${JSON.stringify(f)}`;
              if (v >= 400 && v < 600)
                throw new bs({
                  message: g,
                  status: v
                });
            }
          } catch (f) {
            if (f.name === "ApiError")
              throw f;
          }
          a += l;
          let c = a.match(Nh);
          for (; c; ) {
            const f = c[1];
            try {
              const d = new Response(f, {
                headers: e == null ? void 0 : e.headers,
                status: e == null ? void 0 : e.status,
                statusText: e == null ? void 0 : e.statusText
              });
              yield yield Ve(new dl(d)), a = a.slice(c[0].length), c = a.match(Nh);
            } catch (d) {
              throw new Error(`exception parsing stream chunk ${f}. ${d}`);
            }
          }
        }
      } finally {
        o.releaseLock();
      }
    });
  }
  async apiCall(e, t) {
    return fetch(e, t).catch((r) => {
      throw new Error(`exception ${r} sending request`);
    });
  }
  getDefaultHeaders() {
    const e = {}, t = nb + " " + this.clientOptions.userAgentExtra;
    return e[eb] = t, e[gl] = t, e[Z_] = "application/json", e;
  }
  async getHeadersInternal(e, t) {
    const r = new Headers();
    if (e && e.headers) {
      for (const [o, i] of Object.entries(e.headers))
        r.append(o, i);
      e.timeout && e.timeout > 0 && r.append(j_, String(Math.ceil(e.timeout / 1e3)));
    }
    return await this.clientOptions.auth.addAuthHeaders(r, t), r;
  }
  /**
   * Uploads a file asynchronously using Gemini API only, this is not supported
   * in Vertex AI.
   *
   * @param file The string path to the file to be uploaded or a Blob object.
   * @param config Optional parameters specified in the `UploadFileConfig`
   *     interface. @see {@link types.UploadFileConfig}
   * @return A promise that resolves to a `File` object.
   * @throws An error if called on a Vertex AI client.
   * @throws An error if the `mimeType` is not provided and can not be inferred,
   */
  async uploadFile(e, t) {
    var r, o;
    const i = {};
    t != null && (i.mimeType = t.mimeType, i.name = t.name, i.displayName = t.displayName), i.name && !i.name.startsWith("files/") && (i.name = `files/${i.name}`);
    const a = this.clientOptions.uploader, s = await a.stat(e);
    i.sizeBytes = String(s.size);
    const u = (r = t == null ? void 0 : t.mimeType) !== null && r !== void 0 ? r : s.type;
    if (u === void 0 || u === "")
      throw new Error("Can not determine mimeType. Please provide mimeType in the config.");
    i.mimeType = u;
    let l = "";
    typeof e == "string" && (l = e.replace(/[/\\]+$/, ""), l = (o = l.split(/[/\\]/).pop()) !== null && o !== void 0 ? o : "");
    const c = await this.fetchUploadUrl(i, l, t);
    return a.upload(e, c, this);
  }
  /**
   * Downloads a file asynchronously to the specified path.
   *
   * @params params - The parameters for the download request, see {@link
   * types.DownloadFileParameters}
   */
  async downloadFile(e) {
    await this.clientOptions.downloader.download(e, this);
  }
  async fetchUploadUrl(e, t, r) {
    var o;
    let i = {};
    r != null && r.httpOptions ? i = r.httpOptions : i = {
      apiVersion: "",
      headers: Object.assign({ "Content-Type": "application/json", "X-Goog-Upload-Protocol": "resumable", "X-Goog-Upload-Command": "start", "X-Goog-Upload-Header-Content-Length": `${e.sizeBytes}`, "X-Goog-Upload-Header-Content-Type": `${e.mimeType}` }, t ? { "X-Goog-Upload-File-Name": t } : {})
    };
    const a = {
      file: e
    }, s = await this.request({
      path: Q("upload/v1beta/files", a._url),
      body: JSON.stringify(a),
      httpMethod: "POST",
      httpOptions: i
    });
    if (!s || !(s != null && s.headers))
      throw new Error("Server did not return an HttpResponse or the returned HttpResponse did not have headers.");
    const u = (o = s == null ? void 0 : s.headers) === null || o === void 0 ? void 0 : o["x-goog-upload-url"];
    if (u === void 0)
      throw new Error("Failed to get upload url. Server did not return the x-google-upload-url in the headers");
    return u;
  }
}
async function Mh(n) {
  var e;
  if (n === void 0)
    throw new Error("response is undefined");
  if (!n.ok) {
    const t = n.status;
    let r;
    !((e = n.headers.get("content-type")) === null || e === void 0) && e.includes("application/json") ? r = await n.json() : r = {
      error: {
        message: await n.text(),
        code: n.status,
        status: n.statusText
      }
    };
    const o = JSON.stringify(r);
    throw t >= 400 && t < 600 ? new bs({
      message: o,
      status: t
    }) : new Error(o);
  }
}
function ab(n, e) {
  if (!e || Object.keys(e).length === 0)
    return;
  if (n.body instanceof Blob) {
    console.warn("includeExtraBodyToRequestInit: extraBody provided but current request body is a Blob. extraBody will be ignored as merging is not supported for Blob bodies.");
    return;
  }
  let t = {};
  if (typeof n.body == "string" && n.body.length > 0)
    try {
      const i = JSON.parse(n.body);
      if (typeof i == "object" && i !== null && !Array.isArray(i))
        t = i;
      else {
        console.warn("includeExtraBodyToRequestInit: Original request body is valid JSON but not a non-array object. Skip applying extraBody to the request body.");
        return;
      }
    } catch {
      console.warn("includeExtraBodyToRequestInit: Original request body is not valid JSON. Skip applying extraBody to the request body.");
      return;
    }
  function r(i, a) {
    const s = Object.assign({}, i);
    for (const u in a)
      if (Object.prototype.hasOwnProperty.call(a, u)) {
        const l = a[u], c = s[u];
        l && typeof l == "object" && !Array.isArray(l) && c && typeof c == "object" && !Array.isArray(c) ? s[u] = r(c, l) : (c && l && typeof c != typeof l && console.warn(`includeExtraBodyToRequestInit:deepMerge: Type mismatch for key "${u}". Original type: ${typeof c}, New type: ${typeof l}. Overwriting.`), s[u] = l);
      }
    return s;
  }
  const o = r(t, e);
  n.body = JSON.stringify(o);
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const sb = "mcp_used/unknown";
let ub = !1;
function gv(n) {
  for (const e of n)
    if (lb(e) || typeof e == "object" && "inputSchema" in e)
      return !0;
  return ub;
}
function yv(n) {
  var e;
  const t = (e = n[gl]) !== null && e !== void 0 ? e : "";
  n[gl] = (t + ` ${sb}`).trimStart();
}
function lb(n) {
  return n !== null && typeof n == "object" && n instanceof pc;
}
function cb(n, e = 100) {
  return Vo(this, arguments, function* () {
    let r, o = 0;
    for (; o < e; ) {
      const i = yield Ve(n.listTools({ cursor: r }));
      for (const a of i.tools)
        yield yield Ve(a), o++;
      if (!i.nextCursor)
        break;
      r = i.nextCursor;
    }
  });
}
class pc {
  constructor(e = [], t) {
    this.mcpTools = [], this.functionNameToMcpClient = {}, this.mcpClients = e, this.config = t;
  }
  /**
   * Creates a McpCallableTool.
   */
  static create(e, t) {
    return new pc(e, t);
  }
  /**
   * Validates the function names are not duplicate and initialize the function
   * name to MCP client mapping.
   *
   * @throws {Error} if the MCP tools from the MCP clients have duplicate tool
   *     names.
   */
  async initialize() {
    var e, t, r, o;
    if (this.mcpTools.length > 0)
      return;
    const i = {}, a = [];
    for (const c of this.mcpClients)
      try {
        for (var s = !0, u = (t = void 0, Bi(cb(c))), l; l = await u.next(), e = l.done, !e; s = !0) {
          o = l.value, s = !1;
          const f = o;
          a.push(f);
          const d = f.name;
          if (i[d])
            throw new Error(`Duplicate function name ${d} found in MCP tools. Please ensure function names are unique.`);
          i[d] = c;
        }
      } catch (f) {
        t = { error: f };
      } finally {
        try {
          !s && !e && (r = u.return) && await r.call(u);
        } finally {
          if (t) throw t.error;
        }
      }
    this.mcpTools = a, this.functionNameToMcpClient = i;
  }
  async tool() {
    return await this.initialize(), m2(this.mcpTools, this.config);
  }
  async callTool(e) {
    await this.initialize();
    const t = [];
    for (const r of e)
      if (r.name in this.functionNameToMcpClient) {
        const o = this.functionNameToMcpClient[r.name];
        let i;
        this.config.timeout && (i = {
          timeout: this.config.timeout
        });
        const a = await o.callTool(
          {
            name: r.name,
            arguments: r.args
          },
          // Set the result schema to undefined to allow MCP to rely on the
          // default schema.
          void 0,
          i
        );
        t.push({
          functionResponse: {
            name: r.name,
            response: a.isError ? { error: a } : a
          }
        });
      }
    return t;
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
async function fb(n, e, t) {
  const r = new s2();
  let o;
  t.data instanceof Blob ? o = JSON.parse(await t.data.text()) : o = JSON.parse(t.data), Object.assign(r, o), e(r);
}
class db {
  constructor(e, t, r) {
    this.apiClient = e, this.auth = t, this.webSocketFactory = r;
  }
  /**
       Establishes a connection to the specified model and returns a
       LiveMusicSession object representing that connection.
  
       @experimental
  
       @remarks
  
       @param params - The parameters for establishing a connection to the model.
       @return A live session.
  
       @example
       ```ts
       let model = 'models/lyria-realtime-exp';
       const session = await ai.live.music.connect({
         model: model,
         callbacks: {
           onmessage: (e: MessageEvent) => {
             console.log('Received message from the server: %s\n', debug(e.data));
           },
           onerror: (e: ErrorEvent) => {
             console.log('Error occurred: %s\n', debug(e.error));
           },
           onclose: (e: CloseEvent) => {
             console.log('Connection closed.');
           },
         },
       });
       ```
      */
  async connect(e) {
    var t, r;
    if (this.apiClient.isVertexAI())
      throw new Error("Live music is not supported for Vertex AI.");
    console.warn("Live music generation is experimental and may change in future versions.");
    const o = this.apiClient.getWebsocketBaseUrl(), i = this.apiClient.getApiVersion(), a = mb(this.apiClient.getDefaultHeaders()), s = this.apiClient.getApiKey(), u = `${o}/ws/google.ai.generativelanguage.${i}.GenerativeService.BidiGenerateMusic?key=${s}`;
    let l = () => {
    };
    const c = new Promise((b) => {
      l = b;
    }), f = e.callbacks, d = function() {
      l({});
    }, p = this.apiClient, v = {
      onopen: d,
      onmessage: (b) => {
        fb(p, f.onmessage, b);
      },
      onerror: (t = f == null ? void 0 : f.onerror) !== null && t !== void 0 ? t : function(b) {
      },
      onclose: (r = f == null ? void 0 : f.onclose) !== null && r !== void 0 ? r : function(b) {
      }
    }, g = this.webSocketFactory.create(u, pb(a), v);
    g.connect(), await c;
    const w = { setup: { model: Re(this.apiClient, e.model) } };
    return g.send(JSON.stringify(w)), new hb(g, this.apiClient);
  }
}
class hb {
  constructor(e, t) {
    this.conn = e, this.apiClient = t;
  }
  /**
      Sets inputs to steer music generation. Updates the session's current
      weighted prompts.
  
      @param params - Contains one property, `weightedPrompts`.
  
        - `weightedPrompts` to send to the model; weights are normalized to
          sum to 1.0.
  
      @experimental
     */
  async setWeightedPrompts(e) {
    if (!e.weightedPrompts || Object.keys(e.weightedPrompts).length === 0)
      throw new Error("Weighted prompts must be set and contain at least one entry.");
    const t = ow(e);
    this.conn.send(JSON.stringify({ clientContent: t }));
  }
  /**
      Sets a configuration to the model. Updates the session's current
      music generation config.
  
      @param params - Contains one property, `musicGenerationConfig`.
  
        - `musicGenerationConfig` to set in the model. Passing an empty or
      undefined config to the model will reset the config to defaults.
  
      @experimental
     */
  async setMusicGenerationConfig(e) {
    e.musicGenerationConfig || (e.musicGenerationConfig = {});
    const t = rw(e);
    this.conn.send(JSON.stringify(t));
  }
  sendPlaybackControl(e) {
    const t = { playbackControl: e };
    this.conn.send(JSON.stringify(t));
  }
  /**
   * Start the music stream.
   *
   * @experimental
   */
  play() {
    this.sendPlaybackControl(Bo.PLAY);
  }
  /**
   * Temporarily halt the music stream. Use `play` to resume from the current
   * position.
   *
   * @experimental
   */
  pause() {
    this.sendPlaybackControl(Bo.PAUSE);
  }
  /**
   * Stop the music stream and reset the state. Retains the current prompts
   * and config.
   *
   * @experimental
   */
  stop() {
    this.sendPlaybackControl(Bo.STOP);
  }
  /**
   * Resets the context of the music generation without stopping it.
   * Retains the current prompts and config.
   *
   * @experimental
   */
  resetContext() {
    this.sendPlaybackControl(Bo.RESET_CONTEXT);
  }
  /**
       Terminates the WebSocket connection.
  
       @experimental
     */
  close() {
    this.conn.close();
  }
}
function pb(n) {
  const e = {};
  return n.forEach((t, r) => {
    e[r] = t;
  }), e;
}
function mb(n) {
  const e = new Headers();
  for (const [t, r] of Object.entries(n))
    e.append(t, r);
  return e;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const vb = "FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI.";
async function gb(n, e, t) {
  const r = new a2();
  let o;
  t.data instanceof Blob ? o = await t.data.text() : t.data instanceof ArrayBuffer ? o = new TextDecoder().decode(t.data) : o = t.data;
  const i = JSON.parse(o);
  if (n.isVertexAI()) {
    const a = sw(i);
    Object.assign(r, a);
  } else
    Object.assign(r, i);
  e(r);
}
class yb {
  constructor(e, t, r) {
    this.apiClient = e, this.auth = t, this.webSocketFactory = r, this.music = new db(this.apiClient, this.auth, this.webSocketFactory);
  }
  /**
       Establishes a connection to the specified model with the given
       configuration and returns a Session object representing that connection.
  
       @experimental Built-in MCP support is an experimental feature, may change in
       future versions.
  
       @remarks
  
       @param params - The parameters for establishing a connection to the model.
       @return A live session.
  
       @example
       ```ts
       let model: string;
       if (GOOGLE_GENAI_USE_VERTEXAI) {
         model = 'gemini-2.0-flash-live-preview-04-09';
       } else {
         model = 'gemini-live-2.5-flash-preview';
       }
       const session = await ai.live.connect({
         model: model,
         config: {
           responseModalities: [Modality.AUDIO],
         },
         callbacks: {
           onopen: () => {
             console.log('Connected to the socket.');
           },
           onmessage: (e: MessageEvent) => {
             console.log('Received message from the server: %s\n', debug(e.data));
           },
           onerror: (e: ErrorEvent) => {
             console.log('Error occurred: %s\n', debug(e.error));
           },
           onclose: (e: CloseEvent) => {
             console.log('Connection closed.');
           },
         },
       });
       ```
      */
  async connect(e) {
    var t, r, o, i, a, s;
    if (e.config && e.config.httpOptions)
      throw new Error("The Live module does not support httpOptions at request-level in LiveConnectConfig yet. Please use the client-level httpOptions configuration instead.");
    const u = this.apiClient.getWebsocketBaseUrl(), l = this.apiClient.getApiVersion();
    let c;
    const f = this.apiClient.getHeaders();
    e.config && e.config.tools && gv(e.config.tools) && yv(f);
    const d = bb(f);
    if (this.apiClient.isVertexAI())
      c = `${u}/ws/google.cloud.aiplatform.${l}.LlmBidiService/BidiGenerateContent`, await this.auth.addAuthHeaders(d, c);
    else {
      const I = this.apiClient.getApiKey();
      let S = "BidiGenerateContent", M = "key";
      I != null && I.startsWith("auth_tokens/") && (console.warn("Warning: Ephemeral token support is experimental and may change in future versions."), l !== "v1alpha" && console.warn("Warning: The SDK's ephemeral token support is in v1alpha only. Please use const ai = new GoogleGenAI({apiKey: token.name, httpOptions: { apiVersion: 'v1alpha' }}); before session connection."), S = "BidiGenerateContentConstrained", M = "access_token"), c = `${u}/ws/google.ai.generativelanguage.${l}.GenerativeService.${S}?${M}=${I}`;
    }
    let p = () => {
    };
    const v = new Promise((I) => {
      p = I;
    }), g = e.callbacks, y = function() {
      var I;
      (I = g == null ? void 0 : g.onopen) === null || I === void 0 || I.call(g), p({});
    }, x = this.apiClient, w = {
      onopen: y,
      onmessage: (I) => {
        gb(x, g.onmessage, I);
      },
      onerror: (t = g == null ? void 0 : g.onerror) !== null && t !== void 0 ? t : function(I) {
      },
      onclose: (r = g == null ? void 0 : g.onclose) !== null && r !== void 0 ? r : function(I) {
      }
    }, b = this.webSocketFactory.create(c, _b(d), w);
    b.connect(), await v;
    let _ = Re(this.apiClient, e.model);
    if (this.apiClient.isVertexAI() && _.startsWith("publishers/")) {
      const I = this.apiClient.getProject(), S = this.apiClient.getLocation();
      _ = `projects/${I}/locations/${S}/` + _;
    }
    let E = {};
    this.apiClient.isVertexAI() && ((o = e.config) === null || o === void 0 ? void 0 : o.responseModalities) === void 0 && (e.config === void 0 ? e.config = { responseModalities: [$i.AUDIO] } : e.config.responseModalities = [$i.AUDIO]), !((i = e.config) === null || i === void 0) && i.generationConfig && console.warn("Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025).");
    const C = (s = (a = e.config) === null || a === void 0 ? void 0 : a.tools) !== null && s !== void 0 ? s : [], A = [];
    for (const I of C)
      if (this.isCallableTool(I)) {
        const S = I;
        A.push(await S.tool());
      } else
        A.push(I);
    A.length > 0 && (e.config.tools = A);
    const R = {
      model: _,
      config: e.config,
      callbacks: e.callbacks
    };
    return this.apiClient.isVertexAI() ? E = nw(this.apiClient, R) : E = tw(this.apiClient, R), delete E.config, b.send(JSON.stringify(E)), new wb(b, this.apiClient);
  }
  // TODO: b/416041229 - Abstract this method to a common place.
  isCallableTool(e) {
    return "callTool" in e && typeof e.callTool == "function";
  }
}
const xb = {
  turnComplete: !0
};
class wb {
  constructor(e, t) {
    this.conn = e, this.apiClient = t;
  }
  tLiveClientContent(e, t) {
    if (t.turns !== null && t.turns !== void 0) {
      let r = [];
      try {
        r = yn(t.turns), e.isVertexAI() || (r = r.map((o) => Es(o)));
      } catch {
        throw new Error(`Failed to parse client content "turns", type: '${typeof t.turns}'`);
      }
      return {
        clientContent: { turns: r, turnComplete: t.turnComplete }
      };
    }
    return {
      clientContent: { turnComplete: t.turnComplete }
    };
  }
  tLiveClienttToolResponse(e, t) {
    let r = [];
    if (t.functionResponses == null)
      throw new Error("functionResponses is required.");
    if (Array.isArray(t.functionResponses) ? r = t.functionResponses : r = [t.functionResponses], r.length === 0)
      throw new Error("functionResponses is required.");
    for (const i of r) {
      if (typeof i != "object" || i === null || !("name" in i) || !("response" in i))
        throw new Error(`Could not parse function response, type '${typeof i}'.`);
      if (!e.isVertexAI() && !("id" in i))
        throw new Error(vb);
    }
    return {
      toolResponse: { functionResponses: r }
    };
  }
  /**
      Send a message over the established connection.
  
      @param params - Contains two **optional** properties, `turns` and
          `turnComplete`.
  
        - `turns` will be converted to a `Content[]`
        - `turnComplete: true` [default] indicates that you are done sending
          content and expect a response. If `turnComplete: false`, the server
          will wait for additional messages before starting generation.
  
      @experimental
  
      @remarks
      There are two ways to send messages to the live API:
      `sendClientContent` and `sendRealtimeInput`.
  
      `sendClientContent` messages are added to the model context **in order**.
      Having a conversation using `sendClientContent` messages is roughly
      equivalent to using the `Chat.sendMessageStream`, except that the state of
      the `chat` history is stored on the API server instead of locally.
  
      Because of `sendClientContent`'s order guarantee, the model cannot respons
      as quickly to `sendClientContent` messages as to `sendRealtimeInput`
      messages. This makes the biggest difference when sending objects that have
      significant preprocessing time (typically images).
  
      The `sendClientContent` message sends a `Content[]`
      which has more options than the `Blob` sent by `sendRealtimeInput`.
  
      So the main use-cases for `sendClientContent` over `sendRealtimeInput` are:
  
      - Sending anything that can't be represented as a `Blob` (text,
      `sendClientContent({turns="Hello?"}`)).
      - Managing turns when not using audio input and voice activity detection.
        (`sendClientContent({turnComplete:true})` or the short form
      `sendClientContent()`)
      - Prefilling a conversation context
        ```
        sendClientContent({
            turns: [
              Content({role:user, parts:...}),
              Content({role:user, parts:...}),
              ...
            ]
        })
        ```
      @experimental
     */
  sendClientContent(e) {
    e = Object.assign(Object.assign({}, xb), e);
    const t = this.tLiveClientContent(this.apiClient, e);
    this.conn.send(JSON.stringify(t));
  }
  /**
      Send a realtime message over the established connection.
  
      @param params - Contains one property, `media`.
  
        - `media` will be converted to a `Blob`
  
      @experimental
  
      @remarks
      Use `sendRealtimeInput` for realtime audio chunks and video frames (images).
  
      With `sendRealtimeInput` the api will respond to audio automatically
      based on voice activity detection (VAD).
  
      `sendRealtimeInput` is optimized for responsivness at the expense of
      deterministic ordering guarantees. Audio and video tokens are to the
      context when they become available.
  
      Note: The Call signature expects a `Blob` object, but only a subset
      of audio and image mimetypes are allowed.
     */
  sendRealtimeInput(e) {
    let t = {};
    this.apiClient.isVertexAI() ? t = {
      realtimeInput: aw(e)
    } : t = {
      realtimeInput: iw(e)
    }, this.conn.send(JSON.stringify(t));
  }
  /**
      Send a function response message over the established connection.
  
      @param params - Contains property `functionResponses`.
  
        - `functionResponses` will be converted to a `functionResponses[]`
  
      @remarks
      Use `sendFunctionResponse` to reply to `LiveServerToolCall` from the server.
  
      Use {@link types.LiveConnectConfig#tools} to configure the callable functions.
  
      @experimental
     */
  sendToolResponse(e) {
    if (e.functionResponses == null)
      throw new Error("Tool response parameters are required.");
    const t = this.tLiveClienttToolResponse(this.apiClient, e);
    this.conn.send(JSON.stringify(t));
  }
  /**
       Terminates the WebSocket connection.
  
       @experimental
  
       @example
       ```ts
       let model: string;
       if (GOOGLE_GENAI_USE_VERTEXAI) {
         model = 'gemini-2.0-flash-live-preview-04-09';
       } else {
         model = 'gemini-live-2.5-flash-preview';
       }
       const session = await ai.live.connect({
         model: model,
         config: {
           responseModalities: [Modality.AUDIO],
         }
       });
  
       session.close();
       ```
     */
  close() {
    this.conn.close();
  }
}
function _b(n) {
  const e = {};
  return n.forEach((t, r) => {
    e[r] = t;
  }), e;
}
function bb(n) {
  const e = new Headers();
  for (const [t, r] of Object.entries(n))
    e.append(t, r);
  return e;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Dh = 10;
function Fh(n) {
  var e, t, r;
  if (!((e = n == null ? void 0 : n.automaticFunctionCalling) === null || e === void 0) && e.disable)
    return !0;
  let o = !1;
  for (const a of (t = n == null ? void 0 : n.tools) !== null && t !== void 0 ? t : [])
    if (Go(a)) {
      o = !0;
      break;
    }
  if (!o)
    return !0;
  const i = (r = n == null ? void 0 : n.automaticFunctionCalling) === null || r === void 0 ? void 0 : r.maximumRemoteCalls;
  return i && (i < 0 || !Number.isInteger(i)) || i == 0 ? (console.warn("Invalid maximumRemoteCalls value provided for automatic function calling. Disabled automatic function calling. Please provide a valid integer value greater than 0. maximumRemoteCalls provided:", i), !0) : !1;
}
function Go(n) {
  return "callTool" in n && typeof n.callTool == "function";
}
function Eb(n) {
  var e, t, r;
  return (r = (t = (e = n.config) === null || e === void 0 ? void 0 : e.tools) === null || t === void 0 ? void 0 : t.some((o) => Go(o))) !== null && r !== void 0 ? r : !1;
}
function Cb(n) {
  var e, t, r;
  return (r = (t = (e = n.config) === null || e === void 0 ? void 0 : e.tools) === null || t === void 0 ? void 0 : t.some((o) => !Go(o))) !== null && r !== void 0 ? r : !1;
}
function Lh(n) {
  var e;
  return !(!((e = n == null ? void 0 : n.automaticFunctionCalling) === null || e === void 0) && e.ignoreCallHistory);
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class Tb extends go {
  constructor(e) {
    super(), this.apiClient = e, this.generateContent = async (t) => {
      var r, o, i, a, s;
      const u = await this.processParamsMaybeAddMcpUsage(t);
      if (this.maybeMoveToResponseJsonSchem(t), !Eb(t) || Fh(t.config))
        return await this.generateContentInternal(u);
      if (Cb(t))
        throw new Error("Automatic function calling with CallableTools and Tools is not yet supported.");
      let l, c;
      const f = yn(u.contents), d = (i = (o = (r = u.config) === null || r === void 0 ? void 0 : r.automaticFunctionCalling) === null || o === void 0 ? void 0 : o.maximumRemoteCalls) !== null && i !== void 0 ? i : Dh;
      let p = 0;
      for (; p < d && (l = await this.generateContentInternal(u), !(!l.functionCalls || l.functionCalls.length === 0)); ) {
        const v = l.candidates[0].content, g = [];
        for (const y of (s = (a = t.config) === null || a === void 0 ? void 0 : a.tools) !== null && s !== void 0 ? s : [])
          if (Go(y)) {
            const w = await y.callTool(l.functionCalls);
            g.push(...w);
          }
        p++, c = {
          role: "user",
          parts: g
        }, u.contents = yn(u.contents), u.contents.push(v), u.contents.push(c), Lh(u.config) && (f.push(v), f.push(c));
      }
      return Lh(u.config) && (l.automaticFunctionCallingHistory = f), l;
    }, this.generateContentStream = async (t) => {
      if (this.maybeMoveToResponseJsonSchem(t), Fh(t.config)) {
        const r = await this.processParamsMaybeAddMcpUsage(t);
        return await this.generateContentStreamInternal(r);
      } else
        return await this.processAfcStream(t);
    }, this.generateImages = async (t) => await this.generateImagesInternal(t).then((r) => {
      var o;
      let i;
      const a = [];
      if (r != null && r.generatedImages)
        for (const u of r.generatedImages)
          u && (u != null && u.safetyAttributes) && ((o = u == null ? void 0 : u.safetyAttributes) === null || o === void 0 ? void 0 : o.contentType) === "Positive Prompt" ? i = u == null ? void 0 : u.safetyAttributes : a.push(u);
      let s;
      return i ? s = {
        generatedImages: a,
        positivePromptSafetyAttributes: i,
        sdkHttpResponse: r.sdkHttpResponse
      } : s = {
        generatedImages: a,
        sdkHttpResponse: r.sdkHttpResponse
      }, s;
    }), this.list = async (t) => {
      var r;
      const a = {
        config: Object.assign(Object.assign({}, {
          queryBase: !0
        }), t == null ? void 0 : t.config)
      };
      if (this.apiClient.isVertexAI() && !a.config.queryBase) {
        if (!((r = a.config) === null || r === void 0) && r.filter)
          throw new Error("Filtering tuned models list for Vertex AI is not currently supported");
        a.config.filter = "labels.tune-type:*";
      }
      return new oa(co.PAGED_ITEM_MODELS, (s) => this.listInternal(s), await this.listInternal(a), a);
    }, this.editImage = async (t) => {
      const r = {
        model: t.model,
        prompt: t.prompt,
        referenceImages: [],
        config: t.config
      };
      return t.referenceImages && t.referenceImages && (r.referenceImages = t.referenceImages.map((o) => o.toReferenceImageAPI())), await this.editImageInternal(r);
    }, this.upscaleImage = async (t) => {
      let r = {
        numberOfImages: 1,
        mode: "upscale"
      };
      t.config && (r = Object.assign(Object.assign({}, r), t.config));
      const o = {
        model: t.model,
        image: t.image,
        upscaleFactor: t.upscaleFactor,
        config: r
      };
      return await this.upscaleImageInternal(o);
    }, this.generateVideos = async (t) => {
      var r, o, i, a, s, u;
      if ((t.prompt || t.image || t.video) && t.source)
        throw new Error("Source and prompt/image/video are mutually exclusive. Please only use source.");
      return this.apiClient.isVertexAI() || (!((r = t.video) === null || r === void 0) && r.uri && (!((o = t.video) === null || o === void 0) && o.videoBytes) ? t.video = {
        uri: t.video.uri,
        mimeType: t.video.mimeType
      } : !((a = (i = t.source) === null || i === void 0 ? void 0 : i.video) === null || a === void 0) && a.uri && (!((u = (s = t.source) === null || s === void 0 ? void 0 : s.video) === null || u === void 0) && u.videoBytes) && (t.source.video = {
        uri: t.source.video.uri,
        mimeType: t.source.video.mimeType
      })), await this.generateVideosInternal(t);
    };
  }
  /**
   * This logic is needed for GenerateContentConfig only.
   * Previously we made GenerateContentConfig.responseSchema field to accept
   * unknown. Since v1.9.0, we switch to use backend JSON schema support.
   * To maintain backward compatibility, we move the data that was treated as
   * JSON schema from the responseSchema field to the responseJsonSchema field.
   */
  maybeMoveToResponseJsonSchem(e) {
    e.config && e.config.responseSchema && (e.config.responseJsonSchema || Object.keys(e.config.responseSchema).includes("$schema") && (e.config.responseJsonSchema = e.config.responseSchema, delete e.config.responseSchema));
  }
  /**
   * Transforms the CallableTools in the parameters to be simply Tools, it
   * copies the params into a new object and replaces the tools, it does not
   * modify the original params. Also sets the MCP usage header if there are
   * MCP tools in the parameters.
   */
  async processParamsMaybeAddMcpUsage(e) {
    var t, r, o;
    const i = (t = e.config) === null || t === void 0 ? void 0 : t.tools;
    if (!i)
      return e;
    const a = await Promise.all(i.map(async (u) => Go(u) ? await u.tool() : u)), s = {
      model: e.model,
      contents: e.contents,
      config: Object.assign(Object.assign({}, e.config), { tools: a })
    };
    if (s.config.tools = a, e.config && e.config.tools && gv(e.config.tools)) {
      const u = (o = (r = e.config.httpOptions) === null || r === void 0 ? void 0 : r.headers) !== null && o !== void 0 ? o : {};
      let l = Object.assign({}, u);
      Object.keys(l).length === 0 && (l = this.apiClient.getDefaultHeaders()), yv(l), s.config.httpOptions = Object.assign(Object.assign({}, e.config.httpOptions), { headers: l });
    }
    return s;
  }
  async initAfcToolsMap(e) {
    var t, r, o;
    const i = /* @__PURE__ */ new Map();
    for (const a of (r = (t = e.config) === null || t === void 0 ? void 0 : t.tools) !== null && r !== void 0 ? r : [])
      if (Go(a)) {
        const s = a, u = await s.tool();
        for (const l of (o = u.functionDeclarations) !== null && o !== void 0 ? o : []) {
          if (!l.name)
            throw new Error("Function declaration name is required.");
          if (i.has(l.name))
            throw new Error(`Duplicate tool declaration name: ${l.name}`);
          i.set(l.name, s);
        }
      }
    return i;
  }
  async processAfcStream(e) {
    var t, r, o;
    const i = (o = (r = (t = e.config) === null || t === void 0 ? void 0 : t.automaticFunctionCalling) === null || r === void 0 ? void 0 : r.maximumRemoteCalls) !== null && o !== void 0 ? o : Dh;
    let a = !1, s = 0;
    const u = await this.initAfcToolsMap(e);
    return function(l, c, f) {
      var d, p;
      return Vo(this, arguments, function* () {
        for (var v, g, y, x; s < i; ) {
          a && (s++, a = !1);
          const E = yield Ve(l.processParamsMaybeAddMcpUsage(f)), C = yield Ve(l.generateContentStreamInternal(E)), A = [], R = [];
          try {
            for (var w = !0, b = (g = void 0, Bi(C)), _; _ = yield Ve(b.next()), v = _.done, !v; w = !0) {
              x = _.value, w = !1;
              const I = x;
              if (yield yield Ve(I), I.candidates && (!((d = I.candidates[0]) === null || d === void 0) && d.content)) {
                R.push(I.candidates[0].content);
                for (const S of (p = I.candidates[0].content.parts) !== null && p !== void 0 ? p : [])
                  if (s < i && S.functionCall) {
                    if (!S.functionCall.name)
                      throw new Error("Function call name was not returned by the model.");
                    if (c.has(S.functionCall.name)) {
                      const M = yield Ve(c.get(S.functionCall.name).callTool([S.functionCall]));
                      A.push(...M);
                    } else
                      throw new Error(`Automatic function calling was requested, but not all the tools the model used implement the CallableTool interface. Available tools: ${c.keys()}, mising tool: ${S.functionCall.name}`);
                  }
              }
            }
          } catch (I) {
            g = { error: I };
          } finally {
            try {
              !w && !v && (y = b.return) && (yield Ve(y.call(b)));
            } finally {
              if (g) throw g.error;
            }
          }
          if (A.length > 0) {
            a = !0;
            const I = new Ai();
            I.candidates = [
              {
                content: {
                  role: "user",
                  parts: A
                }
              }
            ], yield yield Ve(I);
            const S = [];
            S.push(...R), S.push({
              role: "user",
              parts: A
            });
            const M = yn(f.contents).concat(S);
            f.contents = M;
          } else
            break;
        }
      });
    }(this, u, e);
  }
  async generateContentInternal(e) {
    var t, r, o, i;
    let a, s = "", u = {};
    if (this.apiClient.isVertexAI()) {
      const l = Rh(this.apiClient, e);
      return s = Q("{model}:generateContent", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "POST",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((c) => c.json().then((f) => {
        const d = f;
        return d.sdkHttpResponse = {
          headers: c.headers
        }, d;
      })), a.then((c) => {
        const f = Ph(c), d = new Ai();
        return Object.assign(d, f), d;
      });
    } else {
      const l = Ah(this.apiClient, e);
      return s = Q("{model}:generateContent", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "POST",
        httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
        abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal
      }).then((c) => c.json().then((f) => {
        const d = f;
        return d.sdkHttpResponse = {
          headers: c.headers
        }, d;
      })), a.then((c) => {
        const f = kh(c), d = new Ai();
        return Object.assign(d, f), d;
      });
    }
  }
  async generateContentStreamInternal(e) {
    var t, r, o, i;
    let a, s = "", u = {};
    if (this.apiClient.isVertexAI()) {
      const l = Rh(this.apiClient, e);
      return s = Q("{model}:streamGenerateContent?alt=sse", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.requestStream({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "POST",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }), a.then(function(f) {
        return Vo(this, arguments, function* () {
          var d, p, v, g;
          try {
            for (var y = !0, x = Bi(f), w; w = yield Ve(x.next()), d = w.done, !d; y = !0) {
              g = w.value, y = !1;
              const b = g, _ = Ph(yield Ve(b.json()));
              _.sdkHttpResponse = {
                headers: b.headers
              };
              const E = new Ai();
              Object.assign(E, _), yield yield Ve(E);
            }
          } catch (b) {
            p = { error: b };
          } finally {
            try {
              !y && !d && (v = x.return) && (yield Ve(v.call(x)));
            } finally {
              if (p) throw p.error;
            }
          }
        });
      });
    } else {
      const l = Ah(this.apiClient, e);
      return s = Q("{model}:streamGenerateContent?alt=sse", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.requestStream({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "POST",
        httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
        abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal
      }), a.then(function(f) {
        return Vo(this, arguments, function* () {
          var d, p, v, g;
          try {
            for (var y = !0, x = Bi(f), w; w = yield Ve(x.next()), d = w.done, !d; y = !0) {
              g = w.value, y = !1;
              const b = g, _ = kh(yield Ve(b.json()));
              _.sdkHttpResponse = {
                headers: b.headers
              };
              const E = new Ai();
              Object.assign(E, _), yield yield Ve(E);
            }
          } catch (b) {
            p = { error: b };
          } finally {
            try {
              !y && !d && (v = x.return) && (yield Ve(v.call(x)));
            } finally {
              if (p) throw p.error;
            }
          }
        });
      });
    }
  }
  /**
   * Calculates embeddings for the given contents. Only text is supported.
   *
   * @param params - The parameters for embedding contents.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response = await ai.models.embedContent({
   *  model: 'text-embedding-004',
   *  contents: [
   *    'What is your name?',
   *    'What is your favorite color?',
   *  ],
   *  config: {
   *    outputDimensionality: 64,
   *  },
   * });
   * console.log(response);
   * ```
   */
  async embedContent(e) {
    var t, r, o, i;
    let a, s = "", u = {};
    if (this.apiClient.isVertexAI()) {
      const l = Bw(this.apiClient, e);
      return s = Q("{model}:predict", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "POST",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((c) => c.json().then((f) => {
        const d = f;
        return d.sdkHttpResponse = {
          headers: c.headers
        }, d;
      })), a.then((c) => {
        const f = Uw(c), d = new dh();
        return Object.assign(d, f), d;
      });
    } else {
      const l = Lw(this.apiClient, e);
      return s = Q("{model}:batchEmbedContents", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "POST",
        httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
        abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal
      }).then((c) => c.json().then((f) => {
        const d = f;
        return d.sdkHttpResponse = {
          headers: c.headers
        }, d;
      })), a.then((c) => {
        const f = Ow(c), d = new dh();
        return Object.assign(d, f), d;
      });
    }
  }
  /**
   * Private method for generating images.
   */
  async generateImagesInternal(e) {
    var t, r, o, i;
    let a, s = "", u = {};
    if (this.apiClient.isVertexAI()) {
      const l = Jw(this.apiClient, e);
      return s = Q("{model}:predict", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "POST",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((c) => c.json().then((f) => {
        const d = f;
        return d.sdkHttpResponse = {
          headers: c.headers
        }, d;
      })), a.then((c) => {
        const f = Yw(c), d = new hh();
        return Object.assign(d, f), d;
      });
    } else {
      const l = Kw(this.apiClient, e);
      return s = Q("{model}:predict", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "POST",
        httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
        abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal
      }).then((c) => c.json().then((f) => {
        const d = f;
        return d.sdkHttpResponse = {
          headers: c.headers
        }, d;
      })), a.then((c) => {
        const f = Xw(c), d = new hh();
        return Object.assign(d, f), d;
      });
    }
  }
  /**
   * Private method for editing an image.
   */
  async editImageInternal(e) {
    var t, r;
    let o, i = "", a = {};
    if (this.apiClient.isVertexAI()) {
      const s = Nw(this.apiClient, e);
      return i = Q("{model}:predict", s._url), a = s._query, delete s._url, delete s._query, o = this.apiClient.request({
        path: i,
        queryParams: a,
        body: JSON.stringify(s),
        httpMethod: "POST",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((u) => u.json().then((l) => {
        const c = l;
        return c.sdkHttpResponse = {
          headers: u.headers
        }, c;
      })), o.then((u) => {
        const l = Mw(u), c = new Zy();
        return Object.assign(c, l), c;
      });
    } else
      throw new Error("This method is only supported by the Vertex AI.");
  }
  /**
   * Private method for upscaling an image.
   */
  async upscaleImageInternal(e) {
    var t, r;
    let o, i = "", a = {};
    if (this.apiClient.isVertexAI()) {
      const s = q_(this.apiClient, e);
      return i = Q("{model}:predict", s._url), a = s._query, delete s._url, delete s._query, o = this.apiClient.request({
        path: i,
        queryParams: a,
        body: JSON.stringify(s),
        httpMethod: "POST",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((u) => u.json().then((l) => {
        const c = l;
        return c.sdkHttpResponse = {
          headers: u.headers
        }, c;
      })), o.then((u) => {
        const l = z_(u), c = new jy();
        return Object.assign(c, l), c;
      });
    } else
      throw new Error("This method is only supported by the Vertex AI.");
  }
  /**
   * Recontextualizes an image.
   *
   * There are two types of recontextualization currently supported:
   * 1) Imagen Product Recontext - Generate images of products in new scenes
   *    and contexts.
   * 2) Virtual Try-On: Generate images of persons modeling fashion products.
   *
   * @param params - The parameters for recontextualizing an image.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response1 = await ai.models.recontextImage({
   *  model: 'imagen-product-recontext-preview-06-30',
   *  source: {
   *    prompt: 'In a modern kitchen setting.',
   *    productImages: [productImage],
   *  },
   *  config: {
   *    numberOfImages: 1,
   *  },
   * });
   * console.log(response1?.generatedImages?.[0]?.image?.imageBytes);
   *
   * const response2 = await ai.models.recontextImage({
   *  model: 'virtual-try-on-preview-08-04',
   *  source: {
   *    personImage: personImage,
   *    productImages: [productImage],
   *  },
   *  config: {
   *    numberOfImages: 1,
   *  },
   * });
   * console.log(response2?.generatedImages?.[0]?.image?.imageBytes);
   * ```
   */
  async recontextImage(e) {
    var t, r;
    let o, i = "", a = {};
    if (this.apiClient.isVertexAI()) {
      const s = S_(this.apiClient, e);
      return i = Q("{model}:predict", s._url), a = s._query, delete s._url, delete s._query, o = this.apiClient.request({
        path: i,
        queryParams: a,
        body: JSON.stringify(s),
        httpMethod: "POST",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((u) => u.json()), o.then((u) => {
        const l = A_(u), c = new e2();
        return Object.assign(c, l), c;
      });
    } else
      throw new Error("This method is only supported by the Vertex AI.");
  }
  /**
   * Segments an image, creating a mask of a specified area.
   *
   * @param params - The parameters for segmenting an image.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response = await ai.models.segmentImage({
   *  model: 'image-segmentation-001',
   *  source: {
   *    image: image,
   *  },
   *  config: {
   *    mode: 'foreground',
   *  },
   * });
   * console.log(response?.generatedMasks?.[0]?.mask?.imageBytes);
   * ```
   */
  async segmentImage(e) {
    var t, r;
    let o, i = "", a = {};
    if (this.apiClient.isVertexAI()) {
      const s = D_(this.apiClient, e);
      return i = Q("{model}:predict", s._url), a = s._query, delete s._url, delete s._query, o = this.apiClient.request({
        path: i,
        queryParams: a,
        body: JSON.stringify(s),
        httpMethod: "POST",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((u) => u.json()), o.then((u) => {
        const l = F_(u), c = new t2();
        return Object.assign(c, l), c;
      });
    } else
      throw new Error("This method is only supported by the Vertex AI.");
  }
  /**
   * Fetches information about a model by name.
   *
   * @example
   * ```ts
   * const modelInfo = await ai.models.get({model: 'gemini-2.0-flash'});
   * ```
   */
  async get(e) {
    var t, r, o, i;
    let a, s = "", u = {};
    if (this.apiClient.isVertexAI()) {
      const l = h_(this.apiClient, e);
      return s = Q("{name}", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "GET",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((c) => c.json()), a.then((c) => vl(c));
    } else {
      const l = d_(this.apiClient, e);
      return s = Q("{name}", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "GET",
        httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
        abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal
      }).then((c) => c.json()), a.then((c) => ml(c));
    }
  }
  async listInternal(e) {
    var t, r, o, i;
    let a, s = "", u = {};
    if (this.apiClient.isVertexAI()) {
      const l = w_(this.apiClient, e);
      return s = Q("{models_url}", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "GET",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((c) => c.json().then((f) => {
        const d = f;
        return d.sdkHttpResponse = {
          headers: c.headers
        }, d;
      })), a.then((c) => {
        const f = b_(c), d = new ph();
        return Object.assign(d, f), d;
      });
    } else {
      const l = x_(this.apiClient, e);
      return s = Q("{models_url}", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "GET",
        httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
        abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal
      }).then((c) => c.json().then((f) => {
        const d = f;
        return d.sdkHttpResponse = {
          headers: c.headers
        }, d;
      })), a.then((c) => {
        const f = __(c), d = new ph();
        return Object.assign(d, f), d;
      });
    }
  }
  /**
   * Updates a tuned model by its name.
   *
   * @param params - The parameters for updating the model.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response = await ai.models.update({
   *   model: 'tuned-model-name',
   *   config: {
   *     displayName: 'New display name',
   *     description: 'New description',
   *   },
   * });
   * ```
   */
  async update(e) {
    var t, r, o, i;
    let a, s = "", u = {};
    if (this.apiClient.isVertexAI()) {
      const l = H_(this.apiClient, e);
      return s = Q("{model}", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "PATCH",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((c) => c.json()), a.then((c) => vl(c));
    } else {
      const l = W_(this.apiClient, e);
      return s = Q("{name}", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "PATCH",
        httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
        abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal
      }).then((c) => c.json()), a.then((c) => ml(c));
    }
  }
  /**
   * Deletes a tuned model by its name.
   *
   * @param params - The parameters for deleting the model.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response = await ai.models.delete({model: 'tuned-model-name'});
   * ```
   */
  async delete(e) {
    var t, r, o, i;
    let a, s = "", u = {};
    if (this.apiClient.isVertexAI()) {
      const l = Aw(this.apiClient, e);
      return s = Q("{name}", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "DELETE",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((c) => c.json().then((f) => {
        const d = f;
        return d.sdkHttpResponse = {
          headers: c.headers
        }, d;
      })), a.then((c) => {
        const f = kw(c), d = new mh();
        return Object.assign(d, f), d;
      });
    } else {
      const l = Sw(this.apiClient, e);
      return s = Q("{name}", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "DELETE",
        httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
        abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal
      }).then((c) => c.json().then((f) => {
        const d = f;
        return d.sdkHttpResponse = {
          headers: c.headers
        }, d;
      })), a.then((c) => {
        const f = Rw(c), d = new mh();
        return Object.assign(d, f), d;
      });
    }
  }
  /**
   * Counts the number of tokens in the given contents. Multimodal input is
   * supported for Gemini models.
   *
   * @param params - The parameters for counting tokens.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response = await ai.models.countTokens({
   *  model: 'gemini-2.0-flash',
   *  contents: 'The quick brown fox jumps over the lazy dog.'
   * });
   * console.log(response);
   * ```
   */
  async countTokens(e) {
    var t, r, o, i;
    let a, s = "", u = {};
    if (this.apiClient.isVertexAI()) {
      const l = Cw(this.apiClient, e);
      return s = Q("{model}:countTokens", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "POST",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((c) => c.json().then((f) => {
        const d = f;
        return d.sdkHttpResponse = {
          headers: c.headers
        }, d;
      })), a.then((c) => {
        const f = Iw(c), d = new vh();
        return Object.assign(d, f), d;
      });
    } else {
      const l = Ew(this.apiClient, e);
      return s = Q("{model}:countTokens", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "POST",
        httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
        abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal
      }).then((c) => c.json().then((f) => {
        const d = f;
        return d.sdkHttpResponse = {
          headers: c.headers
        }, d;
      })), a.then((c) => {
        const f = Tw(c), d = new vh();
        return Object.assign(d, f), d;
      });
    }
  }
  /**
   * Given a list of contents, returns a corresponding TokensInfo containing
   * the list of tokens and list of token ids.
   *
   * This method is not supported by the Gemini Developer API.
   *
   * @param params - The parameters for computing tokens.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response = await ai.models.computeTokens({
   *  model: 'gemini-2.0-flash',
   *  contents: 'What is your name?'
   * });
   * console.log(response);
   * ```
   */
  async computeTokens(e) {
    var t, r;
    let o, i = "", a = {};
    if (this.apiClient.isVertexAI()) {
      const s = vw(this.apiClient, e);
      return i = Q("{model}:computeTokens", s._url), a = s._query, delete s._url, delete s._query, o = this.apiClient.request({
        path: i,
        queryParams: a,
        body: JSON.stringify(s),
        httpMethod: "POST",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((u) => u.json().then((l) => {
        const c = l;
        return c.sdkHttpResponse = {
          headers: u.headers
        }, c;
      })), o.then((u) => {
        const l = gw(u), c = new n2();
        return Object.assign(c, l), c;
      });
    } else
      throw new Error("This method is only supported by the Vertex AI.");
  }
  /**
   * Private method for generating videos.
   */
  async generateVideosInternal(e) {
    var t, r, o, i;
    let a, s = "", u = {};
    if (this.apiClient.isVertexAI()) {
      const l = n_(this.apiClient, e);
      return s = Q("{model}:predictLongRunning", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "POST",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((c) => c.json()), a.then((c) => {
        const f = e_(c), d = new qa();
        return Object.assign(d, f), d;
      });
    } else {
      const l = t_(this.apiClient, e);
      return s = Q("{model}:predictLongRunning", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "POST",
        httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
        abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal
      }).then((c) => c.json()), a.then((c) => {
        const f = jw(c), d = new qa();
        return Object.assign(d, f), d;
      });
    }
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class Ib extends go {
  constructor(e) {
    super(), this.apiClient = e;
  }
  /**
   * Gets the status of a long-running operation.
   *
   * @param parameters The parameters for the get operation request.
   * @return The updated Operation object, with the latest status or result.
   */
  async getVideosOperation(e) {
    const t = e.operation, r = e.config;
    if (t.name === void 0 || t.name === "")
      throw new Error("Operation name is required.");
    if (this.apiClient.isVertexAI()) {
      const o = t.name.split("/operations/")[0];
      let i;
      r && "httpOptions" in r && (i = r.httpOptions);
      const a = await this.fetchPredictVideosOperationInternal({
        operationName: t.name,
        resourceName: o,
        config: { httpOptions: i }
      });
      return t._fromAPIResponse({
        apiResponse: a,
        isVertexAI: !0
      });
    } else {
      const o = await this.getVideosOperationInternal({
        operationName: t.name,
        config: r
      });
      return t._fromAPIResponse({
        apiResponse: o,
        isVertexAI: !1
      });
    }
  }
  /**
   * Gets the status of a long-running operation.
   *
   * @param parameters The parameters for the get operation request.
   * @return The updated Operation object, with the latest status or result.
   */
  async get(e) {
    const t = e.operation, r = e.config;
    if (t.name === void 0 || t.name === "")
      throw new Error("Operation name is required.");
    if (this.apiClient.isVertexAI()) {
      const o = t.name.split("/operations/")[0];
      let i;
      r && "httpOptions" in r && (i = r.httpOptions);
      const a = await this.fetchPredictVideosOperationInternal({
        operationName: t.name,
        resourceName: o,
        config: { httpOptions: i }
      });
      return t._fromAPIResponse({
        apiResponse: a,
        isVertexAI: !0
      });
    } else {
      const o = await this.getVideosOperationInternal({
        operationName: t.name,
        config: r
      });
      return t._fromAPIResponse({
        apiResponse: o,
        isVertexAI: !1
      });
    }
  }
  async getVideosOperationInternal(e) {
    var t, r, o, i;
    let a, s = "", u = {};
    if (this.apiClient.isVertexAI()) {
      const l = Xy(e);
      return s = Q("{operationName}", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "GET",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((c) => c.json()), a;
    } else {
      const l = Jy(e);
      return s = Q("{operationName}", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "GET",
        httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
        abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal
      }).then((c) => c.json()), a;
    }
  }
  async fetchPredictVideosOperationInternal(e) {
    var t, r;
    let o, i = "", a = {};
    if (this.apiClient.isVertexAI()) {
      const s = Gy(e);
      return i = Q("{resourceName}:fetchPredictOperation", s._url), a = s._query, delete s._url, delete s._query, o = this.apiClient.request({
        path: i,
        queryParams: a,
        body: JSON.stringify(s),
        httpMethod: "POST",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((u) => u.json()), o;
    } else
      throw new Error("This method is only supported by the Vertex AI.");
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function Sb(n) {
  const e = {}, t = h(n, ["data"]);
  if (t != null && m(e, ["data"], t), h(n, ["displayName"]) !== void 0)
    throw new Error("displayName parameter is not supported in Gemini API.");
  const r = h(n, ["mimeType"]);
  return r != null && m(e, ["mimeType"], r), e;
}
function Ab(n) {
  const e = {}, t = h(n, ["parts"]);
  if (t != null) {
    let o = t;
    Array.isArray(o) && (o = o.map((i) => Lb(i))), m(e, ["parts"], o);
  }
  const r = h(n, ["role"]);
  return r != null && m(e, ["role"], r), e;
}
function Rb(n, e, t) {
  const r = {}, o = h(e, ["expireTime"]);
  t !== void 0 && o != null && m(t, ["expireTime"], o);
  const i = h(e, [
    "newSessionExpireTime"
  ]);
  t !== void 0 && i != null && m(t, ["newSessionExpireTime"], i);
  const a = h(e, ["uses"]);
  t !== void 0 && a != null && m(t, ["uses"], a);
  const s = h(e, [
    "liveConnectConstraints"
  ]);
  t !== void 0 && s != null && m(t, ["bidiGenerateContentSetup"], Fb(n, s));
  const u = h(e, [
    "lockAdditionalFields"
  ]);
  return t !== void 0 && u != null && m(t, ["fieldMask"], u), r;
}
function kb(n, e) {
  const t = {}, r = h(e, ["config"]);
  return r != null && m(t, ["config"], Rb(n, r, t)), t;
}
function Pb(n) {
  const e = {};
  if (h(n, ["displayName"]) !== void 0)
    throw new Error("displayName parameter is not supported in Gemini API.");
  const t = h(n, ["fileUri"]);
  t != null && m(e, ["fileUri"], t);
  const r = h(n, ["mimeType"]);
  return r != null && m(e, ["mimeType"], r), e;
}
function Nb(n) {
  const e = {};
  if (h(n, ["authConfig"]) !== void 0)
    throw new Error("authConfig parameter is not supported in Gemini API.");
  const t = h(n, ["enableWidget"]);
  return t != null && m(e, ["enableWidget"], t), e;
}
function Mb(n) {
  const e = {};
  if (h(n, ["excludeDomains"]) !== void 0)
    throw new Error("excludeDomains parameter is not supported in Gemini API.");
  const t = h(n, [
    "timeRangeFilter"
  ]);
  return t != null && m(e, ["timeRangeFilter"], t), e;
}
function Db(n, e) {
  const t = {}, r = h(n, [
    "generationConfig"
  ]);
  e !== void 0 && r != null && m(e, ["setup", "generationConfig"], r);
  const o = h(n, [
    "responseModalities"
  ]);
  e !== void 0 && o != null && m(e, ["setup", "generationConfig", "responseModalities"], o);
  const i = h(n, ["temperature"]);
  e !== void 0 && i != null && m(e, ["setup", "generationConfig", "temperature"], i);
  const a = h(n, ["topP"]);
  e !== void 0 && a != null && m(e, ["setup", "generationConfig", "topP"], a);
  const s = h(n, ["topK"]);
  e !== void 0 && s != null && m(e, ["setup", "generationConfig", "topK"], s);
  const u = h(n, [
    "maxOutputTokens"
  ]);
  e !== void 0 && u != null && m(e, ["setup", "generationConfig", "maxOutputTokens"], u);
  const l = h(n, [
    "mediaResolution"
  ]);
  e !== void 0 && l != null && m(e, ["setup", "generationConfig", "mediaResolution"], l);
  const c = h(n, ["seed"]);
  e !== void 0 && c != null && m(e, ["setup", "generationConfig", "seed"], c);
  const f = h(n, ["speechConfig"]);
  e !== void 0 && f != null && m(e, ["setup", "generationConfig", "speechConfig"], hc(f));
  const d = h(n, [
    "thinkingConfig"
  ]);
  e !== void 0 && d != null && m(e, ["setup", "generationConfig", "thinkingConfig"], d);
  const p = h(n, [
    "enableAffectiveDialog"
  ]);
  e !== void 0 && p != null && m(e, ["setup", "generationConfig", "enableAffectiveDialog"], p);
  const v = h(n, [
    "systemInstruction"
  ]);
  e !== void 0 && v != null && m(e, ["setup", "systemInstruction"], Ab(Pt(v)));
  const g = h(n, ["tools"]);
  if (e !== void 0 && g != null) {
    let C = mi(g);
    Array.isArray(C) && (C = C.map((A) => Ob(pi(A)))), m(e, ["setup", "tools"], C);
  }
  const y = h(n, [
    "sessionResumption"
  ]);
  e !== void 0 && y != null && m(e, ["setup", "sessionResumption"], Bb(y));
  const x = h(n, [
    "inputAudioTranscription"
  ]);
  e !== void 0 && x != null && m(e, ["setup", "inputAudioTranscription"], x);
  const w = h(n, [
    "outputAudioTranscription"
  ]);
  e !== void 0 && w != null && m(e, ["setup", "outputAudioTranscription"], w);
  const b = h(n, [
    "realtimeInputConfig"
  ]);
  e !== void 0 && b != null && m(e, ["setup", "realtimeInputConfig"], b);
  const _ = h(n, [
    "contextWindowCompression"
  ]);
  e !== void 0 && _ != null && m(e, ["setup", "contextWindowCompression"], _);
  const E = h(n, ["proactivity"]);
  return e !== void 0 && E != null && m(e, ["setup", "proactivity"], E), t;
}
function Fb(n, e) {
  const t = {}, r = h(e, ["model"]);
  r != null && m(t, ["setup", "model"], Re(n, r));
  const o = h(e, ["config"]);
  return o != null && m(t, ["config"], Db(o, t)), t;
}
function Lb(n) {
  const e = {}, t = h(n, ["functionCall"]);
  t != null && m(e, ["functionCall"], t);
  const r = h(n, [
    "codeExecutionResult"
  ]);
  r != null && m(e, ["codeExecutionResult"], r);
  const o = h(n, [
    "executableCode"
  ]);
  o != null && m(e, ["executableCode"], o);
  const i = h(n, ["fileData"]);
  i != null && m(e, ["fileData"], Pb(i));
  const a = h(n, [
    "functionResponse"
  ]);
  a != null && m(e, ["functionResponse"], a);
  const s = h(n, ["inlineData"]);
  s != null && m(e, ["inlineData"], Sb(s));
  const u = h(n, ["text"]);
  u != null && m(e, ["text"], u);
  const l = h(n, ["thought"]);
  l != null && m(e, ["thought"], l);
  const c = h(n, [
    "thoughtSignature"
  ]);
  c != null && m(e, ["thoughtSignature"], c);
  const f = h(n, [
    "videoMetadata"
  ]);
  return f != null && m(e, ["videoMetadata"], f), e;
}
function Bb(n) {
  const e = {}, t = h(n, ["handle"]);
  if (t != null && m(e, ["handle"], t), h(n, ["transparent"]) !== void 0)
    throw new Error("transparent parameter is not supported in Gemini API.");
  return e;
}
function Ob(n) {
  const e = {}, t = h(n, [
    "functionDeclarations"
  ]);
  if (t != null) {
    let l = t;
    Array.isArray(l) && (l = l.map((c) => c)), m(e, ["functionDeclarations"], l);
  }
  if (h(n, ["retrieval"]) !== void 0)
    throw new Error("retrieval parameter is not supported in Gemini API.");
  const r = h(n, [
    "googleSearchRetrieval"
  ]);
  r != null && m(e, ["googleSearchRetrieval"], r);
  const o = h(n, ["googleMaps"]);
  o != null && m(e, ["googleMaps"], Nb(o));
  const i = h(n, ["computerUse"]);
  i != null && m(e, ["computerUse"], i);
  const a = h(n, [
    "codeExecution"
  ]);
  if (a != null && m(e, ["codeExecution"], a), h(n, ["enterpriseWebSearch"]) !== void 0)
    throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
  const s = h(n, ["googleSearch"]);
  s != null && m(e, ["googleSearch"], Mb(s));
  const u = h(n, ["urlContext"]);
  return u != null && m(e, ["urlContext"], u), e;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function Ub(n) {
  const e = [];
  for (const t in n)
    if (Object.prototype.hasOwnProperty.call(n, t)) {
      const r = n[t];
      if (typeof r == "object" && r != null && Object.keys(r).length > 0) {
        const o = Object.keys(r).map((i) => `${t}.${i}`);
        e.push(...o);
      } else
        e.push(t);
    }
  return e.join(",");
}
function Vb(n, e) {
  let t = null;
  const r = n.bidiGenerateContentSetup;
  if (typeof r == "object" && r !== null && "setup" in r) {
    const i = r.setup;
    typeof i == "object" && i !== null ? (n.bidiGenerateContentSetup = i, t = i) : delete n.bidiGenerateContentSetup;
  } else r !== void 0 && delete n.bidiGenerateContentSetup;
  const o = n.fieldMask;
  if (t) {
    const i = Ub(t);
    if (Array.isArray(e == null ? void 0 : e.lockAdditionalFields) && (e == null ? void 0 : e.lockAdditionalFields.length) === 0)
      i ? n.fieldMask = i : delete n.fieldMask;
    else if (e != null && e.lockAdditionalFields && e.lockAdditionalFields.length > 0 && o !== null && Array.isArray(o) && o.length > 0) {
      const a = [
        "temperature",
        "topK",
        "topP",
        "maxOutputTokens",
        "responseModalities",
        "seed",
        "speechConfig"
      ];
      let s = [];
      o.length > 0 && (s = o.map((l) => a.includes(l) ? `generationConfig.${l}` : l));
      const u = [];
      i && u.push(i), s.length > 0 && u.push(...s), u.length > 0 ? n.fieldMask = u.join(",") : delete n.fieldMask;
    } else
      delete n.fieldMask;
  } else
    o !== null && Array.isArray(o) && o.length > 0 ? n.fieldMask = o.join(",") : delete n.fieldMask;
  return n;
}
class Gb extends go {
  constructor(e) {
    super(), this.apiClient = e;
  }
  /**
   * Creates an ephemeral auth token resource.
   *
   * @experimental
   *
   * @remarks
   * Ephemeral auth tokens is only supported in the Gemini Developer API.
   * It can be used for the session connection to the Live constrained API.
   * Support in v1alpha only.
   *
   * @param params - The parameters for the create request.
   * @return The created auth token.
   *
   * @example
   * ```ts
   * const ai = new GoogleGenAI({
   *     apiKey: token.name,
   *     httpOptions: { apiVersion: 'v1alpha' }  // Support in v1alpha only.
   * });
   *
   * // Case 1: If LiveEphemeralParameters is unset, unlock LiveConnectConfig
   * // when using the token in Live API sessions. Each session connection can
   * // use a different configuration.
   * const config: CreateAuthTokenConfig = {
   *     uses: 3,
   *     expireTime: '2025-05-01T00:00:00Z',
   * }
   * const token = await ai.tokens.create(config);
   *
   * // Case 2: If LiveEphemeralParameters is set, lock all fields in
   * // LiveConnectConfig when using the token in Live API sessions. For
   * // example, changing `outputAudioTranscription` in the Live API
   * // connection will be ignored by the API.
   * const config: CreateAuthTokenConfig =
   *     uses: 3,
   *     expireTime: '2025-05-01T00:00:00Z',
   *     LiveEphemeralParameters: {
   *        model: 'gemini-2.0-flash-001',
   *        config: {
   *           'responseModalities': ['AUDIO'],
   *           'systemInstruction': 'Always answer in English.',
   *        }
   *     }
   * }
   * const token = await ai.tokens.create(config);
   *
   * // Case 3: If LiveEphemeralParameters is set and lockAdditionalFields is
   * // set, lock LiveConnectConfig with set and additional fields (e.g.
   * // responseModalities, systemInstruction, temperature in this example) when
   * // using the token in Live API sessions.
   * const config: CreateAuthTokenConfig =
   *     uses: 3,
   *     expireTime: '2025-05-01T00:00:00Z',
   *     LiveEphemeralParameters: {
   *        model: 'gemini-2.0-flash-001',
   *        config: {
   *           'responseModalities': ['AUDIO'],
   *           'systemInstruction': 'Always answer in English.',
   *        }
   *     },
   *     lockAdditionalFields: ['temperature'],
   * }
   * const token = await ai.tokens.create(config);
   *
   * // Case 4: If LiveEphemeralParameters is set and lockAdditionalFields is
   * // empty array, lock LiveConnectConfig with set fields (e.g.
   * // responseModalities, systemInstruction in this example) when using the
   * // token in Live API sessions.
   * const config: CreateAuthTokenConfig =
   *     uses: 3,
   *     expireTime: '2025-05-01T00:00:00Z',
   *     LiveEphemeralParameters: {
   *        model: 'gemini-2.0-flash-001',
   *        config: {
   *           'responseModalities': ['AUDIO'],
   *           'systemInstruction': 'Always answer in English.',
   *        }
   *     },
   *     lockAdditionalFields: [],
   * }
   * const token = await ai.tokens.create(config);
   * ```
   */
  async create(e) {
    var t, r;
    let o, i = "", a = {};
    if (this.apiClient.isVertexAI())
      throw new Error("The client.tokens.create method is only supported by the Gemini Developer API.");
    {
      const s = kb(this.apiClient, e);
      i = Q("auth_tokens", s._url), a = s._query, delete s.config, delete s._url, delete s._query;
      const u = Vb(s, e.config);
      return o = this.apiClient.request({
        path: i,
        queryParams: a,
        body: JSON.stringify(u),
        httpMethod: "POST",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((l) => l.json()), o.then((l) => l);
    }
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function Wb(n, e) {
  const t = {}, r = h(n, ["name"]);
  return r != null && m(t, ["_url", "name"], r), t;
}
function Hb(n, e) {
  const t = {}, r = h(n, ["name"]);
  return r != null && m(t, ["_url", "name"], r), t;
}
function $b(n, e, t) {
  const r = {};
  if (h(n, ["validationDataset"]) !== void 0)
    throw new Error("validationDataset parameter is not supported in Gemini API.");
  const o = h(n, [
    "tunedModelDisplayName"
  ]);
  if (e !== void 0 && o != null && m(e, ["displayName"], o), h(n, ["description"]) !== void 0)
    throw new Error("description parameter is not supported in Gemini API.");
  const i = h(n, ["epochCount"]);
  e !== void 0 && i != null && m(e, ["tuningTask", "hyperparameters", "epochCount"], i);
  const a = h(n, [
    "learningRateMultiplier"
  ]);
  if (a != null && m(r, ["tuningTask", "hyperparameters", "learningRateMultiplier"], a), h(n, ["exportLastCheckpointOnly"]) !== void 0)
    throw new Error("exportLastCheckpointOnly parameter is not supported in Gemini API.");
  if (h(n, ["preTunedModelCheckpointId"]) !== void 0)
    throw new Error("preTunedModelCheckpointId parameter is not supported in Gemini API.");
  if (h(n, ["adapterSize"]) !== void 0)
    throw new Error("adapterSize parameter is not supported in Gemini API.");
  const s = h(n, ["batchSize"]);
  e !== void 0 && s != null && m(e, ["tuningTask", "hyperparameters", "batchSize"], s);
  const u = h(n, ["learningRate"]);
  if (e !== void 0 && u != null && m(e, ["tuningTask", "hyperparameters", "learningRate"], u), h(n, ["labels"]) !== void 0)
    throw new Error("labels parameter is not supported in Gemini API.");
  if (h(n, ["beta"]) !== void 0)
    throw new Error("beta parameter is not supported in Gemini API.");
  return r;
}
function qb(n, e, t) {
  const r = {};
  let o = h(t, [
    "config",
    "method"
  ]);
  if (o === void 0 && (o = "SUPERVISED_FINE_TUNING"), o === "SUPERVISED_FINE_TUNING") {
    const p = h(n, [
      "validationDataset"
    ]);
    e !== void 0 && p != null && m(e, ["supervisedTuningSpec"], Bh(p));
  } else if (o === "PREFERENCE_TUNING") {
    const p = h(n, [
      "validationDataset"
    ]);
    e !== void 0 && p != null && m(e, ["preferenceOptimizationSpec"], Bh(p));
  }
  const i = h(n, [
    "tunedModelDisplayName"
  ]);
  e !== void 0 && i != null && m(e, ["tunedModelDisplayName"], i);
  const a = h(n, ["description"]);
  e !== void 0 && a != null && m(e, ["description"], a);
  let s = h(t, [
    "config",
    "method"
  ]);
  if (s === void 0 && (s = "SUPERVISED_FINE_TUNING"), s === "SUPERVISED_FINE_TUNING") {
    const p = h(n, ["epochCount"]);
    e !== void 0 && p != null && m(e, ["supervisedTuningSpec", "hyperParameters", "epochCount"], p);
  } else if (s === "PREFERENCE_TUNING") {
    const p = h(n, ["epochCount"]);
    e !== void 0 && p != null && m(e, ["preferenceOptimizationSpec", "hyperParameters", "epochCount"], p);
  }
  let u = h(t, [
    "config",
    "method"
  ]);
  if (u === void 0 && (u = "SUPERVISED_FINE_TUNING"), u === "SUPERVISED_FINE_TUNING") {
    const p = h(n, [
      "learningRateMultiplier"
    ]);
    e !== void 0 && p != null && m(e, ["supervisedTuningSpec", "hyperParameters", "learningRateMultiplier"], p);
  } else if (u === "PREFERENCE_TUNING") {
    const p = h(n, [
      "learningRateMultiplier"
    ]);
    e !== void 0 && p != null && m(e, [
      "preferenceOptimizationSpec",
      "hyperParameters",
      "learningRateMultiplier"
    ], p);
  }
  let l = h(t, ["config", "method"]);
  if (l === void 0 && (l = "SUPERVISED_FINE_TUNING"), l === "SUPERVISED_FINE_TUNING") {
    const p = h(n, [
      "exportLastCheckpointOnly"
    ]);
    e !== void 0 && p != null && m(e, ["supervisedTuningSpec", "exportLastCheckpointOnly"], p);
  } else if (l === "PREFERENCE_TUNING") {
    const p = h(n, [
      "exportLastCheckpointOnly"
    ]);
    e !== void 0 && p != null && m(e, ["preferenceOptimizationSpec", "exportLastCheckpointOnly"], p);
  }
  let c = h(t, [
    "config",
    "method"
  ]);
  if (c === void 0 && (c = "SUPERVISED_FINE_TUNING"), c === "SUPERVISED_FINE_TUNING") {
    const p = h(n, ["adapterSize"]);
    e !== void 0 && p != null && m(e, ["supervisedTuningSpec", "hyperParameters", "adapterSize"], p);
  } else if (c === "PREFERENCE_TUNING") {
    const p = h(n, ["adapterSize"]);
    e !== void 0 && p != null && m(e, ["preferenceOptimizationSpec", "hyperParameters", "adapterSize"], p);
  }
  if (h(n, ["batchSize"]) !== void 0)
    throw new Error("batchSize parameter is not supported in Vertex AI.");
  if (h(n, ["learningRate"]) !== void 0)
    throw new Error("learningRate parameter is not supported in Vertex AI.");
  const f = h(n, ["labels"]);
  e !== void 0 && f != null && m(e, ["labels"], f);
  const d = h(n, ["beta"]);
  return e !== void 0 && d != null && m(e, ["preferenceOptimizationSpec", "hyperParameters", "beta"], d), r;
}
function zb(n, e) {
  const t = {}, r = h(n, ["baseModel"]);
  r != null && m(t, ["baseModel"], r);
  const o = h(n, [
    "preTunedModel"
  ]);
  o != null && m(t, ["preTunedModel"], o);
  const i = h(n, [
    "trainingDataset"
  ]);
  i != null && rE(i);
  const a = h(n, ["config"]);
  return a != null && $b(a, t), t;
}
function Kb(n, e) {
  const t = {}, r = h(n, ["baseModel"]);
  r != null && m(t, ["baseModel"], r);
  const o = h(n, [
    "preTunedModel"
  ]);
  o != null && m(t, ["preTunedModel"], o);
  const i = h(n, [
    "trainingDataset"
  ]);
  i != null && oE(i, t, e);
  const a = h(n, ["config"]);
  return a != null && qb(a, t, e), t;
}
function Jb(n, e) {
  const t = {}, r = h(n, ["name"]);
  return r != null && m(t, ["_url", "name"], r), t;
}
function Xb(n, e) {
  const t = {}, r = h(n, ["name"]);
  return r != null && m(t, ["_url", "name"], r), t;
}
function Yb(n, e, t) {
  const r = {}, o = h(n, ["pageSize"]);
  e !== void 0 && o != null && m(e, ["_query", "pageSize"], o);
  const i = h(n, ["pageToken"]);
  e !== void 0 && i != null && m(e, ["_query", "pageToken"], i);
  const a = h(n, ["filter"]);
  return e !== void 0 && a != null && m(e, ["_query", "filter"], a), r;
}
function Qb(n, e, t) {
  const r = {}, o = h(n, ["pageSize"]);
  e !== void 0 && o != null && m(e, ["_query", "pageSize"], o);
  const i = h(n, ["pageToken"]);
  e !== void 0 && i != null && m(e, ["_query", "pageToken"], i);
  const a = h(n, ["filter"]);
  return e !== void 0 && a != null && m(e, ["_query", "filter"], a), r;
}
function Zb(n, e) {
  const t = {}, r = h(n, ["config"]);
  return r != null && Yb(r, t), t;
}
function jb(n, e) {
  const t = {}, r = h(n, ["config"]);
  return r != null && Qb(r, t), t;
}
function eE(n, e) {
  const t = {}, r = h(n, [
    "sdkHttpResponse"
  ]);
  r != null && m(t, ["sdkHttpResponse"], r);
  const o = h(n, [
    "nextPageToken"
  ]);
  o != null && m(t, ["nextPageToken"], o);
  const i = h(n, ["tunedModels"]);
  if (i != null) {
    let a = i;
    Array.isArray(a) && (a = a.map((s) => xv(s))), m(t, ["tuningJobs"], a);
  }
  return t;
}
function tE(n, e) {
  const t = {}, r = h(n, [
    "sdkHttpResponse"
  ]);
  r != null && m(t, ["sdkHttpResponse"], r);
  const o = h(n, [
    "nextPageToken"
  ]);
  o != null && m(t, ["nextPageToken"], o);
  const i = h(n, ["tuningJobs"]);
  if (i != null) {
    let a = i;
    Array.isArray(a) && (a = a.map((s) => yl(s))), m(t, ["tuningJobs"], a);
  }
  return t;
}
function nE(n, e) {
  const t = {}, r = h(n, ["name"]);
  r != null && m(t, ["model"], r);
  const o = h(n, ["name"]);
  return o != null && m(t, ["endpoint"], o), t;
}
function rE(n, e) {
  const t = {};
  if (h(n, ["gcsUri"]) !== void 0)
    throw new Error("gcsUri parameter is not supported in Gemini API.");
  if (h(n, ["vertexDatasetResource"]) !== void 0)
    throw new Error("vertexDatasetResource parameter is not supported in Gemini API.");
  const r = h(n, ["examples"]);
  if (r != null) {
    let o = r;
    Array.isArray(o) && (o = o.map((i) => i)), m(t, ["examples", "examples"], o);
  }
  return t;
}
function oE(n, e, t) {
  const r = {};
  let o = h(t, [
    "config",
    "method"
  ]);
  if (o === void 0 && (o = "SUPERVISED_FINE_TUNING"), o === "SUPERVISED_FINE_TUNING") {
    const a = h(n, ["gcsUri"]);
    e !== void 0 && a != null && m(e, ["supervisedTuningSpec", "trainingDatasetUri"], a);
  } else if (o === "PREFERENCE_TUNING") {
    const a = h(n, ["gcsUri"]);
    e !== void 0 && a != null && m(e, ["preferenceOptimizationSpec", "trainingDatasetUri"], a);
  }
  let i = h(t, [
    "config",
    "method"
  ]);
  if (i === void 0 && (i = "SUPERVISED_FINE_TUNING"), i === "SUPERVISED_FINE_TUNING") {
    const a = h(n, [
      "vertexDatasetResource"
    ]);
    e !== void 0 && a != null && m(e, ["supervisedTuningSpec", "trainingDatasetUri"], a);
  } else if (i === "PREFERENCE_TUNING") {
    const a = h(n, [
      "vertexDatasetResource"
    ]);
    e !== void 0 && a != null && m(e, ["preferenceOptimizationSpec", "trainingDatasetUri"], a);
  }
  if (h(n, ["examples"]) !== void 0)
    throw new Error("examples parameter is not supported in Vertex AI.");
  return r;
}
function xv(n, e) {
  const t = {}, r = h(n, [
    "sdkHttpResponse"
  ]);
  r != null && m(t, ["sdkHttpResponse"], r);
  const o = h(n, ["name"]);
  o != null && m(t, ["name"], o);
  const i = h(n, ["state"]);
  i != null && m(t, ["state"], ev(i));
  const a = h(n, ["createTime"]);
  a != null && m(t, ["createTime"], a);
  const s = h(n, [
    "tuningTask",
    "startTime"
  ]);
  s != null && m(t, ["startTime"], s);
  const u = h(n, [
    "tuningTask",
    "completeTime"
  ]);
  u != null && m(t, ["endTime"], u);
  const l = h(n, ["updateTime"]);
  l != null && m(t, ["updateTime"], l);
  const c = h(n, ["description"]);
  c != null && m(t, ["description"], c);
  const f = h(n, ["baseModel"]);
  f != null && m(t, ["baseModel"], f);
  const d = h(n, ["_self"]);
  return d != null && m(t, ["tunedModel"], nE(d)), t;
}
function yl(n, e) {
  const t = {}, r = h(n, [
    "sdkHttpResponse"
  ]);
  r != null && m(t, ["sdkHttpResponse"], r);
  const o = h(n, ["name"]);
  o != null && m(t, ["name"], o);
  const i = h(n, ["state"]);
  i != null && m(t, ["state"], ev(i));
  const a = h(n, ["createTime"]);
  a != null && m(t, ["createTime"], a);
  const s = h(n, ["startTime"]);
  s != null && m(t, ["startTime"], s);
  const u = h(n, ["endTime"]);
  u != null && m(t, ["endTime"], u);
  const l = h(n, ["updateTime"]);
  l != null && m(t, ["updateTime"], l);
  const c = h(n, ["error"]);
  c != null && m(t, ["error"], c);
  const f = h(n, ["description"]);
  f != null && m(t, ["description"], f);
  const d = h(n, ["baseModel"]);
  d != null && m(t, ["baseModel"], d);
  const p = h(n, ["tunedModel"]);
  p != null && m(t, ["tunedModel"], p);
  const v = h(n, [
    "preTunedModel"
  ]);
  v != null && m(t, ["preTunedModel"], v);
  const g = h(n, [
    "supervisedTuningSpec"
  ]);
  g != null && m(t, ["supervisedTuningSpec"], g);
  const y = h(n, [
    "preferenceOptimizationSpec"
  ]);
  y != null && m(t, ["preferenceOptimizationSpec"], y);
  const x = h(n, [
    "tuningDataStats"
  ]);
  x != null && m(t, ["tuningDataStats"], x);
  const w = h(n, [
    "encryptionSpec"
  ]);
  w != null && m(t, ["encryptionSpec"], w);
  const b = h(n, [
    "partnerModelTuningSpec"
  ]);
  b != null && m(t, ["partnerModelTuningSpec"], b);
  const _ = h(n, [
    "customBaseModel"
  ]);
  _ != null && m(t, ["customBaseModel"], _);
  const E = h(n, ["experiment"]);
  E != null && m(t, ["experiment"], E);
  const C = h(n, ["labels"]);
  C != null && m(t, ["labels"], C);
  const A = h(n, ["outputUri"]);
  A != null && m(t, ["outputUri"], A);
  const R = h(n, ["pipelineJob"]);
  R != null && m(t, ["pipelineJob"], R);
  const I = h(n, [
    "serviceAccount"
  ]);
  I != null && m(t, ["serviceAccount"], I);
  const S = h(n, [
    "tunedModelDisplayName"
  ]);
  S != null && m(t, ["tunedModelDisplayName"], S);
  const M = h(n, [
    "veoTuningSpec"
  ]);
  return M != null && m(t, ["veoTuningSpec"], M), t;
}
function iE(n, e) {
  const t = {}, r = h(n, [
    "sdkHttpResponse"
  ]);
  r != null && m(t, ["sdkHttpResponse"], r);
  const o = h(n, ["name"]);
  o != null && m(t, ["name"], o);
  const i = h(n, ["metadata"]);
  i != null && m(t, ["metadata"], i);
  const a = h(n, ["done"]);
  a != null && m(t, ["done"], a);
  const s = h(n, ["error"]);
  return s != null && m(t, ["error"], s), t;
}
function Bh(n, e) {
  const t = {}, r = h(n, ["gcsUri"]);
  r != null && m(t, ["validationDatasetUri"], r);
  const o = h(n, [
    "vertexDatasetResource"
  ]);
  return o != null && m(t, ["validationDatasetUri"], o), t;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class aE extends go {
  constructor(e) {
    super(), this.apiClient = e, this.get = async (t) => await this.getInternal(t), this.list = async (t = {}) => new oa(co.PAGED_ITEM_TUNING_JOBS, (r) => this.listInternal(r), await this.listInternal(t), t), this.tune = async (t) => {
      var r;
      if (this.apiClient.isVertexAI())
        if (t.baseModel.startsWith("projects/")) {
          const o = {
            tunedModelName: t.baseModel
          };
          !((r = t.config) === null || r === void 0) && r.preTunedModelCheckpointId && (o.checkpointId = t.config.preTunedModelCheckpointId);
          const i = Object.assign(Object.assign({}, t), { preTunedModel: o });
          return i.baseModel = void 0, await this.tuneInternal(i);
        } else {
          const o = Object.assign({}, t);
          return await this.tuneInternal(o);
        }
      else {
        const o = Object.assign({}, t), i = await this.tuneMldevInternal(o);
        let a = "";
        return i.metadata !== void 0 && i.metadata.tunedModel !== void 0 ? a = i.metadata.tunedModel : i.name !== void 0 && i.name.includes("/operations/") && (a = i.name.split("/operations/")[0]), {
          name: a,
          state: fl.JOB_STATE_QUEUED
        };
      }
    };
  }
  async getInternal(e) {
    var t, r, o, i;
    let a, s = "", u = {};
    if (this.apiClient.isVertexAI()) {
      const l = Xb(e);
      return s = Q("{name}", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "GET",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((c) => c.json().then((f) => {
        const d = f;
        return d.sdkHttpResponse = {
          headers: c.headers
        }, d;
      })), a.then((c) => yl(c));
    } else {
      const l = Jb(e);
      return s = Q("{name}", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "GET",
        httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
        abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal
      }).then((c) => c.json().then((f) => {
        const d = f;
        return d.sdkHttpResponse = {
          headers: c.headers
        }, d;
      })), a.then((c) => xv(c));
    }
  }
  async listInternal(e) {
    var t, r, o, i;
    let a, s = "", u = {};
    if (this.apiClient.isVertexAI()) {
      const l = jb(e);
      return s = Q("tuningJobs", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "GET",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((c) => c.json().then((f) => {
        const d = f;
        return d.sdkHttpResponse = {
          headers: c.headers
        }, d;
      })), a.then((c) => {
        const f = tE(c), d = new gh();
        return Object.assign(d, f), d;
      });
    } else {
      const l = Zb(e);
      return s = Q("tunedModels", l._url), u = l._query, delete l._url, delete l._query, a = this.apiClient.request({
        path: s,
        queryParams: u,
        body: JSON.stringify(l),
        httpMethod: "GET",
        httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
        abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal
      }).then((c) => c.json().then((f) => {
        const d = f;
        return d.sdkHttpResponse = {
          headers: c.headers
        }, d;
      })), a.then((c) => {
        const f = eE(c), d = new gh();
        return Object.assign(d, f), d;
      });
    }
  }
  /**
   * Cancels a tuning job.
   *
   * @param params - The parameters for the cancel request.
   * @return The empty response returned by the API.
   *
   * @example
   * ```ts
   * await ai.tunings.cancel({name: '...'}); // The server-generated resource name.
   * ```
   */
  async cancel(e) {
    var t, r, o, i;
    let a = "", s = {};
    if (this.apiClient.isVertexAI()) {
      const u = Hb(e);
      a = Q("{name}:cancel", u._url), s = u._query, delete u._url, delete u._query, await this.apiClient.request({
        path: a,
        queryParams: s,
        body: JSON.stringify(u),
        httpMethod: "POST",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      });
    } else {
      const u = Wb(e);
      a = Q("{name}:cancel", u._url), s = u._query, delete u._url, delete u._query, await this.apiClient.request({
        path: a,
        queryParams: s,
        body: JSON.stringify(u),
        httpMethod: "POST",
        httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
        abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal
      });
    }
  }
  async tuneInternal(e) {
    var t, r;
    let o, i = "", a = {};
    if (this.apiClient.isVertexAI()) {
      const s = Kb(e, e);
      return i = Q("tuningJobs", s._url), a = s._query, delete s._url, delete s._query, o = this.apiClient.request({
        path: i,
        queryParams: a,
        body: JSON.stringify(s),
        httpMethod: "POST",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((u) => u.json().then((l) => {
        const c = l;
        return c.sdkHttpResponse = {
          headers: u.headers
        }, c;
      })), o.then((u) => yl(u));
    } else
      throw new Error("This method is only supported by the Vertex AI.");
  }
  async tuneMldevInternal(e) {
    var t, r;
    let o, i = "", a = {};
    if (this.apiClient.isVertexAI())
      throw new Error("This method is only supported by the Gemini Developer API.");
    {
      const s = zb(e);
      return i = Q("tunedModels", s._url), a = s._query, delete s._url, delete s._query, o = this.apiClient.request({
        path: i,
        queryParams: a,
        body: JSON.stringify(s),
        httpMethod: "POST",
        httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
        abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal
      }).then((u) => u.json().then((l) => {
        const c = l;
        return c.sdkHttpResponse = {
          headers: u.headers
        }, c;
      })), o.then((u) => iE(u));
    }
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class sE {
  async download(e, t) {
    throw new Error("Download to file is not supported in the browser, please use a browser compliant download like an <a> tag.");
  }
}
const uE = 1024 * 1024 * 8, lE = 3, cE = 1e3, fE = 2, Eu = "x-goog-upload-status";
async function dE(n, e, t) {
  var r, o, i;
  let a = 0, s = 0, u = new dl(new Response()), l = "upload";
  for (a = n.size; s < a; ) {
    const f = Math.min(uE, a - s), d = n.slice(s, s + f);
    s + f >= a && (l += ", finalize");
    let p = 0, v = cE;
    for (; p < lE && (u = await t.request({
      path: "",
      body: d,
      httpMethod: "POST",
      httpOptions: {
        apiVersion: "",
        baseUrl: e,
        headers: {
          "X-Goog-Upload-Command": l,
          "X-Goog-Upload-Offset": String(s),
          "Content-Length": String(f)
        }
      }
    }), !(!((r = u == null ? void 0 : u.headers) === null || r === void 0) && r[Eu])); )
      p++, await pE(v), v = v * fE;
    if (s += f, ((o = u == null ? void 0 : u.headers) === null || o === void 0 ? void 0 : o[Eu]) !== "active")
      break;
    if (a <= s)
      throw new Error("All content has been uploaded, but the upload status is not finalized.");
  }
  const c = await (u == null ? void 0 : u.json());
  if (((i = u == null ? void 0 : u.headers) === null || i === void 0 ? void 0 : i[Eu]) !== "final")
    throw new Error("Failed to upload file: Upload status is not finalized.");
  return c.file;
}
async function hE(n) {
  return { size: n.size, type: n.type };
}
function pE(n) {
  return new Promise((e) => setTimeout(e, n));
}
class mE {
  async upload(e, t, r) {
    if (typeof e == "string")
      throw new Error("File path is not supported in browser uploader.");
    return await dE(e, t, r);
  }
  async stat(e) {
    if (typeof e == "string")
      throw new Error("File path is not supported in browser uploader.");
    return await hE(e);
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class vE {
  create(e, t, r) {
    return new gE(e, t, r);
  }
}
class gE {
  constructor(e, t, r) {
    this.url = e, this.headers = t, this.callbacks = r;
  }
  connect() {
    this.ws = new WebSocket(this.url), this.ws.onopen = this.callbacks.onopen, this.ws.onerror = this.callbacks.onerror, this.ws.onclose = this.callbacks.onclose, this.ws.onmessage = this.callbacks.onmessage;
  }
  send(e) {
    if (this.ws === void 0)
      throw new Error("WebSocket is not connected");
    this.ws.send(e);
  }
  close() {
    if (this.ws === void 0)
      throw new Error("WebSocket is not connected");
    this.ws.close();
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Oh = "x-goog-api-key";
class yE {
  constructor(e) {
    this.apiKey = e;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async addAuthHeaders(e, t) {
    if (e.get(Oh) === null) {
      if (this.apiKey.startsWith("auth_tokens/"))
        throw new Error("Ephemeral tokens are only supported by the live API.");
      if (!this.apiKey)
        throw new Error("API key is missing. Please provide a valid API key.");
      e.append(Oh, this.apiKey);
    }
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const xE = "gl-node/";
class wE {
  constructor(e) {
    var t;
    if (e.apiKey == null)
      throw new Error("An API Key must be set when running in a browser");
    if (e.project || e.location)
      throw new Error("Vertex AI project based authentication is not supported on browser runtimes. Please do not provide a project or location.");
    this.vertexai = (t = e.vertexai) !== null && t !== void 0 ? t : !1, this.apiKey = e.apiKey;
    const r = Uy(
      e.httpOptions,
      e.vertexai,
      /*vertexBaseUrlFromEnv*/
      void 0,
      /*geminiBaseUrlFromEnv*/
      void 0
    );
    r && (e.httpOptions ? e.httpOptions.baseUrl = r : e.httpOptions = { baseUrl: r }), this.apiVersion = e.apiVersion;
    const o = new yE(this.apiKey);
    this.apiClient = new ib({
      auth: o,
      apiVersion: this.apiVersion,
      apiKey: this.apiKey,
      vertexai: this.vertexai,
      httpOptions: e.httpOptions,
      userAgentExtra: xE + "web",
      uploader: new mE(),
      downloader: new sE()
    }), this.models = new Tb(this.apiClient), this.live = new yb(this.apiClient, o, new vE()), this.batches = new ox(this.apiClient), this.chats = new Lx(this.models, this.apiClient), this.caches = new Mx(this.apiClient), this.files = new zx(this.apiClient), this.operations = new Ib(this.apiClient), this.authTokens = new Gb(this.apiClient), this.tunings = new aE(this.apiClient);
  }
}
var jo = typeof self < "u" ? self : {};
function Zr() {
  throw Error("Invalid UTF8");
}
function Uh(n, e) {
  return e = String.fromCharCode.apply(null, e), n == null ? e : n + e;
}
let ya, Cu;
const _E = typeof TextDecoder < "u";
let bE;
const EE = typeof TextEncoder < "u";
function wv(n) {
  if (EE) n = (bE || (bE = new TextEncoder())).encode(n);
  else {
    let t = 0;
    const r = new Uint8Array(3 * n.length);
    for (let o = 0; o < n.length; o++) {
      var e = n.charCodeAt(o);
      if (e < 128) r[t++] = e;
      else {
        if (e < 2048) r[t++] = e >> 6 | 192;
        else {
          if (e >= 55296 && e <= 57343) {
            if (e <= 56319 && o < n.length) {
              const i = n.charCodeAt(++o);
              if (i >= 56320 && i <= 57343) {
                e = 1024 * (e - 55296) + i - 56320 + 65536, r[t++] = e >> 18 | 240, r[t++] = e >> 12 & 63 | 128, r[t++] = e >> 6 & 63 | 128, r[t++] = 63 & e | 128;
                continue;
              }
              o--;
            }
            e = 65533;
          }
          r[t++] = e >> 12 | 224, r[t++] = e >> 6 & 63 | 128;
        }
        r[t++] = 63 & e | 128;
      }
    }
    n = t === r.length ? r : r.subarray(0, t);
  }
  return n;
}
var mc, Ka;
e: {
  for (var Vh = ["CLOSURE_FLAGS"], Tu = jo, Iu = 0; Iu < Vh.length; Iu++) if ((Tu = Tu[Vh[Iu]]) == null) {
    Ka = null;
    break e;
  }
  Ka = Tu;
}
var qi, Gh = Ka && Ka[610401301];
mc = Gh != null && Gh;
const Wh = jo.navigator;
function xl(n) {
  return !!mc && !!qi && qi.brands.some(({ brand: e }) => e && e.indexOf(n) != -1);
}
function hn(n) {
  var e;
  return (e = jo.navigator) && (e = e.userAgent) || (e = ""), e.indexOf(n) != -1;
}
function Rr() {
  return !!mc && !!qi && qi.brands.length > 0;
}
function Su() {
  return Rr() ? xl("Chromium") : (hn("Chrome") || hn("CriOS")) && !(!Rr() && hn("Edge")) || hn("Silk");
}
function Is(n) {
  return Is[" "](n), n;
}
qi = Wh && Wh.userAgentData || null, Is[" "] = function() {
};
var CE = !Rr() && (hn("Trident") || hn("MSIE"));
!hn("Android") || Su(), Su(), hn("Safari") && (Su() || !Rr() && hn("Coast") || !Rr() && hn("Opera") || !Rr() && hn("Edge") || (Rr() ? xl("Microsoft Edge") : hn("Edg/")) || Rr() && xl("Opera"));
var _v = {}, Fi = null;
function TE(n) {
  const e = n.length;
  let t = 3 * e / 4;
  t % 3 ? t = Math.floor(t) : "=.".indexOf(n[e - 1]) != -1 && (t = "=.".indexOf(n[e - 2]) != -1 ? t - 2 : t - 1);
  const r = new Uint8Array(t);
  let o = 0;
  return function(i, a) {
    function s(l) {
      for (; u < i.length; ) {
        const c = i.charAt(u++), f = Fi[c];
        if (f != null) return f;
        if (!/^[\s\xa0]*$/.test(c)) throw Error("Unknown base64 encoding at char: " + c);
      }
      return l;
    }
    bv();
    let u = 0;
    for (; ; ) {
      const l = s(-1), c = s(0), f = s(64), d = s(64);
      if (d === 64 && l === -1) break;
      a(l << 2 | c >> 4), f != 64 && (a(c << 4 & 240 | f >> 2), d != 64 && a(f << 6 & 192 | d));
    }
  }(n, function(i) {
    r[o++] = i;
  }), o !== t ? r.subarray(0, o) : r;
}
function bv() {
  if (!Fi) {
    Fi = {};
    var n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), e = ["+/=", "+/", "-_=", "-_.", "-_"];
    for (let t = 0; t < 5; t++) {
      const r = n.concat(e[t].split(""));
      _v[t] = r;
      for (let o = 0; o < r.length; o++) {
        const i = r[o];
        Fi[i] === void 0 && (Fi[i] = o);
      }
    }
  }
}
var Ev = typeof Uint8Array < "u", Cv = !CE && typeof btoa == "function";
function Hh(n) {
  if (!Cv) {
    var e;
    e === void 0 && (e = 0), bv(), e = _v[e];
    var t = Array(Math.floor(n.length / 3)), r = e[64] || "";
    let u = 0, l = 0;
    for (; u < n.length - 2; u += 3) {
      var o = n[u], i = n[u + 1], a = n[u + 2], s = e[o >> 2];
      o = e[(3 & o) << 4 | i >> 4], i = e[(15 & i) << 2 | a >> 6], a = e[63 & a], t[l++] = s + o + i + a;
    }
    switch (s = 0, a = r, n.length - u) {
      case 2:
        a = e[(15 & (s = n[u + 1])) << 2] || r;
      case 1:
        n = n[u], t[l] = e[n >> 2] + e[(3 & n) << 4 | s >> 4] + a + r;
    }
    return t.join("");
  }
  for (e = "", t = 0, r = n.length - 10240; t < r; ) e += String.fromCharCode.apply(null, n.subarray(t, t += 10240));
  return e += String.fromCharCode.apply(null, t ? n.subarray(t) : n), btoa(e);
}
const $h = /[-_.]/g, IE = { "-": "+", _: "/", ".": "=" };
function SE(n) {
  return IE[n] || "";
}
function Tv(n) {
  if (!Cv) return TE(n);
  $h.test(n) && (n = n.replace($h, SE)), n = atob(n);
  const e = new Uint8Array(n.length);
  for (let t = 0; t < n.length; t++) e[t] = n.charCodeAt(t);
  return e;
}
function fo(n) {
  return Ev && n != null && n instanceof Uint8Array;
}
var ei = {};
function ho() {
  return AE || (AE = new dr(null, ei));
}
function vc(n) {
  Iv(ei);
  var e = n.g;
  return (e = e == null || fo(e) ? e : typeof e == "string" ? Tv(e) : null) == null ? e : n.g = e;
}
var dr = class {
  h() {
    return new Uint8Array(vc(this) || 0);
  }
  constructor(e, t) {
    if (Iv(t), this.g = e, e != null && e.length === 0) throw Error("ByteString should be constructed with non-empty values");
  }
};
let AE, RE;
function Iv(n) {
  if (n !== ei) throw Error("illegal external caller");
}
function Sv(n, e) {
  n.__closure__error__context__984382 || (n.__closure__error__context__984382 = {}), n.__closure__error__context__984382.severity = e;
}
function wl(n) {
  return Sv(n = Error(n), "warning"), n;
}
function gc(n) {
  if (n != null) {
    var e = RE ?? (RE = {}), t = e[n] || 0;
    t >= 5 || (e[n] = t + 1, Sv(n = Error(), "incident"), function(r) {
      jo.setTimeout(() => {
        throw r;
      }, 0);
    }(n));
  }
}
var Ss = typeof Symbol == "function" && typeof Symbol() == "symbol";
function gi(n, e, t = !1) {
  return typeof Symbol == "function" && typeof Symbol() == "symbol" ? t && Symbol.for && n ? Symbol.for(n) : n != null ? Symbol(n) : Symbol() : e;
}
var kE = gi("jas", void 0, !0), qh = gi(void 0, "0di"), Ri = gi(void 0, "1oa"), ti = gi(void 0, Symbol()), PE = gi(void 0, "0actk"), Av = gi(void 0, "8utk");
const ue = Ss ? kE : "Ea", Rv = { Ea: { value: 0, configurable: !0, writable: !0, enumerable: !1 } }, kv = Object.defineProperties;
function As(n, e) {
  Ss || ue in n || kv(n, Rv), n[ue] |= e;
}
function st(n, e) {
  Ss || ue in n || kv(n, Rv), n[ue] = e;
}
function yi(n) {
  return As(n, 34), n;
}
function NE(n, e) {
  st(e, -15615 & (0 | n));
}
function _l(n, e) {
  st(e, -15581 & (34 | n));
}
function Rs() {
  return typeof BigInt == "function";
}
function Wt(n) {
  return Array.prototype.slice.call(n);
}
var yc, ia = {};
function ks(n) {
  return n !== null && typeof n == "object" && !Array.isArray(n) && n.constructor === Object;
}
function xc(n, e) {
  if (n != null) {
    if (typeof n == "string") n = n ? new dr(n, ei) : ho();
    else if (n.constructor !== dr) if (fo(n)) n = n.length ? new dr(new Uint8Array(n), ei) : ho();
    else {
      if (!e) throw Error();
      n = void 0;
    }
  }
  return n;
}
const zh = [];
function zr(n) {
  if (2 & n) throw Error();
}
st(zh, 55), yc = Object.freeze(zh);
let Kh = class {
  constructor(e, t, r) {
    this.g = e, this.h = t, this.l = r;
  }
  next() {
    const e = this.g.next();
    return e.done || (e.value = this.h.call(this.l, e.value)), e;
  }
  [Symbol.iterator]() {
    return this;
  }
};
function wc(n) {
  return ti ? n[ti] : void 0;
}
var ME = Object.freeze({});
function Ps(n) {
  return n.Na = !0, n;
}
var DE = Ps((n) => typeof n == "number"), Jh = Ps((n) => typeof n == "string"), FE = Ps((n) => typeof n == "boolean"), Ns = typeof jo.BigInt == "function" && typeof jo.BigInt(0) == "bigint";
function Dr(n) {
  var e = n;
  if (Jh(e)) {
    if (!/^\s*(?:-?[1-9]\d*|0)?\s*$/.test(e)) throw Error(String(e));
  } else if (DE(e) && !Number.isSafeInteger(e)) throw Error(String(e));
  return Ns ? BigInt(n) : n = FE(n) ? n ? "1" : "0" : Jh(n) ? n.trim() || "0" : String(n);
}
var bl = Ps((n) => Ns ? n >= BE && n <= UE : n[0] === "-" ? Xh(n, LE) : Xh(n, OE));
const LE = Number.MIN_SAFE_INTEGER.toString(), BE = Ns ? BigInt(Number.MIN_SAFE_INTEGER) : void 0, OE = Number.MAX_SAFE_INTEGER.toString(), UE = Ns ? BigInt(Number.MAX_SAFE_INTEGER) : void 0;
function Xh(n, e) {
  if (n.length > e.length) return !1;
  if (n.length < e.length || n === e) return !0;
  for (let t = 0; t < n.length; t++) {
    const r = n[t], o = e[t];
    if (r > o) return !1;
    if (r < o) return !0;
  }
}
const VE = typeof Uint8Array.prototype.slice == "function";
let Pv, Le = 0, tt = 0;
function Yh(n) {
  const e = n >>> 0;
  Le = e, tt = (n - e) / 4294967296 >>> 0;
}
function po(n) {
  if (n < 0) {
    Yh(-n);
    const [e, t] = Cc(Le, tt);
    Le = e >>> 0, tt = t >>> 0;
  } else Yh(n);
}
function _c(n) {
  const e = Pv || (Pv = new DataView(new ArrayBuffer(8)));
  e.setFloat32(0, +n, !0), tt = 0, Le = e.getUint32(0, !0);
}
function bc(n, e) {
  const t = 4294967296 * e + (n >>> 0);
  return Number.isSafeInteger(t) ? t : zi(n, e);
}
function Ec(n, e) {
  const t = 2147483648 & e;
  return t && (e = ~e >>> 0, (n = 1 + ~n >>> 0) == 0 && (e = e + 1 >>> 0)), typeof (n = bc(n, e)) == "number" ? t ? -n : n : t ? "-" + n : n;
}
function zi(n, e) {
  if (n >>>= 0, (e >>>= 0) <= 2097151) var t = "" + (4294967296 * e + n);
  else Rs() ? t = "" + (BigInt(e) << BigInt(32) | BigInt(n)) : (n = (16777215 & n) + 6777216 * (t = 16777215 & (n >>> 24 | e << 8)) + 6710656 * (e = e >> 16 & 65535), t += 8147497 * e, e *= 2, n >= 1e7 && (t += n / 1e7 >>> 0, n %= 1e7), t >= 1e7 && (e += t / 1e7 >>> 0, t %= 1e7), t = e + Qh(t) + Qh(n));
  return t;
}
function Qh(n) {
  return n = String(n), "0000000".slice(n.length) + n;
}
function Nv() {
  var n = Le, e = tt;
  if (2147483648 & e) if (Rs()) n = "" + (BigInt(0 | e) << BigInt(32) | BigInt(n >>> 0));
  else {
    const [t, r] = Cc(n, e);
    n = "-" + zi(t, r);
  }
  else n = zi(n, e);
  return n;
}
function Ms(n) {
  if (n.length < 16) po(Number(n));
  else if (Rs()) n = BigInt(n), Le = Number(n & BigInt(4294967295)) >>> 0, tt = Number(n >> BigInt(32) & BigInt(4294967295));
  else {
    const e = +(n[0] === "-");
    tt = Le = 0;
    const t = n.length;
    for (let r = e, o = (t - e) % 6 + e; o <= t; r = o, o += 6) {
      const i = Number(n.slice(r, o));
      tt *= 1e6, Le = 1e6 * Le + i, Le >= 4294967296 && (tt += Math.trunc(Le / 4294967296), tt >>>= 0, Le >>>= 0);
    }
    if (e) {
      const [r, o] = Cc(Le, tt);
      Le = r, tt = o;
    }
  }
}
function Cc(n, e) {
  return e = ~e, n ? n = 1 + ~n : e += 1, [n, e];
}
const Ki = typeof BigInt == "function" ? BigInt.asIntN : void 0, GE = typeof BigInt == "function" ? BigInt.asUintN : void 0, Fr = Number.isSafeInteger, Ds = Number.isFinite, ni = Math.trunc, WE = Dr(0);
function Kr(n) {
  return n == null || typeof n == "number" ? n : n === "NaN" || n === "Infinity" || n === "-Infinity" ? Number(n) : void 0;
}
function Mv(n) {
  return n == null || typeof n == "boolean" ? n : typeof n == "number" ? !!n : void 0;
}
const HE = /^-?([1-9][0-9]*|0)(\.[0-9]+)?$/;
function Ji(n) {
  switch (typeof n) {
    case "bigint":
      return !0;
    case "number":
      return Ds(n);
    case "string":
      return HE.test(n);
    default:
      return !1;
  }
}
function xi(n) {
  if (n == null) return n;
  if (typeof n == "string" && n) n = +n;
  else if (typeof n != "number") return;
  return Ds(n) ? 0 | n : void 0;
}
function Dv(n) {
  if (n == null) return n;
  if (typeof n == "string" && n) n = +n;
  else if (typeof n != "number") return;
  return Ds(n) ? n >>> 0 : void 0;
}
function Zh(n) {
  if (n[0] === "-") return !1;
  const e = n.length;
  return e < 20 || e === 20 && Number(n.substring(0, 6)) < 184467;
}
function Fv(n) {
  const e = n.length;
  return n[0] === "-" ? e < 20 || e === 20 && Number(n.substring(0, 7)) > -922337 : e < 19 || e === 19 && Number(n.substring(0, 6)) < 922337;
}
function Lv(n) {
  return Fv(n) ? n : (Ms(n), Nv());
}
function Tc(n) {
  return n = ni(n), Fr(n) || (po(n), n = Ec(Le, tt)), n;
}
function Bv(n) {
  var e = ni(Number(n));
  return Fr(e) ? String(e) : ((e = n.indexOf(".")) !== -1 && (n = n.substring(0, e)), Lv(n));
}
function jh(n) {
  var e = ni(Number(n));
  return Fr(e) ? Dr(e) : ((e = n.indexOf(".")) !== -1 && (n = n.substring(0, e)), Rs() ? Dr(Ki(64, BigInt(n))) : Dr(Lv(n)));
}
function ep(n) {
  if (Fr(n)) n = Dr(Tc(n));
  else {
    if (n = ni(n), Fr(n)) n = String(n);
    else {
      const e = String(n);
      Fv(e) ? n = e : (po(n), n = Nv());
    }
    n = Dr(n);
  }
  return n;
}
function El(n) {
  return n == null ? n : typeof n == "bigint" ? (bl(n) ? n = Number(n) : (n = Ki(64, n), n = bl(n) ? Number(n) : String(n)), n) : Ji(n) ? typeof n == "number" ? Tc(n) : Bv(n) : void 0;
}
function $E(n) {
  if (n == null) return n;
  var e = typeof n;
  if (e === "bigint") return String(GE(64, n));
  if (Ji(n)) {
    if (e === "string") return e = ni(Number(n)), Fr(e) && e >= 0 ? n = String(e) : ((e = n.indexOf(".")) !== -1 && (n = n.substring(0, e)), Zh(n) || (Ms(n), n = zi(Le, tt))), n;
    if (e === "number") return (n = ni(n)) >= 0 && Fr(n) ? n : function(t) {
      if (t < 0) {
        po(t);
        var r = zi(Le, tt);
        return t = Number(r), Fr(t) ? t : r;
      }
      return Zh(r = String(t)) ? r : (po(t), bc(Le, tt));
    }(n);
  }
}
function Ov(n) {
  if (typeof n != "string") throw Error();
  return n;
}
function wi(n) {
  if (n != null && typeof n != "string") throw Error();
  return n;
}
function ri(n) {
  return n == null || typeof n == "string" ? n : void 0;
}
function Ic(n, e, t, r) {
  if (n != null && typeof n == "object" && n.W === ia) return n;
  if (!Array.isArray(n)) return t ? 2 & r ? ((n = e[qh]) || (yi((n = new e()).u), n = e[qh] = n), e = n) : e = new e() : e = void 0, e;
  let o = t = 0 | n[ue];
  return o === 0 && (o |= 32 & r), o |= 2 & r, o !== t && st(n, o), new e(n);
}
function qE(n, e, t) {
  if (e) e: {
    if (!Ji(e = n)) throw wl("int64");
    switch (typeof e) {
      case "string":
        e = jh(e);
        break e;
      case "bigint":
        e = Dr(Ki(64, e));
        break e;
      default:
        e = ep(e);
    }
  }
  else n = typeof (e = n), e = e == null ? e : n === "bigint" ? Dr(Ki(64, e)) : Ji(e) ? n === "string" ? jh(e) : ep(e) : void 0;
  return (n = e) == null ? t ? WE : void 0 : n;
}
function zE(n) {
  return n;
}
const KE = {};
let JE = function() {
  try {
    return Is(new class extends Map {
      constructor() {
        super();
      }
    }()), !1;
  } catch {
    return !0;
  }
}(), Au = class {
  constructor() {
    this.g = /* @__PURE__ */ new Map();
  }
  get(e) {
    return this.g.get(e);
  }
  set(e, t) {
    return this.g.set(e, t), this.size = this.g.size, this;
  }
  delete(e) {
    return e = this.g.delete(e), this.size = this.g.size, e;
  }
  clear() {
    this.g.clear(), this.size = this.g.size;
  }
  has(e) {
    return this.g.has(e);
  }
  entries() {
    return this.g.entries();
  }
  keys() {
    return this.g.keys();
  }
  values() {
    return this.g.values();
  }
  forEach(e, t) {
    return this.g.forEach(e, t);
  }
  [Symbol.iterator]() {
    return this.entries();
  }
};
const XE = JE ? (Object.setPrototypeOf(Au.prototype, Map.prototype), Object.defineProperties(Au.prototype, { size: { value: 0, configurable: !0, enumerable: !0, writable: !0 } }), Au) : class extends Map {
  constructor() {
    super();
  }
};
function tp(n) {
  return n;
}
function Ru(n) {
  if (2 & n.M) throw Error("Cannot mutate an immutable Map");
}
var Xn = class extends XE {
  constructor(e, t, r = tp, o = tp) {
    super();
    let i = 0 | e[ue];
    i |= 64, st(e, i), this.M = i, this.I = t, this.S = r, this.X = this.I ? YE : o;
    for (let a = 0; a < e.length; a++) {
      const s = e[a], u = r(s[0], !1, !0);
      let l = s[1];
      t ? l === void 0 && (l = null) : l = o(s[1], !1, !0, void 0, void 0, i), super.set(u, l);
    }
  }
  La() {
    var e = tC;
    if (this.size !== 0) return Array.from(super.entries(), (t) => (t[0] = e(t[0]), t[1] = e(t[1]), t));
  }
  da(e = QE) {
    const t = [], r = super.entries();
    for (var o; !(o = r.next()).done; ) (o = o.value)[0] = e(o[0]), o[1] = e(o[1]), t.push(o);
    return t;
  }
  clear() {
    Ru(this), super.clear();
  }
  delete(e) {
    return Ru(this), super.delete(this.S(e, !0, !1));
  }
  entries() {
    if (this.I) {
      var e = super.keys();
      e = new Kh(e, ZE, this);
    } else e = super.entries();
    return e;
  }
  values() {
    if (this.I) {
      var e = super.keys();
      e = new Kh(e, Xn.prototype.get, this);
    } else e = super.values();
    return e;
  }
  forEach(e, t) {
    this.I ? super.forEach((r, o, i) => {
      e.call(t, i.get(o), o, i);
    }) : super.forEach(e, t);
  }
  set(e, t) {
    return Ru(this), (e = this.S(e, !0, !1)) == null ? this : t == null ? (super.delete(e), this) : super.set(e, this.X(t, !0, !0, this.I, !1, this.M));
  }
  Ja(e) {
    const t = this.S(e[0], !1, !0);
    e = e[1], e = this.I ? e === void 0 ? null : e : this.X(e, !1, !0, void 0, !1, this.M), super.set(t, e);
  }
  has(e) {
    return super.has(this.S(e, !1, !1));
  }
  get(e) {
    e = this.S(e, !1, !1);
    const t = super.get(e);
    if (t !== void 0) {
      var r = this.I;
      return r ? ((r = this.X(t, !1, !0, r, this.pa, this.M)) !== t && super.set(e, r), r) : t;
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
};
function YE(n, e, t, r, o, i) {
  return n = Ic(n, r, t, i), o && (n = Bs(n)), n;
}
function QE(n) {
  return n;
}
function ZE(n) {
  return [n, this.get(n)];
}
let jE, Uv, Vv, eC;
function np() {
  return jE || (jE = new Xn(yi([]), void 0, void 0, void 0, KE));
}
function Cl(n, e, t, r, o) {
  if (n != null) {
    if (Array.isArray(n)) {
      const i = 0 | n[ue];
      return n.length === 0 && 1 & i ? void 0 : o && 2 & i ? n : Fs(n, e, t, r !== void 0, o);
    }
    return e(n, r);
  }
}
function Fs(n, e, t, r, o) {
  const i = r || t ? 0 | n[ue] : 0, a = r ? !!(32 & i) : void 0;
  let s = 0;
  const u = (r = Wt(n)).length;
  for (let v = 0; v < u; v++) {
    var l = r[v];
    if (v === u - 1 && ks(l)) {
      var c = e, f = t, d = a, p = o;
      let g;
      for (let y in l) {
        const x = Cl(l[y], c, f, d, p);
        x != null && ((g ?? (g = {}))[y] = x);
      }
      l = g;
    } else l = Cl(r[v], e, t, a, o);
    r[v] = l, l != null && (s = v + 1);
  }
  return s < u && (r.length = s), t && ((n = wc(n)) && (r[ti] = Wt(n)), t(i, r)), r;
}
function tC(n) {
  return Cl(n, Sc, void 0, void 0, !1);
}
function Sc(n) {
  switch (typeof n) {
    case "number":
      return Number.isFinite(n) ? n : "" + n;
    case "bigint":
      return bl(n) ? Number(n) : "" + n;
    case "boolean":
      return n ? 1 : 0;
    case "object":
      if (fo(n)) return fo(n) && gc(Av), Hh(n);
      if (n.W === ia) return Gv(n);
      if (n instanceof dr) {
        const e = n.g;
        return e == null ? "" : typeof e == "string" ? e : n.g = Hh(e);
      }
      return n instanceof Xn ? n.La() : void 0;
  }
  return n;
}
function Gv(n) {
  var e = n.u;
  n = Fs(e, Sc, void 0, void 0, !1);
  var t = 0 | e[ue];
  if ((e = n.length) && !(512 & t)) {
    var r = n[e - 1], o = !1;
    ks(r) ? (e--, o = !0) : r = void 0;
    var i = e - (t = 512 & t ? 0 : -1), a = (Uv ?? zE)(i, t, n, r);
    if (r && (n[e] = void 0), i < a && r) {
      for (var s in i = !0, r) {
        const u = +s;
        u <= a ? (n[o = u + t] = r[s], e = Math.max(o + 1, e), o = !1, delete r[s]) : i = !1;
      }
      i && (r = void 0);
    }
    for (i = e - 1; e > 0; i = e - 1) if ((s = n[i]) == null) e--, o = !0;
    else {
      if (!((i -= t) >= a)) break;
      (r ?? (r = {}))[i] = s, e--, o = !0;
    }
    o && (n.length = e), r && n.push(r);
  }
  return n;
}
function Lr(n, e, t) {
  return n = Wv(n, e[0], e[1], t ? 1 : 2), e !== Vv && t && As(n, 8192), n;
}
function Wv(n, e, t, r) {
  if (n == null) {
    var o = 96;
    t ? (n = [t], o |= 512) : n = [], e && (o = -16760833 & o | (1023 & e) << 14);
  } else {
    if (!Array.isArray(n)) throw Error("narr");
    if (8192 & (o = 0 | n[ue]) || !(64 & o) || 2 & o || gc(PE), 1024 & o) throw Error("farr");
    if (64 & o) return n;
    if (r === 1 || r === 2 || (o |= 64), t && (o |= 512, t !== n[0])) throw Error("mid");
    e: {
      var i = (t = n).length;
      if (i) {
        var a = i - 1;
        if (ks(r = t[a])) {
          if ((a -= e = 512 & (o |= 256) ? 0 : -1) >= 1024) throw Error("pvtlmt");
          for (var s in r) (i = +s) < a && (t[i + e] = r[s], delete r[s]);
          o = -16760833 & o | (1023 & a) << 14;
          break e;
        }
      }
      if (e) {
        if ((s = Math.max(e, i - (512 & o ? 0 : -1))) > 1024) throw Error("spvt");
        o = -16760833 & o | (1023 & s) << 14;
      }
    }
  }
  return st(n, o), n;
}
function Tl(n, e, t = _l) {
  if (n != null) {
    if (Ev && n instanceof Uint8Array) return e ? n : new Uint8Array(n);
    if (Array.isArray(n)) {
      var r = 0 | n[ue];
      return 2 & r ? n : (e && (e = r === 0 || !!(32 & r) && !(64 & r || !(16 & r))), e ? (st(n, 34 | r), 4 & r && Object.freeze(n), n) : Fs(n, Tl, 4 & r ? _l : t, !0, !0));
    }
    return n.W === ia ? n = 2 & (r = 0 | (t = n.u)[ue]) ? n : new n.constructor(Ls(t, r, !0)) : n instanceof Xn && !(2 & n.M) && (t = yi(n.da(Tl)), n = new Xn(t, n.I, n.S, n.X)), n;
  }
}
function Ls(n, e, t) {
  const r = t || 2 & e ? _l : NE, o = !!(32 & e);
  return n = function(i, a, s) {
    const u = Wt(i);
    var l = u.length;
    const c = 256 & a ? u[l - 1] : void 0;
    for (l += c ? -1 : 0, a = 512 & a ? 1 : 0; a < l; a++) u[a] = s(u[a]);
    if (c) {
      a = u[a] = {};
      for (const f in c) a[f] = s(c[f]);
    }
    return (i = wc(i)) && (u[ti] = Wt(i)), u;
  }(n, e, (i) => Tl(i, o, r)), As(n, 32 | (t ? 2 : 0)), n;
}
function Bs(n) {
  const e = n.u, t = 0 | e[ue];
  return 2 & t ? new n.constructor(Ls(e, t, !1)) : n;
}
function oi(n, e) {
  return yr(n = n.u, 0 | n[ue], e);
}
function yr(n, e, t) {
  if (t === -1) return null;
  const r = t + (512 & e ? 0 : -1), o = n.length - 1;
  return r >= o && 256 & e ? n[o][t] : r <= o ? n[r] : void 0;
}
function Be(n, e, t) {
  const r = n.u;
  let o = 0 | r[ue];
  return zr(o), Ye(r, o, e, t), n;
}
function Ye(n, e, t, r) {
  const o = 512 & e ? 0 : -1, i = t + o;
  var a = n.length - 1;
  return i >= a && 256 & e ? (n[a][t] = r, e) : i <= a ? (n[i] = r, e) : (r !== void 0 && (t >= (a = e >> 14 & 1023 || 536870912) ? r != null && (n[a + o] = { [t]: r }, st(n, e |= 256)) : n[i] = r), e);
}
function Ua(n, e) {
  let t = 0 | (n = n.u)[ue];
  const r = yr(n, t, e), o = Kr(r);
  return o != null && o !== r && Ye(n, t, e, o), o;
}
function Hv(n) {
  let e = 0 | (n = n.u)[ue];
  const t = yr(n, e, 1), r = xc(t, !0);
  return r != null && r !== t && Ye(n, e, 1, r), r;
}
function oo() {
  return ME === void 0 ? 2 : 4;
}
function io(n, e, t, r, o) {
  const i = n.u, a = 2 & (n = 0 | i[ue]) ? 1 : r;
  o = !!o;
  let s = 0 | (r = Ac(i, n, e))[ue];
  if (!(4 & s)) {
    4 & s && (r = Wt(r), s = hr(s, n), n = Ye(i, n, e, r));
    let u = 0, l = 0;
    for (; u < r.length; u++) {
      const c = t(r[u]);
      c != null && (r[l++] = c);
    }
    l < u && (r.length = l), s = Rc(s, n), t = -2049 & (20 | s), s = t &= -4097, st(r, s), 2 & s && Object.freeze(r);
  }
  return a === 1 || a === 4 && 32 & s ? fr(s) || (o = s, s |= 2, s !== o && st(r, s), Object.freeze(r)) : (a === 2 && fr(s) && (r = Wt(r), s = hr(s, n), s = Br(s, n, o), st(r, s), n = Ye(i, n, e, r)), fr(s) || (e = s, s = Br(s, n, o), s !== e && st(r, s))), r;
}
function Ac(n, e, t) {
  return n = yr(n, e, t), Array.isArray(n) ? n : yc;
}
function Rc(n, e) {
  return n === 0 && (n = hr(n, e)), 1 | n;
}
function fr(n) {
  return !!(2 & n) && !!(4 & n) || !!(1024 & n);
}
function $v(n) {
  n = Wt(n);
  for (let e = 0; e < n.length; e++) {
    const t = n[e] = Wt(n[e]);
    Array.isArray(t[1]) && (t[1] = yi(t[1]));
  }
  return n;
}
function Il(n, e, t, r) {
  let o = 0 | (n = n.u)[ue];
  zr(o), Ye(n, o, e, (r === "0" ? Number(t) === 0 : t === r) ? void 0 : t);
}
function _i(n, e, t, r) {
  zr(e);
  let o = Ac(n, e, t);
  const i = o !== yc;
  if (64 & e || !(8192 & e) || !i) {
    const a = i ? 0 | o[ue] : 0;
    let s = a;
    (!i || 2 & s || fr(s) || 4 & s && !(32 & s)) && (o = Wt(o), s = hr(s, e), e = Ye(n, e, t, o)), s = -13 & Rc(s, e), s = Br(r ? -17 & s : 16 | s, e, !0), s !== a && st(o, s);
  }
  return o;
}
function ku(n, e) {
  var t = Ng;
  return Pc(kc(n = n.u), n, 0 | n[ue], t) === e ? e : -1;
}
function kc(n) {
  if (Ss) return n[Ri] ?? (n[Ri] = /* @__PURE__ */ new Map());
  if (Ri in n) return n[Ri];
  const e = /* @__PURE__ */ new Map();
  return Object.defineProperty(n, Ri, { value: e }), e;
}
function qv(n, e, t, r) {
  const o = kc(n), i = Pc(o, n, e, t);
  return i !== r && (i && (e = Ye(n, e, i)), o.set(t, r)), e;
}
function Pc(n, e, t, r) {
  let o = n.get(r);
  if (o != null) return o;
  o = 0;
  for (let i = 0; i < r.length; i++) {
    const a = r[i];
    yr(e, t, a) != null && (o !== 0 && (t = Ye(e, t, o)), o = a);
  }
  return n.set(r, o), o;
}
function Nc(n, e, t) {
  let r = 0 | n[ue];
  const o = yr(n, r, t);
  let i;
  if (o != null && o.W === ia) return (e = Bs(o)) !== o && Ye(n, r, t, e), e.u;
  if (Array.isArray(o)) {
    const a = 0 | o[ue];
    i = 2 & a ? Lr(Ls(o, a, !1), e, !0) : 64 & a ? o : Lr(i, e, !0);
  } else i = Lr(void 0, e, !0);
  return i !== o && Ye(n, r, t, i), i;
}
function zv(n, e, t) {
  let r = 0 | (n = n.u)[ue];
  const o = yr(n, r, t);
  return (e = Ic(o, e, !1, r)) !== o && e != null && Ye(n, r, t, e), e;
}
function Se(n, e, t) {
  if ((e = zv(n, e, t)) == null) return e;
  let r = 0 | (n = n.u)[ue];
  if (!(2 & r)) {
    const o = Bs(e);
    o !== e && Ye(n, r, t, e = o);
  }
  return e;
}
function Kv(n, e, t, r, o, i, a) {
  n = n.u;
  var s = !!(2 & e);
  const u = s ? 1 : o;
  i = !!i, a && (a = !s);
  var l = 0 | (o = Ac(n, e, r))[ue];
  if (!(s = !!(4 & l))) {
    var c = o, f = e;
    const d = !!(2 & (l = Rc(l, e)));
    d && (f |= 2);
    let p = !d, v = !0, g = 0, y = 0;
    for (; g < c.length; g++) {
      const x = Ic(c[g], t, !1, f);
      if (x instanceof t) {
        if (!d) {
          const w = !!(2 & (0 | x.u[ue]));
          p && (p = !w), v && (v = w);
        }
        c[y++] = x;
      }
    }
    y < g && (c.length = y), l |= 4, l = v ? 16 | l : -17 & l, st(c, l = p ? 8 | l : -9 & l), d && Object.freeze(c);
  }
  if (a && !(8 & l || !o.length && (u === 1 || u === 4 && 32 & l))) {
    for (fr(l) && (o = Wt(o), l = hr(l, e), e = Ye(n, e, r, o)), t = o, a = l, c = 0; c < t.length; c++) (l = t[c]) !== (f = Bs(l)) && (t[c] = f);
    a |= 8, st(t, a = t.length ? -17 & a : 16 | a), l = a;
  }
  return u === 1 || u === 4 && 32 & l ? fr(l) || (e = l, (l |= !o.length || 16 & l && (!s || 32 & l) ? 2 : 1024) !== e && st(o, l), Object.freeze(o)) : (u === 2 && fr(l) && (st(o = Wt(o), l = Br(l = hr(l, e), e, i)), e = Ye(n, e, r, o)), fr(l) || (r = l, (l = Br(l, e, i)) !== r && st(o, l))), o;
}
function mr(n, e, t) {
  const r = 0 | n.u[ue];
  return Kv(n, r, e, t, oo(), !1, !(2 & r));
}
function le(n, e, t, r) {
  return r == null && (r = void 0), Be(n, t, r);
}
function Oi(n, e, t, r) {
  r == null && (r = void 0);
  e: {
    let o = 0 | (n = n.u)[ue];
    if (zr(o), r == null) {
      const i = kc(n);
      if (Pc(i, n, o, t) !== e) break e;
      i.set(t, 0);
    } else o = qv(n, o, t, e);
    Ye(n, o, e, r);
  }
}
function hr(n, e) {
  return -1025 & (n = 32 | (2 & e ? 2 | n : -3 & n));
}
function Br(n, e, t) {
  return 32 & e && t || (n &= -33), n;
}
function Os(n, e, t) {
  zr(0 | n.u[ue]), io(n, e, ri, 2, !0).push(Ov(t));
}
function Ja(n, e, t, r) {
  const o = 0 | n.u[ue];
  zr(o), n = Kv(n, o, t, e, 2, !0), r = r ?? new t(), n.push(r), n[ue] = 2 & (0 | r.u[ue]) ? -9 & n[ue] : -17 & n[ue];
}
function vn(n, e) {
  return xi(oi(n, e));
}
function xn(n, e) {
  return ri(oi(n, e));
}
function ot(n, e) {
  return Ua(n, e) ?? 0;
}
function Xi(n, e, t) {
  if (t != null && typeof t != "boolean") throw n = typeof t, Error(`Expected boolean but got ${n != "object" ? n : t ? Array.isArray(t) ? "array" : n : "null"}: ${t}`);
  Be(n, e, t);
}
function Yn(n, e, t) {
  if (t != null) {
    if (typeof t != "number" || !Ds(t)) throw wl("int32");
    t |= 0;
  }
  Be(n, e, t);
}
function ae(n, e, t) {
  if (t != null && typeof t != "number") throw Error(`Value of float/double field must be a number, found ${typeof t}: ${t}`);
  Be(n, e, t);
}
function Xa(n, e, t) {
  {
    const a = n.u;
    let s = 0 | a[ue];
    if (zr(s), t == null) Ye(a, s, e);
    else {
      var r = n = 0 | t[ue], o = fr(n), i = o || Object.isFrozen(t);
      for (o || (n = 0), i || (t = Wt(t), r = 0, n = Br(n = hr(n, s), s, !0), i = !1), n |= 21, o = 0; o < t.length; o++) {
        const u = t[o], l = Ov(u);
        Object.is(u, l) || (i && (t = Wt(t), r = 0, n = Br(n = hr(n, s), s, !0), i = !1), t[o] = l);
      }
      n !== r && (i && (t = Wt(t), n = Br(n = hr(n, s), s, !0)), st(t, n)), Ye(a, s, e, t);
    }
  }
}
function Jv(n, e) {
  return Error(`Invalid wire type: ${n} (at position ${e})`);
}
function Mc() {
  return Error("Failed to read varint, encoding is invalid.");
}
function Xv(n, e) {
  return Error(`Tried to read past the end of the data ${e} > ${n}`);
}
function Dc(n) {
  if (typeof n == "string") return { buffer: Tv(n), O: !1 };
  if (Array.isArray(n)) return { buffer: new Uint8Array(n), O: !1 };
  if (n.constructor === Uint8Array) return { buffer: n, O: !1 };
  if (n.constructor === ArrayBuffer) return { buffer: new Uint8Array(n), O: !1 };
  if (n.constructor === dr) return { buffer: vc(n) || new Uint8Array(0), O: !0 };
  if (n instanceof Uint8Array) return { buffer: new Uint8Array(n.buffer, n.byteOffset, n.byteLength), O: !1 };
  throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers");
}
function Fc(n, e) {
  let t, r = 0, o = 0, i = 0;
  const a = n.h;
  let s = n.g;
  do
    t = a[s++], r |= (127 & t) << i, i += 7;
  while (i < 32 && 128 & t);
  for (i > 32 && (o |= (127 & t) >> 4), i = 3; i < 32 && 128 & t; i += 7) t = a[s++], o |= (127 & t) << i;
  if (uo(n, s), t < 128) return e(r >>> 0, o >>> 0);
  throw Mc();
}
function Lc(n) {
  let e = 0, t = n.g;
  const r = t + 10, o = n.h;
  for (; t < r; ) {
    const i = o[t++];
    if (e |= i, (128 & i) == 0) return uo(n, t), !!(127 & e);
  }
  throw Mc();
}
function Gr(n) {
  const e = n.h;
  let t = n.g, r = e[t++], o = 127 & r;
  if (128 & r && (r = e[t++], o |= (127 & r) << 7, 128 & r && (r = e[t++], o |= (127 & r) << 14, 128 & r && (r = e[t++], o |= (127 & r) << 21, 128 & r && (r = e[t++], o |= r << 28, 128 & r && 128 & e[t++] && 128 & e[t++] && 128 & e[t++] && 128 & e[t++] && 128 & e[t++]))))) throw Mc();
  return uo(n, t), o;
}
function vr(n) {
  return Gr(n) >>> 0;
}
function Sl(n) {
  var e = n.h;
  const t = n.g, r = e[t], o = e[t + 1], i = e[t + 2];
  return e = e[t + 3], uo(n, n.g + 4), (r << 0 | o << 8 | i << 16 | e << 24) >>> 0;
}
function Al(n) {
  var e = Sl(n);
  n = 2 * (e >> 31) + 1;
  const t = e >>> 23 & 255;
  return e &= 8388607, t == 255 ? e ? NaN : n * (1 / 0) : t == 0 ? 1401298464324817e-60 * n * e : n * Math.pow(2, t - 150) * (e + 8388608);
}
function nC(n) {
  return Gr(n);
}
function Pu(n, e, { aa: t = !1 } = {}) {
  n.aa = t, e && (e = Dc(e), n.h = e.buffer, n.m = e.O, n.j = 0, n.l = n.h.length, n.g = n.j);
}
function uo(n, e) {
  if (n.g = e, e > n.l) throw Xv(n.l, e);
}
function Yv(n, e) {
  if (e < 0) throw Error(`Tried to read a negative byte length: ${e}`);
  const t = n.g, r = t + e;
  if (r > n.l) throw Xv(e, n.l - t);
  return n.g = r, t;
}
function Qv(n, e) {
  if (e == 0) return ho();
  var t = Yv(n, e);
  return n.aa && n.m ? t = n.h.subarray(t, t + e) : (n = n.h, t = t === (e = t + e) ? new Uint8Array(0) : VE ? n.slice(t, e) : new Uint8Array(n.subarray(t, e))), t.length == 0 ? ho() : new dr(t, ei);
}
Xn.prototype.toJSON = void 0;
var rp = [];
function Zv(n) {
  var e = n.g;
  if (e.g == e.l) return !1;
  n.l = n.g.g;
  var t = vr(n.g);
  if (e = t >>> 3, !((t &= 7) >= 0 && t <= 5)) throw Jv(t, n.l);
  if (e < 1) throw Error(`Invalid field number: ${e} (at position ${n.l})`);
  return n.m = e, n.h = t, !0;
}
function Va(n) {
  switch (n.h) {
    case 0:
      n.h != 0 ? Va(n) : Lc(n.g);
      break;
    case 1:
      uo(n = n.g, n.g + 8);
      break;
    case 2:
      if (n.h != 2) Va(n);
      else {
        var e = vr(n.g);
        uo(n = n.g, n.g + e);
      }
      break;
    case 5:
      uo(n = n.g, n.g + 4);
      break;
    case 3:
      for (e = n.m; ; ) {
        if (!Zv(n)) throw Error("Unmatched start-group tag: stream EOF");
        if (n.h == 4) {
          if (n.m != e) throw Error("Unmatched end-group tag");
          break;
        }
        Va(n);
      }
      break;
    default:
      throw Jv(n.h, n.l);
  }
}
function aa(n, e, t) {
  const r = n.g.l, o = vr(n.g), i = n.g.g + o;
  let a = i - r;
  if (a <= 0 && (n.g.l = i, t(e, n, void 0, void 0, void 0), a = i - n.g.g), a) throw Error(`Message parsing ended unexpectedly. Expected to read ${o} bytes, instead read ${o - a} bytes, either the data ended unexpectedly or the message misreported its own length`);
  return n.g.g = i, n.g.l = r, e;
}
function Bc(n) {
  var e = vr(n.g), t = Yv(n = n.g, e);
  if (n = n.h, _E) {
    var r, o = n;
    (r = Cu) || (r = Cu = new TextDecoder("utf-8", { fatal: !0 })), e = t + e, o = t === 0 && e === o.length ? o : o.subarray(t, e);
    try {
      var i = r.decode(o);
    } catch (s) {
      if (ya === void 0) {
        try {
          r.decode(new Uint8Array([128]));
        } catch {
        }
        try {
          r.decode(new Uint8Array([97])), ya = !0;
        } catch {
          ya = !1;
        }
      }
      throw !ya && (Cu = void 0), s;
    }
  } else {
    e = (i = t) + e, t = [];
    let s, u = null;
    for (; i < e; ) {
      var a = n[i++];
      a < 128 ? t.push(a) : a < 224 ? i >= e ? Zr() : (s = n[i++], a < 194 || (192 & s) != 128 ? (i--, Zr()) : t.push((31 & a) << 6 | 63 & s)) : a < 240 ? i >= e - 1 ? Zr() : (s = n[i++], (192 & s) != 128 || a === 224 && s < 160 || a === 237 && s >= 160 || (192 & (r = n[i++])) != 128 ? (i--, Zr()) : t.push((15 & a) << 12 | (63 & s) << 6 | 63 & r)) : a <= 244 ? i >= e - 2 ? Zr() : (s = n[i++], (192 & s) != 128 || s - 144 + (a << 28) >> 30 || (192 & (r = n[i++])) != 128 || (192 & (o = n[i++])) != 128 ? (i--, Zr()) : (a = (7 & a) << 18 | (63 & s) << 12 | (63 & r) << 6 | 63 & o, a -= 65536, t.push(55296 + (a >> 10 & 1023), 56320 + (1023 & a)))) : Zr(), t.length >= 8192 && (u = Uh(u, t), t.length = 0);
    }
    i = Uh(u, t);
  }
  return i;
}
function jv(n) {
  const e = vr(n.g);
  return Qv(n.g, e);
}
function Us(n, e, t) {
  var r = vr(n.g);
  for (r = n.g.g + r; n.g.g < r; ) t.push(e(n.g));
}
var xa = [];
function Sn(n, e, t) {
  e.g ? e.m(n, e.g, e.h, t) : e.m(n, e.h, t);
}
var te = class {
  constructor(e, t) {
    this.u = Wv(e, t);
  }
  toJSON() {
    try {
      var e = Gv(this);
    } finally {
      Uv = void 0;
    }
    return e;
  }
  l() {
    var e = OC;
    return e.g ? e.l(this, e.g, e.h) : e.l(this, e.h, e.defaultValue);
  }
  clone() {
    const e = this.u;
    return new this.constructor(Ls(e, 0 | e[ue], !1));
  }
  O() {
    return !!(2 & (0 | this.u[ue]));
  }
};
function op(n) {
  return n ? /^\d+$/.test(n) ? (Ms(n), new Rl(Le, tt)) : null : rC || (rC = new Rl(0, 0));
}
te.prototype.W = ia, te.prototype.toString = function() {
  return this.u.toString();
};
var Rl = class {
  constructor(e, t) {
    this.h = e >>> 0, this.g = t >>> 0;
  }
};
let rC;
function ip(n) {
  return n ? /^-?\d+$/.test(n) ? (Ms(n), new kl(Le, tt)) : null : oC || (oC = new kl(0, 0));
}
var kl = class {
  constructor(e, t) {
    this.h = e >>> 0, this.g = t >>> 0;
  }
};
let oC;
function Wo(n, e, t) {
  for (; t > 0 || e > 127; ) n.g.push(127 & e | 128), e = (e >>> 7 | t << 25) >>> 0, t >>>= 7;
  n.g.push(e);
}
function bi(n, e) {
  for (; e > 127; ) n.g.push(127 & e | 128), e >>>= 7;
  n.g.push(e);
}
function Vs(n, e) {
  if (e >= 0) bi(n, e);
  else {
    for (let t = 0; t < 9; t++) n.g.push(127 & e | 128), e >>= 7;
    n.g.push(1);
  }
}
function Yi(n, e) {
  n.g.push(e >>> 0 & 255), n.g.push(e >>> 8 & 255), n.g.push(e >>> 16 & 255), n.g.push(e >>> 24 & 255);
}
function ii(n, e) {
  e.length !== 0 && (n.l.push(e), n.h += e.length);
}
function sn(n, e, t) {
  bi(n.g, 8 * e + t);
}
function Oc(n, e) {
  return sn(n, e, 2), e = n.g.end(), ii(n, e), e.push(n.h), e;
}
function Uc(n, e) {
  var t = e.pop();
  for (t = n.h + n.g.length() - t; t > 127; ) e.push(127 & t | 128), t >>>= 7, n.h++;
  e.push(t), n.h++;
}
function Gs(n, e, t) {
  sn(n, e, 2), bi(n.g, t.length), ii(n, n.g.end()), ii(n, t);
}
function Ya(n, e, t, r) {
  t != null && (e = Oc(n, e), r(t, n), Uc(n, e));
}
function An() {
  const n = class {
    constructor() {
      throw Error();
    }
  };
  return Object.setPrototypeOf(n, n.prototype), n;
}
var Vc = An(), eg = An(), Gc = An(), Wc = An(), tg = An(), ng = An(), Hc = An(), rg = An(), og = An(), Ei = class {
  constructor(e, t, r) {
    this.g = e, this.h = t, e = Vc, this.l = !!e && r === e || !1;
  }
};
function Ws(n, e) {
  return new Ei(n, e, Vc);
}
function ig(n, e, t, r, o) {
  Ya(n, t, lg(e, r), o);
}
const iC = Ws(function(n, e, t, r, o) {
  return n.h === 2 && (aa(n, Nc(e, r, t), o), !0);
}, ig), aC = Ws(function(n, e, t, r, o) {
  return n.h === 2 && (aa(n, Nc(e, r, t), o), !0);
}, ig);
var Hs = Symbol(), $c = Symbol(), ap = Symbol(), sp = Symbol();
let ag, sg;
function yo(n, e, t, r) {
  var o = r[n];
  if (o) return o;
  (o = {}).Ma = r, o.T = function(f) {
    switch (typeof f) {
      case "boolean":
        return Vv || (Vv = [0, void 0, !0]);
      case "number":
        return f > 0 ? void 0 : f === 0 ? eC || (eC = [0, void 0]) : [-f, void 0];
      case "string":
        return [0, f];
      case "object":
        return f;
    }
  }(r[0]);
  var i = r[1];
  let a = 1;
  i && i.constructor === Object && (o.ga = i, typeof (i = r[++a]) == "function" && (o.la = !0, ag ?? (ag = i), sg ?? (sg = r[a + 1]), i = r[a += 2]));
  const s = {};
  for (; i && Array.isArray(i) && i.length && typeof i[0] == "number" && i[0] > 0; ) {
    for (var u = 0; u < i.length; u++) s[i[u]] = i;
    i = r[++a];
  }
  for (u = 1; i !== void 0; ) {
    let f;
    typeof i == "number" && (u += i, i = r[++a]);
    var l = void 0;
    if (i instanceof Ei ? f = i : (f = iC, a--), f == null ? void 0 : f.l) {
      i = r[++a], l = r;
      var c = a;
      typeof i == "function" && (i = i(), l[c] = i), l = i;
    }
    for (c = u + 1, typeof (i = r[++a]) == "number" && i < 0 && (c -= i, i = r[++a]); u < c; u++) {
      const d = s[u];
      l ? t(o, u, f, l, d) : e(o, u, f, d);
    }
  }
  return r[n] = o;
}
function ug(n) {
  return Array.isArray(n) ? n[0] instanceof Ei ? n : [aC, n] : [n, void 0];
}
function lg(n, e) {
  return n instanceof te ? n.u : Array.isArray(n) ? Lr(n, e, !1) : void 0;
}
function qc(n, e, t, r) {
  const o = t.g;
  n[e] = r ? (i, a, s) => o(i, a, s, r) : o;
}
function zc(n, e, t, r, o) {
  const i = t.g;
  let a, s;
  n[e] = (u, l, c) => i(u, l, c, s || (s = yo($c, qc, zc, r).T), a || (a = Kc(r)), o);
}
function Kc(n) {
  let e = n[ap];
  if (e != null) return e;
  const t = yo($c, qc, zc, n);
  return e = t.la ? (r, o) => ag(r, o, t) : (r, o) => {
    const i = 0 | r[ue];
    for (; Zv(o) && o.h != 4; ) {
      var a = o.m, s = t[a];
      if (s == null) {
        var u = t.ga;
        u && (u = u[a]) && (u = sC(u)) != null && (s = t[a] = u);
      }
      s != null && s(o, r, a) || (a = (s = o).l, Va(s), s.fa ? s = void 0 : (u = s.g.g - a, s.g.g = a, s = Qv(s.g, u)), a = r, s && ((u = a[ti]) ? u.push(s) : a[ti] = [s]));
    }
    return 8192 & i && yi(r), !0;
  }, n[ap] = e;
}
function sC(n) {
  const e = (n = ug(n))[0].g;
  if (n = n[1]) {
    const t = Kc(n), r = yo($c, qc, zc, n).T;
    return (o, i, a) => e(o, i, a, r, t);
  }
  return e;
}
function $s(n, e, t) {
  n[e] = t.h;
}
function qs(n, e, t, r) {
  let o, i;
  const a = t.h;
  n[e] = (s, u, l) => a(s, u, l, i || (i = yo(Hs, $s, qs, r).T), o || (o = cg(r)));
}
function cg(n) {
  let e = n[sp];
  if (!e) {
    const t = yo(Hs, $s, qs, n);
    e = (r, o) => fg(r, o, t), n[sp] = e;
  }
  return e;
}
function fg(n, e, t) {
  (function(r, o, i) {
    const a = 512 & o ? 0 : -1, s = r.length, u = s + ((o = 64 & o ? 256 & o : !!s && ks(r[s - 1])) ? -1 : 0);
    for (let l = 0; l < u; l++) i(l - a, r[l]);
    if (o) {
      r = r[s - 1];
      for (const l in r) !isNaN(l) && i(+l, r[l]);
    }
  })(n, 0 | n[ue] | (t.T[1] ? 512 : 0), (r, o) => {
    if (o != null) {
      var i = function(a, s) {
        var u = a[s];
        if (u) return u;
        if ((u = a.ga) && (u = u[s])) {
          var l = (u = ug(u))[0].h;
          if (u = u[1]) {
            const c = cg(u), f = yo(Hs, $s, qs, u).T;
            u = a.la ? sg(f, c) : (d, p, v) => l(d, p, v, f, c);
          } else u = l;
          return a[s] = u;
        }
      }(t, r);
      i && i(e, o, r);
    }
  }), (n = wc(n)) && function(r, o) {
    ii(r, r.g.end());
    for (let i = 0; i < o.length; i++) ii(r, vc(o[i]) || new Uint8Array(0));
  }(e, n);
}
function Ci(n, e) {
  if (Array.isArray(e)) {
    var t = 0 | e[ue];
    if (4 & t) return e;
    for (var r = 0, o = 0; r < e.length; r++) {
      const i = n(e[r]);
      i != null && (e[o++] = i);
    }
    return o < r && (e.length = o), st(e, -6145 & (5 | t)), 2 & t && Object.freeze(e), e;
  }
}
function Lt(n, e, t) {
  return new Ei(n, e, t);
}
function Ti(n, e, t) {
  return new Ei(n, e, t);
}
function Bt(n, e, t) {
  Ye(n, 0 | n[ue], e, t);
}
var uC = Ws(function(n, e, t, r, o) {
  return n.h === 2 && (n = aa(n, Lr([void 0, void 0], r, !0), o), zr(r = 0 | e[ue]), (o = yr(e, r, t)) instanceof Xn ? 2 & o.M ? ((o = o.da()).push(n), Ye(e, r, t, o)) : o.Ja(n) : Array.isArray(o) ? (2 & (0 | o[ue]) && Ye(e, r, t, o = $v(o)), o.push(n)) : Ye(e, r, t, [n]), !0);
}, function(n, e, t, r, o) {
  if (e instanceof Xn) e.forEach((i, a) => {
    Ya(n, t, Lr([a, i], r, !1), o);
  });
  else if (Array.isArray(e)) for (let i = 0; i < e.length; i++) {
    const a = e[i];
    Array.isArray(a) && Ya(n, t, Lr(a, r, !1), o);
  }
});
function dg(n, e, t) {
  if (e = function(r) {
    if (r == null) return r;
    const o = typeof r;
    if (o === "bigint") return String(Ki(64, r));
    if (Ji(r)) {
      if (o === "string") return Bv(r);
      if (o === "number") return Tc(r);
    }
  }(e), e != null && (typeof e == "string" && ip(e), e != null))
    switch (sn(n, t, 0), typeof e) {
      case "number":
        n = n.g, po(e), Wo(n, Le, tt);
        break;
      case "bigint":
        t = BigInt.asUintN(64, e), t = new kl(Number(t & BigInt(4294967295)), Number(t >> BigInt(32))), Wo(n.g, t.h, t.g);
        break;
      default:
        t = ip(e), Wo(n.g, t.h, t.g);
    }
}
function hg(n, e, t) {
  (e = xi(e)) != null && e != null && (sn(n, t, 0), Vs(n.g, e));
}
function pg(n, e, t) {
  (e = Mv(e)) != null && (sn(n, t, 0), n.g.g.push(e ? 1 : 0));
}
function mg(n, e, t) {
  (e = ri(e)) != null && Gs(n, t, wv(e));
}
function vg(n, e, t, r, o) {
  Ya(n, t, lg(e, r), o);
}
function gg(n, e, t) {
  e == null || typeof e == "string" || e instanceof dr || (fo(e) ? fo(e) && gc(Av) : e = void 0), e != null && Gs(n, t, Dc(e).buffer);
}
function yg(n, e, t) {
  return (n.h === 5 || n.h === 2) && (e = _i(e, 0 | e[ue], t, !1), n.h == 2 ? Us(n, Al, e) : e.push(Al(n.g)), !0);
}
var ur = Lt(function(n, e, t) {
  if (n.h !== 1) return !1;
  var r = n.g;
  n = Sl(r);
  const o = Sl(r);
  r = 2 * (o >> 31) + 1;
  const i = o >>> 20 & 2047;
  return n = 4294967296 * (1048575 & o) + n, Bt(e, t, i == 2047 ? n ? NaN : r * (1 / 0) : i == 0 ? 5e-324 * r * n : r * Math.pow(2, i - 1075) * (n + 4503599627370496)), !0;
}, function(n, e, t) {
  (e = Kr(e)) != null && (sn(n, t, 1), n = n.g, (t = Pv || (Pv = new DataView(new ArrayBuffer(8)))).setFloat64(0, +e, !0), Le = t.getUint32(0, !0), tt = t.getUint32(4, !0), Yi(n, Le), Yi(n, tt));
}, An()), lt = Lt(function(n, e, t) {
  return n.h === 5 && (Bt(e, t, Al(n.g)), !0);
}, function(n, e, t) {
  (e = Kr(e)) != null && (sn(n, t, 5), n = n.g, _c(e), Yi(n, Le));
}, Hc), lC = Ti(yg, function(n, e, t) {
  if ((e = Ci(Kr, e)) != null) for (let a = 0; a < e.length; a++) {
    var r = n, o = t, i = e[a];
    i != null && (sn(r, o, 5), r = r.g, _c(i), Yi(r, Le));
  }
}, Hc), Jc = Ti(yg, function(n, e, t) {
  if ((e = Ci(Kr, e)) != null && e.length) {
    sn(n, t, 2), bi(n.g, 4 * e.length);
    for (let r = 0; r < e.length; r++) t = n.g, _c(e[r]), Yi(t, Le);
  }
}, Hc), Wr = Lt(function(n, e, t) {
  return n.h === 0 && (Bt(e, t, Fc(n.g, Ec)), !0);
}, dg, ng), Nu = Lt(function(n, e, t) {
  return n.h === 0 && (Bt(e, t, (n = Fc(n.g, Ec)) === 0 ? void 0 : n), !0);
}, dg, ng), cC = Lt(function(n, e, t) {
  return n.h === 0 && (Bt(e, t, Fc(n.g, bc)), !0);
}, function(n, e, t) {
  if ((e = $E(e)) != null && (typeof e == "string" && op(e), e != null))
    switch (sn(n, t, 0), typeof e) {
      case "number":
        n = n.g, po(e), Wo(n, Le, tt);
        break;
      case "bigint":
        t = BigInt.asUintN(64, e), t = new Rl(Number(t & BigInt(4294967295)), Number(t >> BigInt(32))), Wo(n.g, t.h, t.g);
        break;
      default:
        t = op(e), Wo(n.g, t.h, t.g);
    }
}, An()), nt = Lt(function(n, e, t) {
  return n.h === 0 && (Bt(e, t, Gr(n.g)), !0);
}, hg, Wc), zs = Ti(function(n, e, t) {
  return (n.h === 0 || n.h === 2) && (e = _i(e, 0 | e[ue], t, !1), n.h == 2 ? Us(n, Gr, e) : e.push(Gr(n.g)), !0);
}, function(n, e, t) {
  if ((e = Ci(xi, e)) != null && e.length) {
    t = Oc(n, t);
    for (let r = 0; r < e.length; r++) Vs(n.g, e[r]);
    Uc(n, t);
  }
}, Wc), Oo = Lt(function(n, e, t) {
  return n.h === 0 && (Bt(e, t, (n = Gr(n.g)) === 0 ? void 0 : n), !0);
}, hg, Wc), $e = Lt(function(n, e, t) {
  return n.h === 0 && (Bt(e, t, Lc(n.g)), !0);
}, pg, eg), Ho = Lt(function(n, e, t) {
  return n.h === 0 && (Bt(e, t, (n = Lc(n.g)) === !1 ? void 0 : n), !0);
}, pg, eg), It = Ti(function(n, e, t) {
  return n.h === 2 && (n = Bc(n), _i(e, 0 | e[ue], t, !1).push(n), !0);
}, function(n, e, t) {
  if ((e = Ci(ri, e)) != null) for (let a = 0; a < e.length; a++) {
    var r = n, o = t, i = e[a];
    i != null && Gs(r, o, wv(i));
  }
}, Gc), kr = Lt(function(n, e, t) {
  return n.h === 2 && (Bt(e, t, (n = Bc(n)) === "" ? void 0 : n), !0);
}, mg, Gc), Me = Lt(function(n, e, t) {
  return n.h === 2 && (Bt(e, t, Bc(n)), !0);
}, mg, Gc), dt = function(n, e, t = Vc) {
  return new Ei(n, e, t);
}(function(n, e, t, r, o) {
  return n.h === 2 && (r = Lr(void 0, r, !0), _i(e, 0 | e[ue], t, !0).push(r), aa(n, r, o), !0);
}, function(n, e, t, r, o) {
  if (Array.isArray(e)) for (let i = 0; i < e.length; i++) vg(n, e[i], t, r, o);
}), Ne = Ws(function(n, e, t, r, o, i) {
  return n.h === 2 && (qv(e, 0 | e[ue], i, t), aa(n, e = Nc(e, r, t), o), !0);
}, vg), xg = Lt(function(n, e, t) {
  return n.h === 2 && (Bt(e, t, jv(n)), !0);
}, gg, rg), fC = Ti(function(n, e, t) {
  return (n.h === 0 || n.h === 2) && (e = _i(e, 0 | e[ue], t, !1), n.h == 2 ? Us(n, vr, e) : e.push(vr(n.g)), !0);
}, function(n, e, t) {
  if ((e = Ci(Dv, e)) != null) for (let a = 0; a < e.length; a++) {
    var r = n, o = t, i = e[a];
    i != null && (sn(r, o, 0), bi(r.g, i));
  }
}, tg), dC = Lt(function(n, e, t) {
  return n.h === 0 && (Bt(e, t, (n = vr(n.g)) === 0 ? void 0 : n), !0);
}, function(n, e, t) {
  (e = Dv(e)) != null && e != null && (sn(n, t, 0), bi(n.g, e));
}, tg), rn = Lt(function(n, e, t) {
  return n.h === 0 && (Bt(e, t, Gr(n.g)), !0);
}, function(n, e, t) {
  (e = xi(e)) != null && (e = parseInt(e, 10), sn(n, t, 0), Vs(n.g, e));
}, og);
let hC = class {
  constructor(e, t) {
    this.h = e, this.g = t, this.l = Se, this.m = le, this.defaultValue = void 0;
  }
  register() {
    Is(this);
  }
};
function Rn(n, e) {
  return new hC(n, e);
}
function Jr(n, e) {
  return (t, r) => {
    if (xa.length) {
      const i = xa.pop();
      i.o(r), Pu(i.g, t, r), t = i;
    } else t = new class {
      constructor(i, a) {
        if (rp.length) {
          const s = rp.pop();
          Pu(s, i, a), i = s;
        } else i = new class {
          constructor(s, u) {
            this.h = null, this.m = !1, this.g = this.l = this.j = 0, Pu(this, s, u);
          }
          clear() {
            this.h = null, this.m = !1, this.g = this.l = this.j = 0, this.aa = !1;
          }
        }(i, a);
        this.g = i, this.l = this.g.g, this.h = this.m = -1, this.o(a);
      }
      o({ fa: i = !1 } = {}) {
        this.fa = i;
      }
    }(t, r);
    try {
      const i = new n(), a = i.u;
      Kc(e)(a, t);
      var o = i;
    } finally {
      t.g.clear(), t.m = -1, t.h = -1, xa.length < 100 && xa.push(t);
    }
    return o;
  };
}
function Ks(n) {
  return function() {
    const e = new class {
      constructor() {
        this.l = [], this.h = 0, this.g = new class {
          constructor() {
            this.g = [];
          }
          length() {
            return this.g.length;
          }
          end() {
            const a = this.g;
            return this.g = [], a;
          }
        }();
      }
    }();
    fg(this.u, e, yo(Hs, $s, qs, n)), ii(e, e.g.end());
    const t = new Uint8Array(e.h), r = e.l, o = r.length;
    let i = 0;
    for (let a = 0; a < o; a++) {
      const s = r[a];
      t.set(s, i), i += s.length;
    }
    return e.l = [t], t;
  };
}
var up = class extends te {
  constructor(e) {
    super(e);
  }
}, lp = [0, kr, Lt(function(n, e, t) {
  return n.h === 2 && (Bt(e, t, (n = jv(n)) === ho() ? void 0 : n), !0);
}, function(n, e, t) {
  if (e != null) {
    if (e instanceof te) {
      const r = e.Oa;
      return void (r && (e = r(e), e != null && Gs(n, t, Dc(e).buffer)));
    }
    if (Array.isArray(e)) return;
  }
  gg(n, e, t);
}, rg)];
let Mu, cp = globalThis.trustedTypes;
function fp(n) {
  Mu === void 0 && (Mu = function() {
    let t = null;
    if (!cp) return t;
    try {
      const r = (o) => o;
      t = cp.createPolicy("goog#html", { createHTML: r, createScript: r, createScriptURL: r });
    } catch {
    }
    return t;
  }());
  var e = Mu;
  return new class {
    constructor(t) {
      this.g = t;
    }
    toString() {
      return this.g + "";
    }
  }(e ? e.createScriptURL(n) : n);
}
function pC(n, ...e) {
  if (e.length === 0) return fp(n[0]);
  let t = n[0];
  for (let r = 0; r < e.length; r++) t += encodeURIComponent(e[r]) + n[r + 1];
  return fp(t);
}
var wg = [0, nt, rn, $e, -1, zs, rn, -1], mC = class extends te {
  constructor(e) {
    super(e);
  }
}, _g = [0, $e, Me, $e, rn, -1, Ti(function(n, e, t) {
  return (n.h === 0 || n.h === 2) && (e = _i(e, 0 | e[ue], t, !1), n.h == 2 ? Us(n, nC, e) : e.push(Gr(n.g)), !0);
}, function(n, e, t) {
  if ((e = Ci(xi, e)) != null && e.length) {
    t = Oc(n, t);
    for (let r = 0; r < e.length; r++) Vs(n.g, e[r]);
    Uc(n, t);
  }
}, og), Me, -1, [0, $e, -1], rn, $e, -1], bg = [0, Me, -2], dp = class extends te {
  constructor(e) {
    super(e);
  }
}, Eg = [0], Cg = [0, nt, $e, 1, $e, -3], an = class extends te {
  constructor(e) {
    super(e, 2);
  }
}, ct = {};
ct[336783863] = [0, Me, $e, -1, nt, [0, [1, 2, 3, 4, 5, 6, 7, 8, 9], Ne, Eg, Ne, _g, Ne, bg, Ne, Cg, Ne, wg, Ne, [0, Me, -2], Ne, [0, Me, rn], Ne, [0, rn, Me, -1], Ne, [0, rn, -1]], [0, Me], $e, [0, [1, 3], [2, 4], Ne, [0, zs], -1, Ne, [0, It], -1, dt, [0, Me, -1]], Me];
var hp = [0, Nu, -1, Ho, -3, Nu, zs, kr, Oo, Nu, -1, Ho, Oo, Ho, -2, kr];
function un(n, e) {
  Il(n, 2, wi(e), "");
}
function Oe(n, e) {
  Os(n, 3, e);
}
function Ee(n, e) {
  Os(n, 4, e);
}
var Ft = class extends te {
  constructor(e) {
    super(e, 500);
  }
  o(e) {
    return le(this, 0, 7, e);
  }
}, Ui = [-1, {}], pp = [0, Me, 1, Ui], mp = [0, Me, It, Ui];
function ln(n, e) {
  Ja(n, 1, Ft, e);
}
function We(n, e) {
  Os(n, 10, e);
}
function Ae(n, e) {
  Os(n, 15, e);
}
var Kt = class extends te {
  constructor(e) {
    super(e, 500);
  }
  o(e) {
    return le(this, 0, 1001, e);
  }
}, Tg = [-500, dt, [-500, kr, -1, It, -3, [-2, ct, $e], dt, lp, Oo, -1, pp, mp, dt, [0, kr, Ho], kr, hp, Oo, It, 987, It], 4, dt, [-500, Me, -1, [-1, {}], 998, Me], dt, [-500, Me, It, -1, [-2, {}, $e], 997, It, -1], Oo, dt, [-500, Me, It, Ui, 998, It], It, Oo, pp, mp, dt, [0, kr, -1, Ui], It, -2, hp, kr, -1, Ho, [0, Ho, dC], 978, Ui, dt, lp];
Kt.prototype.g = Ks(Tg);
var vC = Jr(Kt, Tg), gC = class extends te {
  constructor(e) {
    super(e);
  }
}, Ig = class extends te {
  constructor(e) {
    super(e);
  }
  g() {
    return mr(this, gC, 1);
  }
}, Sg = [0, dt, [0, nt, lt, Me, -1]], Js = Jr(Ig, Sg), yC = class extends te {
  constructor(e) {
    super(e);
  }
}, xC = class extends te {
  constructor(e) {
    super(e);
  }
}, Du = class extends te {
  constructor(e) {
    super(e);
  }
  h() {
    return Se(this, yC, 2);
  }
  g() {
    return mr(this, xC, 5);
  }
}, Ag = Jr(class extends te {
  constructor(n) {
    super(n);
  }
}, [0, It, zs, Jc, [0, rn, [0, nt, -3], [0, lt, -3], [0, nt, -1, [0, dt, [0, nt, -2]]], dt, [0, lt, -1, Me, lt]], Me, -1, Wr, dt, [0, nt, lt], It, Wr]), Rg = class extends te {
  constructor(e) {
    super(e);
  }
}, $o = Jr(class extends te {
  constructor(n) {
    super(n);
  }
}, [0, dt, [0, lt, -4]]), kg = class extends te {
  constructor(e) {
    super(e);
  }
}, sa = Jr(class extends te {
  constructor(n) {
    super(n);
  }
}, [0, dt, [0, lt, -4]]), wC = class extends te {
  constructor(e) {
    super(e);
  }
}, _C = [0, nt, -1, Jc, rn], Pg = class extends te {
  constructor(e) {
    super(e);
  }
};
Pg.prototype.g = Ks([0, lt, -4, Wr]);
var bC = class extends te {
  constructor(e) {
    super(e);
  }
}, EC = Jr(class extends te {
  constructor(n) {
    super(n);
  }
}, [0, dt, [0, 1, nt, Me, Sg], Wr]), vp = class extends te {
  constructor(e) {
    super(e);
  }
}, CC = class extends te {
  constructor(e) {
    super(e);
  }
  ma() {
    const e = Hv(this);
    return e ?? ho();
  }
}, TC = class extends te {
  constructor(e) {
    super(e);
  }
}, Ng = [1, 2], IC = Jr(class extends te {
  constructor(n) {
    super(n);
  }
}, [0, dt, [0, Ng, Ne, [0, Jc], Ne, [0, xg], nt, Me], Wr]), Xc = class extends te {
  constructor(e) {
    super(e);
  }
}, Mg = [0, Me, nt, lt, It, -1], gp = class extends te {
  constructor(e) {
    super(e);
  }
}, SC = [0, $e, -1], yp = class extends te {
  constructor(e) {
    super(e);
  }
}, Ga = [1, 2, 3, 4, 5], Qa = class extends te {
  constructor(e) {
    super(e);
  }
  g() {
    return Hv(this) != null;
  }
  h() {
    return xn(this, 2) != null;
  }
}, qe = class extends te {
  constructor(e) {
    super(e);
  }
  g() {
    return Mv(oi(this, 2)) ?? !1;
  }
}, Dg = [0, xg, Me, [0, nt, Wr, -1], [0, cC, Wr]], at = [0, Dg, $e, [0, Ga, Ne, Cg, Ne, _g, Ne, wg, Ne, Eg, Ne, bg], rn], Xs = class extends te {
  constructor(e) {
    super(e);
  }
}, Yc = [0, at, lt, -1, nt], AC = Rn(502141897, Xs);
ct[502141897] = Yc;
var RC = Jr(class extends te {
  constructor(n) {
    super(n);
  }
}, [0, [0, rn, -1, lC, fC], _C]), Fg = class extends te {
  constructor(e) {
    super(e);
  }
}, Lg = class extends te {
  constructor(e) {
    super(e);
  }
}, Qc = [0, at, lt, [0, at], $e], Bg = [0, at, Yc, Qc, lt, [0, [0, Dg]]], kC = Rn(508968150, Lg);
ct[508968150] = Bg, ct[508968149] = Qc;
var Og = class extends te {
  constructor(e) {
    super(e);
  }
}, PC = Rn(513916220, Og);
ct[513916220] = [0, at, Bg, nt];
var So = class extends te {
  constructor(e) {
    super(e);
  }
  h() {
    return Se(this, Xc, 2);
  }
  g() {
    Be(this, 2);
  }
}, Ug = [0, at, Mg];
ct[478825465] = Ug;
var NC = class extends te {
  constructor(e) {
    super(e);
  }
}, Vg = class extends te {
  constructor(e) {
    super(e);
  }
}, Zc = class extends te {
  constructor(e) {
    super(e);
  }
}, jc = class extends te {
  constructor(e) {
    super(e);
  }
}, Gg = class extends te {
  constructor(e) {
    super(e);
  }
}, xp = [0, at, [0, at], Ug, -1], Wg = [0, at, lt, nt], ef = [0, at, lt], Hg = [0, at, Wg, ef, lt], MC = Rn(479097054, Gg);
ct[479097054] = [0, at, Hg, xp], ct[463370452] = xp, ct[464864288] = Wg;
var DC = Rn(462713202, jc);
ct[462713202] = Hg, ct[474472470] = ef;
var FC = class extends te {
  constructor(e) {
    super(e);
  }
}, $g = class extends te {
  constructor(e) {
    super(e);
  }
}, qg = class extends te {
  constructor(e) {
    super(e);
  }
}, zg = class extends te {
  constructor(e) {
    super(e);
  }
}, tf = [0, at, lt, -1, nt], Pl = [0, at, lt, $e];
zg.prototype.g = Ks([0, at, ef, [0, at], Yc, Qc, tf, Pl]);
var Kg = class extends te {
  constructor(n) {
    super(n);
  }
}, LC = Rn(456383383, Kg);
ct[456383383] = [0, at, Mg];
var Jg = class extends te {
  constructor(n) {
    super(n);
  }
}, BC = Rn(476348187, Jg);
ct[476348187] = [0, at, SC];
var Xg = class extends te {
  constructor(e) {
    super(e);
  }
}, wp = class extends te {
  constructor(n) {
    super(n);
  }
}, Yg = [0, rn, -1], OC = Rn(458105876, class extends te {
  constructor(n) {
    super(n);
  }
  g() {
    var n = this.u;
    const e = 0 | n[ue], t = 2 & e;
    return n = function(r, o, i) {
      var a = wp;
      const s = 2 & o;
      let u = !1;
      if (i == null) {
        if (s) return np();
        i = [];
      } else if (i.constructor === Xn) {
        if (!(2 & i.M) || s) return i;
        i = i.da();
      } else Array.isArray(i) ? u = !!(2 & (0 | i[ue])) : i = [];
      if (s) {
        if (!i.length) return np();
        u || (u = !0, yi(i));
      } else u && (u = !1, i = $v(i));
      return u || (64 & (0 | i[ue]) ? i[ue] &= -33 : 32 & o && As(i, 32)), Ye(r, o, 2, a = new Xn(i, a, qE, void 0)), a;
    }(n, e, yr(n, e, 2)), !t && wp && (n.pa = !0), n;
  }
});
ct[458105876] = [0, Yg, uC, [!0, Wr, [0, Me, -1, It]]];
var nf = class extends te {
  constructor(e) {
    super(e);
  }
}, Qg = Rn(458105758, nf);
ct[458105758] = [0, at, Me, Yg];
var Zg = class extends te {
  constructor(e) {
    super(e);
  }
}, UC = Rn(443442058, Zg);
ct[443442058] = [0, at, Me, nt, lt, It, -1, $e, lt], ct[514774813] = tf;
var jg = class extends te {
  constructor(e) {
    super(e);
  }
}, VC = Rn(516587230, jg);
function Nl(n, e) {
  return e = e ? e.clone() : new Xc(), n.displayNamesLocale !== void 0 ? Be(e, 1, wi(n.displayNamesLocale)) : n.displayNamesLocale === void 0 && Be(e, 1), n.maxResults !== void 0 ? Yn(e, 2, n.maxResults) : "maxResults" in n && Be(e, 2), n.scoreThreshold !== void 0 ? ae(e, 3, n.scoreThreshold) : "scoreThreshold" in n && Be(e, 3), n.categoryAllowlist !== void 0 ? Xa(e, 4, n.categoryAllowlist) : "categoryAllowlist" in n && Be(e, 4), n.categoryDenylist !== void 0 ? Xa(e, 5, n.categoryDenylist) : "categoryDenylist" in n && Be(e, 5), e;
}
function rf(n, e = -1, t = "") {
  return { categories: n.map((r) => ({ index: vn(r, 1) ?? 0 ?? -1, score: ot(r, 2) ?? 0, categoryName: xn(r, 3) ?? "" ?? "", displayName: xn(r, 4) ?? "" ?? "" })), headIndex: e, headName: t };
}
function e1(n) {
  var a, s;
  var e = io(n, 3, Kr, oo()), t = io(n, 2, xi, oo()), r = io(n, 1, ri, oo()), o = io(n, 9, ri, oo());
  const i = { categories: [], keypoints: [] };
  for (let u = 0; u < e.length; u++) i.categories.push({ score: e[u], index: t[u] ?? -1, categoryName: r[u] ?? "", displayName: o[u] ?? "" });
  if ((e = (a = Se(n, Du, 4)) == null ? void 0 : a.h()) && (i.boundingBox = { originX: vn(e, 1) ?? 0, originY: vn(e, 2) ?? 0, width: vn(e, 3) ?? 0, height: vn(e, 4) ?? 0, angle: 0 }), (s = Se(n, Du, 4)) == null ? void 0 : s.g().length) for (const u of Se(n, Du, 4).g()) i.keypoints.push({ x: Ua(u, 1) ?? 0, y: Ua(u, 2) ?? 0, score: Ua(u, 4) ?? 0, label: xn(u, 3) ?? "" });
  return i;
}
function Ys(n) {
  const e = [];
  for (const t of mr(n, kg, 1)) e.push({ x: ot(t, 1) ?? 0, y: ot(t, 2) ?? 0, z: ot(t, 3) ?? 0, visibility: ot(t, 4) ?? 0 });
  return e;
}
function Vi(n) {
  const e = [];
  for (const t of mr(n, Rg, 1)) e.push({ x: ot(t, 1) ?? 0, y: ot(t, 2) ?? 0, z: ot(t, 3) ?? 0, visibility: ot(t, 4) ?? 0 });
  return e;
}
function _p(n) {
  return Array.from(n, (e) => e > 127 ? e - 256 : e);
}
function bp(n, e) {
  if (n.length !== e.length) throw Error(`Cannot compute cosine similarity between embeddings of different sizes (${n.length} vs. ${e.length}).`);
  let t = 0, r = 0, o = 0;
  for (let i = 0; i < n.length; i++) t += n[i] * e[i], r += n[i] * n[i], o += e[i] * e[i];
  if (r <= 0 || o <= 0) throw Error("Cannot compute cosine similarity on embedding with 0 norm.");
  return t / Math.sqrt(r * o);
}
let wa;
ct[516587230] = [0, at, tf, Pl, lt], ct[518928384] = Pl;
const GC = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11]);
async function t1() {
  if (wa === void 0) try {
    await WebAssembly.instantiate(GC), wa = !0;
  } catch {
    wa = !1;
  }
  return wa;
}
async function ki(n, e = pC``) {
  const t = await t1() ? "wasm_internal" : "wasm_nosimd_internal";
  return { wasmLoaderPath: `${e}/${n}_${t}.js`, wasmBinaryPath: `${e}/${n}_${t}.wasm` };
}
var eo = class {
};
function n1() {
  var n = navigator;
  return typeof OffscreenCanvas < "u" && (!function(e = navigator) {
    return (e = e.userAgent).includes("Safari") && !e.includes("Chrome");
  }(n) || !!((n = n.userAgent.match(/Version\/([\d]+).*Safari/)) && n.length >= 1 && Number(n[1]) >= 17));
}
async function Ep(n) {
  if (typeof importScripts != "function") {
    const e = document.createElement("script");
    return e.src = n.toString(), e.crossOrigin = "anonymous", new Promise((t, r) => {
      e.addEventListener("load", () => {
        t();
      }, !1), e.addEventListener("error", (o) => {
        r(o);
      }, !1), document.body.appendChild(e);
    });
  }
  importScripts(n.toString());
}
function r1(n) {
  return n.videoWidth !== void 0 ? [n.videoWidth, n.videoHeight] : n.naturalWidth !== void 0 ? [n.naturalWidth, n.naturalHeight] : n.displayWidth !== void 0 ? [n.displayWidth, n.displayHeight] : [n.width, n.height];
}
function se(n, e, t) {
  n.m || console.error("No wasm multistream support detected: ensure dependency inclusion of :gl_graph_runner_internal_multi_input target"), t(e = n.i.stringToNewUTF8(e)), n.i._free(e);
}
function Cp(n, e, t) {
  if (!n.i.canvas) throw Error("No OpenGL canvas configured.");
  if (t ? n.i._bindTextureToStream(t) : n.i._bindTextureToCanvas(), !(t = n.i.canvas.getContext("webgl2") || n.i.canvas.getContext("webgl"))) throw Error("Failed to obtain WebGL context from the provided canvas. `getContext()` should only be invoked with `webgl` or `webgl2`.");
  n.i.gpuOriginForWebTexturesIsBottomLeft && t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, !0), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, e), n.i.gpuOriginForWebTexturesIsBottomLeft && t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, !1);
  const [r, o] = r1(e);
  return !n.l || r === n.i.canvas.width && o === n.i.canvas.height || (n.i.canvas.width = r, n.i.canvas.height = o), [r, o];
}
function Tp(n, e, t) {
  n.m || console.error("No wasm multistream support detected: ensure dependency inclusion of :gl_graph_runner_internal_multi_input target");
  const r = new Uint32Array(e.length);
  for (let o = 0; o < e.length; o++) r[o] = n.i.stringToNewUTF8(e[o]);
  e = n.i._malloc(4 * r.length), n.i.HEAPU32.set(r, e >> 2), t(e);
  for (const o of r) n.i._free(o);
  n.i._free(e);
}
function Ln(n, e, t) {
  n.i.simpleListeners = n.i.simpleListeners || {}, n.i.simpleListeners[e] = t;
}
function Ir(n, e, t) {
  let r = [];
  n.i.simpleListeners = n.i.simpleListeners || {}, n.i.simpleListeners[e] = (o, i, a) => {
    i ? (t(r, a), r = []) : r.push(o);
  };
}
eo.forVisionTasks = function(n) {
  return ki("vision", n);
}, eo.forTextTasks = function(n) {
  return ki("text", n);
}, eo.forGenAiExperimentalTasks = function(n) {
  return ki("genai_experimental", n);
}, eo.forGenAiTasks = function(n) {
  return ki("genai", n);
}, eo.forAudioTasks = function(n) {
  return ki("audio", n);
}, eo.isSimdSupported = function() {
  return t1();
};
async function WC(n, e, t, r) {
  return n = await (async (o, i, a, s, u) => {
    if (i && await Ep(i), !self.ModuleFactory || a && (await Ep(a), !self.ModuleFactory)) throw Error("ModuleFactory not set.");
    return self.Module && u && ((i = self.Module).locateFile = u.locateFile, u.mainScriptUrlOrBlob && (i.mainScriptUrlOrBlob = u.mainScriptUrlOrBlob)), u = await self.ModuleFactory(self.Module || u), self.ModuleFactory = self.Module = void 0, new o(u, s);
  })(n, t.wasmLoaderPath, t.assetLoaderPath, e, { locateFile: (o) => o.endsWith(".wasm") ? t.wasmBinaryPath.toString() : t.assetBinaryPath && o.endsWith(".data") ? t.assetBinaryPath.toString() : o }), await n.o(r), n;
}
function Fu(n, e) {
  const t = Se(n.baseOptions, Qa, 1) || new Qa();
  typeof e == "string" ? (Be(t, 2, wi(e)), Be(t, 1)) : e instanceof Uint8Array && (Be(t, 1, xc(e, !1)), Be(t, 2)), le(n.baseOptions, 0, 1, t);
}
function Ip(n) {
  try {
    const e = n.G.length;
    if (e === 1) throw Error(n.G[0].message);
    if (e > 1) throw Error("Encountered multiple errors: " + n.G.map((t) => t.message).join(", "));
  } finally {
    n.G = [];
  }
}
function Y(n, e) {
  n.B = Math.max(n.B, e);
}
function Qs(n, e) {
  n.A = new Ft(), un(n.A, "PassThroughCalculator"), Oe(n.A, "free_memory"), Ee(n.A, "free_memory_unused_out"), We(e, "free_memory"), ln(e, n.A);
}
function ai(n, e) {
  Oe(n.A, e), Ee(n.A, e + "_unused_out");
}
function Zs(n) {
  n.g.addBoolToStream(!0, "free_memory", n.B);
}
var Ml = class {
  constructor(e) {
    this.g = e, this.G = [], this.B = 0, this.g.setAutoRenderToScreen(!1);
  }
  l(e, t = !0) {
    var r, o, i, a, s, u;
    if (t) {
      const l = e.baseOptions || {};
      if ((r = e.baseOptions) != null && r.modelAssetBuffer && ((o = e.baseOptions) != null && o.modelAssetPath)) throw Error("Cannot set both baseOptions.modelAssetPath and baseOptions.modelAssetBuffer");
      if (!((i = Se(this.baseOptions, Qa, 1)) != null && i.g() || (a = Se(this.baseOptions, Qa, 1)) != null && a.h() || (s = e.baseOptions) != null && s.modelAssetBuffer || (u = e.baseOptions) != null && u.modelAssetPath)) throw Error("Either baseOptions.modelAssetPath or baseOptions.modelAssetBuffer must be set");
      if (function(c, f) {
        let d = Se(c.baseOptions, yp, 3);
        if (!d) {
          var p = d = new yp(), v = new dp();
          Oi(p, 4, Ga, v);
        }
        "delegate" in f && (f.delegate === "GPU" ? (f = d, p = new mC(), Oi(f, 2, Ga, p)) : (f = d, p = new dp(), Oi(f, 4, Ga, p))), le(c.baseOptions, 0, 3, d);
      }(this, l), l.modelAssetPath) return fetch(l.modelAssetPath.toString()).then((c) => {
        if (c.ok) return c.arrayBuffer();
        throw Error(`Failed to fetch model: ${l.modelAssetPath} (${c.status})`);
      }).then((c) => {
        try {
          this.g.i.FS_unlink("/model.dat");
        } catch {
        }
        this.g.i.FS_createDataFile("/", "model.dat", new Uint8Array(c), !0, !1, !1), Fu(this, "/model.dat"), this.m(), this.J();
      });
      if (l.modelAssetBuffer instanceof Uint8Array) Fu(this, l.modelAssetBuffer);
      else if (l.modelAssetBuffer) return async function(c) {
        const f = [];
        for (var d = 0; ; ) {
          const { done: p, value: v } = await c.read();
          if (p) break;
          f.push(v), d += v.length;
        }
        if (f.length === 0) return new Uint8Array(0);
        if (f.length === 1) return f[0];
        c = new Uint8Array(d), d = 0;
        for (const p of f) c.set(p, d), d += p.length;
        return c;
      }(l.modelAssetBuffer).then((c) => {
        Fu(this, c), this.m(), this.J();
      });
    }
    return this.m(), this.J(), Promise.resolve();
  }
  J() {
  }
  ca() {
    let e;
    if (this.g.ca((t) => {
      e = vC(t);
    }), !e) throw Error("Failed to retrieve CalculatorGraphConfig");
    return e;
  }
  setGraph(e, t) {
    this.g.attachErrorListener((r, o) => {
      this.G.push(Error(o));
    }), this.g.Ha(), this.g.setGraph(e, t), this.A = void 0, Ip(this);
  }
  finishProcessing() {
    this.g.finishProcessing(), Ip(this);
  }
  close() {
    this.A = void 0, this.g.closeGraph();
  }
};
function pr(n, e) {
  if (!n) throw Error(`Unable to obtain required WebGL resource: ${e}`);
  return n;
}
Ml.prototype.close = Ml.prototype.close;
let HC = class {
  constructor(e, t, r, o) {
    this.g = e, this.h = t, this.m = r, this.l = o;
  }
  bind() {
    this.g.bindVertexArray(this.h);
  }
  close() {
    this.g.deleteVertexArray(this.h), this.g.deleteBuffer(this.m), this.g.deleteBuffer(this.l);
  }
};
function Sp(n, e, t) {
  const r = n.g;
  if (t = pr(r.createShader(t), "Failed to create WebGL shader"), r.shaderSource(t, e), r.compileShader(t), !r.getShaderParameter(t, r.COMPILE_STATUS)) throw Error(`Could not compile WebGL shader: ${r.getShaderInfoLog(t)}`);
  return r.attachShader(n.h, t), t;
}
function Ap(n, e) {
  const t = n.g, r = pr(t.createVertexArray(), "Failed to create vertex array");
  t.bindVertexArray(r);
  const o = pr(t.createBuffer(), "Failed to create buffer");
  t.bindBuffer(t.ARRAY_BUFFER, o), t.enableVertexAttribArray(n.P), t.vertexAttribPointer(n.P, 2, t.FLOAT, !1, 0, 0), t.bufferData(t.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), t.STATIC_DRAW);
  const i = pr(t.createBuffer(), "Failed to create buffer");
  return t.bindBuffer(t.ARRAY_BUFFER, i), t.enableVertexAttribArray(n.J), t.vertexAttribPointer(n.J, 2, t.FLOAT, !1, 0, 0), t.bufferData(t.ARRAY_BUFFER, new Float32Array(e ? [0, 1, 0, 0, 1, 0, 1, 1] : [0, 0, 0, 1, 1, 1, 1, 0]), t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, null), t.bindVertexArray(null), new HC(t, r, o, i);
}
function of(n, e) {
  if (n.g) {
    if (e !== n.g) throw Error("Cannot change GL context once initialized");
  } else n.g = e;
}
function af(n, e, t, r) {
  return of(n, e), n.h || (n.m(), n.C()), t ? (n.s || (n.s = Ap(n, !0)), t = n.s) : (n.v || (n.v = Ap(n, !1)), t = n.v), e.useProgram(n.h), t.bind(), n.l(), n = r(), t.g.bindVertexArray(null), n;
}
function js(n, e, t) {
  return of(n, e), n = pr(e.createTexture(), "Failed to create texture"), e.bindTexture(e.TEXTURE_2D, n), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t ?? e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, t ?? e.LINEAR), e.bindTexture(e.TEXTURE_2D, null), n;
}
function eu(n, e, t) {
  of(n, e), n.A || (n.A = pr(e.createFramebuffer(), "Failed to create framebuffe.")), e.bindFramebuffer(e.FRAMEBUFFER, n.A), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0);
}
function sf(n) {
  var e;
  (e = n.g) == null || e.bindFramebuffer(n.g.FRAMEBUFFER, null);
}
var uf = class {
  G() {
    return `
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D inputTexture;
  void main() {
    gl_FragColor = texture2D(inputTexture, vTex);
  }
 `;
  }
  m() {
    const e = this.g;
    if (this.h = pr(e.createProgram(), "Failed to create WebGL program"), this.Z = Sp(this, `
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`, e.VERTEX_SHADER), this.Y = Sp(this, this.G(), e.FRAGMENT_SHADER), e.linkProgram(this.h), !e.getProgramParameter(this.h, e.LINK_STATUS)) throw Error(`Error during program linking: ${e.getProgramInfoLog(this.h)}`);
    this.P = e.getAttribLocation(this.h, "aVertex"), this.J = e.getAttribLocation(this.h, "aTex");
  }
  C() {
  }
  l() {
  }
  close() {
    if (this.h) {
      const e = this.g;
      e.deleteProgram(this.h), e.deleteShader(this.Z), e.deleteShader(this.Y);
    }
    this.A && this.g.deleteFramebuffer(this.A), this.v && this.v.close(), this.s && this.s.close();
  }
};
function lr(n, e) {
  switch (e) {
    case 0:
      return n.g.find((t) => t instanceof Uint8Array);
    case 1:
      return n.g.find((t) => t instanceof Float32Array);
    case 2:
      return n.g.find((t) => typeof WebGLTexture < "u" && t instanceof WebGLTexture);
    default:
      throw Error(`Type is not supported: ${e}`);
  }
}
function Dl(n) {
  var e = lr(n, 1);
  if (!e) {
    if (e = lr(n, 0)) e = new Float32Array(e).map((r) => r / 255);
    else {
      e = new Float32Array(n.width * n.height);
      const r = si(n);
      var t = lf(n);
      if (eu(t, r, o1(n)), "iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform) || navigator.userAgent.includes("Mac") && "document" in self && "ontouchend" in self.document) {
        t = new Float32Array(n.width * n.height * 4), r.readPixels(0, 0, n.width, n.height, r.RGBA, r.FLOAT, t);
        for (let o = 0, i = 0; o < e.length; ++o, i += 4) e[o] = t[i];
      } else r.readPixels(0, 0, n.width, n.height, r.RED, r.FLOAT, e);
    }
    n.g.push(e);
  }
  return e;
}
function o1(n) {
  let e = lr(n, 2);
  if (!e) {
    const t = si(n);
    e = a1(n);
    const r = Dl(n), o = i1(n);
    t.texImage2D(t.TEXTURE_2D, 0, o, n.width, n.height, 0, t.RED, t.FLOAT, r), Fl(n);
  }
  return e;
}
function si(n) {
  if (!n.canvas) throw Error("Conversion to different image formats require that a canvas is passed when initializing the image.");
  return n.h || (n.h = pr(n.canvas.getContext("webgl2"), "You cannot use a canvas that is already bound to a different type of rendering context.")), n.h;
}
function i1(n) {
  if (n = si(n), !_a) if (n.getExtension("EXT_color_buffer_float") && n.getExtension("OES_texture_float_linear") && n.getExtension("EXT_float_blend")) _a = n.R32F;
  else {
    if (!n.getExtension("EXT_color_buffer_half_float")) throw Error("GPU does not fully support 4-channel float32 or float16 formats");
    _a = n.R16F;
  }
  return _a;
}
function lf(n) {
  return n.l || (n.l = new uf()), n.l;
}
function a1(n) {
  const e = si(n);
  e.viewport(0, 0, n.width, n.height), e.activeTexture(e.TEXTURE0);
  let t = lr(n, 2);
  return t || (t = js(lf(n), e, n.m ? e.LINEAR : e.NEAREST), n.g.push(t), n.j = !0), e.bindTexture(e.TEXTURE_2D, t), t;
}
function Fl(n) {
  n.h.bindTexture(n.h.TEXTURE_2D, null);
}
var _a, yt = class {
  constructor(e, t, r, o, i, a, s) {
    this.g = e, this.m = t, this.j = r, this.canvas = o, this.l = i, this.width = a, this.height = s, this.j && --Rp === 0 && console.error("You seem to be creating MPMask instances without invoking .close(). This leaks resources.");
  }
  Da() {
    return !!lr(this, 0);
  }
  ja() {
    return !!lr(this, 1);
  }
  R() {
    return !!lr(this, 2);
  }
  ia() {
    return (t = lr(e = this, 0)) || (t = Dl(e), t = new Uint8Array(t.map((r) => 255 * r)), e.g.push(t)), t;
    var e, t;
  }
  ha() {
    return Dl(this);
  }
  N() {
    return o1(this);
  }
  clone() {
    const e = [];
    for (const t of this.g) {
      let r;
      if (t instanceof Uint8Array) r = new Uint8Array(t);
      else if (t instanceof Float32Array) r = new Float32Array(t);
      else {
        if (!(t instanceof WebGLTexture)) throw Error(`Type is not supported: ${t}`);
        {
          const o = si(this), i = lf(this);
          o.activeTexture(o.TEXTURE1), r = js(i, o, this.m ? o.LINEAR : o.NEAREST), o.bindTexture(o.TEXTURE_2D, r);
          const a = i1(this);
          o.texImage2D(o.TEXTURE_2D, 0, a, this.width, this.height, 0, o.RED, o.FLOAT, null), o.bindTexture(o.TEXTURE_2D, null), eu(i, o, r), af(i, o, !1, () => {
            a1(this), o.clearColor(0, 0, 0, 0), o.clear(o.COLOR_BUFFER_BIT), o.drawArrays(o.TRIANGLE_FAN, 0, 4), Fl(this);
          }), sf(i), Fl(this);
        }
      }
      e.push(r);
    }
    return new yt(e, this.m, this.R(), this.canvas, this.l, this.width, this.height);
  }
  close() {
    this.j && si(this).deleteTexture(lr(this, 2)), Rp = -1;
  }
};
yt.prototype.close = yt.prototype.close, yt.prototype.clone = yt.prototype.clone, yt.prototype.getAsWebGLTexture = yt.prototype.N, yt.prototype.getAsFloat32Array = yt.prototype.ha, yt.prototype.getAsUint8Array = yt.prototype.ia, yt.prototype.hasWebGLTexture = yt.prototype.R, yt.prototype.hasFloat32Array = yt.prototype.ja, yt.prototype.hasUint8Array = yt.prototype.Da;
var Rp = 250;
function Gn(n, e) {
  switch (e) {
    case 0:
      return n.g.find((t) => t instanceof ImageData);
    case 1:
      return n.g.find((t) => typeof ImageBitmap < "u" && t instanceof ImageBitmap);
    case 2:
      return n.g.find((t) => typeof WebGLTexture < "u" && t instanceof WebGLTexture);
    default:
      throw Error(`Type is not supported: ${e}`);
  }
}
function s1(n) {
  var e = Gn(n, 0);
  if (!e) {
    e = ui(n);
    const t = tu(n), r = new Uint8Array(n.width * n.height * 4);
    eu(t, e, Wa(n)), e.readPixels(0, 0, n.width, n.height, e.RGBA, e.UNSIGNED_BYTE, r), sf(t), e = new ImageData(new Uint8ClampedArray(r.buffer), n.width, n.height), n.g.push(e);
  }
  return e;
}
function Wa(n) {
  let e = Gn(n, 2);
  if (!e) {
    const t = ui(n);
    e = Ha(n);
    const r = Gn(n, 1) || s1(n);
    t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, r), Li(n);
  }
  return e;
}
function ui(n) {
  if (!n.canvas) throw Error("Conversion to different image formats require that a canvas is passed when initializing the image.");
  return n.h || (n.h = pr(n.canvas.getContext("webgl2"), "You cannot use a canvas that is already bound to a different type of rendering context.")), n.h;
}
function tu(n) {
  return n.l || (n.l = new uf()), n.l;
}
function Ha(n) {
  const e = ui(n);
  e.viewport(0, 0, n.width, n.height), e.activeTexture(e.TEXTURE0);
  let t = Gn(n, 2);
  return t || (t = js(tu(n), e), n.g.push(t), n.m = !0), e.bindTexture(e.TEXTURE_2D, t), t;
}
function Li(n) {
  n.h.bindTexture(n.h.TEXTURE_2D, null);
}
function kp(n) {
  const e = ui(n);
  return af(tu(n), e, !0, () => function(t, r) {
    const o = t.canvas;
    if (o.width === t.width && o.height === t.height) return r();
    const i = o.width, a = o.height;
    return o.width = t.width, o.height = t.height, t = r(), o.width = i, o.height = a, t;
  }(n, () => {
    if (e.bindFramebuffer(e.FRAMEBUFFER, null), e.clearColor(0, 0, 0, 0), e.clear(e.COLOR_BUFFER_BIT), e.drawArrays(e.TRIANGLE_FAN, 0, 4), !(n.canvas instanceof OffscreenCanvas)) throw Error("Conversion to ImageBitmap requires that the MediaPipe Tasks is initialized with an OffscreenCanvas");
    return n.canvas.transferToImageBitmap();
  }));
}
var xt = class {
  constructor(e, t, r, o, i, a, s) {
    this.g = e, this.j = t, this.m = r, this.canvas = o, this.l = i, this.width = a, this.height = s, (this.j || this.m) && --Pp === 0 && console.error("You seem to be creating MPImage instances without invoking .close(). This leaks resources.");
  }
  Ca() {
    return !!Gn(this, 0);
  }
  ka() {
    return !!Gn(this, 1);
  }
  R() {
    return !!Gn(this, 2);
  }
  Aa() {
    return s1(this);
  }
  za() {
    var e = Gn(this, 1);
    return e || (Wa(this), Ha(this), e = kp(this), Li(this), this.g.push(e), this.j = !0), e;
  }
  N() {
    return Wa(this);
  }
  clone() {
    const e = [];
    for (const t of this.g) {
      let r;
      if (t instanceof ImageData) r = new ImageData(t.data, this.width, this.height);
      else if (t instanceof WebGLTexture) {
        const o = ui(this), i = tu(this);
        o.activeTexture(o.TEXTURE1), r = js(i, o), o.bindTexture(o.TEXTURE_2D, r), o.texImage2D(o.TEXTURE_2D, 0, o.RGBA, this.width, this.height, 0, o.RGBA, o.UNSIGNED_BYTE, null), o.bindTexture(o.TEXTURE_2D, null), eu(i, o, r), af(i, o, !1, () => {
          Ha(this), o.clearColor(0, 0, 0, 0), o.clear(o.COLOR_BUFFER_BIT), o.drawArrays(o.TRIANGLE_FAN, 0, 4), Li(this);
        }), sf(i), Li(this);
      } else {
        if (!(t instanceof ImageBitmap)) throw Error(`Type is not supported: ${t}`);
        Wa(this), Ha(this), r = kp(this), Li(this);
      }
      e.push(r);
    }
    return new xt(e, this.ka(), this.R(), this.canvas, this.l, this.width, this.height);
  }
  close() {
    this.j && Gn(this, 1).close(), this.m && ui(this).deleteTexture(Gn(this, 2)), Pp = -1;
  }
};
xt.prototype.close = xt.prototype.close, xt.prototype.clone = xt.prototype.clone, xt.prototype.getAsWebGLTexture = xt.prototype.N, xt.prototype.getAsImageBitmap = xt.prototype.za, xt.prototype.getAsImageData = xt.prototype.Aa, xt.prototype.hasWebGLTexture = xt.prototype.R, xt.prototype.hasImageBitmap = xt.prototype.ka, xt.prototype.hasImageData = xt.prototype.Ca;
var Pp = 250;
function kn(...n) {
  return n.map(([e, t]) => ({ start: e, end: t }));
}
const $C = /* @__PURE__ */ function(n) {
  return class extends n {
    Ha() {
      this.i._registerModelResourcesGraphService();
    }
  };
}((Np = class {
  constructor(n, e) {
    this.l = !0, this.i = n, this.g = null, this.h = 0, this.m = typeof this.i._addIntToInputStream == "function", e !== void 0 ? this.i.canvas = e : n1() ? this.i.canvas = new OffscreenCanvas(1, 1) : (console.warn("OffscreenCanvas not supported and GraphRunner constructor glCanvas parameter is undefined. Creating backup canvas."), this.i.canvas = document.createElement("canvas"));
  }
  async initializeGraph(n) {
    const e = await (await fetch(n)).arrayBuffer();
    n = !(n.endsWith(".pbtxt") || n.endsWith(".textproto")), this.setGraph(new Uint8Array(e), n);
  }
  setGraphFromString(n) {
    this.setGraph(new TextEncoder().encode(n), !1);
  }
  setGraph(n, e) {
    const t = n.length, r = this.i._malloc(t);
    this.i.HEAPU8.set(n, r), e ? this.i._changeBinaryGraph(t, r) : this.i._changeTextGraph(t, r), this.i._free(r);
  }
  configureAudio(n, e, t, r, o) {
    this.i._configureAudio || console.warn('Attempting to use configureAudio without support for input audio. Is build dep ":gl_graph_runner_audio" missing?'), se(this, r || "input_audio", (i) => {
      se(this, o = o || "audio_header", (a) => {
        this.i._configureAudio(i, a, n, e ?? 0, t);
      });
    });
  }
  setAutoResizeCanvas(n) {
    this.l = n;
  }
  setAutoRenderToScreen(n) {
    this.i._setAutoRenderToScreen(n);
  }
  setGpuBufferVerticalFlip(n) {
    this.i.gpuOriginForWebTexturesIsBottomLeft = n;
  }
  ca(n) {
    Ln(this, "__graph_config__", (e) => {
      n(e);
    }), se(this, "__graph_config__", (e) => {
      this.i._getGraphConfig(e, void 0);
    }), delete this.i.simpleListeners.__graph_config__;
  }
  attachErrorListener(n) {
    this.i.errorListener = n;
  }
  attachEmptyPacketListener(n, e) {
    this.i.emptyPacketListeners = this.i.emptyPacketListeners || {}, this.i.emptyPacketListeners[n] = e;
  }
  addAudioToStream(n, e, t) {
    this.addAudioToStreamWithShape(n, 0, 0, e, t);
  }
  addAudioToStreamWithShape(n, e, t, r, o) {
    const i = 4 * n.length;
    this.h !== i && (this.g && this.i._free(this.g), this.g = this.i._malloc(i), this.h = i), this.i.HEAPF32.set(n, this.g / 4), se(this, r, (a) => {
      this.i._addAudioToInputStream(this.g, e, t, a, o);
    });
  }
  addGpuBufferToStream(n, e, t) {
    se(this, e, (r) => {
      const [o, i] = Cp(this, n, r);
      this.i._addBoundTextureToStream(r, o, i, t);
    });
  }
  addBoolToStream(n, e, t) {
    se(this, e, (r) => {
      this.i._addBoolToInputStream(n, r, t);
    });
  }
  addDoubleToStream(n, e, t) {
    se(this, e, (r) => {
      this.i._addDoubleToInputStream(n, r, t);
    });
  }
  addFloatToStream(n, e, t) {
    se(this, e, (r) => {
      this.i._addFloatToInputStream(n, r, t);
    });
  }
  addIntToStream(n, e, t) {
    se(this, e, (r) => {
      this.i._addIntToInputStream(n, r, t);
    });
  }
  addUintToStream(n, e, t) {
    se(this, e, (r) => {
      this.i._addUintToInputStream(n, r, t);
    });
  }
  addStringToStream(n, e, t) {
    se(this, e, (r) => {
      se(this, n, (o) => {
        this.i._addStringToInputStream(o, r, t);
      });
    });
  }
  addStringRecordToStream(n, e, t) {
    se(this, e, (r) => {
      Tp(this, Object.keys(n), (o) => {
        Tp(this, Object.values(n), (i) => {
          this.i._addFlatHashMapToInputStream(o, i, Object.keys(n).length, r, t);
        });
      });
    });
  }
  addProtoToStream(n, e, t, r) {
    se(this, t, (o) => {
      se(this, e, (i) => {
        const a = this.i._malloc(n.length);
        this.i.HEAPU8.set(n, a), this.i._addProtoToInputStream(a, n.length, i, o, r), this.i._free(a);
      });
    });
  }
  addEmptyPacketToStream(n, e) {
    se(this, n, (t) => {
      this.i._addEmptyPacketToInputStream(t, e);
    });
  }
  addBoolVectorToStream(n, e, t) {
    se(this, e, (r) => {
      const o = this.i._allocateBoolVector(n.length);
      if (!o) throw Error("Unable to allocate new bool vector on heap.");
      for (const i of n) this.i._addBoolVectorEntry(o, i);
      this.i._addBoolVectorToInputStream(o, r, t);
    });
  }
  addDoubleVectorToStream(n, e, t) {
    se(this, e, (r) => {
      const o = this.i._allocateDoubleVector(n.length);
      if (!o) throw Error("Unable to allocate new double vector on heap.");
      for (const i of n) this.i._addDoubleVectorEntry(o, i);
      this.i._addDoubleVectorToInputStream(o, r, t);
    });
  }
  addFloatVectorToStream(n, e, t) {
    se(this, e, (r) => {
      const o = this.i._allocateFloatVector(n.length);
      if (!o) throw Error("Unable to allocate new float vector on heap.");
      for (const i of n) this.i._addFloatVectorEntry(o, i);
      this.i._addFloatVectorToInputStream(o, r, t);
    });
  }
  addIntVectorToStream(n, e, t) {
    se(this, e, (r) => {
      const o = this.i._allocateIntVector(n.length);
      if (!o) throw Error("Unable to allocate new int vector on heap.");
      for (const i of n) this.i._addIntVectorEntry(o, i);
      this.i._addIntVectorToInputStream(o, r, t);
    });
  }
  addUintVectorToStream(n, e, t) {
    se(this, e, (r) => {
      const o = this.i._allocateUintVector(n.length);
      if (!o) throw Error("Unable to allocate new unsigned int vector on heap.");
      for (const i of n) this.i._addUintVectorEntry(o, i);
      this.i._addUintVectorToInputStream(o, r, t);
    });
  }
  addStringVectorToStream(n, e, t) {
    se(this, e, (r) => {
      const o = this.i._allocateStringVector(n.length);
      if (!o) throw Error("Unable to allocate new string vector on heap.");
      for (const i of n) se(this, i, (a) => {
        this.i._addStringVectorEntry(o, a);
      });
      this.i._addStringVectorToInputStream(o, r, t);
    });
  }
  addBoolToInputSidePacket(n, e) {
    se(this, e, (t) => {
      this.i._addBoolToInputSidePacket(n, t);
    });
  }
  addDoubleToInputSidePacket(n, e) {
    se(this, e, (t) => {
      this.i._addDoubleToInputSidePacket(n, t);
    });
  }
  addFloatToInputSidePacket(n, e) {
    se(this, e, (t) => {
      this.i._addFloatToInputSidePacket(n, t);
    });
  }
  addIntToInputSidePacket(n, e) {
    se(this, e, (t) => {
      this.i._addIntToInputSidePacket(n, t);
    });
  }
  addUintToInputSidePacket(n, e) {
    se(this, e, (t) => {
      this.i._addUintToInputSidePacket(n, t);
    });
  }
  addStringToInputSidePacket(n, e) {
    se(this, e, (t) => {
      se(this, n, (r) => {
        this.i._addStringToInputSidePacket(r, t);
      });
    });
  }
  addProtoToInputSidePacket(n, e, t) {
    se(this, t, (r) => {
      se(this, e, (o) => {
        const i = this.i._malloc(n.length);
        this.i.HEAPU8.set(n, i), this.i._addProtoToInputSidePacket(i, n.length, o, r), this.i._free(i);
      });
    });
  }
  addBoolVectorToInputSidePacket(n, e) {
    se(this, e, (t) => {
      const r = this.i._allocateBoolVector(n.length);
      if (!r) throw Error("Unable to allocate new bool vector on heap.");
      for (const o of n) this.i._addBoolVectorEntry(r, o);
      this.i._addBoolVectorToInputSidePacket(r, t);
    });
  }
  addDoubleVectorToInputSidePacket(n, e) {
    se(this, e, (t) => {
      const r = this.i._allocateDoubleVector(n.length);
      if (!r) throw Error("Unable to allocate new double vector on heap.");
      for (const o of n) this.i._addDoubleVectorEntry(r, o);
      this.i._addDoubleVectorToInputSidePacket(r, t);
    });
  }
  addFloatVectorToInputSidePacket(n, e) {
    se(this, e, (t) => {
      const r = this.i._allocateFloatVector(n.length);
      if (!r) throw Error("Unable to allocate new float vector on heap.");
      for (const o of n) this.i._addFloatVectorEntry(r, o);
      this.i._addFloatVectorToInputSidePacket(r, t);
    });
  }
  addIntVectorToInputSidePacket(n, e) {
    se(this, e, (t) => {
      const r = this.i._allocateIntVector(n.length);
      if (!r) throw Error("Unable to allocate new int vector on heap.");
      for (const o of n) this.i._addIntVectorEntry(r, o);
      this.i._addIntVectorToInputSidePacket(r, t);
    });
  }
  addUintVectorToInputSidePacket(n, e) {
    se(this, e, (t) => {
      const r = this.i._allocateUintVector(n.length);
      if (!r) throw Error("Unable to allocate new unsigned int vector on heap.");
      for (const o of n) this.i._addUintVectorEntry(r, o);
      this.i._addUintVectorToInputSidePacket(r, t);
    });
  }
  addStringVectorToInputSidePacket(n, e) {
    se(this, e, (t) => {
      const r = this.i._allocateStringVector(n.length);
      if (!r) throw Error("Unable to allocate new string vector on heap.");
      for (const o of n) se(this, o, (i) => {
        this.i._addStringVectorEntry(r, i);
      });
      this.i._addStringVectorToInputSidePacket(r, t);
    });
  }
  attachBoolListener(n, e) {
    Ln(this, n, e), se(this, n, (t) => {
      this.i._attachBoolListener(t);
    });
  }
  attachBoolVectorListener(n, e) {
    Ir(this, n, e), se(this, n, (t) => {
      this.i._attachBoolVectorListener(t);
    });
  }
  attachIntListener(n, e) {
    Ln(this, n, e), se(this, n, (t) => {
      this.i._attachIntListener(t);
    });
  }
  attachIntVectorListener(n, e) {
    Ir(this, n, e), se(this, n, (t) => {
      this.i._attachIntVectorListener(t);
    });
  }
  attachUintListener(n, e) {
    Ln(this, n, e), se(this, n, (t) => {
      this.i._attachUintListener(t);
    });
  }
  attachUintVectorListener(n, e) {
    Ir(this, n, e), se(this, n, (t) => {
      this.i._attachUintVectorListener(t);
    });
  }
  attachDoubleListener(n, e) {
    Ln(this, n, e), se(this, n, (t) => {
      this.i._attachDoubleListener(t);
    });
  }
  attachDoubleVectorListener(n, e) {
    Ir(this, n, e), se(this, n, (t) => {
      this.i._attachDoubleVectorListener(t);
    });
  }
  attachFloatListener(n, e) {
    Ln(this, n, e), se(this, n, (t) => {
      this.i._attachFloatListener(t);
    });
  }
  attachFloatVectorListener(n, e) {
    Ir(this, n, e), se(this, n, (t) => {
      this.i._attachFloatVectorListener(t);
    });
  }
  attachStringListener(n, e) {
    Ln(this, n, e), se(this, n, (t) => {
      this.i._attachStringListener(t);
    });
  }
  attachStringVectorListener(n, e) {
    Ir(this, n, e), se(this, n, (t) => {
      this.i._attachStringVectorListener(t);
    });
  }
  attachProtoListener(n, e, t) {
    Ln(this, n, e), se(this, n, (r) => {
      this.i._attachProtoListener(r, t || !1);
    });
  }
  attachProtoVectorListener(n, e, t) {
    Ir(this, n, e), se(this, n, (r) => {
      this.i._attachProtoVectorListener(r, t || !1);
    });
  }
  attachAudioListener(n, e, t) {
    this.i._attachAudioListener || console.warn('Attempting to use attachAudioListener without support for output audio. Is build dep ":gl_graph_runner_audio_out" missing?'), Ln(this, n, (r, o) => {
      r = new Float32Array(r.buffer, r.byteOffset, r.length / 4), e(r, o);
    }), se(this, n, (r) => {
      this.i._attachAudioListener(r, t || !1);
    });
  }
  finishProcessing() {
    this.i._waitUntilIdle();
  }
  closeGraph() {
    this.i._closeGraph(), this.i.simpleListeners = void 0, this.i.emptyPacketListeners = void 0;
  }
}, class extends Np {
  get ea() {
    return this.i;
  }
  oa(n, e, t) {
    se(this, e, (r) => {
      const [o, i] = Cp(this, n, r);
      this.ea._addBoundTextureAsImageToStream(r, o, i, t);
    });
  }
  V(n, e) {
    Ln(this, n, e), se(this, n, (t) => {
      this.ea._attachImageListener(t);
    });
  }
  ba(n, e) {
    Ir(this, n, e), se(this, n, (t) => {
      this.ea._attachImageVectorListener(t);
    });
  }
}));
var Np, wn = class extends $C {
};
async function we(n, e, t) {
  return async function(r, o, i, a) {
    return WC(r, o, i, a);
  }(n, t.canvas ?? (n1() ? void 0 : document.createElement("canvas")), e, t);
}
function u1(n, e, t, r) {
  if (n.U) {
    const i = new Pg();
    if (t != null && t.regionOfInterest) {
      if (!n.na) throw Error("This task doesn't support region-of-interest.");
      var o = t.regionOfInterest;
      if (o.left >= o.right || o.top >= o.bottom) throw Error("Expected RectF with left < right and top < bottom.");
      if (o.left < 0 || o.top < 0 || o.right > 1 || o.bottom > 1) throw Error("Expected RectF values to be in [0,1].");
      ae(i, 1, (o.left + o.right) / 2), ae(i, 2, (o.top + o.bottom) / 2), ae(i, 4, o.right - o.left), ae(i, 3, o.bottom - o.top);
    } else ae(i, 1, 0.5), ae(i, 2, 0.5), ae(i, 4, 1), ae(i, 3, 1);
    if (t != null && t.rotationDegrees) {
      if ((t == null ? void 0 : t.rotationDegrees) % 90 != 0) throw Error("Expected rotation to be a multiple of 90.");
      if (ae(i, 5, -Math.PI * t.rotationDegrees / 180), (t == null ? void 0 : t.rotationDegrees) % 180 != 0) {
        const [a, s] = r1(e);
        t = ot(i, 3) * s / a, o = ot(i, 4) * a / s, ae(i, 4, t), ae(i, 3, o);
      }
    }
    n.g.addProtoToStream(i.g(), "mediapipe.NormalizedRect", n.U, r);
  }
  n.g.oa(e, n.Z, r ?? performance.now()), n.finishProcessing();
}
function _n(n, e, t) {
  var r;
  if ((r = n.baseOptions) != null && r.g()) throw Error("Task is not initialized with image mode. 'runningMode' must be set to 'IMAGE'.");
  u1(n, e, t, n.B + 1);
}
function Zn(n, e, t, r) {
  var o;
  if (!((o = n.baseOptions) != null && o.g())) throw Error("Task is not initialized with video mode. 'runningMode' must be set to 'VIDEO'.");
  u1(n, e, t, r);
}
function li(n, e, t, r) {
  var o = e.data;
  const i = e.width, a = i * (e = e.height);
  if ((o instanceof Uint8Array || o instanceof Float32Array) && o.length !== a) throw Error("Unsupported channel count: " + o.length / a);
  return n = new yt([o], t, !1, n.g.i.canvas, n.P, i, e), r ? n.clone() : n;
}
var $t = class extends Ml {
  constructor(e, t, r, o) {
    super(e), this.g = e, this.Z = t, this.U = r, this.na = o, this.P = new uf();
  }
  l(e, t = !0) {
    if ("runningMode" in e && Xi(this.baseOptions, 2, !!e.runningMode && e.runningMode !== "IMAGE"), e.canvas !== void 0 && this.g.i.canvas !== e.canvas) throw Error("You must create a new task to reset the canvas.");
    return super.l(e, t);
  }
  close() {
    this.P.close(), super.close();
  }
};
$t.prototype.close = $t.prototype.close;
var cn = class extends $t {
  constructor(e, t) {
    super(new wn(e, t), "image_in", "norm_rect_in", !1), this.j = { detections: [] }, le(e = this.h = new Xs(), 0, 1, t = new qe()), ae(this.h, 2, 0.5), ae(this.h, 3, 0.3);
  }
  get baseOptions() {
    return Se(this.h, qe, 1);
  }
  set baseOptions(e) {
    le(this.h, 0, 1, e);
  }
  o(e) {
    return "minDetectionConfidence" in e && ae(this.h, 2, e.minDetectionConfidence ?? 0.5), "minSuppressionThreshold" in e && ae(this.h, 3, e.minSuppressionThreshold ?? 0.3), this.l(e);
  }
  D(e, t) {
    return this.j = { detections: [] }, _n(this, e, t), this.j;
  }
  F(e, t, r) {
    return this.j = { detections: [] }, Zn(this, e, r, t), this.j;
  }
  m() {
    var e = new Kt();
    We(e, "image_in"), We(e, "norm_rect_in"), Ae(e, "detections");
    const t = new an();
    Sn(t, AC, this.h);
    const r = new Ft();
    un(r, "mediapipe.tasks.vision.face_detector.FaceDetectorGraph"), Oe(r, "IMAGE:image_in"), Oe(r, "NORM_RECT:norm_rect_in"), Ee(r, "DETECTIONS:detections"), r.o(t), ln(e, r), this.g.attachProtoVectorListener("detections", (o, i) => {
      for (const a of o) o = Ag(a), this.j.detections.push(e1(o));
      Y(this, i);
    }), this.g.attachEmptyPacketListener("detections", (o) => {
      Y(this, o);
    }), e = e.g(), this.setGraph(new Uint8Array(e), !0);
  }
};
cn.prototype.detectForVideo = cn.prototype.F, cn.prototype.detect = cn.prototype.D, cn.prototype.setOptions = cn.prototype.o, cn.createFromModelPath = async function(n, e) {
  return we(cn, n, { baseOptions: { modelAssetPath: e } });
}, cn.createFromModelBuffer = function(n, e) {
  return we(cn, n, { baseOptions: { modelAssetBuffer: e } });
}, cn.createFromOptions = function(n, e) {
  return we(cn, n, e);
};
var cf = kn([61, 146], [146, 91], [91, 181], [181, 84], [84, 17], [17, 314], [314, 405], [405, 321], [321, 375], [375, 291], [61, 185], [185, 40], [40, 39], [39, 37], [37, 0], [0, 267], [267, 269], [269, 270], [270, 409], [409, 291], [78, 95], [95, 88], [88, 178], [178, 87], [87, 14], [14, 317], [317, 402], [402, 318], [318, 324], [324, 308], [78, 191], [191, 80], [80, 81], [81, 82], [82, 13], [13, 312], [312, 311], [311, 310], [310, 415], [415, 308]), ff = kn([263, 249], [249, 390], [390, 373], [373, 374], [374, 380], [380, 381], [381, 382], [382, 362], [263, 466], [466, 388], [388, 387], [387, 386], [386, 385], [385, 384], [384, 398], [398, 362]), df = kn([276, 283], [283, 282], [282, 295], [295, 285], [300, 293], [293, 334], [334, 296], [296, 336]), l1 = kn([474, 475], [475, 476], [476, 477], [477, 474]), hf = kn([33, 7], [7, 163], [163, 144], [144, 145], [145, 153], [153, 154], [154, 155], [155, 133], [33, 246], [246, 161], [161, 160], [160, 159], [159, 158], [158, 157], [157, 173], [173, 133]), pf = kn([46, 53], [53, 52], [52, 65], [65, 55], [70, 63], [63, 105], [105, 66], [66, 107]), c1 = kn([469, 470], [470, 471], [471, 472], [472, 469]), mf = kn([10, 338], [338, 297], [297, 332], [332, 284], [284, 251], [251, 389], [389, 356], [356, 454], [454, 323], [323, 361], [361, 288], [288, 397], [397, 365], [365, 379], [379, 378], [378, 400], [400, 377], [377, 152], [152, 148], [148, 176], [176, 149], [149, 150], [150, 136], [136, 172], [172, 58], [58, 132], [132, 93], [93, 234], [234, 127], [127, 162], [162, 21], [21, 54], [54, 103], [103, 67], [67, 109], [109, 10]), f1 = [...cf, ...ff, ...df, ...hf, ...pf, ...mf], d1 = kn([127, 34], [34, 139], [139, 127], [11, 0], [0, 37], [37, 11], [232, 231], [231, 120], [120, 232], [72, 37], [37, 39], [39, 72], [128, 121], [121, 47], [47, 128], [232, 121], [121, 128], [128, 232], [104, 69], [69, 67], [67, 104], [175, 171], [171, 148], [148, 175], [118, 50], [50, 101], [101, 118], [73, 39], [39, 40], [40, 73], [9, 151], [151, 108], [108, 9], [48, 115], [115, 131], [131, 48], [194, 204], [204, 211], [211, 194], [74, 40], [40, 185], [185, 74], [80, 42], [42, 183], [183, 80], [40, 92], [92, 186], [186, 40], [230, 229], [229, 118], [118, 230], [202, 212], [212, 214], [214, 202], [83, 18], [18, 17], [17, 83], [76, 61], [61, 146], [146, 76], [160, 29], [29, 30], [30, 160], [56, 157], [157, 173], [173, 56], [106, 204], [204, 194], [194, 106], [135, 214], [214, 192], [192, 135], [203, 165], [165, 98], [98, 203], [21, 71], [71, 68], [68, 21], [51, 45], [45, 4], [4, 51], [144, 24], [24, 23], [23, 144], [77, 146], [146, 91], [91, 77], [205, 50], [50, 187], [187, 205], [201, 200], [200, 18], [18, 201], [91, 106], [106, 182], [182, 91], [90, 91], [91, 181], [181, 90], [85, 84], [84, 17], [17, 85], [206, 203], [203, 36], [36, 206], [148, 171], [171, 140], [140, 148], [92, 40], [40, 39], [39, 92], [193, 189], [189, 244], [244, 193], [159, 158], [158, 28], [28, 159], [247, 246], [246, 161], [161, 247], [236, 3], [3, 196], [196, 236], [54, 68], [68, 104], [104, 54], [193, 168], [168, 8], [8, 193], [117, 228], [228, 31], [31, 117], [189, 193], [193, 55], [55, 189], [98, 97], [97, 99], [99, 98], [126, 47], [47, 100], [100, 126], [166, 79], [79, 218], [218, 166], [155, 154], [154, 26], [26, 155], [209, 49], [49, 131], [131, 209], [135, 136], [136, 150], [150, 135], [47, 126], [126, 217], [217, 47], [223, 52], [52, 53], [53, 223], [45, 51], [51, 134], [134, 45], [211, 170], [170, 140], [140, 211], [67, 69], [69, 108], [108, 67], [43, 106], [106, 91], [91, 43], [230, 119], [119, 120], [120, 230], [226, 130], [130, 247], [247, 226], [63, 53], [53, 52], [52, 63], [238, 20], [20, 242], [242, 238], [46, 70], [70, 156], [156, 46], [78, 62], [62, 96], [96, 78], [46, 53], [53, 63], [63, 46], [143, 34], [34, 227], [227, 143], [123, 117], [117, 111], [111, 123], [44, 125], [125, 19], [19, 44], [236, 134], [134, 51], [51, 236], [216, 206], [206, 205], [205, 216], [154, 153], [153, 22], [22, 154], [39, 37], [37, 167], [167, 39], [200, 201], [201, 208], [208, 200], [36, 142], [142, 100], [100, 36], [57, 212], [212, 202], [202, 57], [20, 60], [60, 99], [99, 20], [28, 158], [158, 157], [157, 28], [35, 226], [226, 113], [113, 35], [160, 159], [159, 27], [27, 160], [204, 202], [202, 210], [210, 204], [113, 225], [225, 46], [46, 113], [43, 202], [202, 204], [204, 43], [62, 76], [76, 77], [77, 62], [137, 123], [123, 116], [116, 137], [41, 38], [38, 72], [72, 41], [203, 129], [129, 142], [142, 203], [64, 98], [98, 240], [240, 64], [49, 102], [102, 64], [64, 49], [41, 73], [73, 74], [74, 41], [212, 216], [216, 207], [207, 212], [42, 74], [74, 184], [184, 42], [169, 170], [170, 211], [211, 169], [170, 149], [149, 176], [176, 170], [105, 66], [66, 69], [69, 105], [122, 6], [6, 168], [168, 122], [123, 147], [147, 187], [187, 123], [96, 77], [77, 90], [90, 96], [65, 55], [55, 107], [107, 65], [89, 90], [90, 180], [180, 89], [101, 100], [100, 120], [120, 101], [63, 105], [105, 104], [104, 63], [93, 137], [137, 227], [227, 93], [15, 86], [86, 85], [85, 15], [129, 102], [102, 49], [49, 129], [14, 87], [87, 86], [86, 14], [55, 8], [8, 9], [9, 55], [100, 47], [47, 121], [121, 100], [145, 23], [23, 22], [22, 145], [88, 89], [89, 179], [179, 88], [6, 122], [122, 196], [196, 6], [88, 95], [95, 96], [96, 88], [138, 172], [172, 136], [136, 138], [215, 58], [58, 172], [172, 215], [115, 48], [48, 219], [219, 115], [42, 80], [80, 81], [81, 42], [195, 3], [3, 51], [51, 195], [43, 146], [146, 61], [61, 43], [171, 175], [175, 199], [199, 171], [81, 82], [82, 38], [38, 81], [53, 46], [46, 225], [225, 53], [144, 163], [163, 110], [110, 144], [52, 65], [65, 66], [66, 52], [229, 228], [228, 117], [117, 229], [34, 127], [127, 234], [234, 34], [107, 108], [108, 69], [69, 107], [109, 108], [108, 151], [151, 109], [48, 64], [64, 235], [235, 48], [62, 78], [78, 191], [191, 62], [129, 209], [209, 126], [126, 129], [111, 35], [35, 143], [143, 111], [117, 123], [123, 50], [50, 117], [222, 65], [65, 52], [52, 222], [19, 125], [125, 141], [141, 19], [221, 55], [55, 65], [65, 221], [3, 195], [195, 197], [197, 3], [25, 7], [7, 33], [33, 25], [220, 237], [237, 44], [44, 220], [70, 71], [71, 139], [139, 70], [122, 193], [193, 245], [245, 122], [247, 130], [130, 33], [33, 247], [71, 21], [21, 162], [162, 71], [170, 169], [169, 150], [150, 170], [188, 174], [174, 196], [196, 188], [216, 186], [186, 92], [92, 216], [2, 97], [97, 167], [167, 2], [141, 125], [125, 241], [241, 141], [164, 167], [167, 37], [37, 164], [72, 38], [38, 12], [12, 72], [38, 82], [82, 13], [13, 38], [63, 68], [68, 71], [71, 63], [226, 35], [35, 111], [111, 226], [101, 50], [50, 205], [205, 101], [206, 92], [92, 165], [165, 206], [209, 198], [198, 217], [217, 209], [165, 167], [167, 97], [97, 165], [220, 115], [115, 218], [218, 220], [133, 112], [112, 243], [243, 133], [239, 238], [238, 241], [241, 239], [214, 135], [135, 169], [169, 214], [190, 173], [173, 133], [133, 190], [171, 208], [208, 32], [32, 171], [125, 44], [44, 237], [237, 125], [86, 87], [87, 178], [178, 86], [85, 86], [86, 179], [179, 85], [84, 85], [85, 180], [180, 84], [83, 84], [84, 181], [181, 83], [201, 83], [83, 182], [182, 201], [137, 93], [93, 132], [132, 137], [76, 62], [62, 183], [183, 76], [61, 76], [76, 184], [184, 61], [57, 61], [61, 185], [185, 57], [212, 57], [57, 186], [186, 212], [214, 207], [207, 187], [187, 214], [34, 143], [143, 156], [156, 34], [79, 239], [239, 237], [237, 79], [123, 137], [137, 177], [177, 123], [44, 1], [1, 4], [4, 44], [201, 194], [194, 32], [32, 201], [64, 102], [102, 129], [129, 64], [213, 215], [215, 138], [138, 213], [59, 166], [166, 219], [219, 59], [242, 99], [99, 97], [97, 242], [2, 94], [94, 141], [141, 2], [75, 59], [59, 235], [235, 75], [24, 110], [110, 228], [228, 24], [25, 130], [130, 226], [226, 25], [23, 24], [24, 229], [229, 23], [22, 23], [23, 230], [230, 22], [26, 22], [22, 231], [231, 26], [112, 26], [26, 232], [232, 112], [189, 190], [190, 243], [243, 189], [221, 56], [56, 190], [190, 221], [28, 56], [56, 221], [221, 28], [27, 28], [28, 222], [222, 27], [29, 27], [27, 223], [223, 29], [30, 29], [29, 224], [224, 30], [247, 30], [30, 225], [225, 247], [238, 79], [79, 20], [20, 238], [166, 59], [59, 75], [75, 166], [60, 75], [75, 240], [240, 60], [147, 177], [177, 215], [215, 147], [20, 79], [79, 166], [166, 20], [187, 147], [147, 213], [213, 187], [112, 233], [233, 244], [244, 112], [233, 128], [128, 245], [245, 233], [128, 114], [114, 188], [188, 128], [114, 217], [217, 174], [174, 114], [131, 115], [115, 220], [220, 131], [217, 198], [198, 236], [236, 217], [198, 131], [131, 134], [134, 198], [177, 132], [132, 58], [58, 177], [143, 35], [35, 124], [124, 143], [110, 163], [163, 7], [7, 110], [228, 110], [110, 25], [25, 228], [356, 389], [389, 368], [368, 356], [11, 302], [302, 267], [267, 11], [452, 350], [350, 349], [349, 452], [302, 303], [303, 269], [269, 302], [357, 343], [343, 277], [277, 357], [452, 453], [453, 357], [357, 452], [333, 332], [332, 297], [297, 333], [175, 152], [152, 377], [377, 175], [347, 348], [348, 330], [330, 347], [303, 304], [304, 270], [270, 303], [9, 336], [336, 337], [337, 9], [278, 279], [279, 360], [360, 278], [418, 262], [262, 431], [431, 418], [304, 408], [408, 409], [409, 304], [310, 415], [415, 407], [407, 310], [270, 409], [409, 410], [410, 270], [450, 348], [348, 347], [347, 450], [422, 430], [430, 434], [434, 422], [313, 314], [314, 17], [17, 313], [306, 307], [307, 375], [375, 306], [387, 388], [388, 260], [260, 387], [286, 414], [414, 398], [398, 286], [335, 406], [406, 418], [418, 335], [364, 367], [367, 416], [416, 364], [423, 358], [358, 327], [327, 423], [251, 284], [284, 298], [298, 251], [281, 5], [5, 4], [4, 281], [373, 374], [374, 253], [253, 373], [307, 320], [320, 321], [321, 307], [425, 427], [427, 411], [411, 425], [421, 313], [313, 18], [18, 421], [321, 405], [405, 406], [406, 321], [320, 404], [404, 405], [405, 320], [315, 16], [16, 17], [17, 315], [426, 425], [425, 266], [266, 426], [377, 400], [400, 369], [369, 377], [322, 391], [391, 269], [269, 322], [417, 465], [465, 464], [464, 417], [386, 257], [257, 258], [258, 386], [466, 260], [260, 388], [388, 466], [456, 399], [399, 419], [419, 456], [284, 332], [332, 333], [333, 284], [417, 285], [285, 8], [8, 417], [346, 340], [340, 261], [261, 346], [413, 441], [441, 285], [285, 413], [327, 460], [460, 328], [328, 327], [355, 371], [371, 329], [329, 355], [392, 439], [439, 438], [438, 392], [382, 341], [341, 256], [256, 382], [429, 420], [420, 360], [360, 429], [364, 394], [394, 379], [379, 364], [277, 343], [343, 437], [437, 277], [443, 444], [444, 283], [283, 443], [275, 440], [440, 363], [363, 275], [431, 262], [262, 369], [369, 431], [297, 338], [338, 337], [337, 297], [273, 375], [375, 321], [321, 273], [450, 451], [451, 349], [349, 450], [446, 342], [342, 467], [467, 446], [293, 334], [334, 282], [282, 293], [458, 461], [461, 462], [462, 458], [276, 353], [353, 383], [383, 276], [308, 324], [324, 325], [325, 308], [276, 300], [300, 293], [293, 276], [372, 345], [345, 447], [447, 372], [352, 345], [345, 340], [340, 352], [274, 1], [1, 19], [19, 274], [456, 248], [248, 281], [281, 456], [436, 427], [427, 425], [425, 436], [381, 256], [256, 252], [252, 381], [269, 391], [391, 393], [393, 269], [200, 199], [199, 428], [428, 200], [266, 330], [330, 329], [329, 266], [287, 273], [273, 422], [422, 287], [250, 462], [462, 328], [328, 250], [258, 286], [286, 384], [384, 258], [265, 353], [353, 342], [342, 265], [387, 259], [259, 257], [257, 387], [424, 431], [431, 430], [430, 424], [342, 353], [353, 276], [276, 342], [273, 335], [335, 424], [424, 273], [292, 325], [325, 307], [307, 292], [366, 447], [447, 345], [345, 366], [271, 303], [303, 302], [302, 271], [423, 266], [266, 371], [371, 423], [294, 455], [455, 460], [460, 294], [279, 278], [278, 294], [294, 279], [271, 272], [272, 304], [304, 271], [432, 434], [434, 427], [427, 432], [272, 407], [407, 408], [408, 272], [394, 430], [430, 431], [431, 394], [395, 369], [369, 400], [400, 395], [334, 333], [333, 299], [299, 334], [351, 417], [417, 168], [168, 351], [352, 280], [280, 411], [411, 352], [325, 319], [319, 320], [320, 325], [295, 296], [296, 336], [336, 295], [319, 403], [403, 404], [404, 319], [330, 348], [348, 349], [349, 330], [293, 298], [298, 333], [333, 293], [323, 454], [454, 447], [447, 323], [15, 16], [16, 315], [315, 15], [358, 429], [429, 279], [279, 358], [14, 15], [15, 316], [316, 14], [285, 336], [336, 9], [9, 285], [329, 349], [349, 350], [350, 329], [374, 380], [380, 252], [252, 374], [318, 402], [402, 403], [403, 318], [6, 197], [197, 419], [419, 6], [318, 319], [319, 325], [325, 318], [367, 364], [364, 365], [365, 367], [435, 367], [367, 397], [397, 435], [344, 438], [438, 439], [439, 344], [272, 271], [271, 311], [311, 272], [195, 5], [5, 281], [281, 195], [273, 287], [287, 291], [291, 273], [396, 428], [428, 199], [199, 396], [311, 271], [271, 268], [268, 311], [283, 444], [444, 445], [445, 283], [373, 254], [254, 339], [339, 373], [282, 334], [334, 296], [296, 282], [449, 347], [347, 346], [346, 449], [264, 447], [447, 454], [454, 264], [336, 296], [296, 299], [299, 336], [338, 10], [10, 151], [151, 338], [278, 439], [439, 455], [455, 278], [292, 407], [407, 415], [415, 292], [358, 371], [371, 355], [355, 358], [340, 345], [345, 372], [372, 340], [346, 347], [347, 280], [280, 346], [442, 443], [443, 282], [282, 442], [19, 94], [94, 370], [370, 19], [441, 442], [442, 295], [295, 441], [248, 419], [419, 197], [197, 248], [263, 255], [255, 359], [359, 263], [440, 275], [275, 274], [274, 440], [300, 383], [383, 368], [368, 300], [351, 412], [412, 465], [465, 351], [263, 467], [467, 466], [466, 263], [301, 368], [368, 389], [389, 301], [395, 378], [378, 379], [379, 395], [412, 351], [351, 419], [419, 412], [436, 426], [426, 322], [322, 436], [2, 164], [164, 393], [393, 2], [370, 462], [462, 461], [461, 370], [164, 0], [0, 267], [267, 164], [302, 11], [11, 12], [12, 302], [268, 12], [12, 13], [13, 268], [293, 300], [300, 301], [301, 293], [446, 261], [261, 340], [340, 446], [330, 266], [266, 425], [425, 330], [426, 423], [423, 391], [391, 426], [429, 355], [355, 437], [437, 429], [391, 327], [327, 326], [326, 391], [440, 457], [457, 438], [438, 440], [341, 382], [382, 362], [362, 341], [459, 457], [457, 461], [461, 459], [434, 430], [430, 394], [394, 434], [414, 463], [463, 362], [362, 414], [396, 369], [369, 262], [262, 396], [354, 461], [461, 457], [457, 354], [316, 403], [403, 402], [402, 316], [315, 404], [404, 403], [403, 315], [314, 405], [405, 404], [404, 314], [313, 406], [406, 405], [405, 313], [421, 418], [418, 406], [406, 421], [366, 401], [401, 361], [361, 366], [306, 408], [408, 407], [407, 306], [291, 409], [409, 408], [408, 291], [287, 410], [410, 409], [409, 287], [432, 436], [436, 410], [410, 432], [434, 416], [416, 411], [411, 434], [264, 368], [368, 383], [383, 264], [309, 438], [438, 457], [457, 309], [352, 376], [376, 401], [401, 352], [274, 275], [275, 4], [4, 274], [421, 428], [428, 262], [262, 421], [294, 327], [327, 358], [358, 294], [433, 416], [416, 367], [367, 433], [289, 455], [455, 439], [439, 289], [462, 370], [370, 326], [326, 462], [2, 326], [326, 370], [370, 2], [305, 460], [460, 455], [455, 305], [254, 449], [449, 448], [448, 254], [255, 261], [261, 446], [446, 255], [253, 450], [450, 449], [449, 253], [252, 451], [451, 450], [450, 252], [256, 452], [452, 451], [451, 256], [341, 453], [453, 452], [452, 341], [413, 464], [464, 463], [463, 413], [441, 413], [413, 414], [414, 441], [258, 442], [442, 441], [441, 258], [257, 443], [443, 442], [442, 257], [259, 444], [444, 443], [443, 259], [260, 445], [445, 444], [444, 260], [467, 342], [342, 445], [445, 467], [459, 458], [458, 250], [250, 459], [289, 392], [392, 290], [290, 289], [290, 328], [328, 460], [460, 290], [376, 433], [433, 435], [435, 376], [250, 290], [290, 392], [392, 250], [411, 416], [416, 433], [433, 411], [341, 463], [463, 464], [464, 341], [453, 464], [464, 465], [465, 453], [357, 465], [465, 412], [412, 357], [343, 412], [412, 399], [399, 343], [360, 363], [363, 440], [440, 360], [437, 399], [399, 456], [456, 437], [420, 456], [456, 363], [363, 420], [401, 435], [435, 288], [288, 401], [372, 383], [383, 353], [353, 372], [339, 255], [255, 249], [249, 339], [448, 261], [261, 255], [255, 448], [133, 243], [243, 190], [190, 133], [133, 155], [155, 112], [112, 133], [33, 246], [246, 247], [247, 33], [33, 130], [130, 25], [25, 33], [398, 384], [384, 286], [286, 398], [362, 398], [398, 414], [414, 362], [362, 463], [463, 341], [341, 362], [263, 359], [359, 467], [467, 263], [263, 249], [249, 255], [255, 263], [466, 467], [467, 260], [260, 466], [75, 60], [60, 166], [166, 75], [238, 239], [239, 79], [79, 238], [162, 127], [127, 139], [139, 162], [72, 11], [11, 37], [37, 72], [121, 232], [232, 120], [120, 121], [73, 72], [72, 39], [39, 73], [114, 128], [128, 47], [47, 114], [233, 232], [232, 128], [128, 233], [103, 104], [104, 67], [67, 103], [152, 175], [175, 148], [148, 152], [119, 118], [118, 101], [101, 119], [74, 73], [73, 40], [40, 74], [107, 9], [9, 108], [108, 107], [49, 48], [48, 131], [131, 49], [32, 194], [194, 211], [211, 32], [184, 74], [74, 185], [185, 184], [191, 80], [80, 183], [183, 191], [185, 40], [40, 186], [186, 185], [119, 230], [230, 118], [118, 119], [210, 202], [202, 214], [214, 210], [84, 83], [83, 17], [17, 84], [77, 76], [76, 146], [146, 77], [161, 160], [160, 30], [30, 161], [190, 56], [56, 173], [173, 190], [182, 106], [106, 194], [194, 182], [138, 135], [135, 192], [192, 138], [129, 203], [203, 98], [98, 129], [54, 21], [21, 68], [68, 54], [5, 51], [51, 4], [4, 5], [145, 144], [144, 23], [23, 145], [90, 77], [77, 91], [91, 90], [207, 205], [205, 187], [187, 207], [83, 201], [201, 18], [18, 83], [181, 91], [91, 182], [182, 181], [180, 90], [90, 181], [181, 180], [16, 85], [85, 17], [17, 16], [205, 206], [206, 36], [36, 205], [176, 148], [148, 140], [140, 176], [165, 92], [92, 39], [39, 165], [245, 193], [193, 244], [244, 245], [27, 159], [159, 28], [28, 27], [30, 247], [247, 161], [161, 30], [174, 236], [236, 196], [196, 174], [103, 54], [54, 104], [104, 103], [55, 193], [193, 8], [8, 55], [111, 117], [117, 31], [31, 111], [221, 189], [189, 55], [55, 221], [240, 98], [98, 99], [99, 240], [142, 126], [126, 100], [100, 142], [219, 166], [166, 218], [218, 219], [112, 155], [155, 26], [26, 112], [198, 209], [209, 131], [131, 198], [169, 135], [135, 150], [150, 169], [114, 47], [47, 217], [217, 114], [224, 223], [223, 53], [53, 224], [220, 45], [45, 134], [134, 220], [32, 211], [211, 140], [140, 32], [109, 67], [67, 108], [108, 109], [146, 43], [43, 91], [91, 146], [231, 230], [230, 120], [120, 231], [113, 226], [226, 247], [247, 113], [105, 63], [63, 52], [52, 105], [241, 238], [238, 242], [242, 241], [124, 46], [46, 156], [156, 124], [95, 78], [78, 96], [96, 95], [70, 46], [46, 63], [63, 70], [116, 143], [143, 227], [227, 116], [116, 123], [123, 111], [111, 116], [1, 44], [44, 19], [19, 1], [3, 236], [236, 51], [51, 3], [207, 216], [216, 205], [205, 207], [26, 154], [154, 22], [22, 26], [165, 39], [39, 167], [167, 165], [199, 200], [200, 208], [208, 199], [101, 36], [36, 100], [100, 101], [43, 57], [57, 202], [202, 43], [242, 20], [20, 99], [99, 242], [56, 28], [28, 157], [157, 56], [124, 35], [35, 113], [113, 124], [29, 160], [160, 27], [27, 29], [211, 204], [204, 210], [210, 211], [124, 113], [113, 46], [46, 124], [106, 43], [43, 204], [204, 106], [96, 62], [62, 77], [77, 96], [227, 137], [137, 116], [116, 227], [73, 41], [41, 72], [72, 73], [36, 203], [203, 142], [142, 36], [235, 64], [64, 240], [240, 235], [48, 49], [49, 64], [64, 48], [42, 41], [41, 74], [74, 42], [214, 212], [212, 207], [207, 214], [183, 42], [42, 184], [184, 183], [210, 169], [169, 211], [211, 210], [140, 170], [170, 176], [176, 140], [104, 105], [105, 69], [69, 104], [193, 122], [122, 168], [168, 193], [50, 123], [123, 187], [187, 50], [89, 96], [96, 90], [90, 89], [66, 65], [65, 107], [107, 66], [179, 89], [89, 180], [180, 179], [119, 101], [101, 120], [120, 119], [68, 63], [63, 104], [104, 68], [234, 93], [93, 227], [227, 234], [16, 15], [15, 85], [85, 16], [209, 129], [129, 49], [49, 209], [15, 14], [14, 86], [86, 15], [107, 55], [55, 9], [9, 107], [120, 100], [100, 121], [121, 120], [153, 145], [145, 22], [22, 153], [178, 88], [88, 179], [179, 178], [197, 6], [6, 196], [196, 197], [89, 88], [88, 96], [96, 89], [135, 138], [138, 136], [136, 135], [138, 215], [215, 172], [172, 138], [218, 115], [115, 219], [219, 218], [41, 42], [42, 81], [81, 41], [5, 195], [195, 51], [51, 5], [57, 43], [43, 61], [61, 57], [208, 171], [171, 199], [199, 208], [41, 81], [81, 38], [38, 41], [224, 53], [53, 225], [225, 224], [24, 144], [144, 110], [110, 24], [105, 52], [52, 66], [66, 105], [118, 229], [229, 117], [117, 118], [227, 34], [34, 234], [234, 227], [66, 107], [107, 69], [69, 66], [10, 109], [109, 151], [151, 10], [219, 48], [48, 235], [235, 219], [183, 62], [62, 191], [191, 183], [142, 129], [129, 126], [126, 142], [116, 111], [111, 143], [143, 116], [118, 117], [117, 50], [50, 118], [223, 222], [222, 52], [52, 223], [94, 19], [19, 141], [141, 94], [222, 221], [221, 65], [65, 222], [196, 3], [3, 197], [197, 196], [45, 220], [220, 44], [44, 45], [156, 70], [70, 139], [139, 156], [188, 122], [122, 245], [245, 188], [139, 71], [71, 162], [162, 139], [149, 170], [170, 150], [150, 149], [122, 188], [188, 196], [196, 122], [206, 216], [216, 92], [92, 206], [164, 2], [2, 167], [167, 164], [242, 141], [141, 241], [241, 242], [0, 164], [164, 37], [37, 0], [11, 72], [72, 12], [12, 11], [12, 38], [38, 13], [13, 12], [70, 63], [63, 71], [71, 70], [31, 226], [226, 111], [111, 31], [36, 101], [101, 205], [205, 36], [203, 206], [206, 165], [165, 203], [126, 209], [209, 217], [217, 126], [98, 165], [165, 97], [97, 98], [237, 220], [220, 218], [218, 237], [237, 239], [239, 241], [241, 237], [210, 214], [214, 169], [169, 210], [140, 171], [171, 32], [32, 140], [241, 125], [125, 237], [237, 241], [179, 86], [86, 178], [178, 179], [180, 85], [85, 179], [179, 180], [181, 84], [84, 180], [180, 181], [182, 83], [83, 181], [181, 182], [194, 201], [201, 182], [182, 194], [177, 137], [137, 132], [132, 177], [184, 76], [76, 183], [183, 184], [185, 61], [61, 184], [184, 185], [186, 57], [57, 185], [185, 186], [216, 212], [212, 186], [186, 216], [192, 214], [214, 187], [187, 192], [139, 34], [34, 156], [156, 139], [218, 79], [79, 237], [237, 218], [147, 123], [123, 177], [177, 147], [45, 44], [44, 4], [4, 45], [208, 201], [201, 32], [32, 208], [98, 64], [64, 129], [129, 98], [192, 213], [213, 138], [138, 192], [235, 59], [59, 219], [219, 235], [141, 242], [242, 97], [97, 141], [97, 2], [2, 141], [141, 97], [240, 75], [75, 235], [235, 240], [229, 24], [24, 228], [228, 229], [31, 25], [25, 226], [226, 31], [230, 23], [23, 229], [229, 230], [231, 22], [22, 230], [230, 231], [232, 26], [26, 231], [231, 232], [233, 112], [112, 232], [232, 233], [244, 189], [189, 243], [243, 244], [189, 221], [221, 190], [190, 189], [222, 28], [28, 221], [221, 222], [223, 27], [27, 222], [222, 223], [224, 29], [29, 223], [223, 224], [225, 30], [30, 224], [224, 225], [113, 247], [247, 225], [225, 113], [99, 60], [60, 240], [240, 99], [213, 147], [147, 215], [215, 213], [60, 20], [20, 166], [166, 60], [192, 187], [187, 213], [213, 192], [243, 112], [112, 244], [244, 243], [244, 233], [233, 245], [245, 244], [245, 128], [128, 188], [188, 245], [188, 114], [114, 174], [174, 188], [134, 131], [131, 220], [220, 134], [174, 217], [217, 236], [236, 174], [236, 198], [198, 134], [134, 236], [215, 177], [177, 58], [58, 215], [156, 143], [143, 124], [124, 156], [25, 110], [110, 7], [7, 25], [31, 228], [228, 25], [25, 31], [264, 356], [356, 368], [368, 264], [0, 11], [11, 267], [267, 0], [451, 452], [452, 349], [349, 451], [267, 302], [302, 269], [269, 267], [350, 357], [357, 277], [277, 350], [350, 452], [452, 357], [357, 350], [299, 333], [333, 297], [297, 299], [396, 175], [175, 377], [377, 396], [280, 347], [347, 330], [330, 280], [269, 303], [303, 270], [270, 269], [151, 9], [9, 337], [337, 151], [344, 278], [278, 360], [360, 344], [424, 418], [418, 431], [431, 424], [270, 304], [304, 409], [409, 270], [272, 310], [310, 407], [407, 272], [322, 270], [270, 410], [410, 322], [449, 450], [450, 347], [347, 449], [432, 422], [422, 434], [434, 432], [18, 313], [313, 17], [17, 18], [291, 306], [306, 375], [375, 291], [259, 387], [387, 260], [260, 259], [424, 335], [335, 418], [418, 424], [434, 364], [364, 416], [416, 434], [391, 423], [423, 327], [327, 391], [301, 251], [251, 298], [298, 301], [275, 281], [281, 4], [4, 275], [254, 373], [373, 253], [253, 254], [375, 307], [307, 321], [321, 375], [280, 425], [425, 411], [411, 280], [200, 421], [421, 18], [18, 200], [335, 321], [321, 406], [406, 335], [321, 320], [320, 405], [405, 321], [314, 315], [315, 17], [17, 314], [423, 426], [426, 266], [266, 423], [396, 377], [377, 369], [369, 396], [270, 322], [322, 269], [269, 270], [413, 417], [417, 464], [464, 413], [385, 386], [386, 258], [258, 385], [248, 456], [456, 419], [419, 248], [298, 284], [284, 333], [333, 298], [168, 417], [417, 8], [8, 168], [448, 346], [346, 261], [261, 448], [417, 413], [413, 285], [285, 417], [326, 327], [327, 328], [328, 326], [277, 355], [355, 329], [329, 277], [309, 392], [392, 438], [438, 309], [381, 382], [382, 256], [256, 381], [279, 429], [429, 360], [360, 279], [365, 364], [364, 379], [379, 365], [355, 277], [277, 437], [437, 355], [282, 443], [443, 283], [283, 282], [281, 275], [275, 363], [363, 281], [395, 431], [431, 369], [369, 395], [299, 297], [297, 337], [337, 299], [335, 273], [273, 321], [321, 335], [348, 450], [450, 349], [349, 348], [359, 446], [446, 467], [467, 359], [283, 293], [293, 282], [282, 283], [250, 458], [458, 462], [462, 250], [300, 276], [276, 383], [383, 300], [292, 308], [308, 325], [325, 292], [283, 276], [276, 293], [293, 283], [264, 372], [372, 447], [447, 264], [346, 352], [352, 340], [340, 346], [354, 274], [274, 19], [19, 354], [363, 456], [456, 281], [281, 363], [426, 436], [436, 425], [425, 426], [380, 381], [381, 252], [252, 380], [267, 269], [269, 393], [393, 267], [421, 200], [200, 428], [428, 421], [371, 266], [266, 329], [329, 371], [432, 287], [287, 422], [422, 432], [290, 250], [250, 328], [328, 290], [385, 258], [258, 384], [384, 385], [446, 265], [265, 342], [342, 446], [386, 387], [387, 257], [257, 386], [422, 424], [424, 430], [430, 422], [445, 342], [342, 276], [276, 445], [422, 273], [273, 424], [424, 422], [306, 292], [292, 307], [307, 306], [352, 366], [366, 345], [345, 352], [268, 271], [271, 302], [302, 268], [358, 423], [423, 371], [371, 358], [327, 294], [294, 460], [460, 327], [331, 279], [279, 294], [294, 331], [303, 271], [271, 304], [304, 303], [436, 432], [432, 427], [427, 436], [304, 272], [272, 408], [408, 304], [395, 394], [394, 431], [431, 395], [378, 395], [395, 400], [400, 378], [296, 334], [334, 299], [299, 296], [6, 351], [351, 168], [168, 6], [376, 352], [352, 411], [411, 376], [307, 325], [325, 320], [320, 307], [285, 295], [295, 336], [336, 285], [320, 319], [319, 404], [404, 320], [329, 330], [330, 349], [349, 329], [334, 293], [293, 333], [333, 334], [366, 323], [323, 447], [447, 366], [316, 15], [15, 315], [315, 316], [331, 358], [358, 279], [279, 331], [317, 14], [14, 316], [316, 317], [8, 285], [285, 9], [9, 8], [277, 329], [329, 350], [350, 277], [253, 374], [374, 252], [252, 253], [319, 318], [318, 403], [403, 319], [351, 6], [6, 419], [419, 351], [324, 318], [318, 325], [325, 324], [397, 367], [367, 365], [365, 397], [288, 435], [435, 397], [397, 288], [278, 344], [344, 439], [439, 278], [310, 272], [272, 311], [311, 310], [248, 195], [195, 281], [281, 248], [375, 273], [273, 291], [291, 375], [175, 396], [396, 199], [199, 175], [312, 311], [311, 268], [268, 312], [276, 283], [283, 445], [445, 276], [390, 373], [373, 339], [339, 390], [295, 282], [282, 296], [296, 295], [448, 449], [449, 346], [346, 448], [356, 264], [264, 454], [454, 356], [337, 336], [336, 299], [299, 337], [337, 338], [338, 151], [151, 337], [294, 278], [278, 455], [455, 294], [308, 292], [292, 415], [415, 308], [429, 358], [358, 355], [355, 429], [265, 340], [340, 372], [372, 265], [352, 346], [346, 280], [280, 352], [295, 442], [442, 282], [282, 295], [354, 19], [19, 370], [370, 354], [285, 441], [441, 295], [295, 285], [195, 248], [248, 197], [197, 195], [457, 440], [440, 274], [274, 457], [301, 300], [300, 368], [368, 301], [417, 351], [351, 465], [465, 417], [251, 301], [301, 389], [389, 251], [394, 395], [395, 379], [379, 394], [399, 412], [412, 419], [419, 399], [410, 436], [436, 322], [322, 410], [326, 2], [2, 393], [393, 326], [354, 370], [370, 461], [461, 354], [393, 164], [164, 267], [267, 393], [268, 302], [302, 12], [12, 268], [312, 268], [268, 13], [13, 312], [298, 293], [293, 301], [301, 298], [265, 446], [446, 340], [340, 265], [280, 330], [330, 425], [425, 280], [322, 426], [426, 391], [391, 322], [420, 429], [429, 437], [437, 420], [393, 391], [391, 326], [326, 393], [344, 440], [440, 438], [438, 344], [458, 459], [459, 461], [461, 458], [364, 434], [434, 394], [394, 364], [428, 396], [396, 262], [262, 428], [274, 354], [354, 457], [457, 274], [317, 316], [316, 402], [402, 317], [316, 315], [315, 403], [403, 316], [315, 314], [314, 404], [404, 315], [314, 313], [313, 405], [405, 314], [313, 421], [421, 406], [406, 313], [323, 366], [366, 361], [361, 323], [292, 306], [306, 407], [407, 292], [306, 291], [291, 408], [408, 306], [291, 287], [287, 409], [409, 291], [287, 432], [432, 410], [410, 287], [427, 434], [434, 411], [411, 427], [372, 264], [264, 383], [383, 372], [459, 309], [309, 457], [457, 459], [366, 352], [352, 401], [401, 366], [1, 274], [274, 4], [4, 1], [418, 421], [421, 262], [262, 418], [331, 294], [294, 358], [358, 331], [435, 433], [433, 367], [367, 435], [392, 289], [289, 439], [439, 392], [328, 462], [462, 326], [326, 328], [94, 2], [2, 370], [370, 94], [289, 305], [305, 455], [455, 289], [339, 254], [254, 448], [448, 339], [359, 255], [255, 446], [446, 359], [254, 253], [253, 449], [449, 254], [253, 252], [252, 450], [450, 253], [252, 256], [256, 451], [451, 252], [256, 341], [341, 452], [452, 256], [414, 413], [413, 463], [463, 414], [286, 441], [441, 414], [414, 286], [286, 258], [258, 441], [441, 286], [258, 257], [257, 442], [442, 258], [257, 259], [259, 443], [443, 257], [259, 260], [260, 444], [444, 259], [260, 467], [467, 445], [445, 260], [309, 459], [459, 250], [250, 309], [305, 289], [289, 290], [290, 305], [305, 290], [290, 460], [460, 305], [401, 376], [376, 435], [435, 401], [309, 250], [250, 392], [392, 309], [376, 411], [411, 433], [433, 376], [453, 341], [341, 464], [464, 453], [357, 453], [453, 465], [465, 357], [343, 357], [357, 412], [412, 343], [437, 343], [343, 399], [399, 437], [344, 360], [360, 440], [440, 344], [420, 437], [437, 456], [456, 420], [360, 420], [420, 363], [363, 360], [361, 401], [401, 288], [288, 361], [265, 372], [372, 353], [353, 265], [390, 339], [339, 249], [249, 390], [339, 448], [448, 255], [255, 339]);
function Mp(n) {
  n.j = { faceLandmarks: [], faceBlendshapes: [], facialTransformationMatrixes: [] };
}
var je = class extends $t {
  constructor(e, t) {
    super(new wn(e, t), "image_in", "norm_rect", !1), this.j = { faceLandmarks: [], faceBlendshapes: [], facialTransformationMatrixes: [] }, this.outputFacialTransformationMatrixes = this.outputFaceBlendshapes = !1, le(e = this.h = new Lg(), 0, 1, t = new qe()), this.v = new Fg(), le(this.h, 0, 3, this.v), this.s = new Xs(), le(this.h, 0, 2, this.s), Yn(this.s, 4, 1), ae(this.s, 2, 0.5), ae(this.v, 2, 0.5), ae(this.h, 4, 0.5);
  }
  get baseOptions() {
    return Se(this.h, qe, 1);
  }
  set baseOptions(e) {
    le(this.h, 0, 1, e);
  }
  o(e) {
    return "numFaces" in e && Yn(this.s, 4, e.numFaces ?? 1), "minFaceDetectionConfidence" in e && ae(this.s, 2, e.minFaceDetectionConfidence ?? 0.5), "minTrackingConfidence" in e && ae(this.h, 4, e.minTrackingConfidence ?? 0.5), "minFacePresenceConfidence" in e && ae(this.v, 2, e.minFacePresenceConfidence ?? 0.5), "outputFaceBlendshapes" in e && (this.outputFaceBlendshapes = !!e.outputFaceBlendshapes), "outputFacialTransformationMatrixes" in e && (this.outputFacialTransformationMatrixes = !!e.outputFacialTransformationMatrixes), this.l(e);
  }
  D(e, t) {
    return Mp(this), _n(this, e, t), this.j;
  }
  F(e, t, r) {
    return Mp(this), Zn(this, e, r, t), this.j;
  }
  m() {
    var e = new Kt();
    We(e, "image_in"), We(e, "norm_rect"), Ae(e, "face_landmarks");
    const t = new an();
    Sn(t, kC, this.h);
    const r = new Ft();
    un(r, "mediapipe.tasks.vision.face_landmarker.FaceLandmarkerGraph"), Oe(r, "IMAGE:image_in"), Oe(r, "NORM_RECT:norm_rect"), Ee(r, "NORM_LANDMARKS:face_landmarks"), r.o(t), ln(e, r), this.g.attachProtoVectorListener("face_landmarks", (o, i) => {
      for (const a of o) o = sa(a), this.j.faceLandmarks.push(Ys(o));
      Y(this, i);
    }), this.g.attachEmptyPacketListener("face_landmarks", (o) => {
      Y(this, o);
    }), this.outputFaceBlendshapes && (Ae(e, "blendshapes"), Ee(r, "BLENDSHAPES:blendshapes"), this.g.attachProtoVectorListener("blendshapes", (o, i) => {
      if (this.outputFaceBlendshapes) for (const a of o) o = Js(a), this.j.faceBlendshapes.push(rf(o.g() ?? []));
      Y(this, i);
    }), this.g.attachEmptyPacketListener("blendshapes", (o) => {
      Y(this, o);
    })), this.outputFacialTransformationMatrixes && (Ae(e, "face_geometry"), Ee(r, "FACE_GEOMETRY:face_geometry"), this.g.attachProtoVectorListener("face_geometry", (o, i) => {
      if (this.outputFacialTransformationMatrixes) for (const a of o) (o = Se(RC(a), wC, 2)) && this.j.facialTransformationMatrixes.push({ rows: vn(o, 1) ?? 0 ?? 0, columns: vn(o, 2) ?? 0 ?? 0, data: io(o, 3, Kr, oo()).slice() ?? [] });
      Y(this, i);
    }), this.g.attachEmptyPacketListener("face_geometry", (o) => {
      Y(this, o);
    })), e = e.g(), this.setGraph(new Uint8Array(e), !0);
  }
};
je.prototype.detectForVideo = je.prototype.F, je.prototype.detect = je.prototype.D, je.prototype.setOptions = je.prototype.o, je.createFromModelPath = function(n, e) {
  return we(je, n, { baseOptions: { modelAssetPath: e } });
}, je.createFromModelBuffer = function(n, e) {
  return we(je, n, { baseOptions: { modelAssetBuffer: e } });
}, je.createFromOptions = function(n, e) {
  return we(je, n, e);
}, je.FACE_LANDMARKS_LIPS = cf, je.FACE_LANDMARKS_LEFT_EYE = ff, je.FACE_LANDMARKS_LEFT_EYEBROW = df, je.FACE_LANDMARKS_LEFT_IRIS = l1, je.FACE_LANDMARKS_RIGHT_EYE = hf, je.FACE_LANDMARKS_RIGHT_EYEBROW = pf, je.FACE_LANDMARKS_RIGHT_IRIS = c1, je.FACE_LANDMARKS_FACE_OVAL = mf, je.FACE_LANDMARKS_CONTOURS = f1, je.FACE_LANDMARKS_TESSELATION = d1;
var Bn = class extends $t {
  constructor(e, t) {
    super(new wn(e, t), "image_in", "norm_rect", !0), le(e = this.j = new Og(), 0, 1, t = new qe());
  }
  get baseOptions() {
    return Se(this.j, qe, 1);
  }
  set baseOptions(e) {
    le(this.j, 0, 1, e);
  }
  o(e) {
    return super.l(e);
  }
  Ka(e, t, r) {
    const o = typeof t != "function" ? t : {};
    if (this.h = typeof t == "function" ? t : r, _n(this, e, o ?? {}), !this.h) return this.s;
  }
  m() {
    var e = new Kt();
    We(e, "image_in"), We(e, "norm_rect"), Ae(e, "stylized_image");
    const t = new an();
    Sn(t, PC, this.j);
    const r = new Ft();
    un(r, "mediapipe.tasks.vision.face_stylizer.FaceStylizerGraph"), Oe(r, "IMAGE:image_in"), Oe(r, "NORM_RECT:norm_rect"), Ee(r, "STYLIZED_IMAGE:stylized_image"), r.o(t), ln(e, r), this.g.V("stylized_image", (o, i) => {
      var a = !this.h, s = o.data, u = o.width;
      const l = u * (o = o.height);
      if (s instanceof Uint8Array) if (s.length === 3 * l) {
        const c = new Uint8ClampedArray(4 * l);
        for (let f = 0; f < l; ++f) c[4 * f] = s[3 * f], c[4 * f + 1] = s[3 * f + 1], c[4 * f + 2] = s[3 * f + 2], c[4 * f + 3] = 255;
        s = new ImageData(c, u, o);
      } else {
        if (s.length !== 4 * l) throw Error("Unsupported channel count: " + s.length / l);
        s = new ImageData(new Uint8ClampedArray(s.buffer, s.byteOffset, s.length), u, o);
      }
      else if (!(s instanceof WebGLTexture)) throw Error(`Unsupported format: ${s.constructor.name}`);
      u = new xt([s], !1, !1, this.g.i.canvas, this.P, u, o), this.s = a = a ? u.clone() : u, this.h && this.h(a), Y(this, i);
    }), this.g.attachEmptyPacketListener("stylized_image", (o) => {
      this.s = null, this.h && this.h(null), Y(this, o);
    }), e = e.g(), this.setGraph(new Uint8Array(e), !0);
  }
};
Bn.prototype.stylize = Bn.prototype.Ka, Bn.prototype.setOptions = Bn.prototype.o, Bn.createFromModelPath = function(n, e) {
  return we(Bn, n, { baseOptions: { modelAssetPath: e } });
}, Bn.createFromModelBuffer = function(n, e) {
  return we(Bn, n, { baseOptions: { modelAssetBuffer: e } });
}, Bn.createFromOptions = function(n, e) {
  return we(Bn, n, e);
};
var vf = kn([0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [5, 6], [6, 7], [7, 8], [5, 9], [9, 10], [10, 11], [11, 12], [9, 13], [13, 14], [14, 15], [15, 16], [13, 17], [0, 17], [17, 18], [18, 19], [19, 20]);
function Dp(n) {
  n.gestures = [], n.landmarks = [], n.worldLandmarks = [], n.handedness = [];
}
function Fp(n) {
  return n.gestures.length === 0 ? { gestures: [], landmarks: [], worldLandmarks: [], handedness: [], handednesses: [] } : { gestures: n.gestures, landmarks: n.landmarks, worldLandmarks: n.worldLandmarks, handedness: n.handedness, handednesses: n.handedness };
}
function Lp(n, e = !0) {
  const t = [];
  for (const o of n) {
    var r = Js(o);
    n = [];
    for (const i of r.g()) r = e && vn(i, 1) != null ? vn(i, 1) ?? 0 : -1, n.push({ score: ot(i, 2) ?? 0, index: r, categoryName: xn(i, 3) ?? "" ?? "", displayName: xn(i, 4) ?? "" ?? "" });
    t.push(n);
  }
  return t;
}
var Xt = class extends $t {
  constructor(e, t) {
    super(new wn(e, t), "image_in", "norm_rect", !1), this.gestures = [], this.landmarks = [], this.worldLandmarks = [], this.handedness = [], le(e = this.j = new Gg(), 0, 1, t = new qe()), this.s = new jc(), le(this.j, 0, 2, this.s), this.C = new Zc(), le(this.s, 0, 3, this.C), this.v = new Vg(), le(this.s, 0, 2, this.v), this.h = new NC(), le(this.j, 0, 3, this.h), ae(this.v, 2, 0.5), ae(this.s, 4, 0.5), ae(this.C, 2, 0.5);
  }
  get baseOptions() {
    return Se(this.j, qe, 1);
  }
  set baseOptions(e) {
    le(this.j, 0, 1, e);
  }
  o(e) {
    var i, a, s, u;
    if (Yn(this.v, 3, e.numHands ?? 1), "minHandDetectionConfidence" in e && ae(this.v, 2, e.minHandDetectionConfidence ?? 0.5), "minTrackingConfidence" in e && ae(this.s, 4, e.minTrackingConfidence ?? 0.5), "minHandPresenceConfidence" in e && ae(this.C, 2, e.minHandPresenceConfidence ?? 0.5), e.cannedGesturesClassifierOptions) {
      var t = new So(), r = t, o = Nl(e.cannedGesturesClassifierOptions, (i = Se(this.h, So, 3)) == null ? void 0 : i.h());
      le(r, 0, 2, o), le(this.h, 0, 3, t);
    } else e.cannedGesturesClassifierOptions === void 0 && ((a = Se(this.h, So, 3)) == null || a.g());
    return e.customGesturesClassifierOptions ? (le(r = t = new So(), 0, 2, o = Nl(e.customGesturesClassifierOptions, (s = Se(this.h, So, 4)) == null ? void 0 : s.h())), le(this.h, 0, 4, t)) : e.customGesturesClassifierOptions === void 0 && ((u = Se(this.h, So, 4)) == null || u.g()), this.l(e);
  }
  Fa(e, t) {
    return Dp(this), _n(this, e, t), Fp(this);
  }
  Ga(e, t, r) {
    return Dp(this), Zn(this, e, r, t), Fp(this);
  }
  m() {
    var e = new Kt();
    We(e, "image_in"), We(e, "norm_rect"), Ae(e, "hand_gestures"), Ae(e, "hand_landmarks"), Ae(e, "world_hand_landmarks"), Ae(e, "handedness");
    const t = new an();
    Sn(t, MC, this.j);
    const r = new Ft();
    un(r, "mediapipe.tasks.vision.gesture_recognizer.GestureRecognizerGraph"), Oe(r, "IMAGE:image_in"), Oe(r, "NORM_RECT:norm_rect"), Ee(r, "HAND_GESTURES:hand_gestures"), Ee(r, "LANDMARKS:hand_landmarks"), Ee(r, "WORLD_LANDMARKS:world_hand_landmarks"), Ee(r, "HANDEDNESS:handedness"), r.o(t), ln(e, r), this.g.attachProtoVectorListener("hand_landmarks", (o, i) => {
      for (const a of o) {
        o = sa(a);
        const s = [];
        for (const u of mr(o, kg, 1)) s.push({ x: ot(u, 1) ?? 0, y: ot(u, 2) ?? 0, z: ot(u, 3) ?? 0, visibility: ot(u, 4) ?? 0 });
        this.landmarks.push(s);
      }
      Y(this, i);
    }), this.g.attachEmptyPacketListener("hand_landmarks", (o) => {
      Y(this, o);
    }), this.g.attachProtoVectorListener("world_hand_landmarks", (o, i) => {
      for (const a of o) {
        o = $o(a);
        const s = [];
        for (const u of mr(o, Rg, 1)) s.push({ x: ot(u, 1) ?? 0, y: ot(u, 2) ?? 0, z: ot(u, 3) ?? 0, visibility: ot(u, 4) ?? 0 });
        this.worldLandmarks.push(s);
      }
      Y(this, i);
    }), this.g.attachEmptyPacketListener("world_hand_landmarks", (o) => {
      Y(this, o);
    }), this.g.attachProtoVectorListener("hand_gestures", (o, i) => {
      this.gestures.push(...Lp(o, !1)), Y(this, i);
    }), this.g.attachEmptyPacketListener("hand_gestures", (o) => {
      Y(this, o);
    }), this.g.attachProtoVectorListener("handedness", (o, i) => {
      this.handedness.push(...Lp(o)), Y(this, i);
    }), this.g.attachEmptyPacketListener("handedness", (o) => {
      Y(this, o);
    }), e = e.g(), this.setGraph(new Uint8Array(e), !0);
  }
};
function Bp(n) {
  return { landmarks: n.landmarks, worldLandmarks: n.worldLandmarks, handednesses: n.handedness, handedness: n.handedness };
}
Xt.prototype.recognizeForVideo = Xt.prototype.Ga, Xt.prototype.recognize = Xt.prototype.Fa, Xt.prototype.setOptions = Xt.prototype.o, Xt.createFromModelPath = function(n, e) {
  return we(Xt, n, { baseOptions: { modelAssetPath: e } });
}, Xt.createFromModelBuffer = function(n, e) {
  return we(Xt, n, { baseOptions: { modelAssetBuffer: e } });
}, Xt.createFromOptions = function(n, e) {
  return we(Xt, n, e);
}, Xt.HAND_CONNECTIONS = vf;
var Yt = class extends $t {
  constructor(e, t) {
    super(new wn(e, t), "image_in", "norm_rect", !1), this.landmarks = [], this.worldLandmarks = [], this.handedness = [], le(e = this.h = new jc(), 0, 1, t = new qe()), this.s = new Zc(), le(this.h, 0, 3, this.s), this.j = new Vg(), le(this.h, 0, 2, this.j), Yn(this.j, 3, 1), ae(this.j, 2, 0.5), ae(this.s, 2, 0.5), ae(this.h, 4, 0.5);
  }
  get baseOptions() {
    return Se(this.h, qe, 1);
  }
  set baseOptions(e) {
    le(this.h, 0, 1, e);
  }
  o(e) {
    return "numHands" in e && Yn(this.j, 3, e.numHands ?? 1), "minHandDetectionConfidence" in e && ae(this.j, 2, e.minHandDetectionConfidence ?? 0.5), "minTrackingConfidence" in e && ae(this.h, 4, e.minTrackingConfidence ?? 0.5), "minHandPresenceConfidence" in e && ae(this.s, 2, e.minHandPresenceConfidence ?? 0.5), this.l(e);
  }
  D(e, t) {
    return this.landmarks = [], this.worldLandmarks = [], this.handedness = [], _n(this, e, t), Bp(this);
  }
  F(e, t, r) {
    return this.landmarks = [], this.worldLandmarks = [], this.handedness = [], Zn(this, e, r, t), Bp(this);
  }
  m() {
    var e = new Kt();
    We(e, "image_in"), We(e, "norm_rect"), Ae(e, "hand_landmarks"), Ae(e, "world_hand_landmarks"), Ae(e, "handedness");
    const t = new an();
    Sn(t, DC, this.h);
    const r = new Ft();
    un(r, "mediapipe.tasks.vision.hand_landmarker.HandLandmarkerGraph"), Oe(r, "IMAGE:image_in"), Oe(r, "NORM_RECT:norm_rect"), Ee(r, "LANDMARKS:hand_landmarks"), Ee(r, "WORLD_LANDMARKS:world_hand_landmarks"), Ee(r, "HANDEDNESS:handedness"), r.o(t), ln(e, r), this.g.attachProtoVectorListener("hand_landmarks", (o, i) => {
      for (const a of o) o = sa(a), this.landmarks.push(Ys(o));
      Y(this, i);
    }), this.g.attachEmptyPacketListener("hand_landmarks", (o) => {
      Y(this, o);
    }), this.g.attachProtoVectorListener("world_hand_landmarks", (o, i) => {
      for (const a of o) o = $o(a), this.worldLandmarks.push(Vi(o));
      Y(this, i);
    }), this.g.attachEmptyPacketListener("world_hand_landmarks", (o) => {
      Y(this, o);
    }), this.g.attachProtoVectorListener("handedness", (o, i) => {
      var a = this.handedness, s = a.push;
      const u = [];
      for (const l of o) {
        o = Js(l);
        const c = [];
        for (const f of o.g()) c.push({ score: ot(f, 2) ?? 0, index: vn(f, 1) ?? 0 ?? -1, categoryName: xn(f, 3) ?? "" ?? "", displayName: xn(f, 4) ?? "" ?? "" });
        u.push(c);
      }
      s.call(a, ...u), Y(this, i);
    }), this.g.attachEmptyPacketListener("handedness", (o) => {
      Y(this, o);
    }), e = e.g(), this.setGraph(new Uint8Array(e), !0);
  }
};
Yt.prototype.detectForVideo = Yt.prototype.F, Yt.prototype.detect = Yt.prototype.D, Yt.prototype.setOptions = Yt.prototype.o, Yt.createFromModelPath = function(n, e) {
  return we(Yt, n, { baseOptions: { modelAssetPath: e } });
}, Yt.createFromModelBuffer = function(n, e) {
  return we(Yt, n, { baseOptions: { modelAssetBuffer: e } });
}, Yt.createFromOptions = function(n, e) {
  return we(Yt, n, e);
}, Yt.HAND_CONNECTIONS = vf;
var h1 = kn([0, 1], [1, 2], [2, 3], [3, 7], [0, 4], [4, 5], [5, 6], [6, 8], [9, 10], [11, 12], [11, 13], [13, 15], [15, 17], [15, 19], [15, 21], [17, 19], [12, 14], [14, 16], [16, 18], [16, 20], [16, 22], [18, 20], [11, 23], [12, 24], [23, 24], [23, 25], [24, 26], [25, 27], [26, 28], [27, 29], [28, 30], [29, 31], [30, 32], [27, 31], [28, 32]);
function Op(n) {
  n.h = { faceLandmarks: [], faceBlendshapes: [], poseLandmarks: [], poseWorldLandmarks: [], poseSegmentationMasks: [], leftHandLandmarks: [], leftHandWorldLandmarks: [], rightHandLandmarks: [], rightHandWorldLandmarks: [] };
}
function Up(n) {
  try {
    if (!n.C) return n.h;
    n.C(n.h);
  } finally {
    Zs(n);
  }
}
function ba(n, e) {
  n = sa(n), e.push(Ys(n));
}
var He = class extends $t {
  constructor(e, t) {
    super(new wn(e, t), "input_frames_image", null, !1), this.h = { faceLandmarks: [], faceBlendshapes: [], poseLandmarks: [], poseWorldLandmarks: [], poseSegmentationMasks: [], leftHandLandmarks: [], leftHandWorldLandmarks: [], rightHandLandmarks: [], rightHandWorldLandmarks: [] }, this.outputPoseSegmentationMasks = this.outputFaceBlendshapes = !1, le(e = this.j = new zg(), 0, 1, t = new qe()), this.K = new Zc(), le(this.j, 0, 2, this.K), this.Y = new FC(), le(this.j, 0, 3, this.Y), this.s = new Xs(), le(this.j, 0, 4, this.s), this.H = new Fg(), le(this.j, 0, 5, this.H), this.v = new $g(), le(this.j, 0, 6, this.v), this.L = new qg(), le(this.j, 0, 7, this.L), ae(this.s, 2, 0.5), ae(this.s, 3, 0.3), ae(this.H, 2, 0.5), ae(this.v, 2, 0.5), ae(this.v, 3, 0.3), ae(this.L, 2, 0.5), ae(this.K, 2, 0.5);
  }
  get baseOptions() {
    return Se(this.j, qe, 1);
  }
  set baseOptions(e) {
    le(this.j, 0, 1, e);
  }
  o(e) {
    return "minFaceDetectionConfidence" in e && ae(this.s, 2, e.minFaceDetectionConfidence ?? 0.5), "minFaceSuppressionThreshold" in e && ae(this.s, 3, e.minFaceSuppressionThreshold ?? 0.3), "minFacePresenceConfidence" in e && ae(this.H, 2, e.minFacePresenceConfidence ?? 0.5), "outputFaceBlendshapes" in e && (this.outputFaceBlendshapes = !!e.outputFaceBlendshapes), "minPoseDetectionConfidence" in e && ae(this.v, 2, e.minPoseDetectionConfidence ?? 0.5), "minPoseSuppressionThreshold" in e && ae(this.v, 3, e.minPoseSuppressionThreshold ?? 0.3), "minPosePresenceConfidence" in e && ae(this.L, 2, e.minPosePresenceConfidence ?? 0.5), "outputPoseSegmentationMasks" in e && (this.outputPoseSegmentationMasks = !!e.outputPoseSegmentationMasks), "minHandLandmarksConfidence" in e && ae(this.K, 2, e.minHandLandmarksConfidence ?? 0.5), this.l(e);
  }
  D(e, t, r) {
    const o = typeof t != "function" ? t : {};
    return this.C = typeof t == "function" ? t : r, Op(this), _n(this, e, o), Up(this);
  }
  F(e, t, r, o) {
    const i = typeof r != "function" ? r : {};
    return this.C = typeof r == "function" ? r : o, Op(this), Zn(this, e, i, t), Up(this);
  }
  m() {
    var e = new Kt();
    We(e, "input_frames_image"), Ae(e, "pose_landmarks"), Ae(e, "pose_world_landmarks"), Ae(e, "face_landmarks"), Ae(e, "left_hand_landmarks"), Ae(e, "left_hand_world_landmarks"), Ae(e, "right_hand_landmarks"), Ae(e, "right_hand_world_landmarks");
    const t = new an(), r = new up();
    Il(r, 1, wi("type.googleapis.com/mediapipe.tasks.vision.holistic_landmarker.proto.HolisticLandmarkerGraphOptions"), ""), function(i, a) {
      if (a != null) if (Array.isArray(a)) Be(i, 2, Fs(a, Sc, void 0, void 0, !1));
      else {
        if (!(typeof a == "string" || a instanceof dr || fo(a))) throw Error("invalid value in Any.value field: " + a + " expected a ByteString, a base64 encoded string, a Uint8Array or a jspb array");
        Il(i, 2, xc(a, !1), ho());
      }
    }(r, this.j.g());
    const o = new Ft();
    un(o, "mediapipe.tasks.vision.holistic_landmarker.HolisticLandmarkerGraph"), Ja(o, 8, up, r), Oe(o, "IMAGE:input_frames_image"), Ee(o, "POSE_LANDMARKS:pose_landmarks"), Ee(o, "POSE_WORLD_LANDMARKS:pose_world_landmarks"), Ee(o, "FACE_LANDMARKS:face_landmarks"), Ee(o, "LEFT_HAND_LANDMARKS:left_hand_landmarks"), Ee(o, "LEFT_HAND_WORLD_LANDMARKS:left_hand_world_landmarks"), Ee(o, "RIGHT_HAND_LANDMARKS:right_hand_landmarks"), Ee(o, "RIGHT_HAND_WORLD_LANDMARKS:right_hand_world_landmarks"), o.o(t), ln(e, o), Qs(this, e), this.g.attachProtoListener("pose_landmarks", (i, a) => {
      ba(i, this.h.poseLandmarks), Y(this, a);
    }), this.g.attachEmptyPacketListener("pose_landmarks", (i) => {
      Y(this, i);
    }), this.g.attachProtoListener("pose_world_landmarks", (i, a) => {
      var s = this.h.poseWorldLandmarks;
      i = $o(i), s.push(Vi(i)), Y(this, a);
    }), this.g.attachEmptyPacketListener("pose_world_landmarks", (i) => {
      Y(this, i);
    }), this.outputPoseSegmentationMasks && (Ee(o, "POSE_SEGMENTATION_MASK:pose_segmentation_mask"), ai(this, "pose_segmentation_mask"), this.g.V("pose_segmentation_mask", (i, a) => {
      this.h.poseSegmentationMasks = [li(this, i, !0, !this.C)], Y(this, a);
    }), this.g.attachEmptyPacketListener("pose_segmentation_mask", (i) => {
      this.h.poseSegmentationMasks = [], Y(this, i);
    })), this.g.attachProtoListener("face_landmarks", (i, a) => {
      ba(i, this.h.faceLandmarks), Y(this, a);
    }), this.g.attachEmptyPacketListener("face_landmarks", (i) => {
      Y(this, i);
    }), this.outputFaceBlendshapes && (Ae(e, "extra_blendshapes"), Ee(o, "FACE_BLENDSHAPES:extra_blendshapes"), this.g.attachProtoListener("extra_blendshapes", (i, a) => {
      var s = this.h.faceBlendshapes;
      this.outputFaceBlendshapes && (i = Js(i), s.push(rf(i.g() ?? []))), Y(this, a);
    }), this.g.attachEmptyPacketListener("extra_blendshapes", (i) => {
      Y(this, i);
    })), this.g.attachProtoListener("left_hand_landmarks", (i, a) => {
      ba(i, this.h.leftHandLandmarks), Y(this, a);
    }), this.g.attachEmptyPacketListener("left_hand_landmarks", (i) => {
      Y(this, i);
    }), this.g.attachProtoListener("left_hand_world_landmarks", (i, a) => {
      var s = this.h.leftHandWorldLandmarks;
      i = $o(i), s.push(Vi(i)), Y(this, a);
    }), this.g.attachEmptyPacketListener("left_hand_world_landmarks", (i) => {
      Y(this, i);
    }), this.g.attachProtoListener("right_hand_landmarks", (i, a) => {
      ba(i, this.h.rightHandLandmarks), Y(this, a);
    }), this.g.attachEmptyPacketListener("right_hand_landmarks", (i) => {
      Y(this, i);
    }), this.g.attachProtoListener("right_hand_world_landmarks", (i, a) => {
      var s = this.h.rightHandWorldLandmarks;
      i = $o(i), s.push(Vi(i)), Y(this, a);
    }), this.g.attachEmptyPacketListener("right_hand_world_landmarks", (i) => {
      Y(this, i);
    }), e = e.g(), this.setGraph(new Uint8Array(e), !0);
  }
};
He.prototype.detectForVideo = He.prototype.F, He.prototype.detect = He.prototype.D, He.prototype.setOptions = He.prototype.o, He.createFromModelPath = function(n, e) {
  return we(He, n, { baseOptions: { modelAssetPath: e } });
}, He.createFromModelBuffer = function(n, e) {
  return we(He, n, { baseOptions: { modelAssetBuffer: e } });
}, He.createFromOptions = function(n, e) {
  return we(He, n, e);
}, He.HAND_CONNECTIONS = vf, He.POSE_CONNECTIONS = h1, He.FACE_LANDMARKS_LIPS = cf, He.FACE_LANDMARKS_LEFT_EYE = ff, He.FACE_LANDMARKS_LEFT_EYEBROW = df, He.FACE_LANDMARKS_LEFT_IRIS = l1, He.FACE_LANDMARKS_RIGHT_EYE = hf, He.FACE_LANDMARKS_RIGHT_EYEBROW = pf, He.FACE_LANDMARKS_RIGHT_IRIS = c1, He.FACE_LANDMARKS_FACE_OVAL = mf, He.FACE_LANDMARKS_CONTOURS = f1, He.FACE_LANDMARKS_TESSELATION = d1;
var fn = class extends $t {
  constructor(e, t) {
    super(new wn(e, t), "input_image", "norm_rect", !0), this.j = { classifications: [] }, le(e = this.h = new Kg(), 0, 1, t = new qe());
  }
  get baseOptions() {
    return Se(this.h, qe, 1);
  }
  set baseOptions(e) {
    le(this.h, 0, 1, e);
  }
  o(e) {
    return le(this.h, 0, 2, Nl(e, Se(this.h, Xc, 2))), this.l(e);
  }
  qa(e, t) {
    return this.j = { classifications: [] }, _n(this, e, t), this.j;
  }
  ra(e, t, r) {
    return this.j = { classifications: [] }, Zn(this, e, r, t), this.j;
  }
  m() {
    var e = new Kt();
    We(e, "input_image"), We(e, "norm_rect"), Ae(e, "classifications");
    const t = new an();
    Sn(t, LC, this.h);
    const r = new Ft();
    un(r, "mediapipe.tasks.vision.image_classifier.ImageClassifierGraph"), Oe(r, "IMAGE:input_image"), Oe(r, "NORM_RECT:norm_rect"), Ee(r, "CLASSIFICATIONS:classifications"), r.o(t), ln(e, r), this.g.attachProtoListener("classifications", (o, i) => {
      this.j = function(a) {
        const s = { classifications: mr(a, bC, 1).map((u) => {
          var l;
          return rf(((l = Se(u, Ig, 4)) == null ? void 0 : l.g()) ?? [], vn(u, 2) ?? 0, xn(u, 3) ?? "");
        }) };
        return El(oi(a, 2)) != null && (s.timestampMs = El(oi(a, 2)) ?? 0), s;
      }(EC(o)), Y(this, i);
    }), this.g.attachEmptyPacketListener("classifications", (o) => {
      Y(this, o);
    }), e = e.g(), this.setGraph(new Uint8Array(e), !0);
  }
};
fn.prototype.classifyForVideo = fn.prototype.ra, fn.prototype.classify = fn.prototype.qa, fn.prototype.setOptions = fn.prototype.o, fn.createFromModelPath = function(n, e) {
  return we(fn, n, { baseOptions: { modelAssetPath: e } });
}, fn.createFromModelBuffer = function(n, e) {
  return we(fn, n, { baseOptions: { modelAssetBuffer: e } });
}, fn.createFromOptions = function(n, e) {
  return we(fn, n, e);
};
var Qt = class extends $t {
  constructor(e, t) {
    super(new wn(e, t), "image_in", "norm_rect", !0), this.h = new Jg(), this.embeddings = { embeddings: [] }, le(e = this.h, 0, 1, t = new qe());
  }
  get baseOptions() {
    return Se(this.h, qe, 1);
  }
  set baseOptions(e) {
    le(this.h, 0, 1, e);
  }
  o(e) {
    var t = this.h, r = Se(this.h, gp, 2);
    return r = r ? r.clone() : new gp(), e.l2Normalize !== void 0 ? Xi(r, 1, e.l2Normalize) : "l2Normalize" in e && Be(r, 1), e.quantize !== void 0 ? Xi(r, 2, e.quantize) : "quantize" in e && Be(r, 2), le(t, 0, 2, r), this.l(e);
  }
  xa(e, t) {
    return _n(this, e, t), this.embeddings;
  }
  ya(e, t, r) {
    return Zn(this, e, r, t), this.embeddings;
  }
  m() {
    var e = new Kt();
    We(e, "image_in"), We(e, "norm_rect"), Ae(e, "embeddings_out");
    const t = new an();
    Sn(t, BC, this.h);
    const r = new Ft();
    un(r, "mediapipe.tasks.vision.image_embedder.ImageEmbedderGraph"), Oe(r, "IMAGE:image_in"), Oe(r, "NORM_RECT:norm_rect"), Ee(r, "EMBEDDINGS:embeddings_out"), r.o(t), ln(e, r), this.g.attachProtoListener("embeddings_out", (o, i) => {
      o = IC(o), this.embeddings = function(a) {
        return { embeddings: mr(a, TC, 1).map((s) => {
          var l, c;
          const u = { headIndex: vn(s, 3) ?? 0 ?? -1, headName: xn(s, 4) ?? "" ?? "" };
          if (zv(s, vp, ku(s, 1)) !== void 0) s = io(s = Se(s, vp, ku(s, 1)), 1, Kr, oo()), u.floatEmbedding = s.slice();
          else {
            const f = new Uint8Array(0);
            u.quantizedEmbedding = ((c = (l = Se(s, CC, ku(s, 2))) == null ? void 0 : l.ma()) == null ? void 0 : c.h()) ?? f;
          }
          return u;
        }), timestampMs: El(oi(a, 2)) ?? 0 };
      }(o), Y(this, i);
    }), this.g.attachEmptyPacketListener("embeddings_out", (o) => {
      Y(this, o);
    }), e = e.g(), this.setGraph(new Uint8Array(e), !0);
  }
};
Qt.cosineSimilarity = function(n, e) {
  if (n.floatEmbedding && e.floatEmbedding) n = bp(n.floatEmbedding, e.floatEmbedding);
  else {
    if (!n.quantizedEmbedding || !e.quantizedEmbedding) throw Error("Cannot compute cosine similarity between quantized and float embeddings.");
    n = bp(_p(n.quantizedEmbedding), _p(e.quantizedEmbedding));
  }
  return n;
}, Qt.prototype.embedForVideo = Qt.prototype.ya, Qt.prototype.embed = Qt.prototype.xa, Qt.prototype.setOptions = Qt.prototype.o, Qt.createFromModelPath = function(n, e) {
  return we(Qt, n, { baseOptions: { modelAssetPath: e } });
}, Qt.createFromModelBuffer = function(n, e) {
  return we(Qt, n, { baseOptions: { modelAssetBuffer: e } });
}, Qt.createFromOptions = function(n, e) {
  return we(Qt, n, e);
};
var Ll = class {
  constructor(e, t, r) {
    this.confidenceMasks = e, this.categoryMask = t, this.qualityScores = r;
  }
  close() {
    var e, t;
    (e = this.confidenceMasks) == null || e.forEach((r) => {
      r.close();
    }), (t = this.categoryMask) == null || t.close();
  }
};
function Vp(n) {
  n.categoryMask = void 0, n.confidenceMasks = void 0, n.qualityScores = void 0;
}
function Gp(n) {
  try {
    const e = new Ll(n.confidenceMasks, n.categoryMask, n.qualityScores);
    if (!n.j) return e;
    n.j(e);
  } finally {
    Zs(n);
  }
}
Ll.prototype.close = Ll.prototype.close;
var Ot = class extends $t {
  constructor(e, t) {
    super(new wn(e, t), "image_in", "norm_rect", !1), this.s = [], this.outputCategoryMask = !1, this.outputConfidenceMasks = !0, this.h = new nf(), this.v = new Xg(), le(this.h, 0, 3, this.v), le(e = this.h, 0, 1, t = new qe());
  }
  get baseOptions() {
    return Se(this.h, qe, 1);
  }
  set baseOptions(e) {
    le(this.h, 0, 1, e);
  }
  o(e) {
    return e.displayNamesLocale !== void 0 ? Be(this.h, 2, wi(e.displayNamesLocale)) : "displayNamesLocale" in e && Be(this.h, 2), "outputCategoryMask" in e && (this.outputCategoryMask = e.outputCategoryMask ?? !1), "outputConfidenceMasks" in e && (this.outputConfidenceMasks = e.outputConfidenceMasks ?? !0), super.l(e);
  }
  J() {
    (function(e) {
      var r, o;
      const t = mr(e.ca(), Ft, 1).filter((i) => (xn(i, 1) ?? "").includes("mediapipe.tasks.TensorsToSegmentationCalculator"));
      if (e.s = [], t.length > 1) throw Error("The graph has more than one mediapipe.tasks.TensorsToSegmentationCalculator.");
      t.length === 1 && (((o = (r = Se(t[0], an, 7)) == null ? void 0 : r.l()) == null ? void 0 : o.g()) ?? /* @__PURE__ */ new Map()).forEach((i, a) => {
        e.s[Number(a)] = xn(i, 1) ?? "";
      });
    })(this);
  }
  segment(e, t, r) {
    const o = typeof t != "function" ? t : {};
    return this.j = typeof t == "function" ? t : r, Vp(this), _n(this, e, o), Gp(this);
  }
  Ia(e, t, r, o) {
    const i = typeof r != "function" ? r : {};
    return this.j = typeof r == "function" ? r : o, Vp(this), Zn(this, e, i, t), Gp(this);
  }
  Ba() {
    return this.s;
  }
  m() {
    var e = new Kt();
    We(e, "image_in"), We(e, "norm_rect");
    const t = new an();
    Sn(t, Qg, this.h);
    const r = new Ft();
    un(r, "mediapipe.tasks.vision.image_segmenter.ImageSegmenterGraph"), Oe(r, "IMAGE:image_in"), Oe(r, "NORM_RECT:norm_rect"), r.o(t), ln(e, r), Qs(this, e), this.outputConfidenceMasks && (Ae(e, "confidence_masks"), Ee(r, "CONFIDENCE_MASKS:confidence_masks"), ai(this, "confidence_masks"), this.g.ba("confidence_masks", (o, i) => {
      this.confidenceMasks = o.map((a) => li(this, a, !0, !this.j)), Y(this, i);
    }), this.g.attachEmptyPacketListener("confidence_masks", (o) => {
      this.confidenceMasks = [], Y(this, o);
    })), this.outputCategoryMask && (Ae(e, "category_mask"), Ee(r, "CATEGORY_MASK:category_mask"), ai(this, "category_mask"), this.g.V("category_mask", (o, i) => {
      this.categoryMask = li(this, o, !1, !this.j), Y(this, i);
    }), this.g.attachEmptyPacketListener("category_mask", (o) => {
      this.categoryMask = void 0, Y(this, o);
    })), Ae(e, "quality_scores"), Ee(r, "QUALITY_SCORES:quality_scores"), this.g.attachFloatVectorListener("quality_scores", (o, i) => {
      this.qualityScores = o, Y(this, i);
    }), this.g.attachEmptyPacketListener("quality_scores", (o) => {
      this.categoryMask = void 0, Y(this, o);
    }), e = e.g(), this.setGraph(new Uint8Array(e), !0);
  }
};
Ot.prototype.getLabels = Ot.prototype.Ba, Ot.prototype.segmentForVideo = Ot.prototype.Ia, Ot.prototype.segment = Ot.prototype.segment, Ot.prototype.setOptions = Ot.prototype.o, Ot.createFromModelPath = function(n, e) {
  return we(Ot, n, { baseOptions: { modelAssetPath: e } });
}, Ot.createFromModelBuffer = function(n, e) {
  return we(Ot, n, { baseOptions: { modelAssetBuffer: e } });
}, Ot.createFromOptions = function(n, e) {
  return we(Ot, n, e);
};
var Bl = class {
  constructor(e, t, r) {
    this.confidenceMasks = e, this.categoryMask = t, this.qualityScores = r;
  }
  close() {
    var e, t;
    (e = this.confidenceMasks) == null || e.forEach((r) => {
      r.close();
    }), (t = this.categoryMask) == null || t.close();
  }
};
Bl.prototype.close = Bl.prototype.close;
var qC = class extends te {
  constructor(e) {
    super(e);
  }
}, Ao = [0, nt, -2], Za = [0, ur, -3, $e, ur, -1], Wp = [0, Za], Hp = [0, Za, nt, -1], Lu = class extends te {
  constructor(e) {
    super(e);
  }
}, $p = [0, ur, -1, $e], zC = class extends te {
  constructor(e) {
    super(e);
  }
}, qp = class extends te {
  constructor(e) {
    super(e);
  }
}, Ol = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14, 15], p1 = class extends te {
  constructor(e) {
    super(e);
  }
};
p1.prototype.g = Ks([0, dt, [0, Ol, Ne, Za, Ne, [0, Za, Ao], Ne, Wp, Ne, [0, Wp, Ao], Ne, $p, Ne, [0, ur, -3, $e, rn], Ne, [0, ur, -3, $e], Ne, [0, Me, ur, -2, $e, nt, $e, -1, 2, ur, Ao], Ne, Hp, Ne, [0, Hp, Ao], ur, Ao, Me, Ne, [0, ur, -3, $e, Ao, -1], Ne, [0, dt, $p]], Me, [0, Me, nt, -1, $e]]);
var On = class extends $t {
  constructor(e, t) {
    super(new wn(e, t), "image_in", "norm_rect_in", !1), this.outputCategoryMask = !1, this.outputConfidenceMasks = !0, this.h = new nf(), this.s = new Xg(), le(this.h, 0, 3, this.s), le(e = this.h, 0, 1, t = new qe());
  }
  get baseOptions() {
    return Se(this.h, qe, 1);
  }
  set baseOptions(e) {
    le(this.h, 0, 1, e);
  }
  o(e) {
    return "outputCategoryMask" in e && (this.outputCategoryMask = e.outputCategoryMask ?? !1), "outputConfidenceMasks" in e && (this.outputConfidenceMasks = e.outputConfidenceMasks ?? !0), super.l(e);
  }
  segment(e, t, r, o) {
    const i = typeof r != "function" ? r : {};
    this.j = typeof r == "function" ? r : o, this.qualityScores = this.categoryMask = this.confidenceMasks = void 0, r = this.B + 1, o = new p1();
    const a = new qp();
    var s = new qC();
    if (Yn(s, 1, 255), le(a, 0, 12, s), t.keypoint && t.scribble) throw Error("Cannot provide both keypoint and scribble.");
    if (t.keypoint) {
      var u = new Lu();
      Xi(u, 3, !0), ae(u, 1, t.keypoint.x), ae(u, 2, t.keypoint.y), Oi(a, 5, Ol, u);
    } else {
      if (!t.scribble) throw Error("Must provide either a keypoint or a scribble.");
      for (u of (s = new zC(), t.scribble)) Xi(t = new Lu(), 3, !0), ae(t, 1, u.x), ae(t, 2, u.y), Ja(s, 1, Lu, t);
      Oi(a, 15, Ol, s);
    }
    Ja(o, 1, qp, a), this.g.addProtoToStream(o.g(), "drishti.RenderData", "roi_in", r), _n(this, e, i);
    e: {
      try {
        const c = new Bl(this.confidenceMasks, this.categoryMask, this.qualityScores);
        if (!this.j) {
          var l = c;
          break e;
        }
        this.j(c);
      } finally {
        Zs(this);
      }
      l = void 0;
    }
    return l;
  }
  m() {
    var e = new Kt();
    We(e, "image_in"), We(e, "roi_in"), We(e, "norm_rect_in");
    const t = new an();
    Sn(t, Qg, this.h);
    const r = new Ft();
    un(r, "mediapipe.tasks.vision.interactive_segmenter.InteractiveSegmenterGraph"), Oe(r, "IMAGE:image_in"), Oe(r, "ROI:roi_in"), Oe(r, "NORM_RECT:norm_rect_in"), r.o(t), ln(e, r), Qs(this, e), this.outputConfidenceMasks && (Ae(e, "confidence_masks"), Ee(r, "CONFIDENCE_MASKS:confidence_masks"), ai(this, "confidence_masks"), this.g.ba("confidence_masks", (o, i) => {
      this.confidenceMasks = o.map((a) => li(this, a, !0, !this.j)), Y(this, i);
    }), this.g.attachEmptyPacketListener("confidence_masks", (o) => {
      this.confidenceMasks = [], Y(this, o);
    })), this.outputCategoryMask && (Ae(e, "category_mask"), Ee(r, "CATEGORY_MASK:category_mask"), ai(this, "category_mask"), this.g.V("category_mask", (o, i) => {
      this.categoryMask = li(this, o, !1, !this.j), Y(this, i);
    }), this.g.attachEmptyPacketListener("category_mask", (o) => {
      this.categoryMask = void 0, Y(this, o);
    })), Ae(e, "quality_scores"), Ee(r, "QUALITY_SCORES:quality_scores"), this.g.attachFloatVectorListener("quality_scores", (o, i) => {
      this.qualityScores = o, Y(this, i);
    }), this.g.attachEmptyPacketListener("quality_scores", (o) => {
      this.categoryMask = void 0, Y(this, o);
    }), e = e.g(), this.setGraph(new Uint8Array(e), !0);
  }
};
On.prototype.segment = On.prototype.segment, On.prototype.setOptions = On.prototype.o, On.createFromModelPath = function(n, e) {
  return we(On, n, { baseOptions: { modelAssetPath: e } });
}, On.createFromModelBuffer = function(n, e) {
  return we(On, n, { baseOptions: { modelAssetBuffer: e } });
}, On.createFromOptions = function(n, e) {
  return we(On, n, e);
};
var dn = class extends $t {
  constructor(e, t) {
    super(new wn(e, t), "input_frame_gpu", "norm_rect", !1), this.j = { detections: [] }, le(e = this.h = new Zg(), 0, 1, t = new qe());
  }
  get baseOptions() {
    return Se(this.h, qe, 1);
  }
  set baseOptions(e) {
    le(this.h, 0, 1, e);
  }
  o(e) {
    return e.displayNamesLocale !== void 0 ? Be(this.h, 2, wi(e.displayNamesLocale)) : "displayNamesLocale" in e && Be(this.h, 2), e.maxResults !== void 0 ? Yn(this.h, 3, e.maxResults) : "maxResults" in e && Be(this.h, 3), e.scoreThreshold !== void 0 ? ae(this.h, 4, e.scoreThreshold) : "scoreThreshold" in e && Be(this.h, 4), e.categoryAllowlist !== void 0 ? Xa(this.h, 5, e.categoryAllowlist) : "categoryAllowlist" in e && Be(this.h, 5), e.categoryDenylist !== void 0 ? Xa(this.h, 6, e.categoryDenylist) : "categoryDenylist" in e && Be(this.h, 6), this.l(e);
  }
  D(e, t) {
    return this.j = { detections: [] }, _n(this, e, t), this.j;
  }
  F(e, t, r) {
    return this.j = { detections: [] }, Zn(this, e, r, t), this.j;
  }
  m() {
    var e = new Kt();
    We(e, "input_frame_gpu"), We(e, "norm_rect"), Ae(e, "detections");
    const t = new an();
    Sn(t, UC, this.h);
    const r = new Ft();
    un(r, "mediapipe.tasks.vision.ObjectDetectorGraph"), Oe(r, "IMAGE:input_frame_gpu"), Oe(r, "NORM_RECT:norm_rect"), Ee(r, "DETECTIONS:detections"), r.o(t), ln(e, r), this.g.attachProtoVectorListener("detections", (o, i) => {
      for (const a of o) o = Ag(a), this.j.detections.push(e1(o));
      Y(this, i);
    }), this.g.attachEmptyPacketListener("detections", (o) => {
      Y(this, o);
    }), e = e.g(), this.setGraph(new Uint8Array(e), !0);
  }
};
dn.prototype.detectForVideo = dn.prototype.F, dn.prototype.detect = dn.prototype.D, dn.prototype.setOptions = dn.prototype.o, dn.createFromModelPath = async function(n, e) {
  return we(dn, n, { baseOptions: { modelAssetPath: e } });
}, dn.createFromModelBuffer = function(n, e) {
  return we(dn, n, { baseOptions: { modelAssetBuffer: e } });
}, dn.createFromOptions = function(n, e) {
  return we(dn, n, e);
};
var Ul = class {
  constructor(e, t, r) {
    this.landmarks = e, this.worldLandmarks = t, this.segmentationMasks = r;
  }
  close() {
    var e;
    (e = this.segmentationMasks) == null || e.forEach((t) => {
      t.close();
    });
  }
};
function zp(n) {
  n.landmarks = [], n.worldLandmarks = [], n.segmentationMasks = void 0;
}
function Kp(n) {
  try {
    const e = new Ul(n.landmarks, n.worldLandmarks, n.segmentationMasks);
    if (!n.s) return e;
    n.s(e);
  } finally {
    Zs(n);
  }
}
Ul.prototype.close = Ul.prototype.close;
var Ut = class extends $t {
  constructor(e, t) {
    super(new wn(e, t), "image_in", "norm_rect", !1), this.landmarks = [], this.worldLandmarks = [], this.outputSegmentationMasks = !1, le(e = this.h = new jg(), 0, 1, t = new qe()), this.v = new qg(), le(this.h, 0, 3, this.v), this.j = new $g(), le(this.h, 0, 2, this.j), Yn(this.j, 4, 1), ae(this.j, 2, 0.5), ae(this.v, 2, 0.5), ae(this.h, 4, 0.5);
  }
  get baseOptions() {
    return Se(this.h, qe, 1);
  }
  set baseOptions(e) {
    le(this.h, 0, 1, e);
  }
  o(e) {
    return "numPoses" in e && Yn(this.j, 4, e.numPoses ?? 1), "minPoseDetectionConfidence" in e && ae(this.j, 2, e.minPoseDetectionConfidence ?? 0.5), "minTrackingConfidence" in e && ae(this.h, 4, e.minTrackingConfidence ?? 0.5), "minPosePresenceConfidence" in e && ae(this.v, 2, e.minPosePresenceConfidence ?? 0.5), "outputSegmentationMasks" in e && (this.outputSegmentationMasks = e.outputSegmentationMasks ?? !1), this.l(e);
  }
  D(e, t, r) {
    const o = typeof t != "function" ? t : {};
    return this.s = typeof t == "function" ? t : r, zp(this), _n(this, e, o), Kp(this);
  }
  F(e, t, r, o) {
    const i = typeof r != "function" ? r : {};
    return this.s = typeof r == "function" ? r : o, zp(this), Zn(this, e, i, t), Kp(this);
  }
  m() {
    var e = new Kt();
    We(e, "image_in"), We(e, "norm_rect"), Ae(e, "normalized_landmarks"), Ae(e, "world_landmarks"), Ae(e, "segmentation_masks");
    const t = new an();
    Sn(t, VC, this.h);
    const r = new Ft();
    un(r, "mediapipe.tasks.vision.pose_landmarker.PoseLandmarkerGraph"), Oe(r, "IMAGE:image_in"), Oe(r, "NORM_RECT:norm_rect"), Ee(r, "NORM_LANDMARKS:normalized_landmarks"), Ee(r, "WORLD_LANDMARKS:world_landmarks"), r.o(t), ln(e, r), Qs(this, e), this.g.attachProtoVectorListener("normalized_landmarks", (o, i) => {
      this.landmarks = [];
      for (const a of o) o = sa(a), this.landmarks.push(Ys(o));
      Y(this, i);
    }), this.g.attachEmptyPacketListener("normalized_landmarks", (o) => {
      this.landmarks = [], Y(this, o);
    }), this.g.attachProtoVectorListener("world_landmarks", (o, i) => {
      this.worldLandmarks = [];
      for (const a of o) o = $o(a), this.worldLandmarks.push(Vi(o));
      Y(this, i);
    }), this.g.attachEmptyPacketListener("world_landmarks", (o) => {
      this.worldLandmarks = [], Y(this, o);
    }), this.outputSegmentationMasks && (Ee(r, "SEGMENTATION_MASK:segmentation_masks"), ai(this, "segmentation_masks"), this.g.ba("segmentation_masks", (o, i) => {
      this.segmentationMasks = o.map((a) => li(this, a, !0, !this.s)), Y(this, i);
    }), this.g.attachEmptyPacketListener("segmentation_masks", (o) => {
      this.segmentationMasks = [], Y(this, o);
    })), e = e.g(), this.setGraph(new Uint8Array(e), !0);
  }
};
Ut.prototype.detectForVideo = Ut.prototype.F, Ut.prototype.detect = Ut.prototype.D, Ut.prototype.setOptions = Ut.prototype.o, Ut.createFromModelPath = function(n, e) {
  return we(Ut, n, { baseOptions: { modelAssetPath: e } });
}, Ut.createFromModelBuffer = function(n, e) {
  return we(Ut, n, { baseOptions: { modelAssetBuffer: e } });
}, Ut.createFromOptions = function(n, e) {
  return we(Ut, n, e);
}, Ut.POSE_CONNECTIONS = h1;
class KC {
  constructor() {
    this.cam = null, this.poseLandmarker = null, this.isProcessing = !1, this.animationFrameId = null, this.debugLogged = !1, this.smoothedPoseLandmarks = null, this.smoothingFactor = 0.7, this.currentPoseLandmarks = null, this.currentVisibility = null, this.sensitivity = 0.3, this.previousPoseData = null, this.MAX_CHANGE_THRESHOLD = 0.05, this.MIN_CHANGE_THRESHOLD = 2e-3, this.changeScoreHistory = [], this.changeScoreHistoryIndex = 0, this.changeScoreHistoryCount = 0, this.CHANGE_SCORE_HISTORY_SIZE = 20, this.reusableSmoothedLandmarks = [], this.reusablePreviousPoseData = [], this.UPPER_BODY_INDICES = [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22], this.reusableEventDetail = {
      changeScore: 0,
      threshold: 0,
      sensitivity: 0
    };
  }
  init(e) {
    if (!e) {
      console.log("CamSkeletal error: must pass cam reference");
      return;
    }
    this.cam = e, this.setupMediaPipe();
  }
  async setupMediaPipe() {
    try {
      if (!this.cam.video) {
        const e = setInterval(() => {
          this.cam.video && this.cam.video.readyState >= this.cam.video.HAVE_METADATA && (clearInterval(e), this.initializePoseLandmarker());
        }, 100);
        setTimeout(() => {
          clearInterval(e), this.cam.video || console.error("[CamSkeletal] Video not available after timeout");
        }, 1e4);
        return;
      }
      await this.initializePoseLandmarker();
    } catch (e) {
      console.error("[CamSkeletal] Error setting up MediaPipe:", e);
    }
  }
  async initializePoseLandmarker() {
    var e;
    if (!this.cam.video) {
      console.error("[CamSkeletal] Video not available");
      return;
    }
    try {
      const t = await eo.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
      );
      this.poseLandmarker = await Ut.createFromOptions(t, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_heavy/float16/1/pose_landmarker_heavy.task",
          delegate: "GPU"
        },
        runningMode: "VIDEO",
        numPoses: 1,
        minPoseDetectionConfidence: 0.5,
        minPosePresenceConfidence: 0.5,
        minTrackingConfidence: 0.5
      }), (e = this.cam) != null && e.verboseLogging && (console.log("[CamSkeletal] MediaPipe Pose Landmarker initialized successfully"), console.log("[CamSkeletal] Video dimensions:", this.cam.video.videoWidth, "x", this.cam.video.videoHeight)), this.isProcessing = !0, this.startProcessing();
    } catch (t) {
      console.error("[CamSkeletal] Error initializing Pose Landmarker:", t);
    }
  }
  startProcessing() {
    if (!this.isProcessing) return;
    const e = () => {
      this.isProcessing && (this.processFrame(), this.animationFrameId = requestAnimationFrame(e));
    };
    e();
  }
  processFrame() {
    var e, t;
    if (!(!this.isProcessing || !this.cam.video || !this.poseLandmarker) && this.cam.video.readyState === this.cam.video.HAVE_ENOUGH_DATA && this.cam.video.videoWidth > 0 && this.cam.video.videoHeight > 0)
      try {
        const r = performance.now(), o = this.poseLandmarker.detectForVideo(this.cam.video, r);
        (!this.debugLogged || !o.landmarks || o.landmarks.length === 0) && ((e = this.cam) != null && e.verboseLogging && (console.log("[CamSkeletal] Results object keys:", Object.keys(o)), console.log("[CamSkeletal] landmarks:", (t = o.landmarks) == null ? void 0 : t.length), console.log("[CamSkeletal] Video being processed:", {
          width: this.cam.video.videoWidth,
          height: this.cam.video.videoHeight,
          readyState: this.cam.video.readyState
        })), o.landmarks && o.landmarks.length > 0 && (this.debugLogged = !0));
        let i = null;
        o.landmarks && o.landmarks.length > 0 && (i = o.landmarks[0]), o.visibility && o.visibility.length > 0 ? this.currentVisibility = o.visibility[0] : this.currentVisibility = null, this.currentPoseLandmarks = this.smoothLandmarks(i, this.smoothedPoseLandmarks), this.checkSkeletonChange(), this.smoothedPoseLandmarks = this.currentPoseLandmarks;
      } catch (r) {
        this.debugLogged || (console.error("[CamSkeletal] Error detecting pose:", r), this.debugLogged = !0);
      }
  }
  smoothLandmarks(e, t) {
    if (!e || e.length === 0)
      return null;
    if (!t || t.length === 0 || e.length !== t.length)
      return e;
    const r = 1 - this.smoothingFactor, o = e.length, i = new Array(o), a = this.reusableSmoothedLandmarks;
    for (; a.length < o; )
      a.push({ x: 0, y: 0, z: 0, visibility: 1 });
    for (let s = 0; s < o; s++) {
      const u = e[s], l = t[s], c = a[s];
      c.x = l.x * this.smoothingFactor + u.x * r, c.y = l.y * this.smoothingFactor + u.y * r, c.z = l.z !== void 0 && u.z !== void 0 ? l.z * this.smoothingFactor + u.z * r : u.z, c.visibility = u.visibility !== void 0 ? u.visibility : 1, i[s] = {
        x: c.x,
        y: c.y,
        z: c.z,
        visibility: c.visibility
      };
    }
    return i;
  }
  getLandmarkVisibility(e) {
    if (this.currentPoseLandmarks && this.currentPoseLandmarks[e]) {
      const t = this.currentPoseLandmarks[e];
      if (t.visibility !== void 0)
        return t.visibility;
      if (this.currentVisibility && this.currentVisibility[e] !== void 0)
        return this.currentVisibility[e];
    }
    return 1;
  }
  getCurrentPoseLandmarks() {
    return this.currentPoseLandmarks;
  }
  getCurrentVisibility() {
    return this.currentVisibility;
  }
  // Set sensitivity (0.0 to 1.0)
  setSensitivity(e) {
    this.sensitivity = Math.max(0, Math.min(1, e));
  }
  // Calculate change score between two pose states
  // Returns a value representing the magnitude of skeleton movement
  calculateSkeletonChange(e, t) {
    if (!e || !t || e.length !== t.length) return 1;
    const r = this.UPPER_BODY_INDICES;
    let o = 0, i = 0;
    for (let s = 0, u = r.length; s < u; s++) {
      const l = r[s];
      if (l >= e.length || l >= t.length) continue;
      const c = e[l], f = t[l], d = c.visibility !== void 0 ? c.visibility : 1, p = f.visibility !== void 0 ? f.visibility : 1;
      if (d > 0.3 && p > 0.3) {
        const v = f.x - c.x, g = f.y - c.y, y = Math.sqrt(v * v + g * g);
        o += y, i++;
      }
    }
    return i === 0 ? 0 : o / i;
  }
  // Get current change threshold based on sensitivity
  getChangeThreshold() {
    return this.MAX_CHANGE_THRESHOLD - this.sensitivity * (this.MAX_CHANGE_THRESHOLD - this.MIN_CHANGE_THRESHOLD);
  }
  // Check for skeleton changes and fire event if threshold exceeded
  checkSkeletonChange() {
    if (!this.cam || !this.cam.eventTarget) return;
    const e = this.cam.eventTarget;
    if (this.previousPoseData !== null && this.currentPoseLandmarks !== null) {
      const t = this.calculateSkeletonChange(this.previousPoseData, this.currentPoseLandmarks), r = this.changeScoreHistory, o = this.CHANGE_SCORE_HISTORY_SIZE, i = this.changeScoreHistoryIndex;
      if (r.length < o) {
        r.length = o;
        for (let l = 0; l < o; l++)
          r[l] = 0;
      }
      r[i] = t, this.changeScoreHistoryIndex = (i + 1) % o, this.changeScoreHistoryCount < o && this.changeScoreHistoryCount++;
      let a = 0;
      const s = this.changeScoreHistoryCount;
      if (s === o)
        for (let l = 0; l < s; l++) {
          const c = (i + l) % o;
          a += r[c];
        }
      else
        for (let l = 0; l < s; l++)
          a += r[l];
      a /= s;
      const u = this.getChangeThreshold();
      if (a >= u) {
        const l = this.reusableEventDetail;
        l.changeScore = a, l.threshold = u, l.sensitivity = this.sensitivity, e.dispatchEvent(new CustomEvent("skeletonchanged", {
          detail: l
        }));
      }
    }
    if (this.currentPoseLandmarks !== null) {
      const t = this.currentPoseLandmarks.length, r = this.reusablePreviousPoseData;
      for (; r.length < t; )
        r.push({ x: 0, y: 0, z: void 0, visibility: 1 });
      const o = new Array(t);
      for (let i = 0; i < t; i++) {
        const a = this.currentPoseLandmarks[i], s = r[i];
        s.x = a.x, s.y = a.y, s.z = a.z !== void 0 ? a.z : void 0, s.visibility = a.visibility !== void 0 ? a.visibility : 1, o[i] = {
          x: s.x,
          y: s.y,
          z: s.z,
          visibility: s.visibility
        };
      }
      this.previousPoseData = o;
    } else
      this.previousPoseData = null;
  }
  disconnect() {
    this.isProcessing = !1, this.animationFrameId && (cancelAnimationFrame(this.animationFrameId), this.animationFrameId = null), this.poseLandmarker && (this.poseLandmarker.close(), this.poseLandmarker = null), this.currentPoseLandmarks = null, this.currentVisibility = null, this.smoothedPoseLandmarks = null, this.previousPoseData = null, this.changeScoreHistory.length = 0, this.changeScoreHistoryIndex = 0, this.changeScoreHistoryCount = 0, this.reusableSmoothedLandmarks.length = 0, this.reusablePreviousPoseData.length = 0;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var m1 = function(n, e) {
  return (m1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, r) {
    t.__proto__ = r;
  } || function(t, r) {
    for (var o in r) r.hasOwnProperty(o) && (t[o] = r[o]);
  })(n, e);
};
function Pn(n, e) {
  function t() {
    this.constructor = n;
  }
  m1(n, e), n.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
function Z(n, e, t, r) {
  return new (t || (t = Promise))(function(o, i) {
    function a(l) {
      try {
        u(r.next(l));
      } catch (c) {
        i(c);
      }
    }
    function s(l) {
      try {
        u(r.throw(l));
      } catch (c) {
        i(c);
      }
    }
    function u(l) {
      l.done ? o(l.value) : new t(function(c) {
        c(l.value);
      }).then(a, s);
    }
    u((r = r.apply(n, [])).next());
  });
}
function j(n, e) {
  var t, r, o, i, a = { label: 0, sent: function() {
    if (1 & o[0]) throw o[1];
    return o[1];
  }, trys: [], ops: [] };
  return i = { next: s(0), throw: s(1), return: s(2) }, typeof Symbol == "function" && (i[Symbol.iterator] = function() {
    return this;
  }), i;
  function s(u) {
    return function(l) {
      return function(c) {
        if (t) throw new TypeError("Generator is already executing.");
        for (; a; ) try {
          if (t = 1, r && (o = 2 & c[0] ? r.return : c[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, c[1])).done) return o;
          switch (r = 0, o && (c = [2 & c[0], o.value]), c[0]) {
            case 0:
            case 1:
              o = c;
              break;
            case 4:
              return a.label++, { value: c[1], done: !1 };
            case 5:
              a.label++, r = c[1], c = [0];
              continue;
            case 7:
              c = a.ops.pop(), a.trys.pop();
              continue;
            default:
              if (!(o = (o = a.trys).length > 0 && o[o.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                a = 0;
                continue;
              }
              if (c[0] === 3 && (!o || c[1] > o[0] && c[1] < o[3])) {
                a.label = c[1];
                break;
              }
              if (c[0] === 6 && a.label < o[1]) {
                a.label = o[1], o = c;
                break;
              }
              if (o && a.label < o[2]) {
                a.label = o[2], a.ops.push(c);
                break;
              }
              o[2] && a.ops.pop(), a.trys.pop();
              continue;
          }
          c = e.call(n, a);
        } catch (f) {
          c = [6, f], r = 0;
        } finally {
          t = o = 0;
        }
        if (5 & c[0]) throw c[1];
        return { value: c[0] ? c[1] : void 0, done: !0 };
      }([u, l]);
    };
  }
}
var JC = function() {
  function n(e) {
    this.global = e, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.populateURLFlags();
  }
  return n.prototype.setPlatform = function(e, t) {
    this.platform != null && console.warn("Platform " + this.platformName + " has already been set. Overwriting the platform with " + t + "."), this.platformName = e, this.platform = t;
  }, n.prototype.registerFlag = function(e, t, r) {
    if (this.flagRegistry[e] = { evaluationFn: t, setHook: r }, this.urlFlags[e] != null) {
      var o = this.urlFlags[e];
      console.warn("Setting feature override from URL " + e + ": " + o + "."), this.set(e, o);
    }
  }, n.prototype.get = function(e) {
    return e in this.flags ? this.flags[e] : (this.flags[e] = this.evaluateFlag(e), this.flags[e]);
  }, n.prototype.getNumber = function(e) {
    return this.get(e);
  }, n.prototype.getBool = function(e) {
    return this.get(e);
  }, n.prototype.getFlags = function() {
    return this.flags;
  }, Object.defineProperty(n.prototype, "features", { get: function() {
    return this.flags;
  }, enumerable: !0, configurable: !0 }), n.prototype.set = function(e, t) {
    if (this.flagRegistry[e] == null) throw new Error("Cannot set flag " + e + " as it has not been registered.");
    this.flags[e] = t, this.flagRegistry[e].setHook != null && this.flagRegistry[e].setHook(t);
  }, n.prototype.evaluateFlag = function(e) {
    if (this.flagRegistry[e] == null) throw new Error("Cannot evaluate flag '" + e + "': no evaluation function found.");
    return this.flagRegistry[e].evaluationFn();
  }, n.prototype.setFlags = function(e) {
    this.flags = Object.assign({}, e);
  }, n.prototype.reset = function() {
    this.flags = {}, this.urlFlags = {}, this.populateURLFlags();
  }, n.prototype.populateURLFlags = function() {
    var e = this;
    if (this.global !== void 0 && this.global.location !== void 0 && this.global.location.search !== void 0) {
      var t, r, o = (t = this.global.location.search, r = {}, t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function(i) {
        for (var a = [], s = 1; s < arguments.length; s++) a[s - 1] = arguments[s];
        return XC(r, a[0], a[1]), a.join("=");
      }), r);
      "tfjsflags" in o && o.tfjsflags.split(",").forEach(function(i) {
        var a = i.split(":"), s = a[0], u = a[1];
        e.urlFlags[s] = function(l, c) {
          if ((c = c.toLowerCase()) === "true" || c === "false") return c === "true";
          if ("" + +c === c) return +c;
          throw new Error("Could not parse value flag value " + c + " for flag " + l + ".");
        }(s, u);
      });
    }
  }, n;
}();
function XC(n, e, t) {
  n[decodeURIComponent(e)] = decodeURIComponent(t || "");
}
function V() {
  return v1;
}
var v1 = null, ja = /* @__PURE__ */ new Map(), Vl = /* @__PURE__ */ new Map();
function g1(n, e) {
  var t = x1(n, e);
  return ja.get(t);
}
function YC(n) {
  return Vl.get(n);
}
function Jp(n) {
  for (var e = ja.entries(), t = []; ; ) {
    var r = e.next(), o = r.done, i = r.value;
    if (o) break;
    var a = i[0], s = i[1];
    a.split("_")[0] === n && t.push(s);
  }
  return t;
}
function y1(n) {
  var e = n.kernelName, t = n.backendName, r = x1(e, t);
  if (ja.has(r)) throw new Error("The kernel '" + e + "' for backend '" + t + "' is already registered");
  ja.set(r, n);
}
function QC(n) {
  var e = n.kernelName;
  Vl.has(e) && console.warn("Overriding the gradient for '" + e + "'"), Vl.set(e, n);
}
function x1(n, e) {
  return e + "_" + n;
}
function Gl(n, e, t) {
  return Math.max(n, Math.min(e, t));
}
function w1(n) {
  return n % 2 == 0 ? n : n + 1;
}
function ZC(n) {
  for (var e = 0, t = 0; t < n.length; t++) e += n[t];
  return e;
}
function k(n, e) {
  if (!n) throw new Error(typeof e == "string" ? e : e());
}
function De(n, e, t) {
  t === void 0 && (t = ""), k(_t(n, e), function() {
    return t + " Shapes " + n + " and " + e + " must match";
  });
}
function Ii(n) {
  k(n != null, function() {
    return "The input to the tensor constructor must be a non-null value.";
  });
}
function ci(n, e, t) {
  if (e === void 0 && (e = []), t === void 0 && (t = !1), e == null && (e = []), Array.isArray(n) || zn(n) && !t) for (var r = 0; r < n.length; ++r) ci(n[r], e, t);
  else e.push(n);
  return e;
}
function ee(n) {
  if (n.length === 0) return 1;
  for (var e = n[0], t = 1; t < n.length; t++) e *= n[t];
  return e;
}
function _t(n, e) {
  if (n === e) return !0;
  if (n == null || e == null || n.length !== e.length) return !1;
  for (var t = 0; t < n.length; t++) if (n[t] !== e[t]) return !1;
  return !0;
}
function it(n) {
  return n % 1 == 0;
}
function jC(n) {
  if (Math.tanh != null) return Math.tanh(n);
  if (n === 1 / 0) return 1;
  if (n === -1 / 0) return -1;
  var e = Math.exp(2 * n);
  return (e - 1) / (e + 1);
}
function Wl(n) {
  var e = Math.ceil(Math.sqrt(n));
  return [e, Math.ceil(n / e)];
}
function qo(n, e) {
  return e <= n.length ? n : n + " ".repeat(e - n.length);
}
function Xp(n, e, t) {
  return e === void 0 && (e = function(r) {
    return 0;
  }), new Promise(function(r, o) {
    var i = 0, a = function() {
      if (n()) r();
      else {
        i++;
        var s = e(i);
        t != null && i >= t ? o() : setTimeout(a, s);
      }
    };
    a();
  });
}
function e3(n, e) {
  for (var t = 1, r = -1, o = 0; o < n.length; ++o) if (n[o] >= 0) t *= n[o];
  else if (n[o] === -1) {
    if (r !== -1) throw Error("Shapes can only have 1 implicit size. Found -1 at dim " + r + " and dim " + o);
    r = o;
  } else if (n[o] < 0) throw Error("Shapes can not be < 0. Found " + n[o] + " at dim " + o);
  if (r === -1) {
    if (e > 0 && e !== t) throw Error("Size(" + e + ") must match the product of shape " + n);
    return n;
  }
  if (t === 0) throw Error("Cannot infer the missing size in [" + n + "] when there are 0 elements");
  if (e % t != 0) throw Error("The implicit shape can't be a fractional number. Got " + e + " / " + t);
  var i = n.slice();
  return i[r] = e / t, i;
}
function gt(n, e) {
  var t = e.length;
  return k((n = n == null ? e.map(function(r, o) {
    return o;
  }) : [].concat(n)).every(function(r) {
    return r >= -t && r < t;
  }), function() {
    return "All values in axis param must be in range [-" + t + ", " + t + ") but got axis " + n;
  }), k(n.every(function(r) {
    return it(r);
  }), function() {
    return "All values in axis param must be integers but got axis " + n;
  }), n.map(function(r) {
    return r < 0 ? t + r : r;
  });
}
function ro(n, e) {
  for (var t = [], r = [], o = e != null && Array.isArray(e) && e.length === 0, i = e == null || o ? null : gt(e, n).sort(), a = 0, s = 0; s < n.length; ++s) {
    if (i != null) {
      if (i[a] === s && n[s] !== 1) throw new Error("Can't squeeze axis " + s + " since its dim '" + n[s] + "' is not 1");
      (i[a] == null || i[a] > s) && n[s] === 1 && (t.push(n[s]), r.push(s)), i[a] <= s && a++;
    }
    n[s] !== 1 && (t.push(n[s]), r.push(s));
  }
  return { newShape: t, keptDims: r };
}
function Qi(n, e) {
  var t = null;
  if (n == null || n === "float32") t = new Float32Array(e);
  else if (n === "int32") t = new Int32Array(e);
  else {
    if (n !== "bool") throw new Error("Unknown data type " + n);
    t = new Uint8Array(e);
  }
  return t;
}
function es(n, e) {
  var t = null;
  if (n == null || n === "float32") t = new Float32Array(e);
  else if (n === "int32") t = new Int32Array(e);
  else if (n === "bool") t = new Uint8Array(e);
  else {
    if (n !== "string") throw new Error("Unknown data type " + n);
    t = new Array(e);
  }
  return t;
}
function t3(n, e) {
  for (var t = 0; t < n.length; t++) {
    var r = n[t];
    if (isNaN(r) || !isFinite(r)) throw Error("A tensor of type " + e + " being uploaded contains " + r + ".");
  }
}
function n3(n) {
  return n === "bool" || n === "complex64" || n === "float32" || n === "int32" || n === "string";
}
function r3(n, e) {
  return e !== "complex64" && (e !== "float32" || n === "complex64") && (e !== "int32" || n === "float32" || n === "complex64") && (e !== "bool" || n !== "bool");
}
function zn(n) {
  return n instanceof Float32Array || n instanceof Int32Array || n instanceof Uint8Array;
}
function _1(n) {
  if (n === "float32" || n === "int32") return 4;
  if (n === "complex64") return 8;
  if (n === "bool") return 1;
  throw new Error("Unknown dtype " + n);
}
function o3(n) {
  if (n == null) return 0;
  var e = 0;
  return n.forEach(function(t) {
    return e += t.length;
  }), e;
}
function gf(n) {
  return typeof n == "string" || n instanceof String;
}
function i3(n) {
  return typeof n == "boolean";
}
function a3(n) {
  return typeof n == "number";
}
function ua(n) {
  return Array.isArray(n) ? ua(n[0]) : n instanceof Float32Array ? "float32" : n instanceof Int32Array || n instanceof Uint8Array ? "int32" : a3(n) ? "float32" : gf(n) ? "string" : i3(n) ? "bool" : "float32";
}
function Hl(n) {
  return !!(n && n.constructor && n.call && n.apply);
}
function $l(n, e) {
  for (var t = e; t < n; ++t) if (n % t == 0) return t;
  return n;
}
function Kn(n) {
  var e = n.length;
  if (e < 2) return [];
  var t = new Array(e - 1);
  t[e - 2] = n[e - 1];
  for (var r = e - 3; r >= 0; --r) t[r] = t[r + 1] * n[r + 1];
  return t;
}
function b1(n, e, t) {
  if (e === "string") throw new Error("Cannot convert a string[] to a TypedArray");
  if (Array.isArray(n) && (n = ci(n)), t && t3(n, e), function(i, a) {
    return i instanceof Float32Array && a === "float32" || i instanceof Int32Array && a === "int32" || i instanceof Uint8Array && a === "bool";
  }(n, e)) return n;
  if (e == null || e === "float32" || e === "complex64") return new Float32Array(n);
  if (e === "int32") return new Int32Array(n);
  if (e === "bool") {
    for (var r = new Uint8Array(n.length), o = 0; o < r.length; ++o) Math.round(n[o]) !== 0 && (r[o] = 1);
    return r;
  }
  throw new Error("Unknown data type " + e);
}
function Yp(n, e) {
  if (n.length === 0) return e[0];
  var t = n.reduce(function(r, o) {
    return r * o;
  });
  if (t === 0) return [];
  if (t !== e.length) throw new Error("[" + n + "] does not match the input size.");
  return function r(o, i, a) {
    var s = new Array();
    if (i.length === 1) for (var u = i[0], l = 0; l < u; l++) s[l] = a[o + l];
    else {
      u = i[0];
      var c = i.slice(1), f = c.reduce(function(d, p) {
        return d * p;
      });
      for (l = 0; l < u; l++) s[l] = r(o + l * f, c, a);
    }
    return s;
  }(0, n, e);
}
function E1(n, e) {
  for (var t = la(n, e), r = 0; r < t.length; r++) t[r] = 1;
  return t;
}
function la(n, e) {
  if (e == null || e === "float32" || e === "complex64") return new Float32Array(n);
  if (e === "int32") return new Int32Array(n);
  if (e === "bool") return new Uint8Array(n);
  throw new Error("Unknown data type " + e);
}
function Wn() {
  return V().platform.now();
}
function C1(n) {
  n.forEach(function(e) {
    k(Number.isInteger(e) && e >= 0, function() {
      return "Tensor must have a shape comprised of positive integers but got shape [" + n + "].";
    });
  });
}
function s3(n, e) {
  return e === void 0 && (e = "utf-8"), e = e || "utf-8", V().platform.encode(n, e);
}
function ts(n, e) {
  return e === void 0 && (e = "utf-8"), e = e || "utf-8", V().platform.decode(n, e);
}
function Qp(n, e, t) {
  if (e === 0) return 0;
  if (e === 1) return n[0];
  for (var r = n[n.length - 1], o = 0; o < n.length - 1; ++o) r += t[o] * n[o];
  return r;
}
function u3(n, e, t) {
  if (e === 0) return [];
  if (e === 1) return [n];
  for (var r = new Array(e), o = 0; o < r.length - 1; ++o) r[o] = Math.floor(n / t[o]), n -= r[o] * t[o];
  return r[r.length - 1] = n, r;
}
var l3 = function() {
  function n(e, t) {
    this.backendTimer = e, this.logger = t, t == null && (this.logger = new c3());
  }
  return n.prototype.profileKernel = function(e, t, r) {
    var o, i = this, a = this.backendTimer.time(function() {
      o = r();
    });
    return o.forEach(function(s) {
      s.data().then(function(u) {
        (function(l, c, f) {
          if (c !== "float32") return !1;
          for (var d = 0; d < l.length; d++) {
            var p = l[d];
            if (isNaN(p) || !isFinite(p)) return console.warn("Found " + p + " in the result of '" + f + "'"), !0;
          }
        })(u, s.dtype, e), a.then(function(l) {
          var c = "";
          l.getExtraProfileInfo != null && (c = l.getExtraProfileInfo()), i.logger.logKernelProfile(e, s, u, l.kernelMs, t, c);
        });
      });
    }), o;
  }, n;
}(), c3 = function() {
  function n() {
  }
  return n.prototype.logKernelProfile = function(e, t, r, o, i, a) {
    var s = typeof o == "number" ? qo(o + "ms", 9) : o.error, u = qo(e, 25), l = t.rank, c = t.size, f = qo(t.shape.toString(), 14), d = "";
    for (var p in i) {
      var v = i[p].shape || t.shape, g = v.length;
      d += p + ": " + g + "D " + (g > 0 ? v : "") + " ";
    }
    console.log("%c" + u + "	%c" + s + "	%c" + l + "D " + f + "	%c" + c + "	%c" + d + "	%c" + a, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
  }, n;
}(), Zp = 20, Pi = 3, Bu = 7;
function f3(n, e, t, r) {
  var o = Kn(e), i = function(l, c, f, d) {
    var p = ee(c), v = d[d.length - 1], g = new Array(v).fill(0), y = c.length, x = f === "complex64" ? Mi(l) : l;
    if (y > 1) for (var w = 0; w < p / v; w++) for (var b = w * v, _ = 0; _ < v; _++) g[_] = Math.max(g[_], Ni(x[b + _], 0, f).length);
    return g;
  }(n, e, t, o), a = e.length, s = function l(c, f, d, p, v, g) {
    g === void 0 && (g = !0);
    var y = d === "complex64" ? 2 : 1, x = f[0], w = f.length;
    if (w === 0)
      return d === "complex64" ? [Ni(Mi(c)[0], 0, d)] : d === "bool" ? [T1(c[0])] : [c[0].toString()];
    if (w === 1) {
      if (x > Zp) {
        var b = Pi * y, _ = Array.from(c.slice(0, b)), E = Array.from(c.slice((x - Pi) * y, x * y));
        return d === "complex64" && (_ = Mi(_), E = Mi(E)), ["[" + _.map(function(U, G) {
          return Ni(U, v[G], d);
        }).join(", ") + ", ..., " + E.map(function(U, G) {
          return Ni(U, v[x - Pi + G], d);
        }).join(", ") + "]"];
      }
      return ["[" + (d === "complex64" ? Mi(c) : Array.from(c)).map(function(U, G) {
        return Ni(U, v[G], d);
      }).join(", ") + "]"];
    }
    var C = f.slice(1), A = p.slice(1), R = p[0] * y, I = [];
    if (x > Zp) {
      for (var S = 0; S < Pi; S++) {
        var M = (P = S * R) + R;
        I.push.apply(I, l(c.slice(P, M), C, d, A, v, !1));
      }
      for (I.push("..."), S = x - Pi; S < x; S++)
        M = (P = S * R) + R, I.push.apply(I, l(c.slice(P, M), C, d, A, v, S === x - 1));
    } else for (S = 0; S < x; S++) {
      var P;
      M = (P = S * R) + R, I.push.apply(I, l(c.slice(P, M), C, d, A, v, S === x - 1));
    }
    var B = w === 2 ? "," : "";
    for (I[0] = "[" + I[0] + B, S = 1; S < I.length - 1; S++) I[S] = " " + I[S] + B;
    var O = `,
`;
    for (S = 2; S < w; S++) O += `
`;
    return I[I.length - 1] = " " + I[I.length - 1] + "]" + (g ? "" : O), I;
  }(n, e, t, o, i), u = ["Tensor"];
  return r && (u.push("  dtype: " + t), u.push("  rank: " + a), u.push("  shape: [" + e + "]"), u.push("  values:")), u.push(s.map(function(l) {
    return "    " + l;
  }).join(`
`)), u.join(`
`);
}
function Ni(n, e, t) {
  return qo(Array.isArray(n) ? parseFloat(n[0].toFixed(Bu)) + " + " + parseFloat(n[1].toFixed(Bu)) + "j" : gf(n) ? "'" + n + "'" : t === "bool" ? T1(n) : parseFloat(n.toFixed(Bu)).toString(), e);
}
function T1(n) {
  return n === 0 ? "false" : "true";
}
function Mi(n) {
  for (var e = [], t = 0; t < n.length; t += 2) e.push([n[t], n[t + 1]]);
  return e;
}
var Zi = function() {
  function n(e, t, r) {
    var o = this;
    if (this.dtype = t, this.shape = e.slice(), this.size = ee(e), r != null) {
      var i = r.length;
      k(i === this.size, function() {
        return "Length of values '" + i + "' does not match the size inferred by the shape '" + o.size + "'.";
      });
    }
    if (t === "complex64") throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
    this.values = r || es(t, this.size), this.strides = Kn(e);
  }
  return n.prototype.set = function(e) {
    for (var t = this, r = [], o = 1; o < arguments.length; o++) r[o - 1] = arguments[o];
    r.length === 0 && (r = [0]), k(r.length === this.rank, function() {
      return "The number of provided coordinates (" + r.length + ") must match the rank (" + t.rank + ")";
    });
    var i = this.locToIndex(r);
    this.values[i] = e;
  }, n.prototype.get = function() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
    e.length === 0 && (e = [0]);
    for (var r = 0, o = 0, i = e; o < i.length; o++) {
      var a = i[o];
      if (a < 0 || a >= this.shape[r]) {
        var s = "Requested out of range element at " + e + ".   Buffer shape=" + this.shape;
        throw new Error(s);
      }
      r++;
    }
    for (var u = e[e.length - 1], l = 0; l < e.length - 1; ++l) u += this.strides[l] * e[l];
    return this.values[u];
  }, n.prototype.locToIndex = function(e) {
    if (this.rank === 0) return 0;
    if (this.rank === 1) return e[0];
    for (var t = e[e.length - 1], r = 0; r < e.length - 1; ++r) t += this.strides[r] * e[r];
    return t;
  }, n.prototype.indexToLoc = function(e) {
    if (this.rank === 0) return [];
    if (this.rank === 1) return [e];
    for (var t = new Array(this.shape.length), r = 0; r < t.length - 1; ++r) t[r] = Math.floor(e / this.strides[r]), e -= t[r] * this.strides[r];
    return t[t.length - 1] = e, t;
  }, Object.defineProperty(n.prototype, "rank", { get: function() {
    return this.shape.length;
  }, enumerable: !0, configurable: !0 }), n.prototype.toTensor = function() {
    return Hn().makeTensor(this.values, this.shape, this.dtype);
  }, n;
}(), Hn = null, L = null, I1 = null, Je = function() {
  function n(e, t, r, o) {
    this.kept = !1, this.isDisposedInternal = !1, this.shape = e.slice(), this.dtype = t || "float32", this.size = ee(e), this.strides = Kn(e), this.dataId = r, this.id = o, this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
  }
  return n.prototype.flatten = function() {
    return this.throwIfDisposed(), this.as1D();
  }, n.prototype.asScalar = function() {
    return this.throwIfDisposed(), k(this.size === 1, function() {
      return "The array must have only 1 element.";
    }), this.reshape([]);
  }, n.prototype.as1D = function() {
    return this.throwIfDisposed(), this.reshape([this.size]);
  }, n.prototype.as2D = function(e, t) {
    return this.throwIfDisposed(), this.reshape([e, t]);
  }, n.prototype.as3D = function(e, t, r) {
    return this.throwIfDisposed(), this.reshape([e, t, r]);
  }, n.prototype.as4D = function(e, t, r, o) {
    return this.throwIfDisposed(), this.reshape([e, t, r, o]);
  }, n.prototype.as5D = function(e, t, r, o, i) {
    return this.throwIfDisposed(), this.reshape([e, t, r, o, i]);
  }, n.prototype.asType = function(e) {
    return this.throwIfDisposed(), L.cast(this, e);
  }, Object.defineProperty(n.prototype, "rank", { get: function() {
    return this.shape.length;
  }, enumerable: !0, configurable: !0 }), n.prototype.buffer = function() {
    return Z(this, void 0, void 0, function() {
      var e;
      return j(this, function(t) {
        switch (t.label) {
          case 0:
            return [4, this.data()];
          case 1:
            return e = t.sent(), [2, L.buffer(this.shape, this.dtype, e)];
        }
      });
    });
  }, n.prototype.bufferSync = function() {
    return L.buffer(this.shape, this.dtype, this.dataSync());
  }, n.prototype.array = function() {
    return Z(this, void 0, void 0, function() {
      var e;
      return j(this, function(t) {
        switch (t.label) {
          case 0:
            return [4, this.data()];
          case 1:
            return e = t.sent(), [2, Yp(this.shape, e)];
        }
      });
    });
  }, n.prototype.arraySync = function() {
    return Yp(this.shape, this.dataSync());
  }, n.prototype.data = function() {
    return Z(this, void 0, void 0, function() {
      var e, t;
      return j(this, function(r) {
        switch (r.label) {
          case 0:
            return this.throwIfDisposed(), e = Hn().read(this.dataId), this.dtype !== "string" ? [3, 2] : [4, e];
          case 1:
            t = r.sent();
            try {
              return [2, t.map(function(o) {
                return ts(o);
              })];
            } catch {
              throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
            }
            r.label = 2;
          case 2:
            return [2, e];
        }
      });
    });
  }, n.prototype.dataSync = function() {
    this.throwIfDisposed();
    var e = Hn().readSync(this.dataId);
    if (this.dtype === "string") try {
      return e.map(function(t) {
        return ts(t);
      });
    } catch {
      throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
    }
    return e;
  }, n.prototype.bytes = function() {
    return Z(this, void 0, void 0, function() {
      var e;
      return j(this, function(t) {
        switch (t.label) {
          case 0:
            return this.throwIfDisposed(), [4, Hn().read(this.dataId)];
          case 1:
            return e = t.sent(), this.dtype === "string" ? [2, e] : [2, new Uint8Array(e.buffer)];
        }
      });
    });
  }, n.prototype.dispose = function() {
    this.isDisposed || (Hn().disposeTensor(this), this.isDisposedInternal = !0);
  }, Object.defineProperty(n.prototype, "isDisposed", { get: function() {
    return this.isDisposedInternal;
  }, enumerable: !0, configurable: !0 }), n.prototype.throwIfDisposed = function() {
    if (this.isDisposed) throw new Error("Tensor is disposed.");
  }, n.prototype.toFloat = function() {
    return this.asType("float32");
  }, n.prototype.toInt = function() {
    return this.asType("int32");
  }, n.prototype.toBool = function() {
    return this.asType("bool");
  }, n.prototype.print = function(e) {
    return e === void 0 && (e = !1), L.print(this, e);
  }, n.prototype.reshape = function(e) {
    return this.throwIfDisposed(), L.reshape(this, e);
  }, n.prototype.reshapeAs = function(e) {
    return this.throwIfDisposed(), this.reshape(e.shape);
  }, n.prototype.expandDims = function(e) {
    return e === void 0 && (e = 0), L.expandDims(this, e);
  }, n.prototype.cumsum = function(e, t, r) {
    return e === void 0 && (e = 0), t === void 0 && (t = !1), r === void 0 && (r = !1), L.cumsum(this, e, t, r);
  }, n.prototype.squeeze = function(e) {
    return this.throwIfDisposed(), L.squeeze(this, e);
  }, n.prototype.clone = function() {
    return this.throwIfDisposed(), L.clone(this);
  }, n.prototype.oneHot = function(e, t, r) {
    return this.throwIfDisposed(), L.oneHot(this, e, t, r);
  }, n.prototype.toString = function(e) {
    return e === void 0 && (e = !1), f3(this.dataSync(), this.shape, this.dtype, e);
  }, n.prototype.tile = function(e) {
    return this.throwIfDisposed(), L.tile(this, e);
  }, n.prototype.gather = function(e, t) {
    return t === void 0 && (t = 0), this.throwIfDisposed(), L.gather(this, e, t);
  }, n.prototype.matMul = function(e, t, r) {
    return t === void 0 && (t = !1), r === void 0 && (r = !1), this.throwIfDisposed(), L.matMul(this, e, t, r);
  }, n.prototype.dot = function(e) {
    return this.throwIfDisposed(), L.dot(this, e);
  }, n.prototype.norm = function(e, t, r) {
    return e === void 0 && (e = "euclidean"), t === void 0 && (t = null), r === void 0 && (r = !1), this.throwIfDisposed(), L.norm(this, e, t, r);
  }, n.prototype.slice = function(e, t) {
    return this.throwIfDisposed(), L.slice(this, e, t);
  }, n.prototype.reverse = function(e) {
    return this.throwIfDisposed(), L.reverse(this, e);
  }, n.prototype.concat = function(e, t) {
    return t === void 0 && (t = 0), this.throwIfDisposed(), e instanceof n && (e = [e]), L.concat([this].concat(e), t);
  }, n.prototype.split = function(e, t) {
    return t === void 0 && (t = 0), this.throwIfDisposed(), L.split(this, e, t);
  }, n.prototype.stack = function(e, t) {
    return t === void 0 && (t = 0), L.stack([this, e], t);
  }, n.prototype.unstack = function(e) {
    return e === void 0 && (e = 0), L.unstack(this, e);
  }, n.prototype.pad = function(e, t) {
    return t === void 0 && (t = 0), L.pad(this, e, t);
  }, n.prototype.batchNormalization = function(e, t, r, o, i) {
    return r === void 0 && (r = 1e-3), I1("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon"), this.batchNorm(e, t, i, o, r);
  }, n.prototype.batchNorm = function(e, t, r, o, i) {
    return i === void 0 && (i = 1e-3), this.throwIfDisposed(), L.batchNorm(this, e, t, r, o, i);
  }, n.prototype.all = function(e, t) {
    return e === void 0 && (e = null), t === void 0 && (t = !1), this.throwIfDisposed(), L.all(this, e, t);
  }, n.prototype.any = function(e, t) {
    return e === void 0 && (e = null), t === void 0 && (t = !1), this.throwIfDisposed(), L.any(this, e, t);
  }, n.prototype.logSumExp = function(e, t) {
    return e === void 0 && (e = null), t === void 0 && (t = !1), this.throwIfDisposed(), L.logSumExp(this, e, t);
  }, n.prototype.sum = function(e, t) {
    return e === void 0 && (e = null), t === void 0 && (t = !1), this.throwIfDisposed(), L.sum(this, e, t);
  }, n.prototype.prod = function(e, t) {
    return e === void 0 && (e = null), t === void 0 && (t = !1), this.throwIfDisposed(), L.prod(this, e, t);
  }, n.prototype.mean = function(e, t) {
    return e === void 0 && (e = null), t === void 0 && (t = !1), this.throwIfDisposed(), L.mean(this, e, t);
  }, n.prototype.min = function(e, t) {
    return e === void 0 && (e = null), t === void 0 && (t = !1), this.throwIfDisposed(), L.min(this, e, t);
  }, n.prototype.max = function(e, t) {
    return e === void 0 && (e = null), t === void 0 && (t = !1), this.throwIfDisposed(), L.max(this, e, t);
  }, n.prototype.argMin = function(e) {
    return e === void 0 && (e = null), this.throwIfDisposed(), L.argMin(this, e);
  }, n.prototype.argMax = function(e) {
    return e === void 0 && (e = null), this.throwIfDisposed(), L.argMax(this, e);
  }, n.prototype.cast = function(e) {
    return this.throwIfDisposed(), L.cast(this, e);
  }, n.prototype.add = function(e) {
    return this.throwIfDisposed(), L.add(this, e);
  }, n.prototype.addStrict = function(e) {
    return this.throwIfDisposed(), L.addStrict(this, e);
  }, n.prototype.atan2 = function(e) {
    return this.throwIfDisposed(), L.atan2(this, e);
  }, n.prototype.sub = function(e) {
    return this.throwIfDisposed(), L.sub(this, e);
  }, n.prototype.subStrict = function(e) {
    return this.throwIfDisposed(), L.subStrict(this, e);
  }, n.prototype.pow = function(e) {
    return this.throwIfDisposed(), L.pow(this, e);
  }, n.prototype.powStrict = function(e) {
    return this.throwIfDisposed(), L.powStrict(this, e);
  }, n.prototype.mul = function(e) {
    return this.throwIfDisposed(), L.mul(this, e);
  }, n.prototype.mulStrict = function(e) {
    return this.throwIfDisposed(), L.mulStrict(this, e);
  }, n.prototype.div = function(e) {
    return this.throwIfDisposed(), L.div(this, e);
  }, n.prototype.divNoNan = function(e) {
    return this.throwIfDisposed(), L.divNoNan(this, e);
  }, n.prototype.floorDiv = function(e) {
    return this.throwIfDisposed(), L.floorDiv(this, e);
  }, n.prototype.divStrict = function(e) {
    return this.throwIfDisposed(), L.divStrict(this, e);
  }, n.prototype.minimum = function(e) {
    return this.throwIfDisposed(), L.minimum(this, e);
  }, n.prototype.minimumStrict = function(e) {
    return this.throwIfDisposed(), L.minimumStrict(this, e);
  }, n.prototype.maximum = function(e) {
    return this.throwIfDisposed(), L.maximum(this, e);
  }, n.prototype.maximumStrict = function(e) {
    return this.throwIfDisposed(), L.maximumStrict(this, e);
  }, n.prototype.mod = function(e) {
    return this.throwIfDisposed(), L.mod(this, e);
  }, n.prototype.modStrict = function(e) {
    return this.throwIfDisposed(), L.modStrict(this, e);
  }, n.prototype.squaredDifferenceStrict = function(e) {
    return this.throwIfDisposed(), L.squaredDifferenceStrict(this, e);
  }, n.prototype.transpose = function(e) {
    return this.throwIfDisposed(), L.transpose(this, e);
  }, n.prototype.notEqual = function(e) {
    return this.throwIfDisposed(), L.notEqual(this, e);
  }, n.prototype.notEqualStrict = function(e) {
    return this.throwIfDisposed(), L.notEqualStrict(this, e);
  }, n.prototype.less = function(e) {
    return this.throwIfDisposed(), L.less(this, e);
  }, n.prototype.lessStrict = function(e) {
    return this.throwIfDisposed(), L.lessStrict(this, e);
  }, n.prototype.equal = function(e) {
    return this.throwIfDisposed(), L.equal(this, e);
  }, n.prototype.equalStrict = function(e) {
    return this.throwIfDisposed(), L.equalStrict(this, e);
  }, n.prototype.lessEqual = function(e) {
    return this.throwIfDisposed(), L.lessEqual(this, e);
  }, n.prototype.lessEqualStrict = function(e) {
    return this.throwIfDisposed(), L.lessEqualStrict(this, e);
  }, n.prototype.greater = function(e) {
    return this.throwIfDisposed(), L.greater(this, e);
  }, n.prototype.greaterStrict = function(e) {
    return this.throwIfDisposed(), L.greaterStrict(this, e);
  }, n.prototype.greaterEqual = function(e) {
    return this.throwIfDisposed(), L.greaterEqual(this, e);
  }, n.prototype.greaterEqualStrict = function(e) {
    return this.throwIfDisposed(), L.greaterEqualStrict(this, e);
  }, n.prototype.logicalAnd = function(e) {
    return this.throwIfDisposed(), L.logicalAnd(this, e);
  }, n.prototype.logicalOr = function(e) {
    return this.throwIfDisposed(), L.logicalOr(this, e);
  }, n.prototype.logicalNot = function() {
    return this.throwIfDisposed(), L.logicalNot(this);
  }, n.prototype.logicalXor = function(e) {
    return this.throwIfDisposed(), L.logicalXor(this, e);
  }, n.prototype.where = function(e, t) {
    return this.throwIfDisposed(), L.where(e, this, t);
  }, n.prototype.neg = function() {
    return this.throwIfDisposed(), L.neg(this);
  }, n.prototype.ceil = function() {
    return this.throwIfDisposed(), L.ceil(this);
  }, n.prototype.floor = function() {
    return this.throwIfDisposed(), L.floor(this);
  }, n.prototype.sign = function() {
    return this.throwIfDisposed(), L.sign(this);
  }, n.prototype.isNaN = function() {
    return this.throwIfDisposed(), L.isNaN(this);
  }, n.prototype.isInf = function() {
    return this.throwIfDisposed(), L.isInf(this);
  }, n.prototype.isFinite = function() {
    return this.throwIfDisposed(), L.isFinite(this);
  }, n.prototype.exp = function() {
    return this.throwIfDisposed(), L.exp(this);
  }, n.prototype.expm1 = function() {
    return this.throwIfDisposed(), L.expm1(this);
  }, n.prototype.log = function() {
    return this.throwIfDisposed(), L.log(this);
  }, n.prototype.log1p = function() {
    return this.throwIfDisposed(), L.log1p(this);
  }, n.prototype.sqrt = function() {
    return this.throwIfDisposed(), L.sqrt(this);
  }, n.prototype.rsqrt = function() {
    return this.throwIfDisposed(), L.rsqrt(this);
  }, n.prototype.square = function() {
    return this.throwIfDisposed(), L.square(this);
  }, n.prototype.reciprocal = function() {
    return this.throwIfDisposed(), L.reciprocal(this);
  }, n.prototype.abs = function() {
    return this.throwIfDisposed(), L.abs(this);
  }, n.prototype.clipByValue = function(e, t) {
    return this.throwIfDisposed(), L.clipByValue(this, e, t);
  }, n.prototype.relu = function() {
    return this.throwIfDisposed(), L.relu(this);
  }, n.prototype.relu6 = function() {
    return this.throwIfDisposed(), L.relu6(this);
  }, n.prototype.elu = function() {
    return this.throwIfDisposed(), L.elu(this);
  }, n.prototype.selu = function() {
    return this.throwIfDisposed(), L.selu(this);
  }, n.prototype.leakyRelu = function(e) {
    return e === void 0 && (e = 0.2), this.throwIfDisposed(), L.leakyRelu(this, e);
  }, n.prototype.prelu = function(e) {
    return this.throwIfDisposed(), L.prelu(this, e);
  }, n.prototype.sigmoid = function() {
    return this.throwIfDisposed(), L.sigmoid(this);
  }, n.prototype.logSigmoid = function() {
    return this.throwIfDisposed(), L.logSigmoid(this);
  }, n.prototype.softplus = function() {
    return this.throwIfDisposed(), L.softplus(this);
  }, n.prototype.zerosLike = function() {
    return this.throwIfDisposed(), L.zerosLike(this);
  }, n.prototype.onesLike = function() {
    return this.throwIfDisposed(), L.onesLike(this);
  }, n.prototype.sin = function() {
    return this.throwIfDisposed(), L.sin(this);
  }, n.prototype.cos = function() {
    return this.throwIfDisposed(), L.cos(this);
  }, n.prototype.tan = function() {
    return this.throwIfDisposed(), L.tan(this);
  }, n.prototype.asin = function() {
    return this.throwIfDisposed(), L.asin(this);
  }, n.prototype.acos = function() {
    return this.throwIfDisposed(), L.acos(this);
  }, n.prototype.atan = function() {
    return this.throwIfDisposed(), L.atan(this);
  }, n.prototype.sinh = function() {
    return this.throwIfDisposed(), L.sinh(this);
  }, n.prototype.cosh = function() {
    return this.throwIfDisposed(), L.cosh(this);
  }, n.prototype.tanh = function() {
    return this.throwIfDisposed(), L.tanh(this);
  }, n.prototype.asinh = function() {
    return this.throwIfDisposed(), L.asinh(this);
  }, n.prototype.acosh = function() {
    return this.throwIfDisposed(), L.acosh(this);
  }, n.prototype.atanh = function() {
    return this.throwIfDisposed(), L.atanh(this);
  }, n.prototype.erf = function() {
    return this.throwIfDisposed(), L.erf(this);
  }, n.prototype.round = function() {
    return this.throwIfDisposed(), L.round(this);
  }, n.prototype.step = function(e) {
    return e === void 0 && (e = 0), this.throwIfDisposed(), L.step(this, e);
  }, n.prototype.softmax = function(e) {
    return e === void 0 && (e = -1), this.throwIfDisposed(), L.softmax(this, e);
  }, n.prototype.logSoftmax = function(e) {
    return e === void 0 && (e = -1), this.throwIfDisposed(), L.logSoftmax(this, e);
  }, n.prototype.resizeBilinear = function(e, t) {
    return t === void 0 && (t = !1), this.throwIfDisposed(), L.image.resizeBilinear(this, e, t);
  }, n.prototype.resizeNearestNeighbor = function(e, t) {
    return t === void 0 && (t = !1), this.throwIfDisposed(), L.image.resizeNearestNeighbor(this, e, t);
  }, n.prototype.conv1d = function(e, t, r, o, i, a) {
    return o === void 0 && (o = "NWC"), i === void 0 && (i = 1), this.throwIfDisposed(), L.conv1d(this, e, t, r, o, i, a);
  }, n.prototype.conv2d = function(e, t, r, o, i, a) {
    return o === void 0 && (o = "NHWC"), i === void 0 && (i = [1, 1]), this.throwIfDisposed(), L.conv2d(this, e, t, r, o, i, a);
  }, n.prototype.conv2dTranspose = function(e, t, r, o, i) {
    return this.throwIfDisposed(), L.conv2dTranspose(this, e, t, r, o, i);
  }, n.prototype.depthwiseConv2D = function(e, t, r, o, i, a) {
    return o === void 0 && (o = "NHWC"), i === void 0 && (i = [1, 1]), this.throwIfDisposed(), L.depthwiseConv2d(this, e, t, r, o, i, a);
  }, n.prototype.separableConv2d = function(e, t, r, o, i, a) {
    return i === void 0 && (i = [1, 1]), a === void 0 && (a = "NHWC"), this.throwIfDisposed(), L.separableConv2d(this, e, t, r, o, i, a);
  }, n.prototype.avgPool = function(e, t, r, o) {
    return this.throwIfDisposed(), L.avgPool(this, e, t, r, o);
  }, n.prototype.maxPool = function(e, t, r, o) {
    return this.throwIfDisposed(), L.maxPool(this, e, t, r, o);
  }, n.prototype.localResponseNormalization = function(e, t, r, o) {
    return e === void 0 && (e = 5), t === void 0 && (t = 1), r === void 0 && (r = 1), o === void 0 && (o = 0.5), L.localResponseNormalization(this, e, t, r, o);
  }, n.prototype.pool = function(e, t, r, o, i) {
    return this.throwIfDisposed(), L.pool(this, e, t, r, o, i);
  }, n.prototype.variable = function(e, t, r) {
    return e === void 0 && (e = !0), this.throwIfDisposed(), Hn().makeVariable(this, e, t, r);
  }, n.prototype.unsortedSegmentSum = function(e, t) {
    return this.throwIfDisposed(), L.unsortedSegmentSum(this, e, t);
  }, n.prototype.batchToSpaceND = function(e, t) {
    return this.throwIfDisposed(), L.batchToSpaceND(this, e, t);
  }, n.prototype.spaceToBatchND = function(e, t) {
    return this.throwIfDisposed(), L.spaceToBatchND(this, e, t);
  }, n.prototype.topk = function(e, t) {
    return e === void 0 && (e = 1), t === void 0 && (t = !0), this.throwIfDisposed(), L.topk(this, e, t);
  }, n.prototype.stridedSlice = function(e, t, r, o, i, a, s, u) {
    return o === void 0 && (o = 0), i === void 0 && (i = 0), a === void 0 && (a = 0), s === void 0 && (s = 0), u === void 0 && (u = 0), this.throwIfDisposed(), L.stridedSlice(this, e, t, r, o, i, a, s, u);
  }, n.prototype.depthToSpace = function(e, t) {
    return this.throwIfDisposed(), L.depthToSpace(this, e, t);
  }, n.prototype.fft = function() {
    return this.throwIfDisposed(), L.spectral.fft(this);
  }, n.prototype.ifft = function() {
    return this.throwIfDisposed(), L.spectral.ifft(this);
  }, n.prototype.rfft = function() {
    return this.throwIfDisposed(), L.spectral.rfft(this);
  }, n.prototype.irfft = function() {
    return this.throwIfDisposed(), L.spectral.irfft(this);
  }, n;
}();
Object.defineProperty(Je, Symbol.hasInstance, { value: function(n) {
  return !!n && n.dataId != null && n.shape != null && n.dtype != null;
} });
var jp, ql, zl, Kl, Jl, fi = function(n) {
  function e(t, r, o, i) {
    var a = n.call(this, t.shape, t.dtype, t.dataId, i) || this;
    return a.trainable = r, a.name = o, a;
  }
  return Pn(e, n), e.prototype.assign = function(t) {
    if (t.dtype !== this.dtype) throw new Error("dtype of the new value (" + t.dtype + ") and previous value (" + this.dtype + ") must match");
    if (!_t(t.shape, this.shape)) throw new Error("shape of the new value (" + t.shape + ") and previous value (" + this.shape + ") must match");
    Hn().disposeTensor(this), this.dataId = t.dataId, Hn().incRef(this, null);
  }, e.prototype.dispose = function() {
    Hn().disposeVariable(this), this.isDisposedInternal = !0;
  }, e;
}(Je);
Object.defineProperty(fi, Symbol.hasInstance, { value: function(n) {
  return n instanceof Je && n.assign != null && n.assign instanceof Function;
} }), function(n) {
  n.R0 = "R0", n.R1 = "R1", n.R2 = "R2", n.R3 = "R3", n.R4 = "R4", n.R5 = "R5", n.R6 = "R6";
}(jp || (jp = {})), function(n) {
  n.float32 = "float32", n.int32 = "int32", n.bool = "int32", n.complex64 = "complex64";
}(ql || (ql = {})), function(n) {
  n.float32 = "float32", n.int32 = "int32", n.bool = "bool", n.complex64 = "complex64";
}(zl || (zl = {})), function(n) {
  n.float32 = "float32", n.int32 = "float32", n.bool = "float32", n.complex64 = "complex64";
}(Kl || (Kl = {})), function(n) {
  n.float32 = "complex64", n.int32 = "complex64", n.bool = "complex64", n.complex64 = "complex64";
}(Jl || (Jl = {}));
var d3 = { float32: Kl, int32: ql, bool: zl, complex64: Jl };
function Ct(n, e) {
  if (n === "string" || e === "string") {
    if (n === "string" && e === "string") return "string";
    throw new Error("Can not upcast " + n + " with " + e);
  }
  return d3[n][e];
}
function Ou(n) {
  return Ct(n, "int32");
}
function Qe(n, e) {
  if (n.dtype === e.dtype) return [n, e];
  var t = Ct(n.dtype, e.dtype);
  return [n.cast(t), e.cast(t)];
}
function h3(n, e) {
  k(n.dtype === e.dtype, function() {
    return "The dtypes of the first(" + n.dtype + ") and second(" + e.dtype + ") input must match";
  });
}
function S1(n) {
  var e = [];
  return function t(r, o, i) {
    if (r != null) {
      if (r instanceof Je) return void o.push(r);
      if (a = r, !(!Array.isArray(a) && typeof a != "object")) {
        var a, s = r;
        for (var u in s) {
          var l = s[u];
          i.has(l) || (i.add(l), t(l, o, i));
        }
      }
    }
  }(n, e, /* @__PURE__ */ new Set()), e;
}
var Uu, em = function() {
  function n() {
    this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = /* @__PURE__ */ new WeakMap(), this.profiling = !1, this.activeProfile = { newBytes: 0, newTensors: 0, peakBytes: 0, kernels: [], result: null };
  }
  return n.prototype.dispose = function() {
    for (var e in this.registeredVariables) this.registeredVariables[e].dispose();
  }, n;
}(), p3 = function() {
  function n(e) {
    this.ENV = e, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new em();
  }
  return n.prototype.ready = function() {
    return Z(this, void 0, void 0, function() {
      var e, t, r;
      return j(this, function(o) {
        switch (o.label) {
          case 0:
            if (this.pendingBackendInit != null) return [2, this.pendingBackendInit.then(function() {
            })];
            if (this.backendInstance != null) return [2];
            e = this.getSortedBackends(), t = 0, o.label = 1;
          case 1:
            return t < e.length ? (r = e[t], [4, this.initializeBackend(r).success]) : [3, 5];
          case 2:
            return o.sent() ? [4, this.setBackend(r)] : [3, 4];
          case 3:
            return o.sent(), [2];
          case 4:
            return t++, [3, 1];
          case 5:
            throw new Error("Could not initialize any backends, all backend initializations failed.");
        }
      });
    });
  }, Object.defineProperty(n.prototype, "backend", { get: function() {
    if (this.pendingBackendInit != null) throw new Error("Backend '" + this.backendName + "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");
    if (this.backendInstance == null) {
      var e = this.initializeBackendsAndReturnBest(), t = e.name;
      if (e.asyncInit) throw new Error("The highest priority backend '" + t + "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");
      this.setBackend(t);
    }
    return this.backendInstance;
  }, enumerable: !0, configurable: !0 }), n.prototype.backendNames = function() {
    return Object.keys(this.registryFactory);
  }, n.prototype.findBackend = function(e) {
    return !(e in this.registry) && (!(e in this.registryFactory) || this.initializeBackend(e).asyncInit) ? null : this.registry[e];
  }, n.prototype.findBackendFactory = function(e) {
    return e in this.registryFactory ? this.registryFactory[e].factory : null;
  }, n.prototype.registerBackend = function(e, t, r) {
    return r === void 0 && (r = 1), e in this.registryFactory ? (console.warn(e + " backend was already registered. Reusing existing backend factory."), !1) : (this.registryFactory[e] = { factory: t, priority: r }, !0);
  }, n.prototype.setBackend = function(e) {
    return Z(this, void 0, void 0, function() {
      var t, r, o;
      return j(this, function(i) {
        switch (i.label) {
          case 0:
            if (this.registryFactory[e] == null) throw new Error("Backend name '" + e + "' not found in registry");
            return this.backendName = e, this.registry[e] != null ? [3, 4] : (this.backendInstance = null, t = this.initializeBackend(e), r = t.success, t.asyncInit ? [4, r] : [3, 2]);
          case 1:
            return o = i.sent(), [3, 3];
          case 2:
            o = r, i.label = 3;
          case 3:
            if (!o) return [2, !1];
            i.label = 4;
          case 4:
            return this.backendInstance = this.registry[e], this.setupRegisteredKernels(), this.profiler = new l3(this.backendInstance), [2, !0];
        }
      });
    });
  }, n.prototype.setupRegisteredKernels = function() {
    var e = this;
    Jp(this.backendName).forEach(function(t) {
      t.setupFunc != null && t.setupFunc(e.backendInstance);
    });
  }, n.prototype.disposeRegisteredKernels = function(e) {
    var t = this;
    Jp(e).forEach(function(r) {
      r.disposeFunc != null && r.disposeFunc(t.registry[e]);
    });
  }, n.prototype.initializeBackend = function(e) {
    var t = this, r = this.registryFactory[e];
    if (r == null) throw new Error("Cannot initialize backend " + e + ", no registration found.");
    try {
      var o = r.factory();
      if (Promise.resolve(o) === o) {
        var i = ++this.pendingBackendInitId, a = o.then(function(s) {
          return !(i < t.pendingBackendInitId) && (t.registry[e] = s, t.pendingBackendInit = null, !0);
        }).catch(function(s) {
          return !(i < t.pendingBackendInitId) && (t.pendingBackendInit = null, console.warn("Initialization of backend " + e + " failed"), console.warn(s.stack || s.message), !1);
        });
        return this.pendingBackendInit = a, { success: a, asyncInit: !0 };
      }
      return this.registry[e] = o, { success: !0, asyncInit: !1 };
    } catch (s) {
      return console.warn("Initialization of backend " + e + " failed"), console.warn(s.stack || s.message), { success: !1, asyncInit: !1 };
    }
  }, n.prototype.removeBackend = function(e) {
    if (!(e in this.registryFactory)) throw new Error(e + " backend not found in registry");
    this.backendName === e && this.pendingBackendInit != null && this.pendingBackendInitId++, e in this.registry && (this.disposeRegisteredKernels(e), this.registry[e].dispose(), delete this.registry[e]), delete this.registryFactory[e], this.backendName === e && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null);
  }, n.prototype.getSortedBackends = function() {
    var e = this;
    if (Object.keys(this.registryFactory).length === 0) throw new Error("No backend found in registry.");
    return Object.keys(this.registryFactory).sort(function(t, r) {
      return e.registryFactory[r].priority - e.registryFactory[t].priority;
    });
  }, n.prototype.initializeBackendsAndReturnBest = function() {
    for (var e = this.getSortedBackends(), t = 0; t < e.length; t++) {
      var r = e[t], o = this.initializeBackend(r), i = o.success, a = o.asyncInit;
      if (a || i) return { name: r, asyncInit: a };
    }
    throw new Error("Could not initialize any backends, all backend initializations failed.");
  }, n.prototype.moveData = function(e, t) {
    var r = this.state.tensorInfo.get(t), o = r.backend, i = this.readSync(t);
    o.disposeData(t), r.backend = e, e.move(t, i, r.shape, r.dtype), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
  }, n.prototype.tidy = function(e, t) {
    var r, o = this, i = null;
    if (t == null) {
      if (typeof e != "function") throw new Error("Please provide a function to tidy()");
      t = e;
    } else {
      if (typeof e != "string" && !(e instanceof String)) throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
      if (typeof t != "function") throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
      i = e;
    }
    return this.scopedRun(function() {
      return o.startScope(i);
    }, function() {
      return o.endScope(r);
    }, function() {
      return (r = t()) instanceof Promise && console.error("Cannot return a Promise inside of tidy."), r;
    });
  }, n.prototype.scopedRun = function(e, t, r) {
    e();
    try {
      var o = r();
      return t(), o;
    } catch (i) {
      throw t(), i;
    }
  }, n.prototype.nextTensorId = function() {
    return n.nextTensorId++;
  }, n.prototype.nextVariableId = function() {
    return n.nextVariableId++;
  }, n.prototype.clone = function(e) {
    var t = this.makeTensorFromDataId(e.dataId, e.shape, e.dtype), r = { x: e };
    return this.addTapeNode(this.state.activeScope.name, r, [t], function(o) {
      return { x: function() {
        return o.toFloat();
      } };
    }, []), t;
  }, n.prototype.runKernel = function(e, t, r, o, i) {
    return this.runKernelFunc(null, t, null, e, r, o, i);
  }, n.prototype.shouldCheckForMemLeaks = function() {
    return this.ENV.getBool("IS_TEST");
  }, n.prototype.checkKernelForMemLeak = function(e, t, r) {
    var o = this.backend.numDataIds(), i = 0;
    r.forEach(function(u) {
      i += u.dtype === "complex64" ? 3 : 1;
    });
    var a = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1], s = o - t - i - a;
    if (s > 0) throw new Error("Backend '" + this.backendName + "' has an internal memory leak (" + s + " data ids) after running '" + e + "'");
  }, n.prototype.runKernelFunc = function(e, t, r, o, i, a, s) {
    var u, l = this;
    a === void 0 && (a = []), s === void 0 && (s = []);
    var c = [], f = this.isTapeOn();
    o == null && (o = this.state.activeScope != null ? this.state.activeScope.name : "");
    var d, p = function(w) {
      f && (c = w.map(function(b) {
        return l.keep(l.clone(b));
      }));
    }, v = this.state.numBytes, g = this.state.numTensors;
    this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0);
    var y, x = g1(o, this.backendName);
    return d = x != null ? function() {
      var w = l.backend.numDataIds();
      y = x.kernelFunc({ inputs: t, attrs: i, backend: l.backend });
      var b = Array.isArray(y) ? y : [y];
      l.shouldCheckForMemLeaks() && l.checkKernelForMemLeak(o, w, b);
      var _ = b.map(function(C) {
        var A = C.dataId, R = C.shape, I = C.dtype;
        return l.makeTensorFromDataId(A, R, I);
      }), E = _.filter(function(C, A) {
        return s[A];
      });
      return p((a || []).slice().concat(E)), _;
    } : function() {
      var w = l.backend.numDataIds();
      y = l.tidy(function() {
        return e(l.backend, p);
      });
      var b = Array.isArray(y) ? y : [y];
      return l.shouldCheckForMemLeaks() && l.checkKernelForMemLeak(o, w, b), b;
    }, this.scopedRun(function() {
      return l.state.kernelDepth++;
    }, function() {
      return l.state.kernelDepth--;
    }, function() {
      u = l.ENV.getBool("DEBUG") ? l.profiler.profileKernel(o, t, function() {
        return d();
      }) : d();
    }), f && this.addTapeNode(o, t, u, r, c), this.state.profiling && this.state.activeProfile.kernels.push({ name: o, bytesAdded: this.state.numBytes - v, totalBytesSnapshot: this.state.numBytes, tensorsAdded: this.state.numTensors - g, totalTensorsSnapshot: this.state.numTensors, inputShapes: Object.keys(t).map(function(w) {
      return t[w].shape;
    }), outputShapes: u.map(function(w) {
      return w.shape;
    }) }), Array.isArray(y) ? u : u[0];
  }, n.prototype.makeTensor = function(e, t, r, o) {
    if (e == null) throw new Error("Values passed to engine.makeTensor() are null");
    r = r || "float32", o = o || this.backend;
    var i = e;
    r === "string" && gf(e[0]) && (i = e.map(function(c) {
      return s3(c);
    }));
    var a = o.write(i, t, r), s = new Je(t, r, a, this.nextTensorId());
    if (this.incRef(s, o), r === "string") {
      var u = this.state.tensorInfo.get(a), l = o3(i);
      this.state.numBytes += l - u.bytes, u.bytes = l;
    }
    return s;
  }, n.prototype.makeTensorFromDataId = function(e, t, r, o) {
    var i = new Je(t, r = r || "float32", e, this.nextTensorId());
    return this.incRef(i, o), i;
  }, n.prototype.makeVariable = function(e, t, r, o) {
    t === void 0 && (t = !0), r = r || this.nextVariableId().toString(), o != null && o !== e.dtype && (e = e.asType(o));
    var i = new fi(e, t, r, this.nextTensorId());
    if (this.state.registeredVariables[i.name] != null) throw new Error("Variable with name " + i.name + " was already registered");
    return this.state.registeredVariables[i.name] = i, this.incRef(i, this.backend), i;
  }, n.prototype.incRef = function(e, t) {
    var r = this.state.tensorInfo.has(e.dataId) ? this.state.tensorInfo.get(e.dataId).refCount : 0;
    if (this.state.numTensors++, e.dtype === "string" && this.state.numStringTensors++, r === 0) {
      this.state.numDataBuffers++;
      var o = 0;
      e.dtype !== "complex64" && e.dtype !== "string" && (o = e.size * _1(e.dtype)), this.state.tensorInfo.set(e.dataId, { backend: t || this.backend, dtype: e.dtype, shape: e.shape, bytes: o, refCount: 0 }), this.state.numBytes += o;
    }
    this.state.tensorInfo.get(e.dataId).refCount++, e instanceof fi || this.track(e);
  }, n.prototype.disposeTensor = function(e) {
    if (this.state.tensorInfo.has(e.dataId)) {
      this.state.numTensors--, e.dtype === "string" && this.state.numStringTensors--;
      var t = this.state.tensorInfo.get(e.dataId);
      t.refCount <= 1 ? (e.dtype !== "complex64" && (this.state.numBytes -= t.bytes), this.state.numDataBuffers--, t.backend.disposeData(e.dataId), this.state.tensorInfo.delete(e.dataId)) : this.state.tensorInfo.get(e.dataId).refCount--;
    }
  }, n.prototype.disposeVariables = function() {
    for (var e in this.state.registeredVariables) {
      var t = this.state.registeredVariables[e];
      this.disposeVariable(t);
    }
  }, n.prototype.disposeVariable = function(e) {
    this.disposeTensor(e), this.state.registeredVariables[e.name] != null && delete this.state.registeredVariables[e.name];
  }, n.prototype.memory = function() {
    var e = this.backend.memory();
    return e.numTensors = this.state.numTensors, e.numDataBuffers = this.state.numDataBuffers, e.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (e.unreliable = !0, e.reasons == null && (e.reasons = []), e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), e;
  }, n.prototype.profile = function(e) {
    return Z(this, void 0, void 0, function() {
      var t, r;
      return j(this, function(o) {
        return this.state.profiling = !0, t = this.state.numBytes, r = this.state.numTensors, this.state.activeProfile.kernels = [], this.state.activeProfile.result = e(), this.state.profiling = !1, this.state.activeProfile.peakBytes = Math.max.apply(Math, this.state.activeProfile.kernels.map(function(i) {
          return i.totalBytesSnapshot;
        })), this.state.activeProfile.newBytes = this.state.numBytes - t, this.state.activeProfile.newTensors = this.state.numTensors - r, [2, this.state.activeProfile];
      });
    });
  }, n.prototype.isTapeOn = function() {
    return this.state.gradientDepth > 0 && this.state.kernelDepth === 0;
  }, n.prototype.addTapeNode = function(e, t, r, o, i) {
    var a = this, s = { id: this.state.nextTapeNodeId++, kernelName: e, inputs: t, outputs: r, saved: i }, u = YC(e);
    u != null && (o = u.gradFunc), o != null && (s.gradient = function(l) {
      return l = l.map(function(c, f) {
        if (c == null) {
          var d = r[f], p = la(d.size, d.dtype);
          return a.makeTensor(p, d.shape, d.dtype);
        }
        return c;
      }), o(l.length > 1 ? l : l[0], i);
    }), this.state.activeTape.push(s);
  }, n.prototype.keep = function(e) {
    return e.kept = !0, e;
  }, n.prototype.startTape = function() {
    this.state.gradientDepth === 0 && (this.state.activeTape = []), this.state.gradientDepth++;
  }, n.prototype.endTape = function() {
    this.state.gradientDepth--;
  }, n.prototype.startScope = function(e) {
    var t = { track: [], name: "unnamed scope", id: this.state.nextScopeId++ };
    e && (t.name = e), this.state.scopeStack.push(t), this.state.activeScope = t;
  }, n.prototype.endScope = function(e) {
    for (var t = this, r = S1(e), o = new Set(r.map(function(u) {
      return u.id;
    })), i = 0; i < this.state.activeScope.track.length; i++) {
      var a = this.state.activeScope.track[i];
      a.kept || o.has(a.id) || a.dispose();
    }
    var s = this.state.scopeStack.pop();
    this.state.activeScope = this.state.scopeStack.length === 0 ? null : this.state.scopeStack[this.state.scopeStack.length - 1], r.forEach(function(u) {
      u.kept || u.scopeId !== s.id || t.track(u);
    });
  }, n.prototype.gradients = function(e, t, r, o) {
    var i = this;
    if (o === void 0 && (o = !1), k(t.length > 0, function() {
      return "gradients() received an empty list of xs.";
    }), r != null && r.dtype !== "float32") throw new Error("dy must have 'float32' dtype, but has '" + r.dtype + "'");
    var a = this.scopedRun(function() {
      return i.startTape();
    }, function() {
      return i.endTape();
    }, function() {
      return i.tidy("forward", e);
    });
    k(a instanceof Je, function() {
      return "The result y returned by f() must be a tensor.";
    });
    var s = function(u, l, c) {
      for (var f = {}, d = {}, p = 0; p < l.length; p++) f[l[p].id] = !0;
      for (p = 0; p < u.length; p++) {
        var v = (C = u[p]).inputs;
        for (var g in v) {
          for (var y = v[g], x = !1, w = 0; w < l.length; w++) if (f[y.id]) {
            C.outputs.forEach(function(S) {
              return f[S.id] = !0;
            }), x = !0, d[C.id] = !0;
            break;
          }
          if (x) break;
        }
      }
      var b = {};
      b[c.id] = !0;
      var _ = {};
      for (p = u.length - 1; p >= 0; p--) for (v = (C = u[p]).inputs, w = 0; w < C.outputs.length; w++) if (b[C.outputs[w].id]) {
        for (var g in v) b[v[g].id] = !0, _[C.id] = !0;
        break;
      }
      var E = [];
      for (p = 0; p < u.length; p++) {
        var C;
        if (d[(C = u[p]).id] && _[C.id]) {
          var A = {};
          for (var g in C.inputs) {
            var R = C.inputs[g];
            f[R.id] && (A[g] = R);
          }
          var I = Object.assign({}, C);
          I.inputs = A, I.outputs = C.outputs, E.push(I);
        }
      }
      return E;
    }(this.state.activeTape, t, a);
    if (!o && s.length === 0 && t.length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
    return this.tidy("backward", function() {
      var u, l, c = {};
      c[a.id] = r ?? (u = a.shape, l = E1(ee(u), "float32"), D.makeTensor(l, u, "float32")), function(d, p, v) {
        for (var g = function(x) {
          var w = p[x], b = [];
          if (w.outputs.forEach(function(A) {
            var R = d[A.id];
            R != null ? b.push(R) : b.push(null);
          }), w.gradient == null) throw new Error("Cannot compute gradient: gradient function not found for " + w.kernelName + ".");
          var _ = w.gradient(b), E = function(A) {
            if (!(A in _)) throw new Error("Cannot backprop through input " + A + ". Available gradients found: " + Object.keys(_) + ".");
            var R = v(function() {
              return _[A]();
            });
            if (R.dtype !== "float32") throw new Error("Error in gradient for op " + w.kernelName + ". The gradient of input " + A + " must have 'float32' dtype, but has '" + R.dtype + "'");
            var I = w.inputs[A];
            if (!_t(R.shape, I.shape)) throw new Error("Error in gradient for op " + w.kernelName + ". The gradient of input '" + A + "' has shape '" + R.shape + "', which does not match the shape of the input '" + I.shape + "'");
            if (d[I.id] == null) d[I.id] = R;
            else {
              var S = d[I.id];
              d[I.id] = S.add(R), S.dispose();
            }
          };
          for (var C in w.inputs) E(C);
        }, y = p.length - 1; y >= 0; y--) g(y);
      }(c, s, function(d) {
        return i.tidy(d);
      });
      var f = t.map(function(d) {
        return c[d.id];
      });
      return i.state.gradientDepth === 0 && (i.state.activeTape.forEach(function(d) {
        for (var p = 0, v = d.saved; p < v.length; p++)
          v[p].dispose();
      }), i.state.activeTape = null), { value: a, grads: f };
    });
  }, n.prototype.customGrad = function(e) {
    var t = this;
    return k(Hl(e), function() {
      return "The f passed in customGrad(f) must be a function.";
    }), function() {
      for (var r, o = [], i = 0; i < arguments.length; i++) o[i] = arguments[i];
      k(o.every(function(s) {
        return s instanceof Je;
      }), function() {
        return "The args passed in customGrad(f)(x1, x2,...) must all be tensors";
      });
      var a = {};
      return o.forEach(function(s, u) {
        a[u] = s;
      }), t.runKernelFunc(function(s, u) {
        return k((r = e.apply(void 0, o.concat([u]))).value instanceof Je, function() {
          return "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor";
        }), k(Hl(r.gradFunc), function() {
          return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.";
        }), r.value;
      }, a, function(s, u) {
        var l = r.gradFunc(s, u), c = Array.isArray(l) ? l : [l];
        k(c.length === o.length, function() {
          return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).";
        }), k(c.every(function(d) {
          return d instanceof Je;
        }), function() {
          return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.";
        });
        var f = {};
        return c.forEach(function(d, p) {
          f[p] = function() {
            return d;
          };
        }), f;
      });
    };
  }, n.prototype.readSync = function(e) {
    return this.state.tensorInfo.get(e).backend.readSync(e);
  }, n.prototype.read = function(e) {
    return this.state.tensorInfo.get(e).backend.read(e);
  }, n.prototype.time = function(e) {
    return Z(this, void 0, void 0, function() {
      var t, r;
      return j(this, function(o) {
        switch (o.label) {
          case 0:
            return t = Wn(), [4, this.backend.time(e)];
          case 1:
            return (r = o.sent()).wallMs = Wn() - t, [2, r];
        }
      });
    });
  }, n.prototype.track = function(e) {
    return this.state.activeScope != null && (e.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(e)), e;
  }, Object.defineProperty(n.prototype, "registeredVariables", { get: function() {
    return this.state.registeredVariables;
  }, enumerable: !0, configurable: !0 }), n.prototype.reset = function() {
    for (var e in this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new em(), this.registry) this.disposeRegisteredKernels(e), this.registry[e].dispose(), delete this.registry[e];
    this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null;
  }, n.nextTensorId = 0, n.nextVariableId = 0, n;
}(), D = function() {
  var n = function() {
    if (Uu == null) {
      var t = void 0;
      if (typeof window < "u") t = window;
      else if (typeof global < "u") t = global;
      else if (typeof process < "u") t = process;
      else {
        if (typeof self > "u") throw new Error("Could not find a global object");
        t = self;
      }
      Uu = t;
    }
    return Uu;
  }();
  if (n._tfengine == null) {
    var e = new JC(n);
    n._tfengine = new p3(e);
  }
  return function(t) {
    v1 = t;
  }(n._tfengine.ENV), Hn = function() {
    return n._tfengine;
  }, n._tfengine;
}();
function A1() {
  return typeof window < "u" && window.document != null || typeof WorkerGlobalScope < "u";
}
var ar = V();
ar.registerFlag("DEBUG", function() {
  return !1;
}, function(n) {
  n && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
}), ar.registerFlag("IS_BROWSER", function() {
  return A1();
}), ar.registerFlag("IS_NODE", function() {
  return typeof process < "u" && process.versions !== void 0 && process.versions.node !== void 0;
}), ar.registerFlag("IS_CHROME", function() {
  return typeof navigator < "u" && navigator != null && navigator.userAgent != null && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
}), ar.registerFlag("PROD", function() {
  return !1;
}), ar.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", function() {
  return ar.getBool("DEBUG");
}), ar.registerFlag("DEPRECATION_WARNINGS_ENABLED", function() {
  return !0;
}), ar.registerFlag("IS_TEST", function() {
  return !1;
});
var ji, en, jt, to = {}, Vu = { alpha: !1, antialias: !1, premultipliedAlpha: !1, preserveDrawingBuffer: !1, depth: !1, stencil: !1, failIfMajorPerformanceCaveat: !0 };
function m3(n, e) {
  to[n] = e;
}
function jn(n) {
  n in to || (to[n] = function(t) {
    if (t !== 1 && t !== 2) throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
    var r = function(o) {
      if (typeof OffscreenCanvas < "u" && o === 2) return new OffscreenCanvas(300, 150);
      if (typeof document < "u") return document.createElement("canvas");
      throw new Error("Cannot create a canvas in this context");
    }(t);
    return r.addEventListener("webglcontextlost", function(o) {
      o.preventDefault(), delete to[t];
    }, !1), t === 1 ? r.getContext("webgl", Vu) || r.getContext("experimental-webgl", Vu) : r.getContext("webgl2", Vu);
  }(n));
  var e = to[n];
  return e.isContextLost() ? (delete to[n], jn(n)) : (e.disable(e.DEPTH_TEST), e.disable(e.STENCIL_TEST), e.disable(e.BLEND), e.disable(e.DITHER), e.disable(e.POLYGON_OFFSET_FILL), e.disable(e.SAMPLE_COVERAGE), e.enable(e.SCISSOR_TEST), e.enable(e.CULL_FACE), e.cullFace(e.BACK), to[n]);
}
function nu(n, e) {
  return [e, n];
}
function Gi(n) {
  var e = ee(n);
  return Wl(Math.ceil(e / 4));
}
function ca(n, e) {
  return [Math.max(1, Math.ceil(e / 2)), Math.max(1, Math.ceil(n / 2))];
}
function yf(n, e) {
  var t, r, o, i, a, s, u, l, c, f = n;
  return V().getNumber("WEBGL_VERSION") === 2 ? (t = f.R32F, r = f.R16F, o = f.RGBA16F, i = f.RGBA32F, a = f.RED, s = 4, u = 1, l = f.HALF_FLOAT, c = f.FLOAT) : (t = n.RGBA, r = n.RGBA, o = n.RGBA, i = f.RGBA, a = n.RGBA, s = 4, u = 4, l = e != null ? e.HALF_FLOAT_OES : null, c = n.FLOAT), { internalFormatFloat: t, internalFormatHalfFloat: r, internalFormatPackedHalfFloat: o, internalFormatPackedFloat: i, textureFormatFloat: a, downloadTextureFormat: n.RGBA, downloadUnpackNumChannels: s, defaultNumChannels: u, textureTypeHalfFloat: l, textureTypeFloat: c };
}
function ne(n, e, t) {
  var r = t();
  return e && function(o) {
    var i = o.getError();
    if (i !== o.NO_ERROR) throw new Error("WebGL Error: " + x3(o, i));
  }(n), r;
}
(function(n) {
  n[n.DENSE = 0] = "DENSE", n[n.SHARED_BATCH = 1] = "SHARED_BATCH";
})(ji || (ji = {})), function(n) {
  n[n.RENDER = 0] = "RENDER", n[n.UPLOAD = 1] = "UPLOAD", n[n.PIXELS = 2] = "PIXELS", n[n.DOWNLOAD = 3] = "DOWNLOAD";
}(en || (en = {})), function(n) {
  n[n.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16", n[n.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32", n[n.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE", n[n.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32", n[n.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16";
}(jt || (jt = {}));
var v3 = 596e-10, g3 = 65504;
function y3(n) {
  return !!(V().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || n === 0 || v3 < Math.abs(n) && Math.abs(n) < g3);
}
function x3(n, e) {
  switch (e) {
    case n.NO_ERROR:
      return "NO_ERROR";
    case n.INVALID_ENUM:
      return "INVALID_ENUM";
    case n.INVALID_VALUE:
      return "INVALID_VALUE";
    case n.INVALID_OPERATION:
      return "INVALID_OPERATION";
    case n.INVALID_FRAMEBUFFER_OPERATION:
      return "INVALID_FRAMEBUFFER_OPERATION";
    case n.OUT_OF_MEMORY:
      return "OUT_OF_MEMORY";
    case n.CONTEXT_LOST_WEBGL:
      return "CONTEXT_LOST_WEBGL";
    default:
      return "Unknown error code " + e;
  }
}
function Ea(n, e, t) {
  return xr(n, e, function() {
    return n.getExtension(t);
  }, 'Extension "' + t + '" not supported on this browser.');
}
function w3(n, e, t) {
  var r = xr(n, e, function() {
    return n.createShader(n.VERTEX_SHADER);
  }, "Unable to create vertex WebGLShader.");
  if (ne(n, e, function() {
    return n.shaderSource(r, t);
  }), ne(n, e, function() {
    return n.compileShader(r);
  }), n.getShaderParameter(r, n.COMPILE_STATUS) === !1) throw console.log(n.getShaderInfoLog(r)), new Error("Failed to compile vertex shader.");
  return r;
}
function _3(n, e, t) {
  var r = xr(n, e, function() {
    return n.createShader(n.FRAGMENT_SHADER);
  }, "Unable to create fragment WebGLShader.");
  if (ne(n, e, function() {
    return n.shaderSource(r, t);
  }), ne(n, e, function() {
    return n.compileShader(r);
  }), n.getShaderParameter(r, n.COMPILE_STATUS) === !1) throw function(o, i) {
    var a = b3.exec(i);
    if (a == null) return console.log("Couldn't parse line number in error: " + i), void console.log(o);
    for (var s = +a[1], u = o.split(`
`), l = u.length.toString().length + 2, c = u.map(function(y, x) {
      return qo((x + 1).toString(), l) + y;
    }), f = 0, d = 0; d < c.length; d++) f = Math.max(c[d].length, f);
    var p = c.slice(0, s - 1), v = c.slice(s - 1, s), g = c.slice(s);
    console.log(p.join(`
`)), console.log(i.split(`
`)[0]), console.log("%c " + qo(v[0], f), "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console.log(g.join(`
`));
  }(t, n.getShaderInfoLog(r)), new Error("Failed to compile fragment shader.");
  return r;
}
var Gu, Wu, b3 = /ERROR: [0-9]+:([0-9]+):/g;
function E3(n, e) {
  return xr(n, e, function() {
    return n.createProgram();
  }, "Unable to create WebGLProgram.");
}
function C3(n, e, t) {
  if (ne(n, e, function() {
    return n.linkProgram(t);
  }), n.getProgramParameter(t, n.LINK_STATUS) === !1) throw console.log(n.getProgramInfoLog(t)), new Error("Failed to link vertex and fragment shaders.");
}
function Hu(n, e, t) {
  if (ne(n, e, function() {
    return n.validateProgram(t);
  }), n.getProgramParameter(t, n.VALIDATE_STATUS) === !1) throw console.log(n.getProgramInfoLog(t)), new Error("Shader program validation failed.");
}
function T3(n, e, t) {
  var r = xr(n, e, function() {
    return n.createBuffer();
  }, "Unable to create WebGLBuffer");
  return ne(n, e, function() {
    return n.bindBuffer(n.ARRAY_BUFFER, r);
  }), ne(n, e, function() {
    return n.bufferData(n.ARRAY_BUFFER, t, n.STATIC_DRAW);
  }), r;
}
function I3(n, e, t) {
  var r = xr(n, e, function() {
    return n.createBuffer();
  }, "Unable to create WebGLBuffer");
  return ne(n, e, function() {
    return n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, r);
  }), ne(n, e, function() {
    return n.bufferData(n.ELEMENT_ARRAY_BUFFER, t, n.STATIC_DRAW);
  }), r;
}
function S3(n, e) {
  return xr(n, e, function() {
    return n.createTexture();
  }, "Unable to create WebGLTexture.");
}
function A3(n, e) {
  var t = V().getNumber("WEBGL_MAX_TEXTURE_SIZE");
  if (n <= 0 || e <= 0) {
    var r = "[" + n + "x" + e + "]";
    throw new Error("Requested texture size " + r + " is invalid.");
  }
  if (n > t || e > t)
    throw r = "[" + n + "x" + e + "]", new Error("Requested texture size " + r + " greater than WebGL maximum on this browser / GPU " + ("[" + t + "x" + t + "]") + ".");
}
function R3(n, e) {
  return xr(n, e, function() {
    return n.createFramebuffer();
  }, "Unable to create WebGLFramebuffer.");
}
function tm(n, e, t, r, o, i, a, s) {
  var u = n.getAttribLocation(t, r);
  return u !== -1 && (ne(n, e, function() {
    return n.bindBuffer(n.ARRAY_BUFFER, o);
  }), ne(n, e, function() {
    return n.vertexAttribPointer(u, i, n.FLOAT, !1, a, s);
  }), ne(n, e, function() {
    return n.enableVertexAttribArray(u);
  }), !0);
}
function k3(n, e, t, r) {
  F3(n, r), ne(n, e, function() {
    return n.activeTexture(n.TEXTURE0 + r);
  }), ne(n, e, function() {
    return n.bindTexture(n.TEXTURE_2D, t);
  });
}
function P3(n, e, t, r) {
  return xr(n, e, function() {
    return n.getUniformLocation(t, r);
  }, 'uniform "' + r + '" not present in program.');
}
function N3(n, e, t) {
  return n.getUniformLocation(e, t);
}
function M3(n, e, t, r, o, i) {
  ne(n, e, function() {
    return k3(n, e, r, i);
  }), ne(n, e, function() {
    return n.uniform1i(o, i);
  });
}
function $u(n, e, t, r) {
  ne(n, e, function() {
    return n.bindFramebuffer(n.FRAMEBUFFER, r);
  }), ne(n, e, function() {
    return n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, t, 0);
  });
}
function nm(n, e, t) {
  ne(n, e, function() {
    return n.bindFramebuffer(n.FRAMEBUFFER, t);
  }), ne(n, e, function() {
    return n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, null, 0);
  });
}
function Ca(n) {
  var e = n.checkFramebufferStatus(n.FRAMEBUFFER);
  if (e !== n.FRAMEBUFFER_COMPLETE) throw new Error("Error binding framebuffer: " + D3(n, e));
}
function D3(n, e) {
  switch (e) {
    case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
      return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
    case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
      return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
    case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
      return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
    case n.FRAMEBUFFER_UNSUPPORTED:
      return "FRAMEBUFFER_UNSUPPORTED";
    default:
      return "unknown error " + e;
  }
}
function xr(n, e, t, r) {
  var o = ne(n, e, function() {
    return t();
  });
  if (o == null) throw new Error(r);
  return o;
}
function F3(n, e) {
  var t = n.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1, r = e + n.TEXTURE0;
  if (r < n.TEXTURE0 || r > t) throw new Error("textureUnit must be in " + ("[gl.TEXTURE0, gl.TEXTURE" + t + "]") + ".");
}
function ns(n, e) {
  return e === void 0 && (e = 2), ee(n.slice(0, n.length - e));
}
function rs(n) {
  if (n.length === 0) throw Error("Cannot get rows and columns of an empty shape array.");
  return [n.length > 1 ? n[n.length - 2] : 1, n[n.length - 1]];
}
function qu(n) {
  var e = [1, 1, 1];
  return n.length === 0 || n.length === 1 && n[0] === 1 || (e = [ns(n)].concat(rs(n))), e;
}
function L3(n, e) {
  var t;
  e === void 0 && (e = !1);
  var r = V().getNumber("WEBGL_MAX_TEXTURE_SIZE");
  if (e && (r *= 2, (n = n.map(function(l, c) {
    return c >= n.length - 2 ? w1(n[c]) : n[c];
  })).length === 1 && (n = [2, n[0]])), n.length !== 2) {
    var o = ro(n);
    n = o.newShape;
  }
  var i = ee(n);
  if (n.length <= 1 && i <= r) return [1, i];
  if (n.length === 2 && n[0] <= r && n[1] <= r) return n;
  if (n.length === 3 && n[0] * n[1] <= r && n[2] <= r) return [n[0] * n[1], n[2]];
  if (n.length === 3 && n[0] <= r && n[1] * n[2] <= r) return [n[0], n[1] * n[2]];
  if (n.length === 4 && n[0] * n[1] * n[2] <= r && n[3] <= r) return [n[0] * n[1] * n[2], n[3]];
  if (n.length === 4 && n[0] <= r && n[1] * n[2] * n[3] <= r) return [n[0], n[1] * n[2] * n[3]];
  if (e) {
    var a = ns(n), s = 2, u = 2;
    return n.length && (s = (t = rs(n))[0], u = t[1]), Wl(i = a * (s / 2) * (u / 2)).map(function(l) {
      return 2 * l;
    });
  }
  return Wl(i);
}
function Ta(n) {
  return n % 2 == 0;
}
function Ia(n, e) {
  if (_t(n = n.slice(-2), e = e.slice(-2)) || !n.length || !e.length || n[0] === 0 || n[1] === 0 || e[0] === 0 || e[1] === 0) return !0;
  if (n.length !== e.length) {
    var t = n.slice(-1)[0], r = e.slice(-1)[0];
    if (t === r || Ta(t) && Ta(r) && (n[0] === 1 || e[0] === 1)) return !0;
  }
  return n[1] === e[1] && Ta(n[0]) && Ta(e[0]);
}
function B3(n) {
  if (Gu == null) {
    var e = jn(n);
    Gu = e.getParameter(e.MAX_TEXTURE_SIZE);
  }
  return Gu;
}
function O3(n) {
  if (Wu == null) {
    var e = jn(n);
    Wu = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS);
  }
  return Math.min(16, Wu);
}
function U3(n) {
  if (n === 0) return 0;
  var e = jn(n);
  return gn(e, "EXT_disjoint_timer_query_webgl2") && n === 2 ? 2 : gn(e, "EXT_disjoint_timer_query") ? 1 : 0;
}
function gn(n, e) {
  return n.getExtension(e) != null;
}
function rm(n) {
  try {
    if (jn(n) != null) return !0;
  } catch {
    return !1;
  }
  return !1;
}
function V3(n) {
  if (n === 0) return !1;
  var e = jn(n);
  if (n === 1) {
    if (!gn(e, "OES_texture_float")) return !1;
  } else if (!gn(e, "EXT_color_buffer_float")) return !1;
  return Xl(e);
}
function G3(n) {
  if (n === 0) return !1;
  var e = jn(n);
  if (n !== 1) {
    if (gn(e, "EXT_color_buffer_float")) return Xl(e);
    if (gn(e, "EXT_color_buffer_half_float")) {
      var t = e.getExtension("EXT_color_buffer_half_float");
      return function(r, o) {
        var i = yf(r, o), a = r.createTexture();
        r.bindTexture(r.TEXTURE_2D, a), r.texImage2D(r.TEXTURE_2D, 0, i.internalFormatHalfFloat, 1, 1, 0, i.textureFormatFloat, i.textureTypeHalfFloat, null);
        var s = r.createFramebuffer();
        r.bindFramebuffer(r.FRAMEBUFFER, s), r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, a, 0);
        var u = r.checkFramebufferStatus(r.FRAMEBUFFER) === r.FRAMEBUFFER_COMPLETE;
        return r.bindTexture(r.TEXTURE_2D, null), r.bindFramebuffer(r.FRAMEBUFFER, null), r.deleteTexture(a), r.deleteFramebuffer(s), u;
      }(e, t);
    }
    return !1;
  }
  return !!gn(e, "OES_texture_float") && !!gn(e, "WEBGL_color_buffer_float") && Xl(e);
}
function Xl(n) {
  var e = yf(n), t = n.createTexture();
  n.bindTexture(n.TEXTURE_2D, t), n.texImage2D(n.TEXTURE_2D, 0, e.internalFormatFloat, 1, 1, 0, e.textureFormatFloat, e.textureTypeFloat, null);
  var r = n.createFramebuffer();
  n.bindFramebuffer(n.FRAMEBUFFER, r), n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, t, 0);
  var o = n.checkFramebufferStatus(n.FRAMEBUFFER) === n.FRAMEBUFFER_COMPLETE;
  return n.bindTexture(n.TEXTURE_2D, null), n.bindFramebuffer(n.FRAMEBUFFER, null), n.deleteTexture(t), n.deleteFramebuffer(r), o;
}
function W3(n) {
  return n === 2 && jn(n).fenceSync != null;
}
var fe = V();
function R1(n) {
  V().getBool("DEPRECATION_WARNINGS_ENABLED") && console.warn(n + " You can disable deprecation warnings with tf.disableDeprecationWarnings().");
}
function X(n, e) {
  return D.tidy(n, e);
}
function Ht(n) {
  S1(n).forEach(function(e) {
    return e.dispose();
  });
}
function H3(n) {
  return D.keep(n);
}
function os() {
  for (var n = [], e = 0; e < arguments.length; e++) n[e] = arguments[e];
  V().getBool("IS_TEST") || console.warn.apply(console, n);
}
function Xr(n, e) {
  var t = n;
  if (zn(n)) return e === "string" ? [] : [n.length];
  if (!Array.isArray(n)) return [];
  for (var r = []; Array.isArray(t) || zn(t) && e !== "string"; ) r.push(t.length), t = t[0];
  return Array.isArray(n) && V().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && function o(i, a, s) {
    if (s = s || [], !Array.isArray(i) && !zn(i)) return void k(a.length === 0, function() {
      return "Element arr[" + s.join("][") + "] is a primitive, but should be an array/TypedArray of " + a[0] + " elements";
    });
    k(a.length > 0, function() {
      return "Element arr[" + s.join("][") + "] should be a primitive, but is an array of " + i.length + " elements";
    }), k(i.length === a[0], function() {
      return "Element arr[" + s.join("][") + "] should have " + a[0] + " elements, but has " + i.length + " elements";
    });
    for (var u = a.slice(1), l = 0; l < i.length; ++l) o(i[l], u, s.concat(l));
  }(n, r, []), r;
}
function om(n, e, t, r) {
  if (n != null && (n !== "numeric" && n !== e || n === "numeric" && e === "string")) throw new Error("Argument '" + t + "' passed to '" + r + "' must be " + n + " tensor, but got " + e + " tensor");
}
function T(n, e, t, r) {
  if (r === void 0 && (r = "numeric"), n instanceof Je) return om(r, n.dtype, e, t), n;
  var o = ua(n);
  if (o !== "string" && ["bool", "int32", "float32"].indexOf(r) >= 0 && (o = r), om(r, o, e, t), n == null || !zn(n) && !Array.isArray(n) && typeof n != "number" && typeof n != "boolean" && typeof n != "string") {
    var i = n == null ? "null" : n.constructor.name;
    throw new Error("Argument '" + e + "' passed to '" + t + "' must be a Tensor or TensorLike, but got '" + i + "'");
  }
  var a = Xr(n, o);
  zn(n) || Array.isArray(n) || (n = [n]);
  var s = o !== "string" ? b1(n, o, V().getBool("DEBUG")) : ci(n, [], !0);
  return D.makeTensor(s, a, o);
}
function is(n, e, t, r) {
  if (r === void 0 && (r = "numeric"), !Array.isArray(n)) throw new Error("Argument " + e + " passed to " + t + " must be a `Tensor[]` or `TensorLike[]`");
  return n.map(function(o, i) {
    return T(o, e + "[" + i + "]", t);
  }, r);
}
function k1(n, e) {
  for (var t = 0; t < n.length; ++t) if (n[n.length - t - 1] !== e - 1 - t) return !1;
  return !0;
}
function $3(n, e, t) {
  for (var r = n.length + e.length, o = [], i = 0, a = 0, s = 0; s < r; s++) t.indexOf(s) === -1 ? o.push(n[i++]) : o.push(e[a++]);
  return o;
}
function St(n, e) {
  for (var t = [], r = n.length, o = 0; o < r; o++) e.indexOf(o) === -1 && t.push(n[o]);
  return [t, e.map(function(i) {
    return n[i];
  })];
}
function qt(n, e) {
  return $3(n, e.map(function(t) {
    return 1;
  }), e);
}
function Zt(n, e, t) {
  k(k1(e, t), function() {
    return n + " supports only inner-most axes for now. Got axes " + e + " and rank-" + t + " input.";
  });
}
function er(n, e) {
  if (k1(n, e)) return null;
  for (var t = [], r = 0; r < e; ++r) n.indexOf(r) === -1 && t.push(r);
  return n.forEach(function(o) {
    return t.push(o);
  }), t;
}
function xf(n) {
  return n.map(function(e, t) {
    return [t, e];
  }).sort(function(e, t) {
    return e[1] - t[1];
  }).map(function(e) {
    return e[0];
  });
}
function tr(n, e) {
  for (var t = [], r = e - n; r < e; ++r) t.push(r);
  return t;
}
function q3(n, e) {
  var t = n[0].length;
  n.forEach(function(o, i) {
    k(o.length === t, function() {
      return "Error in concat" + t + "D: rank of tensors[" + i + "] must be the same as the rank of the rest (" + t + ")";
    });
  }), k(e >= 0 && e < t, function() {
    return "Error in concat" + t + "D: axis must be between 0 and " + (t - 1) + ".";
  });
  var r = n[0];
  n.forEach(function(o, i) {
    for (var a = 0; a < t; a++) k(a === e || o[a] === r[a], function() {
      return "Error in concat" + t + "D: Shape of tensors[" + i + "] (" + o + ") does not match the shape of the rest (" + r + ") along the non-concatenated axis " + i + ".";
    });
  });
}
function di(n, e) {
  for (var t = n[0].slice(), r = 1; r < n.length; r++) t[e] += n[r][e];
  return t;
}
function N(n) {
  var e = Object.keys(n);
  if (e.length !== 1) throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with " + e.length + " keys.");
  var t = e[0], r = n[t];
  t.endsWith("_") && (t = t.substring(0, t.length - 1));
  var o = function() {
    for (var i = [], a = 0; a < arguments.length; a++) i[a] = arguments[a];
    D.startScope(t);
    try {
      var s = r.apply(void 0, i);
      return s instanceof Promise && console.error("Cannot return a Promise inside of tidy."), D.endScope(s), s;
    } catch (u) {
      throw D.endScope(null), u;
    }
  };
  return Object.defineProperty(o, "name", { value: t, configurable: !0 }), o;
}
fe.registerFlag("HAS_WEBGL", function() {
  return fe.getNumber("WEBGL_VERSION") > 0;
}), fe.registerFlag("WEBGL_VERSION", function() {
  return rm(2) ? 2 : rm(1) ? 1 : 0;
}), fe.registerFlag("WEBGL_BUFFER_SUPPORTED", function() {
  return fe.get("WEBGL_VERSION") === 2;
}), fe.registerFlag("WEBGL_CPU_FORWARD", function() {
  return !0;
}), fe.registerFlag("WEBGL_FORCE_F16_TEXTURES", function() {
  return !1;
}), fe.registerFlag("WEBGL_PACK", function() {
  return fe.getBool("HAS_WEBGL");
}), fe.registerFlag("WEBGL_PACK_NORMALIZATION", function() {
  return fe.getBool("WEBGL_PACK");
}), fe.registerFlag("WEBGL_PACK_CLIP", function() {
  return fe.getBool("WEBGL_PACK");
}), fe.registerFlag("WEBGL_PACK_DEPTHWISECONV", function() {
  return !1;
}), fe.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", function() {
  return fe.getBool("WEBGL_PACK");
}), fe.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", function() {
  return fe.getBool("WEBGL_PACK");
}), fe.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", function() {
  return fe.getBool("WEBGL_PACK");
}), fe.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", function() {
  return fe.getBool("WEBGL_PACK");
}), fe.registerFlag("WEBGL_PACK_REDUCE", function() {
  return fe.getBool("WEBGL_PACK");
}), fe.registerFlag("WEBGL_LAZILY_UNPACK", function() {
  return fe.getBool("WEBGL_PACK");
}), fe.registerFlag("WEBGL_CONV_IM2COL", function() {
  return fe.getBool("WEBGL_PACK");
}), fe.registerFlag("WEBGL_MAX_TEXTURE_SIZE", function() {
  return B3(fe.getNumber("WEBGL_VERSION"));
}), fe.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", function() {
  return O3(fe.getNumber("WEBGL_VERSION"));
}), fe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", function() {
  var n = fe.getNumber("WEBGL_VERSION");
  return n === 0 ? 0 : U3(n);
}), fe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", function() {
  return fe.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && (n = navigator.userAgent || navigator.vendor || window.opera, !(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(n) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(n.substr(0, 4))));
  var n;
}), fe.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", function() {
  return V3(fe.getNumber("WEBGL_VERSION"));
}), fe.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", function() {
  return !fe.getBool("WEBGL_FORCE_F16_TEXTURES") && fe.getBool("WEBGL_RENDER_FLOAT32_CAPABLE");
}), fe.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", function() {
  return G3(fe.getNumber("WEBGL_VERSION"));
}), fe.registerFlag("WEBGL_FENCE_API_ENABLED", function() {
  return W3(fe.getNumber("WEBGL_VERSION"));
}), fe.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", function() {
  return fe.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0;
}), I1 = R1;
var Et = N({ complex_: function(n, e) {
  var t = T(n, "real", "complex"), r = T(e, "imag", "complex");
  return De(t.shape, r.shape, "real and imag shapes, " + t.shape + " and " + r.shape + ", must match in call to tf.complex()."), D.runKernelFunc(function(o) {
    return o.complex(t, r);
  }, { $real: t, $imag: r });
} }), mn = N({ real_: function(n) {
  var e = T(n, "input", "real");
  return D.runKernelFunc(function(t) {
    return t.real(e);
  }, { $input: e });
} }), $n = N({ imag_: function(n) {
  var e = T(n, "input", "imag");
  return D.runKernelFunc(function(t) {
    return t.imag(e);
  }, { $input: e });
} });
function Tt(n, e, t) {
  return Yr(n, e, Xr(n, t), t);
}
function Yr(n, e, t, r) {
  if (r == null && (r = ua(n)), r === "complex64") throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
  if (!zn(n) && !Array.isArray(n) && typeof n != "number" && typeof n != "boolean" && typeof n != "string") throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
  if (e != null) {
    C1(e);
    var o = ee(e), i = ee(t);
    k(o === i, function() {
      return "Based on the provided shape, [" + e + "], the tensor should have " + o + " values but has " + i;
    });
    for (var a = 0; a < t.length; ++a) {
      var s = t[a], u = a !== t.length - 1 || s !== ee(e.slice(a));
      k(t[a] === e[a] || !u, function() {
        return "Error creating a new Tensor. Inferred shape (" + t + ") does not match the provided shape (" + e + "). ";
      });
    }
  }
  return zn(n) || Array.isArray(n) || (n = [n]), e = e || t, n = r !== "string" ? b1(n, r, V().getBool("DEBUG")) : ci(n, [], !0), D.makeTensor(n, e, r);
}
function K(n, e) {
  if ((zn(n) && e !== "string" || Array.isArray(n)) && e !== "complex64") throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
  if (e === "string" && zn(n) && !(n instanceof Uint8Array)) throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
  return Yr(n, [], [], e);
}
function ut(n, e) {
  Ii(n);
  var t = Xr(n, e);
  if (t.length !== 1) throw new Error("tensor1d() requires values to be a flat/TypedArray");
  return Yr(n, null, t, e);
}
function Or(n, e, t) {
  if (Ii(n), e != null && e.length !== 2) throw new Error("tensor2d() requires shape to have two numbers");
  var r = Xr(n, t);
  if (r.length !== 2 && r.length !== 1) throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
  if (r.length === 1 && e == null) throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
  return Yr(n, e, r, t);
}
function wf(n, e, t) {
  if (Ii(n), e != null && e.length !== 3) throw new Error("tensor3d() requires shape to have three numbers");
  var r = Xr(n, t);
  if (r.length !== 3 && r.length !== 1) throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
  if (r.length === 1 && e == null) throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
  return Yr(n, e, r, t);
}
function Vt(n, e, t) {
  if (Ii(n), e != null && e.length !== 4) throw new Error("tensor4d() requires shape to have four numbers");
  var r = Xr(n, t);
  if (r.length !== 4 && r.length !== 1) throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
  if (r.length === 1 && e == null) throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
  return Yr(n, e, r, t);
}
function z3(n, e, t) {
  if (Ii(n), e != null && e.length !== 5) throw new Error("tensor5d() requires shape to have five numbers");
  var r = Xr(n, t);
  if (r.length !== 5 && r.length !== 1) throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
  if (r.length === 1 && e == null) throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
  return Yr(n, e, r, t);
}
function K3(n, e, t) {
  if (Ii(n), e != null && e.length !== 6) throw new Error("tensor6d() requires shape to have six numbers");
  var r = Xr(n, t);
  if (r.length !== 6 && r.length !== 1) throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
  if (r.length === 1 && e == null) throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
  return Yr(n, e = e || r, r, t);
}
function J3(n, e, t, r) {
  return e === void 0 && (e = !0), D.makeVariable(n, e, t, r);
}
function Si(n, e) {
  if (e === void 0 && (e = "float32"), e === "complex64") {
    var t = Si(n, "float32"), r = Ge(n, "float32");
    return Et(t, r);
  }
  var o = E1(ee(n), e);
  return D.makeTensor(o, n, e);
}
function Ge(n, e) {
  if (e === void 0 && (e = "float32"), e === "complex64") {
    var t = Ge(n, "float32"), r = Ge(n, "float32");
    return Et(t, r);
  }
  var o = la(ee(n), e);
  return D.makeTensor(o, n, e);
}
function Jn(n, e, t) {
  return D.runKernelFunc(function(r) {
    return r.fill(n, e, t);
  }, {});
}
function X3(n, e, t) {
  if (t <= 0) throw new Error("The number of values should be positive.");
  return D.runKernelFunc(function(r) {
    return r.linspace(n, e, t);
  }, {});
}
function as(n, e, t, r) {
  if (t === void 0 && (t = 1), r === void 0 && (r = "float32"), t === 0) throw new Error("Cannot have a step of zero");
  if (n === e || n < e && t < 0 || e < n && t > 1) return Ge([0], r);
  var o = la(Math.abs(Math.ceil((e - n) / t)), r);
  e < n && t === 1 && (t = -1), o[0] = n;
  for (var i = 1; i < o.length; i++) o[i] = o[i - 1] + t;
  return ut(o, r);
}
var P1 = N({ onesLike_: function(n) {
  var e = T(n, "x", "onesLike");
  if (e.dtype === "complex64") {
    var t = P1(mn(e)), r = Ie($n(e));
    return Et(t, r);
  }
  return D.runKernelFunc(function(o) {
    return o.onesLike(e);
  }, { $x: e }, function(o, i) {
    return { $x: function() {
      return Ie(o);
    } };
  });
} }), Ie = N({ zerosLike_: function(n) {
  var e = T(n, "x", "zerosLike");
  return D.runKernelFunc(function(t) {
    return t.zerosLike(e);
  }, { $x: e }, function(t, r) {
    return { $x: function() {
      return Ie(t);
    } };
  });
} }), ht = N({ concat_: function(n, e) {
  e === void 0 && (e = 0), k(n.length >= 1, function() {
    return "Pass at least one tensor to concat";
  });
  var t = is(n, "tensors", "concat");
  t[0].dtype === "complex64" && t.forEach(function(s) {
    if (s.dtype !== "complex64") throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ` + s.dtype + ". ");
  }), e = gt(e, t[0].shape)[0];
  var r = di(t.map(function(s) {
    return s.shape;
  }), e);
  if (ee(r) === 0) return Tt([], r);
  if ((t = t.filter(function(s) {
    return s.size > 0;
  })).length === 1) return t[0];
  var o = t.map(function(s) {
    return s.shape;
  });
  q3(o, e);
  var i = t, a = { axis: e };
  return D.runKernelFunc(function(s) {
    return s.concat(t, e);
  }, i, function(s) {
    var u = o.map(function(l) {
      return l[e];
    });
    return _f(s, u, e).map(function(l) {
      return function() {
        return l;
      };
    });
  }, "Concat", a);
} }), Y3 = N({ concat1d_: function(n) {
  return ht(n, 0);
} }), Q3 = N({ concat2d_: function(n, e) {
  return ht(n, e);
} }), Z3 = N({ concat3d_: function(n, e) {
  return ht(n, e);
} }), j3 = N({ concat4d_: function(n, e) {
  return ht(n, e);
} }), _f = N({ split_: function(n, e, t) {
  t === void 0 && (t = 0);
  var r, o = T(n, "x", "split");
  return t = gt(t, o.shape)[0], typeof e == "number" ? (k(o.shape[t] % e == 0, function() {
    return "Number of splits must evenly divide the axis.";
  }), r = new Array(e).fill(o.shape[t] / e)) : (k(o.shape[t] === e.reduce(function(i, a) {
    return i + a;
  }), function() {
    return "The sum of sizes must match the size of the axis dimension.";
  }), r = e), D.runKernelFunc(function(i) {
    return i.split(o, r, t);
  }, { $x: o }, function(i) {
    return { $x: function() {
      return ht(i, t);
    } };
  });
} });
function xo(n, e) {
  return n(e = { exports: {} }, e.exports), e.exports;
}
var eT = xo(function(n) {
  (function(e, t, r) {
    function o(s) {
      var u, l = this, c = (u = 4022871197, function(f) {
        f = f.toString();
        for (var d = 0; d < f.length; d++) {
          var p = 0.02519603282416938 * (u += f.charCodeAt(d));
          p -= u = p >>> 0, u = (p *= u) >>> 0, u += 4294967296 * (p -= u);
        }
        return 23283064365386963e-26 * (u >>> 0);
      });
      l.next = function() {
        var f = 2091639 * l.s0 + 23283064365386963e-26 * l.c;
        return l.s0 = l.s1, l.s1 = l.s2, l.s2 = f - (l.c = 0 | f);
      }, l.c = 1, l.s0 = c(" "), l.s1 = c(" "), l.s2 = c(" "), l.s0 -= c(s), l.s0 < 0 && (l.s0 += 1), l.s1 -= c(s), l.s1 < 0 && (l.s1 += 1), l.s2 -= c(s), l.s2 < 0 && (l.s2 += 1), c = null;
    }
    function i(s, u) {
      return u.c = s.c, u.s0 = s.s0, u.s1 = s.s1, u.s2 = s.s2, u;
    }
    function a(s, u) {
      var l = new o(s), c = u && u.state, f = l.next;
      return f.int32 = function() {
        return 4294967296 * l.next() | 0;
      }, f.double = function() {
        return f() + 11102230246251565e-32 * (2097152 * f() | 0);
      }, f.quick = f, c && (typeof c == "object" && i(c, l), f.state = function() {
        return i(l, {});
      }), f;
    }
    t && t.exports ? t.exports = a : this.alea = a;
  })(0, n);
}), tT = xo(function(n) {
  (function(e, t, r) {
    function o(s) {
      var u = this, l = "";
      u.x = 0, u.y = 0, u.z = 0, u.w = 0, u.next = function() {
        var f = u.x ^ u.x << 11;
        return u.x = u.y, u.y = u.z, u.z = u.w, u.w ^= u.w >>> 19 ^ f ^ f >>> 8;
      }, s === (0 | s) ? u.x = s : l += s;
      for (var c = 0; c < l.length + 64; c++) u.x ^= 0 | l.charCodeAt(c), u.next();
    }
    function i(s, u) {
      return u.x = s.x, u.y = s.y, u.z = s.z, u.w = s.w, u;
    }
    function a(s, u) {
      var l = new o(s), c = u && u.state, f = function() {
        return (l.next() >>> 0) / 4294967296;
      };
      return f.double = function() {
        do
          var d = ((l.next() >>> 11) + (l.next() >>> 0) / 4294967296) / 2097152;
        while (d === 0);
        return d;
      }, f.int32 = l.next, f.quick = f, c && (typeof c == "object" && i(c, l), f.state = function() {
        return i(l, {});
      }), f;
    }
    t && t.exports ? t.exports = a : this.xor128 = a;
  })(0, n);
}), nT = xo(function(n) {
  (function(e, t, r) {
    function o(s) {
      var u = this, l = "";
      u.next = function() {
        var f = u.x ^ u.x >>> 2;
        return u.x = u.y, u.y = u.z, u.z = u.w, u.w = u.v, (u.d = u.d + 362437 | 0) + (u.v = u.v ^ u.v << 4 ^ f ^ f << 1) | 0;
      }, u.x = 0, u.y = 0, u.z = 0, u.w = 0, u.v = 0, s === (0 | s) ? u.x = s : l += s;
      for (var c = 0; c < l.length + 64; c++) u.x ^= 0 | l.charCodeAt(c), c == l.length && (u.d = u.x << 10 ^ u.x >>> 4), u.next();
    }
    function i(s, u) {
      return u.x = s.x, u.y = s.y, u.z = s.z, u.w = s.w, u.v = s.v, u.d = s.d, u;
    }
    function a(s, u) {
      var l = new o(s), c = u && u.state, f = function() {
        return (l.next() >>> 0) / 4294967296;
      };
      return f.double = function() {
        do
          var d = ((l.next() >>> 11) + (l.next() >>> 0) / 4294967296) / 2097152;
        while (d === 0);
        return d;
      }, f.int32 = l.next, f.quick = f, c && (typeof c == "object" && i(c, l), f.state = function() {
        return i(l, {});
      }), f;
    }
    t && t.exports ? t.exports = a : this.xorwow = a;
  })(0, n);
}), rT = xo(function(n) {
  (function(e, t, r) {
    function o(s) {
      var u = this;
      u.next = function() {
        var l, c, f = u.x, d = u.i;
        return l = f[d], c = (l ^= l >>> 7) ^ l << 24, c ^= (l = f[d + 1 & 7]) ^ l >>> 10, c ^= (l = f[d + 3 & 7]) ^ l >>> 3, c ^= (l = f[d + 4 & 7]) ^ l << 7, l = f[d + 7 & 7], c ^= (l ^= l << 13) ^ l << 9, f[d] = c, u.i = d + 1 & 7, c;
      }, function(l, c) {
        var f, d = [];
        if (c === (0 | c)) d[0] = c;
        else for (c = "" + c, f = 0; f < c.length; ++f) d[7 & f] = d[7 & f] << 15 ^ c.charCodeAt(f) + d[f + 1 & 7] << 13;
        for (; d.length < 8; ) d.push(0);
        for (f = 0; f < 8 && d[f] === 0; ++f) ;
        for (f == 8 ? d[7] = -1 : d[f], l.x = d, l.i = 0, f = 256; f > 0; --f) l.next();
      }(u, s);
    }
    function i(s, u) {
      return u.x = s.x.slice(), u.i = s.i, u;
    }
    function a(s, u) {
      s == null && (s = +/* @__PURE__ */ new Date());
      var l = new o(s), c = u && u.state, f = function() {
        return (l.next() >>> 0) / 4294967296;
      };
      return f.double = function() {
        do
          var d = ((l.next() >>> 11) + (l.next() >>> 0) / 4294967296) / 2097152;
        while (d === 0);
        return d;
      }, f.int32 = l.next, f.quick = f, c && (c.x && i(c, l), f.state = function() {
        return i(l, {});
      }), f;
    }
    t && t.exports ? t.exports = a : this.xorshift7 = a;
  })(0, n);
}), oT = xo(function(n) {
  (function(e, t, r) {
    function o(s) {
      var u = this;
      u.next = function() {
        var l, c, f = u.w, d = u.X, p = u.i;
        return u.w = f = f + 1640531527 | 0, c = d[p + 34 & 127], l = d[p = p + 1 & 127], c ^= c << 13, l ^= l << 17, c ^= c >>> 15, l ^= l >>> 12, c = d[p] = c ^ l, u.i = p, c + (f ^ f >>> 16) | 0;
      }, function(l, c) {
        var f, d, p, v, g, y = [], x = 128;
        for (c === (0 | c) ? (d = c, c = null) : (c += "\0", d = 0, x = Math.max(x, c.length)), p = 0, v = -32; v < x; ++v) c && (d ^= c.charCodeAt((v + 32) % c.length)), v === 0 && (g = d), d ^= d << 10, d ^= d >>> 15, d ^= d << 4, d ^= d >>> 13, v >= 0 && (g = g + 1640531527 | 0, p = (f = y[127 & v] ^= d + g) == 0 ? p + 1 : 0);
        for (p >= 128 && (y[127 & (c && c.length || 0)] = -1), p = 127, v = 512; v > 0; --v) d = y[p + 34 & 127], f = y[p = p + 1 & 127], d ^= d << 13, f ^= f << 17, d ^= d >>> 15, f ^= f >>> 12, y[p] = d ^ f;
        l.w = g, l.X = y, l.i = p;
      }(u, s);
    }
    function i(s, u) {
      return u.i = s.i, u.w = s.w, u.X = s.X.slice(), u;
    }
    function a(s, u) {
      s == null && (s = +/* @__PURE__ */ new Date());
      var l = new o(s), c = u && u.state, f = function() {
        return (l.next() >>> 0) / 4294967296;
      };
      return f.double = function() {
        do
          var d = ((l.next() >>> 11) + (l.next() >>> 0) / 4294967296) / 2097152;
        while (d === 0);
        return d;
      }, f.int32 = l.next, f.quick = f, c && (c.X && i(c, l), f.state = function() {
        return i(l, {});
      }), f;
    }
    t && t.exports ? t.exports = a : this.xor4096 = a;
  })(0, n);
}), iT = xo(function(n) {
  (function(e, t, r) {
    function o(s) {
      var u = this, l = "";
      u.next = function() {
        var f = u.b, d = u.c, p = u.d, v = u.a;
        return f = f << 25 ^ f >>> 7 ^ d, d = d - p | 0, p = p << 24 ^ p >>> 8 ^ v, v = v - f | 0, u.b = f = f << 20 ^ f >>> 12 ^ d, u.c = d = d - p | 0, u.d = p << 16 ^ d >>> 16 ^ v, u.a = v - f | 0;
      }, u.a = 0, u.b = 0, u.c = -1640531527, u.d = 1367130551, s === Math.floor(s) ? (u.a = s / 4294967296 | 0, u.b = 0 | s) : l += s;
      for (var c = 0; c < l.length + 20; c++) u.b ^= 0 | l.charCodeAt(c), u.next();
    }
    function i(s, u) {
      return u.a = s.a, u.b = s.b, u.c = s.c, u.d = s.d, u;
    }
    function a(s, u) {
      var l = new o(s), c = u && u.state, f = function() {
        return (l.next() >>> 0) / 4294967296;
      };
      return f.double = function() {
        do
          var d = ((l.next() >>> 11) + (l.next() >>> 0) / 4294967296) / 2097152;
        while (d === 0);
        return d;
      }, f.int32 = l.next, f.quick = f, c && (typeof c == "object" && i(c, l), f.state = function() {
        return i(l, {});
      }), f;
    }
    t && t.exports ? t.exports = a : this.tychei = a;
  })(0, n);
}), no = xo(function(n) {
  (function(e, t) {
    var r, o = this, i = 256, a = 6, s = "random", u = t.pow(i, a), l = t.pow(2, 52), c = 2 * l, f = i - 1;
    function d(x, w, b) {
      var _ = [], E = g(function R(I, S) {
        var M, P = [], B = typeof I;
        if (S && B == "object") for (M in I) try {
          P.push(R(I[M], S - 1));
        } catch {
        }
        return P.length ? P : B == "string" ? I : I + "\0";
      }((w = w == 1 ? { entropy: !0 } : w || {}).entropy ? [x, y(e)] : x ?? function() {
        try {
          var R;
          return r && (R = r.randomBytes) ? R = R(i) : (R = new Uint8Array(i), (o.crypto || o.msCrypto).getRandomValues(R)), y(R);
        } catch {
          var I = o.navigator, S = I && I.plugins;
          return [+/* @__PURE__ */ new Date(), o, S, o.screen, y(e)];
        }
      }(), 3), _), C = new p(_), A = function() {
        for (var R = C.g(a), I = u, S = 0; R < l; ) R = (R + S) * i, I *= i, S = C.g(1);
        for (; R >= c; ) R /= 2, I /= 2, S >>>= 1;
        return (R + S) / I;
      };
      return A.int32 = function() {
        return 0 | C.g(4);
      }, A.quick = function() {
        return C.g(4) / 4294967296;
      }, A.double = A, g(y(C.S), e), (w.pass || b || function(R, I, S, M) {
        return M && (M.S && v(M, C), R.state = function() {
          return v(C, {});
        }), S ? (t[s] = R, I) : R;
      })(A, E, "global" in w ? w.global : this == t, w.state);
    }
    function p(x) {
      var w, b = x.length, _ = this, E = 0, C = _.i = _.j = 0, A = _.S = [];
      for (b || (x = [b++]); E < i; ) A[E] = E++;
      for (E = 0; E < i; E++) A[E] = A[C = f & C + x[E % b] + (w = A[E])], A[C] = w;
      (_.g = function(R) {
        for (var I, S = 0, M = _.i, P = _.j, B = _.S; R--; ) I = B[M = f & M + 1], S = S * i + B[f & (B[M] = B[P = f & P + I]) + (B[P] = I)];
        return _.i = M, _.j = P, S;
      })(i);
    }
    function v(x, w) {
      return w.i = x.i, w.j = x.j, w.S = x.S.slice(), w;
    }
    function g(x, w) {
      for (var b, _ = x + "", E = 0; E < _.length; ) w[f & E] = f & (b ^= 19 * w[f & E]) + _.charCodeAt(E++);
      return y(w);
    }
    function y(x) {
      return String.fromCharCode.apply(0, x);
    }
    if (t["seed" + s] = d, g(t.random(), e), n.exports) {
      n.exports = d;
      try {
        r = require("crypto");
      } catch {
      }
    }
  })([], Math);
});
no.alea = eT, no.xor128 = tT, no.xorwow = nT, no.xorshift7 = rT, no.xor4096 = oT, no.tychei = iT;
var ru = no.alea, bf = function() {
  function n(e, t, r, o, i) {
    this.mean = e, this.stdDev = t, this.dtype = r, this.nextVal = NaN, this.truncated = o, this.truncated && (this.upper = this.mean + 2 * this.stdDev, this.lower = this.mean - 2 * this.stdDev);
    var a = i || Math.random();
    this.random = ru(a.toString());
  }
  return n.prototype.nextValue = function() {
    if (!isNaN(this.nextVal)) {
      var e = this.nextVal;
      return this.nextVal = NaN, e;
    }
    for (var t, r, o = !1; !o; ) {
      var i = void 0, a = void 0, s = void 0;
      do
        s = (i = 2 * this.random() - 1) * i + (a = 2 * this.random() - 1) * a;
      while (s >= 1 || s === 0);
      var u = Math.sqrt(-2 * Math.log(s) / s);
      t = this.mean + this.stdDev * i * u, r = this.mean + this.stdDev * a * u, this.truncated && !this.isValidTruncated(t) || (o = !0);
    }
    return this.truncated && !this.isValidTruncated(r) || (this.nextVal = this.convertValue(r)), this.convertValue(t);
  }, n.prototype.convertValue = function(e) {
    return this.dtype == null || this.dtype === "float32" ? e : Math.round(e);
  }, n.prototype.isValidTruncated = function(e) {
    return e <= this.upper && e >= this.lower;
  }, n;
}(), aT = function() {
  function n(e, t, r, o) {
    this.alpha = e, this.beta = 1 / t, this.dtype = r;
    var i = o || Math.random();
    this.randu = ru(i.toString()), this.randn = new bf(0, 1, r, !1, this.randu()), this.d = e < 1 ? e + 2 / 3 : e - 1 / 3, this.c = 1 / Math.sqrt(9 * this.d);
  }
  return n.prototype.nextValue = function() {
    for (var e, t, r, o, i, a; ; ) {
      do
        o = this.randn.nextValue(), a = 1 + this.c * o;
      while (a <= 0);
      if (a *= a * a, t = 1 - 0.331 * (e = o * o) * e, r = 0.5 * e + this.d * (1 - a + Math.log(a)), (i = this.randu()) < t || Math.log(i) < r) break;
    }
    return a = 1 / this.beta * this.d * a, this.alpha < 1 && (a *= Math.pow(this.randu(), 1 / this.alpha)), this.convertValue(a);
  }, n.prototype.convertValue = function(e) {
    return this.dtype === "float32" ? e : Math.round(e);
  }, n;
}(), sT = function() {
  function n(e, t, r, o) {
    var i = this;
    if (e === void 0 && (e = 0), t === void 0 && (t = 1), this.canReturnFloat = function() {
      return i.dtype == null || i.dtype === "float32";
    }, this.min = e, this.range = t - e, this.dtype = r, o == null && (o = Math.random()), typeof o == "number" && (o = o.toString()), !this.canReturnFloat() && this.range <= 1) throw new Error("The difference between " + e + " - " + t + " <= 1 and dtype is not float");
    this.random = ru(o);
  }
  return n.prototype.convertValue = function(e) {
    return this.canReturnFloat() ? e : Math.round(e);
  }, n.prototype.nextValue = function() {
    return this.convertValue(this.min + this.range * this.random());
  }, n;
}();
function he(n, e, t) {
  return e === void 0 && (e = "float32"), e = e || "float32", C1(n), new Zi(n, e, t);
}
function uT(n, e) {
  e === void 0 && (e = !1), console.log(n.toString(e));
}
var N1 = N({ batchToSpaceND_: function(n, e, t) {
  var r = T(n, "x", "batchToSpaceND"), o = e.reduce(function(i, a) {
    return i * a;
  });
  return k(r.rank >= 1 + e.length, function() {
    return "input rank is " + r.rank + " but should be > than blockShape.length " + e.length;
  }), k(t.length === e.length, function() {
    return "crops.length is " + t.length + " but should be equal to blockShape.length  " + e.length;
  }), k(r.shape[0] % o == 0, function() {
    return "input tensor batch is " + r.shape[0] + " but is not divisible by the product of the elements of blockShape " + e.join(" * ") + " === " + o;
  }), D.runKernelFunc(function(i) {
    return i.batchToSpaceND(r, e, t);
  }, { $x: r }, function(i) {
    return { $x: function() {
      return i.spaceToBatchND(e, t);
    } };
  });
} }), lT = N({ broadcastTo_: function(n, e) {
  var t = T(n, "broadcastTo", "x"), r = t.shape;
  if (e.some(function(u) {
    return !(u > 0) || u % 1 != 0;
  })) throw new Error("broadcastTo(): Invalid broadcast shape [" + e + "].");
  if (e.length < t.rank) throw new Error("broadcastTo(): shape.length=" + e.length + " < input.rank=" + t.rank + ".");
  if (e.length > t.rank) {
    for (var o = t.shape.slice(); o.length < e.length; ) o.unshift(1);
    t = t.reshape(o);
  }
  for (var i = Array.from(e), a = e.length - 1; a >= 0; a--) if (t.shape[a] === e[a]) i[a] = 1;
  else if (t.shape[a] !== 1) throw new Error("broadcastTo(): [" + r + "] cannot be broadcast to [" + e + "].");
  var s = i.map(function(u, l) {
    return u > 1 ? l : -1;
  }).filter(function(u) {
    return u >= 0;
  });
  return s.length === 0 ? t.clone() : D.runKernelFunc(function(u) {
    return u.tile(t, i);
  }, { input: t }, function(u) {
    return { input: function() {
      return u.sum(s, !0);
    } };
  });
} }), cT = N({ cast_: function(n, e) {
  var t = T(n, "x", "cast");
  if (!n3(e)) throw new Error("Failed to cast to unknown dtype " + e);
  if (e === "string" && t.dtype !== "string" || e !== "string" && t.dtype === "string") throw new Error("Only strings can be casted to strings");
  var r = { dtype: e };
  return D.runKernelFunc(function(o) {
    return o.cast(t, e);
  }, { x: t }, function(o) {
    return { x: function() {
      return o.clone();
    } };
  }, "Cast", r);
} }), fT = N({ clone_: function(n) {
  var e = T(n, "x", "clone", null);
  return D.runKernelFunc(function() {
    return D.makeTensorFromDataId(e.dataId, e.shape, e.dtype);
  }, { $x: e }, function(t) {
    return { $x: function() {
      return t.toFloat();
    } };
  });
} }), dT = N({ cumsum_: function(n, e, t, r) {
  e === void 0 && (e = 0), t === void 0 && (t = !1), r === void 0 && (r = !1);
  var o = T(n, "x", "cumsum"), i = er([e |= 0], o.rank), a = o;
  i != null && (a = o.transpose(i));
  var s = tr(1, o.rank)[0], u = D.runKernelFunc(function(l) {
    return l.cumsum(a, s, t, r);
  }, { permutedX: a }, function(l) {
    return { permutedX: function() {
      return l.cumsum(e, t, !r);
    } };
  });
  return i != null && (u = u.transpose(i)), u;
} }), hT = N({ depthToSpace_: function(n, e, t) {
  t === void 0 && (t = "NHWC");
  var r = T(n, "x", "depthToSpace"), o = t === "NHWC" ? r.shape[1] : r.shape[2], i = t === "NHWC" ? r.shape[2] : r.shape[3], a = t === "NHWC" ? r.shape[3] : r.shape[1];
  return k(o * e >= 0, function() {
    return `Negative dimension size caused by overflow when multiplying
      ` + o + " and " + e + `  for depthToSpace with input shape
      ` + r.shape;
  }), k(i * e >= 0, function() {
    return `Negative dimension size caused by overflow when multiplying
      ` + i + " and " + e + ` for depthToSpace with input shape
          ` + r.shape;
  }), k(a % (e * e) == 0, function() {
    return "Dimension size must be evenly divisible by " + e * e + " but is " + a + " for depthToSpace with input shape " + r.shape;
  }), D.runKernelFunc(function(s) {
    return s.depthToSpace(r, e, t);
  }, { $x: r });
} }), pn = N({ expandDims_: function(n, e) {
  e === void 0 && (e = 0);
  var t = T(n, "x", "expandDims", null);
  k(e <= t.rank, function() {
    return "Axis must be <= rank of the tensor";
  });
  var r = t.shape.slice();
  return e < 0 && (k(-(t.rank + 1) <= e, function() {
    return "Axis must be in the interval [" + -(t.rank + 1) + ", " + t.rank + "]";
  }), e = t.rank + e + 1), r.splice(e, 0, 1), Cn(t, r);
} }), M1 = N({ eye_: function(n, e, t, r) {
  r === void 0 && (r = "float32"), e == null && (e = n);
  for (var o = he([n, e], r), i = n <= e ? n : e, a = 0; a < i; ++a) o.set(1, a, a);
  var s = o.toTensor().as2D(n, e);
  if (t == null) return s;
  if (t.length === 1) return zo(pn(s, 0), [t[0], 1, 1]);
  if (t.length === 2) return zo(pn(pn(s, 0), 0), [t[0], t[1], 1, 1]);
  if (t.length === 3) return zo(pn(pn(pn(s, 0), 0), 0), [t[0], t[1], t[2], 1, 1]);
  throw new Error("eye() currently supports only 1D and 2D batchShapes, but received " + t.length + "D.");
} }), pT = N({ multinomial_: function(n, e, t, r) {
  r === void 0 && (r = !1);
  var o = T(n, "logits", "multinomial"), i = o.size, a = o.rank;
  if (i < 2) throw new Error("Error in multinomial: you need at least 2 outcomes, but got " + i + ".");
  if (a > 2) throw new Error("Rank of probabilities must be 1 or 2, but is " + a);
  t = t || Math.random();
  var s = a === 1 ? o.as2D(1, -1) : o, u = D.runKernelFunc(function(l) {
    return l.multinomial(s, r, e, t);
  }, { logits2D: s });
  return a === 1 ? u.as1D() : u;
} }), Yl = N({ oneHot_: function(n, e, t, r) {
  if (t === void 0 && (t = 1), r === void 0 && (r = 0), e < 2) throw new Error("Error in oneHot: depth must be >=2, but it is " + e);
  var o = T(n, "indices", "oneHot", "int32"), i = o.shape.concat([e]);
  return o = o.flatten(), D.runKernelFunc(function(a) {
    return a.oneHot(o, e, t, r);
  }, { $indices: o }, function(a) {
    return { $indices: function() {
      return Ge(o.shape, "float32");
    } };
  }).reshape(i);
} }), wo = N({ pad_: function(n, e, t) {
  t === void 0 && (t = 0);
  var r = T(n, "x", "pad");
  if (r.rank === 0) throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
  var o = { paddings: e, constantValue: t };
  return D.runKernelFunc(function(i) {
    return i.pad(r, e, t);
  }, { x: r }, function(i) {
    var a = e.map(function(s) {
      return s[0];
    });
    return { x: function() {
      return i.slice(a, r.shape);
    } };
  }, "PadV2", o);
} }), mT = N({ pad1d_: function(n, e, t) {
  return t === void 0 && (t = 0), k(e.length === 2, function() {
    return "Invalid number of paddings. Must be length of 2.";
  }), wo(n, [e], t);
} }), vT = N({ pad2d_: function(n, e, t) {
  return t === void 0 && (t = 0), k(e.length === 2 && e[0].length === 2 && e[1].length === 2, function() {
    return "Invalid number of paddings. Must be length of 2 each.";
  }), wo(n, e, t);
} }), gT = N({ pad3d_: function(n, e, t) {
  return t === void 0 && (t = 0), k(e.length === 3 && e[0].length === 2 && e[1].length === 2 && e[2].length === 2, function() {
    return "Invalid number of paddings. Must be length of 2 each.";
  }), wo(n, e, t);
} }), yT = N({ pad4d_: function(n, e, t) {
  return t === void 0 && (t = 0), k(e.length === 4 && e[0].length === 2 && e[1].length === 2 && e[2].length === 2 && e[3].length === 2, function() {
    return "Invalid number of paddings. Must be length of 2 each.";
  }), wo(n, e, t);
} }), xT = N({ rand_: function(n, e, t) {
  var r = ee(n), o = null;
  if (t == null || t === "float32") o = new Float32Array(r);
  else if (t === "int32") o = new Int32Array(r);
  else {
    if (t !== "bool") throw new Error("Unknown data type " + t);
    o = new Uint8Array(r);
  }
  for (var i = 0; i < r; i++) o[i] = e();
  return D.makeTensor(o, n, t);
} }), wT = N({ randomNormal_: function(n, e, t, r, o) {
  if (e === void 0 && (e = 0), t === void 0 && (t = 1), r != null && r === "bool") throw new Error("Unsupported data type " + r);
  for (var i = new bf(e, t, r, !1, o), a = he(n, r), s = 0; s < a.values.length; s++) a.values[s] = i.nextValue();
  return a.toTensor();
} }), _T = N({ randomGamma_: function(n, e, t, r, o) {
  if (t === void 0 && (t = 1), r === void 0 && (r = "float32"), t == null && (t = 1), r == null && (r = "float32"), r !== "float32" && r !== "int32") throw new Error("Unsupported data type " + r);
  for (var i = new aT(e, t, r, o), a = he(n, r), s = 0; s < a.values.length; s++) a.values[s] = i.nextValue();
  return a.toTensor();
} }), D1 = N({ randomUniform_: function(n, e, t, r, o) {
  e === void 0 && (e = 0), t === void 0 && (t = 1), r === void 0 && (r = "float32");
  for (var i = he(n, r), a = new sT(e, t, null, o), s = 0; s < i.values.length; s++) i.values[s] = a.nextValue();
  return i.toTensor();
} }), Cn = N({ reshape_: function(n, e) {
  var t = T(n, "x", "reshape", null);
  e = e3(e, t.size), k(t.size === ee(e), function() {
    return "new shape and old shape must have the same number of elements.";
  });
  var r = { shape: e };
  return D.runKernelFunc(function(o) {
    return o.reshape(t, e);
  }, { x: t }, function(o) {
    return { x: function() {
      return o.reshape(t.shape);
    } };
  }, "Reshape", r);
} }), F1 = N({ spaceToBatchND_: function(n, e, t) {
  var r = T(n, "x", "spaceToBatchND");
  return k(r.rank >= 1 + e.length, function() {
    return "input rank " + r.rank + " should be > than [blockShape] " + e.length;
  }), k(t.length === e.length, function() {
    return "paddings.shape[0] " + t.length + " must be equal to [blockShape] " + e.length;
  }), k(r.shape.reduce(function(o, i, a) {
    return a > 0 && a <= e.length ? o && (i + t[a - 1][0] + t[a - 1][1]) % e[a - 1] == 0 : o;
  }, !0), function() {
    return "input spatial dimensions " + r.shape.slice(1) + " with paddings " + t.toString() + " must be divisible by blockShapes " + e.toString();
  }), D.runKernelFunc(function(o) {
    return o.spaceToBatchND(r, e, t);
  }, { $x: r }, function(o) {
    return { $x: function() {
      return o.batchToSpaceND(e, t);
    } };
  });
} }), L1 = N({ squeeze_: function(n, e) {
  var t = T(n, "x", "squeeze");
  return Cn(t, ro(t.shape, e).newShape);
} }), on = N({ stack_: function(n, e) {
  e === void 0 && (e = 0);
  var t = is(n, "tensors", "stack");
  if (k(t.length >= 1, function() {
    return "Pass at least one tensor to tf.stack";
  }), t.length === 1) return t[0].expandDims(e);
  var r = t[0].rank, o = t[0].shape, i = t[0].dtype;
  k(e <= r, function() {
    return "Axis must be <= rank of the tensor";
  }), t.forEach(function(s) {
    De(o, s.shape, "All tensors passed to stack must have matching shapes");
  }), t.forEach(function(s) {
    k(i === s.dtype, function() {
      return "All tensors passed to stack must have matching dtypes";
    });
  });
  var a = t.map(function(s) {
    return s.expandDims(e);
  });
  return ht(a, e);
} }), zo = N({ tile_: function(n, e) {
  var t = T(n, "x", "tile", null);
  k(t.rank === e.length, function() {
    return "Error in transpose: rank of input " + t.rank + " must match length of reps " + e + ".";
  });
  var r = [t], o = { reps: e };
  return D.runKernelFunc(function(i, a) {
    var s = i.tile(t, e);
    return a([t]), s;
  }, { x: t }, function(i, a) {
    var s = a[0];
    return { x: function() {
      var u = Ie(s);
      if (s.rank === 1) for (var l = 0; l < e[0]; ++l) u = u.add(i.slice([l * s.shape[0]], [s.shape[0]]));
      else if (s.rank === 2) for (l = 0; l < e[0]; ++l) for (var c = 0; c < e[1]; ++c) u = u.add(i.slice([l * s.shape[0], c * s.shape[1]], [s.shape[0], s.shape[1]]));
      else if (s.rank === 3) for (l = 0; l < e[0]; ++l) for (c = 0; c < e[1]; ++c) for (var f = 0; f < e[2]; ++f) u = u.add(i.slice([l * s.shape[0], c * s.shape[1], f * s.shape[2]], [s.shape[0], s.shape[1], s.shape[2]]));
      else {
        if (s.rank !== 4) throw new Error("Gradient for tile operation is not implemented for rank-" + s.rank + " tensors yet.");
        for (l = 0; l < e[0]; ++l) for (c = 0; c < e[1]; ++c) for (f = 0; f < e[2]; ++f) for (var d = 0; d < e[3]; ++d) u = u.add(i.slice([l * s.shape[0], c * s.shape[1], f * s.shape[2], d * s.shape[3]], [s.shape[0], s.shape[1], s.shape[2], s.shape[3]]));
      }
      return u;
    } };
  }, "Tile", o, r);
} }), bT = N({ truncatedNormal_: function(n, e, t, r, o) {
  if (e === void 0 && (e = 0), t === void 0 && (t = 1), r != null && r === "bool") throw new Error("Unsupported data type " + r);
  for (var i = new bf(e, t, r, !0, o), a = he(n, r), s = 0; s < a.values.length; s++) a.values[s] = i.nextValue();
  return a.toTensor();
} }), pt = N({ unstack_: function(n, e) {
  e === void 0 && (e = 0), e = e || 0;
  var t = T(n, "x", "unstack");
  k(e >= -t.shape.length && e < t.shape.length, function() {
    return "Axis = " + e + " is not in [-" + t.shape.length + ", " + t.shape.length + ")";
  }), e < 0 && (e += t.shape.length);
  var r = { axis: e };
  return D.runKernelFunc(function(o) {
    return o.unstack(t, e);
  }, { x: t }, function(o) {
    return { x: function() {
      return on(o, e);
    } };
  }, "Unpack", r);
} }), ET = function(n, e) {
  return Z(this, void 0, void 0, function() {
    var t, r, o, i, a, s, u, l, c, f;
    return j(this, function(d) {
      switch (d.label) {
        case 0:
          return t = T(n, "x", "setdiff1d"), r = T(e, "y", "setdiff1d"), k(t.dtype === r.dtype, function() {
            return "x and y should have the same dtype, but got x (" + t.dtype + ") and y (" + r.dtype + ").";
          }), k(t.rank === 1, function() {
            return "x should be 1D tensor, but got x (" + t.shape + ").";
          }), k(r.rank === 1, function() {
            return "y should be 1D tensor, but got y (" + r.shape + ").";
          }), [4, t.data()];
        case 1:
          return o = d.sent(), [4, r.data()];
        case 2:
          for (i = d.sent(), a = new Set(i), s = 0, c = 0; c < o.length; c++) a.has(o[c]) || s++;
          for (u = new Zi([s], t.dtype), l = new Zi([s], "int32"), c = 0, f = 0; c < o.length; c++) a.has(o[c]) || (u.values[f] = o[c], l.values[f] = c, f++);
          return [2, [u.toTensor(), l.toTensor()]];
      }
    });
  });
};
function ss(n, e, t, r) {
  r === void 0 && (r = !0);
  var o = [];
  if (r) (o = o.concat(e.slice(0))).push(n[0] / t), o = o.concat(n.slice(1));
  else {
    o = o.concat(n[0]);
    for (var i = e.length, a = 0; a < i; ++a) o = o.concat([n[a + 1] / e[a], e[a]]);
    o = o.concat(n.slice(i + 1));
  }
  return o;
}
function us(n, e, t) {
  t === void 0 && (t = !0);
  var r = [];
  if (t) {
    r.push(e);
    for (var o = e + 1; o < n; ++o) o <= 2 * e ? (r.push(o), r.push(o - (e + 1))) : r.push(o);
  } else {
    var i = [], a = [];
    for (o = 1; o < n; ++o) o >= 2 * e + 1 || o % 2 == 1 ? a.push(o) : i.push(o);
    r.push.apply(r, i), r.push(0), r.push.apply(r, a);
  }
  return r;
}
function ls(n, e, t, r) {
  r === void 0 && (r = !0);
  var o = [];
  r ? o.push(n[0] / t) : o.push(n[0] * t);
  for (var i = 1; i < n.length; ++i) i <= e.length ? r ? o.push(e[i - 1] * n[i]) : o.push(n[i] / e[i - 1]) : o.push(n[i]);
  return o;
}
function B1(n, e) {
  for (var t = [0], r = 0; r < e; ++r) t.push(n[r][0]);
  return t;
}
function O1(n, e, t) {
  for (var r = n.slice(0, 1), o = 0; o < t; ++o) r.push(n[o + 1] - e[o][0] - e[o][1]);
  return r;
}
function U1(n, e) {
  if (n.rank < 1) throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was " + n.rank + ".");
  if (e.rank < 1) throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was " + e.rank + ".");
  if (e.dtype !== "int32") throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was " + e.dtype + ".");
  if (e.shape[e.rank - 1] > n.rank) throw new Error("index innermost dimension length must be <= tensor rank; saw: " + e.shape[e.rank - 1] + " vs. " + n.rank);
  if (n.size === 0) throw new Error("Requested more than 0 entries, but input is empty. Input shape: " + n.shape + ".");
  for (var t = e.shape, r = t[t.length - 1], o = 1, i = 0; i < t.length - 1; ++i) o *= t[i];
  var a = n.shape, s = t.slice();
  s.pop();
  var u = 1;
  for (i = r; i < n.rank; ++i) u *= a[i], s.push(a[i]);
  var l = Kn(n.shape).map(function(c) {
    return c / u;
  }).concat([1]).slice(0, r);
  return [s, o, u, l];
}
var V1 = 30;
function zu(n) {
  return n <= V1 ? n : $l(n, Math.floor(Math.sqrt(n)));
}
function CT(n, e, t) {
  var r = e.rank > 1 ? e.shape[e.rank - 1] : 1, o = e.rank > 1 ? e.rank - 1 : 1, i = "Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: " + t.shape + ", indices.shape: " + e.shape + ", shape: " + n + ", sliceDim: " + r + ", and batchDim: " + o + ".";
  if (t.rank < o) throw new Error(i + " update.rank < " + o + ". ");
  if (n.length < r + (t.rank - o)) throw new Error(i + " Output shape length < " + (r + (t.rank - o)));
  if (t.rank !== o + n.length - r) throw new Error(i + " update.rank != " + (o + n.length - r));
  for (var a = 0; a < o; ++a) if (t.shape[a] !== e.shape[a]) throw new Error(i + " updates.shape[" + a + "] (" + t.shape[a] + ") != indices.shape[" + a + "] (" + e.shape[a] + ").");
  for (a = 0; a < t.rank - o; ++a) if (t.shape[a + o] !== n[a + r]) throw new Error(i + " updates.shape[" + (a + o) + "] (" + t.shape[a + o] + ") != shape[" + (a + o) + "] (" + n[a + o] + ")");
}
function TT(n, e, t) {
  if (e.rank < 1) throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was " + e.rank + ".");
  if (n.rank < 1) throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was " + n.rank + ".");
  if (e.dtype !== "int32") throw new Error("The dtype of 'indices' should be int32, but got dtype: " + e.dtype);
  if (t.length < 1) throw new Error("Output rank must be greater or equal to 1, but got shape: " + t);
  if (t.length === 0) {
    if (e.size === 0) throw new Error("Indices specified for empty output. indices shape: " + e.shape);
    if (n.size === 0) throw new Error("Updates specified for empty output. updates shape: " + n.shape);
  }
  CT(t, e, n);
}
function cs(n, e, t) {
  for (var r = e.shape.length, o = r > 1 ? e.shape[r - 1] : 1, i = t.length, a = 1, s = o; s < i; ++s) a *= t[s];
  var u = o < 1 ? 1 : o;
  return { sliceRank: o, numUpdates: ee(e.shape) / u, sliceSize: a, strides: Kn(t.slice(0, o)).concat([1]), outputSize: ee(t) };
}
function IT(n, e, t) {
  k(n.rank === e.length, function() {
    return "Error in slice" + n.rank + "D: Length of begin " + e + " must match the rank of the array (" + n.rank + ").";
  }), k(n.rank === t.length, function() {
    return "Error in slice" + n.rank + "D: Length of size " + t + " must match the rank of the array (" + n.rank + ").";
  });
  for (var r = function(i) {
    k(e[i] + t[i] <= n.shape[i], function() {
      return "Error in slice" + n.rank + "D: begin[" + i + "] + size[" + i + "] (" + (e[i] + t[i]) + ") would overflow input.shape[" + i + "] (" + n.shape[i] + ")";
    });
  }, o = 0; o < n.rank; ++o) r(o);
}
function im(n) {
  for (var e = [], t = 0; n > 0; ) 1 & n && e.push(t), n /= 2, t++;
  return e;
}
function Ef(n, e, t) {
  for (var r = [], o = 0; o < n.length; o++) r[o] = Math.ceil((e[o] - n[o]) / t[o]);
  return r;
}
function ST(n, e, t, r, o) {
  var i = e[o], a = t[o] || 1;
  (n & 1 << o || i == null) && (i = a > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);
  var s = r[o];
  return i < 0 && (i += s), i = Gl(0, i, s - 1);
}
function AT(n, e, t, r, o) {
  var i = e[o], a = t[o] || 1;
  (n & 1 << o || i == null) && (i = a > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);
  var s = r[o];
  return i < 0 && (i += s), i = a > 0 ? Gl(0, i, s) : Gl(-1, i, s - 1);
}
function G1(n, e, t) {
  for (var r = t.length, o = 0; o < t.length; o++) if (t[o] > 1) {
    r = o;
    break;
  }
  for (o = r + 1; o < t.length; o++) if (e[o] > 0 || t[o] !== n[o]) return !1;
  return !0;
}
function W1(n, e) {
  for (var t = n.length > 0 ? n[n.length - 1] : 1, r = 0; r < n.length - 1; r++) t += n[r] * e[r];
  return t;
}
function RT(n, e) {
  k(Hl(n), function() {
    return "The f passed in variableGrads(f) must be a function";
  }), k(e == null || Array.isArray(e) && e.every(function(c) {
    return c instanceof fi;
  }), function() {
    return "The varList passed in variableGrads(f, varList) must be an array of variables";
  });
  var t = e != null;
  if (!t) for (var r in e = [], D.registeredVariables) e.push(D.registeredVariables[r]);
  var o = t ? e.filter(function(c) {
    return !c.trainable;
  }) : null, i = e.length;
  k((e = e.filter(function(c) {
    return c.trainable;
  })).length > 0, function() {
    return "variableGrads() expects at least one of the input variables to be trainable, but none of the " + i + " variables is trainable.";
  });
  var a = D.gradients(n, e, null, !0), s = a.value, u = a.grads;
  k(u.some(function(c) {
    return c != null;
  }), function() {
    return "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().";
  }), k(s.rank === 0, function() {
    return "The f passed in variableGrads(f) must return a scalar, but it returned a rank-" + s.rank + " tensor";
  });
  var l = {};
  return e.forEach(function(c, f) {
    u[f] != null && (l[c.name] = u[f]);
  }), o != null && o.forEach(function(c) {
    return l[c.name] = null;
  }), { value: s, grads: l };
}
function ou(n) {
  return D.customGrad(n);
}
var wr = N({ softmax_: function(n, e) {
  e === void 0 && (e = -1);
  var t = T(n, "logits", "softmax", "float32");
  if (e === -1 && (e = t.rank - 1), e !== t.rank - 1) throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank " + t.rank + " and dim was " + e);
  return D.runKernelFunc(function(r, o) {
    var i = r.softmax(t, e);
    return o([i]), i;
  }, { logits: t }, function(r, o) {
    var i = o[0], a = r.mul(i);
    return { logits: function() {
      return a.sub(a.sum([e], !0).mul(i));
    } };
  }, "Softmax", { dim: e }, [], [!0]);
} }), kT = N({ logSoftmax_: function(n, e) {
  e === void 0 && (e = -1);
  var t = T(n, "logits", "logSoftmax");
  if (e === -1 && (e = t.rank - 1), e !== t.rank - 1) throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank " + t.rank + " and axis was " + e);
  return ou(function(r, o) {
    var i = r.max(e, !0), a = r.sub(i), s = a.toFloat().sub(a.exp().sum(e, !0).log());
    return o([s]), { value: s, gradFunc: function(u, l) {
      var c = l[0].exp();
      return u.sub(u.sum(e, !0).mul(c));
    } };
  })(t);
} }), H1 = function() {
  function n(e, t) {
    this.backend = e, this.dataMover = t, this.data = /* @__PURE__ */ new WeakMap(), this.dataIdsCount = 0;
  }
  return n.prototype.get = function(e) {
    return this.data.has(e) || this.dataMover.moveData(this.backend, e), this.data.get(e);
  }, n.prototype.set = function(e, t) {
    this.dataIdsCount++, this.data.set(e, t);
  }, n.prototype.has = function(e) {
    return this.data.has(e);
  }, n.prototype.delete = function(e) {
    return this.dataIdsCount--, this.data.delete(e);
  }, n.prototype.numDataIds = function() {
    return this.dataIdsCount;
  }, n;
}(), $1 = function() {
  function n() {
  }
  return n.prototype.time = function(e) {
    return F("time");
  }, n.prototype.read = function(e) {
    return F("read");
  }, n.prototype.readSync = function(e) {
    return F("readSync");
  }, n.prototype.numDataIds = function() {
    return F("numDataIds");
  }, n.prototype.disposeData = function(e) {
    return F("disposeData");
  }, n.prototype.write = function(e, t, r) {
    return F("write");
  }, n.prototype.move = function(e, t, r, o) {
    return F("move");
  }, n.prototype.memory = function() {
    return F("memory");
  }, n.prototype.floatPrecision = function() {
    return F("floatPrecision");
  }, n.prototype.epsilon = function() {
    return this.floatPrecision() === 32 ? 1e-7 : 1e-4;
  }, n.prototype.batchMatMul = function(e, t, r, o) {
    return F("batchMatMul");
  }, n.prototype.fusedBatchMatMul = function(e) {
    return e.a, e.b, e.transposeA, e.transposeB, e.bias, e.activation, e.preluActivationWeights, F("fusedBatchMatMul");
  }, n.prototype.slice = function(e, t, r) {
    return F("slice");
  }, n.prototype.stridedSlice = function(e, t, r, o) {
    return F("stridedSlice");
  }, n.prototype.unstack = function(e, t) {
    return F("unstack");
  }, n.prototype.reverse = function(e, t) {
    return F("reverse");
  }, n.prototype.concat = function(e, t) {
    return F("concat");
  }, n.prototype.neg = function(e) {
    return F("neg");
  }, n.prototype.add = function(e, t) {
    return F("add");
  }, n.prototype.addN = function(e) {
    return F("addN");
  }, n.prototype.subtract = function(e, t) {
    return F("subtract");
  }, n.prototype.multiply = function(e, t) {
    return F("multiply");
  }, n.prototype.realDivide = function(e, t) {
    return F("realDivide");
  }, n.prototype.floorDiv = function(e, t) {
    return F("floorDiv");
  }, n.prototype.sum = function(e, t) {
    return F("sum");
  }, n.prototype.prod = function(e, t) {
    return F("prod");
  }, n.prototype.unsortedSegmentSum = function(e, t, r) {
    return F("unsortedSegmentSum");
  }, n.prototype.argMin = function(e, t) {
    return F("argMin");
  }, n.prototype.argMax = function(e, t) {
    return F("argMax");
  }, n.prototype.equal = function(e, t) {
    return F("equal");
  }, n.prototype.notEqual = function(e, t) {
    return F("notEqual");
  }, n.prototype.less = function(e, t) {
    return F("less");
  }, n.prototype.lessEqual = function(e, t) {
    return F("lessEqual");
  }, n.prototype.greater = function(e, t) {
    return F("greater");
  }, n.prototype.greaterEqual = function(e, t) {
    return F("greaterEqual");
  }, n.prototype.logicalNot = function(e) {
    return F("logicalNot");
  }, n.prototype.logicalAnd = function(e, t) {
    return F("logicalAnd");
  }, n.prototype.logicalOr = function(e, t) {
    return F("logicalOr");
  }, n.prototype.where = function(e) {
    return F("where");
  }, n.prototype.select = function(e, t, r) {
    return F("select");
  }, n.prototype.topk = function(e, t, r) {
    return F("topk");
  }, n.prototype.min = function(e, t) {
    return F("min");
  }, n.prototype.minimum = function(e, t) {
    return F("minimum");
  }, n.prototype.mod = function(e, t) {
    return F("mod");
  }, n.prototype.max = function(e, t) {
    return F("max");
  }, n.prototype.maximum = function(e, t) {
    return F("maximum");
  }, n.prototype.all = function(e, t) {
    return F("all");
  }, n.prototype.any = function(e, t) {
    return F("any");
  }, n.prototype.squaredDifference = function(e, t) {
    return F("squaredDifference");
  }, n.prototype.ceil = function(e) {
    return F("ceil");
  }, n.prototype.floor = function(e) {
    return F("floor");
  }, n.prototype.round = function(e) {
    return F("round");
  }, n.prototype.sign = function(e) {
    return F("sign");
  }, n.prototype.isNaN = function(e) {
    return F("isNaN");
  }, n.prototype.isInf = function(e) {
    return F("isInf");
  }, n.prototype.isFinite = function(e) {
    return F("isFinite");
  }, n.prototype.pow = function(e, t) {
    return F("pow");
  }, n.prototype.exp = function(e) {
    return F("exp");
  }, n.prototype.expm1 = function(e) {
    return F("expm1");
  }, n.prototype.softmax = function(e, t) {
    return F("softmax");
  }, n.prototype.log = function(e) {
    return F("log");
  }, n.prototype.log1p = function(e) {
    return F("log1p");
  }, n.prototype.sqrt = function(e) {
    return F("sqrt");
  }, n.prototype.rsqrt = function(e) {
    return F("rsqrt");
  }, n.prototype.square = function(e) {
    return F("square");
  }, n.prototype.reciprocal = function(e) {
    return F("reciprocal");
  }, n.prototype.relu = function(e) {
    return F("relu");
  }, n.prototype.relu6 = function(e) {
    return F("relu6");
  }, n.prototype.prelu = function(e, t) {
    return F("prelu");
  }, n.prototype.elu = function(e) {
    return F("elu");
  }, n.prototype.eluDer = function(e, t) {
    return F("eluDer");
  }, n.prototype.selu = function(e) {
    return F("selu");
  }, n.prototype.int = function(e) {
    return F("int");
  }, n.prototype.clip = function(e, t, r) {
    return F("clip");
  }, n.prototype.abs = function(e) {
    return F("abs");
  }, n.prototype.complexAbs = function(e) {
    return F("complexAbs");
  }, n.prototype.sigmoid = function(e) {
    return F("sigmoid");
  }, n.prototype.softplus = function(e) {
    return F("softplus");
  }, n.prototype.sin = function(e) {
    return F("sin");
  }, n.prototype.cos = function(e) {
    return F("cos");
  }, n.prototype.tan = function(e) {
    return F("tan");
  }, n.prototype.asin = function(e) {
    return F("asin");
  }, n.prototype.acos = function(e) {
    return F("acos");
  }, n.prototype.atan = function(e) {
    return F("atan");
  }, n.prototype.atan2 = function(e, t) {
    return F("atan2");
  }, n.prototype.sinh = function(e) {
    return F("sinh");
  }, n.prototype.cosh = function(e) {
    return F("cosh");
  }, n.prototype.tanh = function(e) {
    return F("tanh");
  }, n.prototype.asinh = function(e) {
    return F("asinh");
  }, n.prototype.acosh = function(e) {
    return F("acosh");
  }, n.prototype.atanh = function(e) {
    return F("atanh");
  }, n.prototype.erf = function(e) {
    return F("erf");
  }, n.prototype.step = function(e, t) {
    return F("step");
  }, n.prototype.fusedConv2d = function(e) {
    return e.input, e.filter, e.convInfo, e.bias, e.activation, e.preluActivationWeights, F("fusedConv2d");
  }, n.prototype.conv2d = function(e, t, r) {
    return F("conv2d");
  }, n.prototype.conv2dDerInput = function(e, t, r) {
    return F("conv2dDerInput");
  }, n.prototype.conv2dDerFilter = function(e, t, r) {
    return F("conv2dDerFilter");
  }, n.prototype.fusedDepthwiseConv2D = function(e) {
    return e.input, e.filter, e.convInfo, e.bias, e.activation, e.preluActivationWeights, F("fusedDepthwiseConv2D");
  }, n.prototype.depthwiseConv2D = function(e, t, r) {
    return F("depthwiseConv2D");
  }, n.prototype.depthwiseConv2DDerInput = function(e, t, r) {
    return F("depthwiseConv2DDerInput");
  }, n.prototype.depthwiseConv2DDerFilter = function(e, t, r) {
    return F("depthwiseConv2DDerFilter");
  }, n.prototype.conv3d = function(e, t, r) {
    return F("conv3d");
  }, n.prototype.conv3dDerInput = function(e, t, r) {
    return F("conv3dDerInput");
  }, n.prototype.conv3dDerFilter = function(e, t, r) {
    return F("conv3dDerFilter");
  }, n.prototype.maxPool = function(e, t) {
    return F("maxPool");
  }, n.prototype.maxPoolBackprop = function(e, t, r, o) {
    return F("maxPoolBackprop");
  }, n.prototype.avgPool = function(e, t) {
    return F("avgPool");
  }, n.prototype.avgPoolBackprop = function(e, t, r) {
    return F("avgPoolBackprop");
  }, n.prototype.avgPool3d = function(e, t) {
    return F("avgPool3d");
  }, n.prototype.avgPool3dBackprop = function(e, t, r) {
    return F("avgPool3dBackprop");
  }, n.prototype.maxPool3d = function(e, t) {
    return F("maxPool3d");
  }, n.prototype.maxPool3dBackprop = function(e, t, r, o) {
    return F("maxPool3dBackprop");
  }, n.prototype.reshape = function(e, t) {
    return F("reshape");
  }, n.prototype.cast = function(e, t) {
    return F("cast");
  }, n.prototype.tile = function(e, t) {
    return F("tile");
  }, n.prototype.pad = function(e, t, r) {
    return F("pad");
  }, n.prototype.transpose = function(e, t) {
    return F("transpose");
  }, n.prototype.gather = function(e, t, r) {
    return F("gather");
  }, n.prototype.gatherND = function(e, t) {
    return F("gatherND");
  }, n.prototype.scatterND = function(e, t, r) {
    return F("scatterND");
  }, n.prototype.batchToSpaceND = function(e, t, r) {
    return F("batchToSpaceND");
  }, n.prototype.spaceToBatchND = function(e, t, r) {
    return F("spaceToBatchND");
  }, n.prototype.resizeBilinear = function(e, t, r, o) {
    return F("resizeBilinear");
  }, n.prototype.resizeBilinearBackprop = function(e, t, r) {
    return F("resizeBilinearBackprop");
  }, n.prototype.resizeNearestNeighbor = function(e, t, r, o) {
    return F("resizeNearestNeighbor");
  }, n.prototype.resizeNearestNeighborBackprop = function(e, t, r) {
    return F("resizeNearestNeighborBackprop");
  }, n.prototype.batchNormalization = function(e, t, r, o, i, a) {
    return F("batchNormalization");
  }, n.prototype.localResponseNormalization4D = function(e, t, r, o, i) {
    return F("localResponseNormalization4D");
  }, n.prototype.LRNGrad = function(e, t, r, o, i, a, s) {
    return F("LRNGrad");
  }, n.prototype.multinomial = function(e, t, r, o) {
    return F("multinomial");
  }, n.prototype.oneHot = function(e, t, r, o) {
    return F("oneHot");
  }, n.prototype.cumsum = function(e, t, r, o) {
    return F("cumsum");
  }, n.prototype.nonMaxSuppression = function(e, t, r, o, i) {
    return F("nonMaxSuppression");
  }, n.prototype.fft = function(e) {
    return F("fft");
  }, n.prototype.ifft = function(e) {
    return F("ifft");
  }, n.prototype.complex = function(e, t) {
    return F("complex");
  }, n.prototype.real = function(e) {
    return F("real");
  }, n.prototype.imag = function(e) {
    return F("imag");
  }, n.prototype.cropAndResize = function(e, t, r, o, i, a) {
    return F("cropAndResize");
  }, n.prototype.depthToSpace = function(e, t, r) {
    return F("depthToSpace");
  }, n.prototype.split = function(e, t, r) {
    return F("split");
  }, n.prototype.sparseToDense = function(e, t, r, o) {
    return F("sparseToDense");
  }, n.prototype.diag = function(e) {
    return F("diag");
  }, n.prototype.fill = function(e, t, r) {
    return F("fill");
  }, n.prototype.onesLike = function(e) {
    return F("onesLike");
  }, n.prototype.zerosLike = function(e) {
    return F("zerosLike");
  }, n.prototype.linspace = function(e, t, r) {
    return F("linspace");
  }, n.prototype.dispose = function() {
    return F("dispose");
  }, n;
}();
function F(n) {
  throw new Error("'" + n + "' not yet implemented or not found in the registry. Did you forget to import the kernel?");
}
function Nr(n, e) {
  for (var t = n.length, r = [], o = 0; o < t; o++) {
    var i = t - 1 - o, a = n[i] || 1;
    (e[e.length - 1 - o] || 1) > 1 && a === 1 && r.unshift(i);
  }
  return r;
}
function mt(n, e) {
  for (var t = [], r = 0; r < e.length; r++) {
    var o = n[n.length - r - 1], i = e.length - r - 1, a = e[i];
    (o == null || o === 1 && a > 1) && t.unshift(i);
  }
  return t;
}
function xe(n, e) {
  for (var t = [], r = Math.max(n.length, e.length), o = 0; o < r; o++) {
    var i = n[n.length - o - 1];
    i == null && (i = 1);
    var a = e[e.length - o - 1];
    if (a == null && (a = 1), i === 1) t.unshift(a);
    else if (a === 1) t.unshift(i);
    else {
      if (i !== a) throw Error("Operands could not be broadcast together with shapes " + n + " and " + e + ".");
      t.unshift(i);
    }
  }
  return t;
}
function ea(n, e, t, r, o, i, a) {
  a === void 0 && (a = "channelsLast");
  var s, u = hs(e), l = u[0], c = u[1];
  if (a === "channelsLast") s = [l, c, n[3], n[3]];
  else {
    if (a !== "channelsFirst") throw new Error("Unknown dataFormat " + a);
    s = [l, c, n[1], n[1]];
  }
  return _o(n, s, t, r, o, i, !1, a);
}
function fs(n, e, t, r, o, i, a) {
  a === void 0 && (a = "NDHWC");
  var s, u, l = Ql(e), c = l[0], f = l[1], d = l[2];
  if (a === "NDHWC") u = "channelsLast", s = [c, f, d, n[4], n[4]];
  else {
    if (a !== "NCDHW") throw new Error("Unknown dataFormat " + a);
    u = "channelsFirst", s = [c, f, d, n[1], n[1]];
  }
  return ds(n, s, t, r, o, !1, u, i);
}
function _o(n, e, t, r, o, i, a, s) {
  a === void 0 && (a = !1), s === void 0 && (s = "channelsLast");
  var u = [-1, -1, -1, -1], l = u[0], c = u[1], f = u[2], d = u[3];
  if (s === "channelsLast") l = n[0], c = n[1], f = n[2], d = n[3];
  else {
    if (s !== "channelsFirst") throw new Error("Unknown dataFormat " + s);
    l = n[0], d = n[1], c = n[2], f = n[3];
  }
  var p, v = e[0], g = e[1], y = e[3], x = hs(t), w = x[0], b = x[1], _ = hs(r), E = _[0], C = _[1], A = Ko(v, E), R = Ko(g, C), I = function(O, U, G, H, W, q, z, J) {
    var ie, ce, me;
    if (typeof O == "number") {
      ie = { top: O, bottom: O, left: O, right: O, type: O === 0 ? "VALID" : "NUMBER" };
      var ve = function(be, Fe, ke, Ze, ze) {
        Ze == null && (Ze = q1(be, Fe, ke));
        var Ke = be[0], Mn = be[1], Dn = Wi((Ke - Fe + 2 * Ze) / ke + 1, ze);
        k(it(Dn), function() {
          return "The output # of rows (" + Dn + ") must be an integer. Change the stride and/or zero pad parameters";
        });
        var Jt = Wi((Mn - Fe + 2 * Ze) / ke + 1, ze);
        return k(it(Jt), function() {
          return "The output # of columns (" + Jt + ") must be an integer. Change the stride and/or zero pad parameters";
        }), [Dn, Jt];
      }([U, G], q, H, O, J);
      ce = ve[0], me = ve[1];
    } else if (O === "same") {
      ce = Math.ceil(U / H), me = Math.ceil(G / W);
      var ye = Math.max(0, (ce - 1) * H + q - U), Ce = Math.max(0, (me - 1) * W + z - G), _e = Math.floor(ye / 2), Te = ye - _e, rt = Math.floor(Ce / 2);
      ie = { top: _e, bottom: Te, left: rt, right: Ce - rt, type: "SAME" };
    } else {
      if (O !== "valid") throw Error("Unknown padding parameter: " + O);
      ie = { top: 0, bottom: 0, left: 0, right: 0, type: "VALID" }, ce = Math.ceil((U - q + 1) / H), me = Math.ceil((G - z + 1) / W);
    }
    return { padInfo: ie, outHeight: ce, outWidth: me };
  }(o, c, f, w, b, A, R, i), S = I.padInfo, M = I.outHeight, P = I.outWidth, B = a ? y * d : y;
  return s === "channelsFirst" ? p = [l, B, M, P] : s === "channelsLast" && (p = [l, M, P, B]), { batchSize: l, dataFormat: s, inHeight: c, inWidth: f, inChannels: d, outHeight: M, outWidth: P, outChannels: B, padInfo: S, strideHeight: w, strideWidth: b, filterHeight: v, filterWidth: g, effectiveFilterHeight: A, effectiveFilterWidth: R, dilationHeight: E, dilationWidth: C, inShape: n, outShape: p, filterShape: e };
}
function ds(n, e, t, r, o, i, a, s) {
  i === void 0 && (i = !1), a === void 0 && (a = "channelsLast");
  var u = [-1, -1, -1, -1, -1], l = u[0], c = u[1], f = u[2], d = u[3], p = u[4];
  if (a === "channelsLast") l = n[0], c = n[1], f = n[2], d = n[3], p = n[4];
  else {
    if (a !== "channelsFirst") throw new Error("Unknown dataFormat " + a);
    l = n[0], p = n[1], c = n[2], f = n[3], d = n[4];
  }
  var v, g = e[0], y = e[1], x = e[2], w = e[4], b = Ql(t), _ = b[0], E = b[1], C = b[2], A = Ql(r), R = A[0], I = A[1], S = A[2], M = Ko(g, R), P = Ko(y, I), B = Ko(x, S), O = function(z, J, ie, ce, me, ve, ye, Ce, _e, Te, rt) {
    var be, Fe, ke, Ze;
    if (typeof z == "number") {
      be = { top: z, bottom: z, left: z, right: z, front: z, back: z, type: z === 0 ? "VALID" : "NUMBER" };
      var ze = function(To, ir, yu, Io, Fn, xu) {
        Fn == null && (Fn = q1(To, ir, Io));
        var My = To[0], Dy = To[1], Fy = To[2], wu = Wi((My - ir + 2 * Fn) / Io + 1, xu);
        k(it(wu), function() {
          return "The output # of depths (" + wu + ") must be an integer. Change the stride and/or zero pad parameters";
        });
        var _u = Wi((Dy - ir + 2 * Fn) / Io + 1, xu);
        k(it(_u), function() {
          return "The output # of rows (" + _u + ") must be an integer. Change the stride and/or zero pad parameters";
        });
        var bu = Wi((Fy - ir + 2 * Fn) / Io + 1, xu);
        return k(it(bu), function() {
          return "The output # of columns (" + bu + ") must be an integer. Change the stride and/or zero pad parameters";
        }), [wu, _u, bu, yu];
      }([J, ie, ce, 1], Ce, 1, me, z, rt);
      Fe = ze[0], ke = ze[1], Ze = ze[2];
    } else if (z === "same") {
      Fe = Math.ceil(J / me), ke = Math.ceil(ie / ve), Ze = Math.ceil(ce / ye);
      var Ke = (Fe - 1) * me + Ce - J, Mn = (ke - 1) * ve + _e - ie, Dn = (Ze - 1) * ye + Te - ce, Jt = Math.floor(Ke / 2), Co = Ke - Jt, rr = Math.floor(Mn / 2), Tr = Mn - rr, or = Math.floor(Dn / 2);
      be = { top: rr, bottom: Tr, left: or, right: Dn - or, front: Jt, back: Co, type: "SAME" };
    } else {
      if (z !== "valid") throw Error("Unknown padding parameter: " + z);
      be = { top: 0, bottom: 0, left: 0, right: 0, front: 0, back: 0, type: "VALID" }, Fe = Math.ceil((J - Ce + 1) / me), ke = Math.ceil((ie - _e + 1) / ve), Ze = Math.ceil((ce - Te + 1) / ye);
    }
    return { padInfo: be, outDepth: Fe, outHeight: ke, outWidth: Ze };
  }(o, c, f, d, _, E, C, M, P, B, s), U = O.padInfo, G = O.outDepth, H = O.outHeight, W = O.outWidth, q = i ? w * p : w;
  return a === "channelsFirst" ? v = [l, q, G, H, W] : a === "channelsLast" && (v = [l, G, H, W, q]), { batchSize: l, dataFormat: a, inDepth: c, inHeight: f, inWidth: d, inChannels: p, outDepth: G, outHeight: H, outWidth: W, outChannels: q, padInfo: U, strideDepth: _, strideHeight: E, strideWidth: C, filterDepth: g, filterHeight: y, filterWidth: x, effectiveFilterDepth: M, effectiveFilterHeight: P, effectiveFilterWidth: B, dilationDepth: R, dilationHeight: I, dilationWidth: S, inShape: n, outShape: v, filterShape: e };
}
function q1(n, e, t, r) {
  r === void 0 && (r = 1);
  var o = Ko(e, r);
  return Math.floor((n[0] * (t - 1) - t + o) / 2);
}
function hs(n) {
  return typeof n == "number" ? [n, n, n] : n.length === 2 ? [n[0], n[1], 1] : n;
}
function Ql(n) {
  return typeof n == "number" ? [n, n, n] : n;
}
function Ko(n, e) {
  return e <= 1 ? n : n + (n - 1) * (e - 1);
}
function Wi(n, e) {
  if (!e) return n;
  switch (e) {
    case "round":
      return Math.round(n);
    case "ceil":
      return Math.ceil(n);
    case "floor":
      return Math.floor(n);
    default:
      throw new Error("Unknown roundingMode " + e);
  }
}
function hi(n) {
  var e = hs(n), t = e[0], r = e[1], o = e[2];
  return t === 1 && r === 1 && o === 1;
}
function zt(n, e) {
  return hi(n) || hi(e);
}
function Cf(n) {
  if (n === "NHWC") return "channelsLast";
  if (n === "NCHW") return "channelsFirst";
  throw new Error("Unknown dataFormat " + n);
}
function z1(n, e, t) {
  if (e === "complex64") {
    if (n.dtype === "complex64") return n.clone();
    var r = Ge(n.shape), o = n.toFloat(), i = t.complex(o, r);
    return r.dispose(), o.dispose(), i;
  }
  if (!r3(n.dtype, e)) return D.makeTensorFromDataId(n.dataId, n.shape, e);
  if (n.dtype === "complex64") {
    var a = t.real(n);
    return i = a.cast(e), a.dispose(), i;
  }
  if (e === "int32") return t.int(n);
  if (e === "bool") {
    var s = K(0, n.dtype);
    return i = t.notEqual(n, s), s.dispose(), i;
  }
  throw new Error("Error in Cast: failed to cast " + n.dtype + " to " + e);
}
function Zl(n, e) {
  return D.makeTensorFromDataId(n.dataId, e, n.dtype);
}
function K1(n, e, t) {
  var r = (e - n) / (t - 1), o = la(t, "float32");
  o[0] = n;
  for (var i = 1; i < o.length; i++) o[i] = o[i - 1] + r;
  return ut(o, "float32");
}
function jl(n, e) {
  if (n.length !== e.length) throw new Error("Cannot merge real and imag arrays of different lengths. real:" + n.length + ", imag: " + e.length + ".");
  for (var t = new Float32Array(2 * n.length), r = 0; r < t.length; r += 2) t[r] = n[r / 2], t[r + 1] = e[r / 2];
  return t;
}
function am(n, e) {
  return { real: n[2 * e], imag: n[2 * e + 1] };
}
function PT(n, e, t, r) {
  n[2 * r] = e, n[2 * r + 1] = t;
}
function NT(n, e, t) {
  var r = (t ? 2 : -2) * Math.PI * (n / e);
  return { real: Math.cos(r), imag: Math.sin(r) };
}
function MT(n, e, t) {
  var r = function(i, a, s) {
    return function(u, l, c) {
      for (var f = 0, d = u.length, p = 0, v = !1; f < d; ) {
        var g = c(l, u[p = f + (d - f >>> 1)]);
        g > 0 ? f = p + 1 : (d = p, v = !g);
      }
      return v ? f : -f - 1;
    }(i, a, s || DT);
  }(n, e, t), o = r < 0 ? -(r + 1) : r;
  n.splice(o, 0, e);
}
function DT(n, e) {
  return n > e ? 1 : n < e ? -1 : 0;
}
function Tf(n, e, t, r, o) {
  return J1(n, e, t, r, o, 0).selectedIndices;
}
function If(n, e, t, r, o, i) {
  var a = J1(n, e, t, r, o, i);
  return a.numValidOutputs.dispose(), { selectedIndices: a.selectedIndices, selectedScores: a.selectedScores };
}
function J1(n, e, t, r, o, i, a, s) {
  s === void 0 && (s = !1);
  for (var u = Array.from(e).map(function(_, E) {
    return { score: _, boxIndex: E, suppressBeginIndex: 0 };
  }).filter(function(_) {
    return _.score > o;
  }).sort(sm), l = i > 0 ? -0.5 / i : 0, c = [], f = []; c.length < t && u.length > 0; ) {
    var d = u.pop(), p = d.score, v = d.boxIndex, g = d.suppressBeginIndex;
    if (p < o) break;
    for (var y = !1, x = c.length - 1; x >= g; --x) {
      var w = FT(n, v, c[x]);
      if (w >= r) {
        y = !0;
        break;
      }
      if (d.score = d.score * LT(r, l, w), d.score <= o) break;
    }
    d.suppressBeginIndex = c.length, y || (d.score === p ? (c.push(v), f.push(d.score)) : d.score > o && MT(u, d, sm));
  }
  var b = c.length;
  return s && (c.fill(0, b), f.fill(0, b)), { selectedIndices: ut(c, "int32"), selectedScores: ut(f, "float32"), numValidOutputs: K(b, "int32") };
}
function FT(n, e, t) {
  var r = n.subarray(4 * e, 4 * e + 4), o = n.subarray(4 * t, 4 * t + 4), i = Math.min(r[0], r[2]), a = Math.min(r[1], r[3]), s = Math.max(r[0], r[2]), u = Math.max(r[1], r[3]), l = Math.min(o[0], o[2]), c = Math.min(o[1], o[3]), f = Math.max(o[0], o[2]), d = Math.max(o[1], o[3]), p = (s - i) * (u - a), v = (f - l) * (d - c);
  if (p <= 0 || v <= 0) return 0;
  var g = Math.max(i, l), y = Math.max(a, c), x = Math.min(s, f), w = Math.min(u, d), b = Math.max(x - g, 0) * Math.max(w - y, 0);
  return b / (p + v - b);
}
function LT(n, e, t) {
  var r = Math.exp(e * t * t);
  return t <= n ? r : 0;
}
function sm(n, e) {
  return n.score - e.score || n.score === e.score && e.boxIndex - n.boxIndex;
}
function X1(n, e, t) {
  var r = new Array(n.rank).fill(0), o = n.shape.slice();
  return e.map(function(i) {
    o[t] = i;
    var a = n.slice(r, o);
    return r[t] += i, a;
  });
}
function Y1(n, e) {
  for (var t = new Array(n.rank), r = 0; r < t.length; r++) t[r] = n.shape[r] * e[r];
  var o = he(t, n.dtype);
  for (r = 0; r < o.values.length; ++r) {
    for (var i = o.indexToLoc(r), a = new Array(n.rank), s = 0; s < a.length; s++) a[s] = i[s] % n.shape[s];
    var u = n.locToIndex(a);
    o.values[r] = n.values[u];
  }
  return o.toTensor();
}
function Q1(n, e, t, r, o) {
  for (var i = e[e.length - 1], a = [n.length / i, i], s = a[0], u = a[1], l = Qi(t, s * r), c = Qi("int32", s * r), f = 0; f < s; f++) {
    for (var d = f * u, p = n.subarray(d, d + u), v = [], g = 0; g < p.length; g++) v.push({ value: p[g], index: g });
    v.sort(function(_, E) {
      return E.value - _.value;
    });
    var y = f * r, x = l.subarray(y, y + r), w = c.subarray(y, y + r);
    for (g = 0; g < r; g++) x[g] = v[g].value, w[g] = v[g].index;
  }
  var b = e.slice();
  return b[b.length - 1] = r, [Tt(l, b, t), Tt(c, b, "int32")];
}
function Sf(n, e) {
  for (var t = [], r = 0; r < e.length; r++) e[r] && t.push(r);
  var o = he(n, "int32"), i = he([t.length, n.length], "int32");
  for (r = 0; r < t.length; r++) {
    var a = o.indexToLoc(t[r]), s = r * n.length;
    i.values.set(a, s);
  }
  return i.toTensor();
}
var BT = function(n, e) {
  this.outputShape = [], this.outputShape = n, this.variableNames = e.map(function(o, i) {
    return "T" + i;
  });
  var t = [];
  this.variableNames.forEach(function(o) {
    t.push("float v" + o + " = get" + o + "AtOutCoords();");
  });
  var r = this.variableNames.map(function(o) {
    return "v" + o;
  }).join(" + ");
  this.userCode = `
      void main() {
        ` + t.join(`
        `) + `

        float result = ` + r + `;
        setOutput(result);
      }
    `;
}, OT = function(n, e) {
  this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = n, this.variableNames = e.map(function(o, i) {
    return "T" + i;
  });
  var t = [];
  this.variableNames.forEach(function(o) {
    t.push("vec4 v" + o + " = get" + o + "AtOutCoords();");
  });
  var r = this.variableNames.map(function(o) {
    return "v" + o;
  }).join(" + ");
  this.userCode = `
      void main() {
        ` + t.join(`
        `) + `

        vec4 result = ` + r + `;
        setOutput(result);
      }
    `;
}, UT = function(n, e, t) {
  this.variableNames = ["A"];
  var r = n.windowSize, o = n.batchSize, i = n.inSize, a = Math.ceil(i / r);
  t || this.variableNames.push("bestIndicesA"), this.outputShape = [o, a];
  var s = e === "max" ? ">" : "<", u = t ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
  this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ` + r + `;

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ` + r + `; i++) {
          int inIdx = ` + u + `;
          float candidate = getA(batch, inIdx);
          if (candidate ` + s + ` bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `;
};
function Z1(n, e) {
  return ["x", "y", "z", "w", "u", "v"].slice(0, e).map(function(t) {
    return n + "." + t;
  });
}
function Gt(n, e) {
  return e === 1 ? [n] : Z1(n, e);
}
function Rt() {
  var n, e, t, r, o, i, a, s, u, l;
  return V().getNumber("WEBGL_VERSION") === 2 ? (n = "#version 300 es", e = "in", t = "out", r = "in", o = "texture", i = "outputColor", a = "out vec4 outputColor;", s = `
      bool isnan_custom(float val) {
        return (val > 0.0 || val < 0.0) ? false : val != 0.0;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `, u = "", l = `
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `) : (n = "", e = "attribute", t = "varying", r = "varying", o = "texture2D", i = "gl_FragColor", a = "", s = `
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `, u = `
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `, l = `
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `), { version: n, attribute: e, varyingVs: t, varyingFs: r, texture2D: o, output: i, defineOutput: a, defineSpecialNaN: s, defineSpecialInf: u, defineRound: l };
}
function ao(n, e, t) {
  t === void 0 && (t = "index");
  var r = Kn(e);
  return r.map(function(o, i) {
    return "int " + n[i] + " = " + t + " / " + o + "; " + (i === r.length - 1 ? "int " + n[i + 1] + " = " + t + " - " + n[i] + " * " + o : "index -= " + n[i] + " * " + o) + ";";
  }).join("");
}
function Af(n) {
  var e = Kn(n).map(function(t) {
    return t.toString();
  });
  return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * ` + e[0] + " + coords.y * " + e[1] + ` + coords.z;
  }
`;
}
var j1 = `
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;
function VT(n, e, t, r) {
  var o = [];
  n.forEach(function(p) {
    var v = ee(p.shapeInfo.logicalShape);
    p.shapeInfo.isUniform ? o.push("uniform float " + p.name + (v > 1 ? "[" + v + "]" : "") + ";") : (o.push("uniform sampler2D " + p.name + ";"), o.push("uniform int offset" + p.name + ";"));
  });
  var i, a, s = o.join(`
`), u = n.map(function(p) {
    return function(v, g, y) {
      y === void 0 && (y = !1);
      var x = "";
      x += y ? e0(v) : Mo(v);
      var w = v.shapeInfo.logicalShape, b = g.logicalShape;
      return w.length <= b.length && (x += y ? function(_, E) {
        var C, A = _.name, R = A.charAt(0).toUpperCase() + A.slice(1), I = "get" + R + "AtOutCoords", S = _.shapeInfo.logicalShape.length, M = E.logicalShape.length, P = Nr(_.shapeInfo.logicalShape, E.logicalShape), B = Ue(M), O = M - S, U = ["x", "y", "z", "w", "u", "v"];
        C = S === 0 ? "" : M < 2 && P.length >= 1 ? "coords = 0;" : P.map(function(ie) {
          return "coords." + U[ie + O] + " = 0;";
        }).join(`
`);
        var G = "";
        G = M < 2 && S > 0 ? "coords" : _.shapeInfo.logicalShape.map(function(ie, ce) {
          return "coords." + U[ce + O];
        }).join(", ");
        var H = "return outputValue;", W = ee(_.shapeInfo.logicalShape) === 1, q = ee(E.logicalShape) === 1;
        if (S !== 1 || W || q) {
          if (W && !q) H = M === 1 ? `
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      ` : `
        return vec4(outputValue.x);
      `;
          else if (P.length) {
            var z = S - 2, J = S - 1;
            P.indexOf(z) > -1 && P.indexOf(J) > -1 ? H = "return vec4(outputValue.x);" : P.indexOf(z) > -1 ? H = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : P.indexOf(J) > -1 && (H = "return vec4(outputValue.xx, outputValue.zz);");
          }
        } else H = `
      return vec4(outputValue.xy, outputValue.xy);
    `;
        return `
    vec4 ` + I + `() {
      ` + B + ` coords = getOutputCoords();
      ` + C + `
      vec4 outputValue = get` + R + "(" + G + `);
      ` + H + `
    }
  `;
      }(v, g) : function(_, E) {
        var C = _.name, A = C.charAt(0).toUpperCase() + C.slice(1), R = "get" + A + "AtOutCoords", I = E.texShape, S = _.shapeInfo.texShape, M = _.shapeInfo.logicalShape.length, P = E.logicalShape.length;
        if (!_.shapeInfo.isUniform && M === P && _.shapeInfo.flatOffset == null && _t(S, I)) return `
      float ` + R + `() {
        return sampleTexture(` + C + `, resultUV);
      }
    `;
        var B, O = Ue(P), U = Nr(_.shapeInfo.logicalShape, E.logicalShape), G = P - M, H = ["x", "y", "z", "w", "u", "v"];
        B = M === 0 ? "" : P < 2 && U.length >= 1 ? "coords = 0;" : U.map(function(q) {
          return "coords." + H[q + G] + " = 0;";
        }).join(`
`);
        var W = "";
        return W = P < 2 && M > 0 ? "coords" : _.shapeInfo.logicalShape.map(function(q, z) {
          return "coords." + H[z + G];
        }).join(", "), `
    float ` + R + `() {
      ` + O + ` coords = getOutputCoords();
      ` + B + `
      return get` + A + "(" + W + `);
    }
  `;
      }(v, g)), x;
    }(p, e, r);
  }).join(`
`), l = e.texShape, c = Rt(), f = function(p) {
    return `
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ` + p.texture2D + `(textureSampler, uv).r;
    }
  `;
  }(c), d = function(p) {
    return p.version + `
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ` + p.varyingFs + ` vec2 resultUV;
    ` + p.defineOutput + `
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ` + p.defineSpecialNaN + `
    ` + p.defineSpecialInf + `
    ` + p.defineRound + `

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ` + GT + `
    ` + WT + `
    ` + HT + `
  `;
  }(c);
  return e.isPacked ? (i = function(p, v) {
    switch (p.length) {
      case 0:
        return `
    int getOutputCoords() {
      return 0;
    }
  `;
      case 1:
        return function(_, E) {
          var C = [Math.ceil(E[0] / 2), Math.ceil(E[1] / 2)];
          return C[0] === 1 ? `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ` + C[1] + `.0);
      }
    ` : C[1] === 1 ? `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ` + C[0] + `.0);
      }
    ` : `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(` + C[0] + ", " + C[1] + `));
      return 2 * (resTexRC.x * ` + C[1] + ` + resTexRC.y);
    }
  `;
        }(0, v);
      case 2:
        return function(_, E) {
          var C = [Math.ceil(E[0] / 2), Math.ceil(E[1] / 2)];
          if (_t(_, E)) return `
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(` + C[0] + ", " + C[1] + `));
      }
    `;
          var A = Math.ceil(_[1] / 2);
          return `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(` + C[0] + ", " + C[1] + `));

      int index = resTexRC.x * ` + C[1] + ` + resTexRC.y;
      int r = 2 * (index / ` + A + `);
      int c = imod(index, ` + A + `) * 2;

      return ivec2(r, c);
    }
  `;
        }(p, v);
      case 3:
        return g = p, y = v, x = [Math.ceil(y[0] / 2), Math.ceil(y[1] / 2)], w = Math.ceil(g[2] / 2), b = w * Math.ceil(g[1] / 2), `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(` + x[0] + ", " + x[1] + `));
      int index = resTexRC.x * ` + x[1] + ` + resTexRC.y;

      int b = index / ` + b + `;
      index -= b * ` + b + `;

      int r = 2 * (index / ` + w + `);
      int c = imod(index, ` + w + `) * 2;

      return ivec3(b, r, c);
    }
  `;
      default:
        return function(_, E) {
          for (var C = [Math.ceil(E[0] / 2), Math.ceil(E[1] / 2)], A = Math.ceil(_[_.length - 1] / 2), R = A * Math.ceil(_[_.length - 2] / 2), I = R, S = "", M = "b, r, c", P = 2; P < _.length - 1; P++) I *= _[_.length - P - 1], S = `
      int b` + P + " = index / " + I + `;
      index -= b` + P + " * " + I + `;
    ` + S, M = "b" + P + ", " + M;
          return `
    ivec` + _.length + ` getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(` + C[0] + ", " + C[1] + `));
      int index = resTexRC.x * ` + C[1] + ` + resTexRC.y;

      ` + S + `

      int b = index / ` + R + `;
      index -= b * ` + R + `;

      int r = 2 * (index / ` + A + `);
      int c = imod(index, ` + A + `) * 2;

      return ivec` + _.length + "(" + M + `);
    }
  `;
        }(p, v);
    }
    var g, y, x, w, b;
  }(e.logicalShape, l), a = function(p) {
    return `
    void setOutput(vec4 val) {
      ` + p.output + ` = val;
    }
  `;
  }(c)) : (i = function(p, v) {
    switch (p.length) {
      case 0:
        return `
    int getOutputCoords() {
      return 0;
    }
  `;
      case 1:
        return function(x, w) {
          return w[0] === 1 ? `
      int getOutputCoords() {
        return int(resultUV.x * ` + w[1] + `.0);
      }
    ` : w[1] === 1 ? `
      int getOutputCoords() {
        return int(resultUV.y * ` + w[0] + `.0);
      }
    ` : `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(` + w[0] + ", " + w[1] + `));
      return resTexRC.x * ` + w[1] + ` + resTexRC.y;
    }
  `;
        }(0, v);
      case 2:
        return function(x, w) {
          return _t(x, w) ? `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(` + w[0] + ", " + w[1] + `));
      }
    ` : x[1] === 1 ? `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(` + w[0] + ", " + w[1] + `));
        int index = resTexRC.x * ` + w[1] + ` + resTexRC.y;
        return ivec2(index, 0);
      }
    ` : x[0] === 1 ? `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(` + w[0] + ", " + w[1] + `));
        int index = resTexRC.x * ` + w[1] + ` + resTexRC.y;
        return ivec2(0, index);
      }
    ` : `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(` + w[0] + ", " + w[1] + `));
      int index = resTexRC.x * ` + w[1] + ` + resTexRC.y;
      int r = index / ` + x[1] + `;
      int c = index - r * ` + x[1] + `;
      return ivec2(r, c);
    }
  `;
        }(p, v);
      case 3:
        return g = v, y = ao(["r", "c", "d"], p), `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(` + g[0] + ", " + g[1] + `));
      int index = resTexRC.x * ` + g[1] + ` + resTexRC.y;
      ` + y + `
      return ivec3(r, c, d);
    }
  `;
      case 4:
        return function(x, w) {
          var b = ao(["r", "c", "d", "d2"], x);
          return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(` + w[0] + ", " + w[1] + `));
      int index = resTexRC.x * ` + w[1] + ` + resTexRC.y;
      ` + b + `
      return ivec4(r, c, d, d2);
    }
  `;
        }(p, v);
      case 5:
        return function(x, w) {
          var b = ao(["r", "c", "d", "d2", "d3"], x);
          return `
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(` + w[0] + `,
                             ` + w[1] + `));

      int index = resTexRC.x * ` + w[1] + ` + resTexRC.y;

      ` + b + `

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `;
        }(p, v);
      case 6:
        return function(x, w) {
          var b = ao(["r", "c", "d", "d2", "d3", "d4"], x);
          return `
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(` + w[0] + ", " + w[1] + `));
      int index = resTexRC.x * ` + w[1] + ` + resTexRC.y;

      ` + b + `

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `;
        }(p, v);
      default:
        throw new Error(p.length + "-D output sampling is not yet supported");
    }
    var g, y;
  }(e.logicalShape, l), a = function(p) {
    return `
    void setOutput(float val) {
      ` + p.output + ` = vec4(val, 0, 0, 0);
    }
  `;
  }(c)), r && (d += $T), [d, f, a, s, i, u, t].join(`
`);
}
function Mo(n) {
  var e = n.shapeInfo.logicalShape;
  switch (e.length) {
    case 0:
      return function(t) {
        var r = t.name, o = "get" + r.charAt(0).toUpperCase() + r.slice(1);
        if (t.shapeInfo.isUniform) return "float " + o + "() {return " + r + ";}";
        var i = t.shapeInfo.texShape, a = i[0], s = i[1];
        if (a === 1 && s === 1) return `
      float ` + o + `() {
        return sampleTexture(` + r + `, halfCR);
      }
    `;
        var u = t.shapeInfo.texShape, l = u[0], c = u[1], f = jr(r);
        return `
    float ` + o + `() {
      vec2 uv = uvFromFlat(` + l + ", " + c + ", " + f + `);
      return sampleTexture(` + r + `, uv);
    }
  `;
      }(n);
    case 1:
      return function(t) {
        var r = t.name, o = "get" + r.charAt(0).toUpperCase() + r.slice(1);
        if (t.shapeInfo.isUniform) return `
      float ` + o + `(int index) {
        ` + Ro(t) + `
      }
    `;
        var i = t.shapeInfo.texShape, a = i[0], s = i[1];
        if (s === 1 && a === 1) return `
      float ` + o + `(int index) {
        return sampleTexture(` + r + `, halfCR);
      }
    `;
        var u = jr(r);
        return s === 1 ? `
      float ` + o + `(int index) {
        vec2 uv = vec2(0.5, (float(index + ` + u + ") + 0.5) / " + a + `.0);
        return sampleTexture(` + r + `, uv);
      }
    ` : a === 1 ? `
      float ` + o + `(int index) {
        vec2 uv = vec2((float(index + ` + u + ") + 0.5) / " + s + `.0, 0.5);
        return sampleTexture(` + r + `, uv);
      }
    ` : `
    float ` + o + `(int index) {
      vec2 uv = uvFromFlat(` + a + ", " + s + ", index + " + u + `);
      return sampleTexture(` + r + `, uv);
    }
  `;
      }(n);
    case 2:
      return function(t) {
        var r = t.shapeInfo.logicalShape, o = t.name, i = "get" + o.charAt(0).toUpperCase() + o.slice(1), a = t.shapeInfo.texShape;
        if (a != null && _t(r, a)) {
          var s = a[0], u = a[1];
          return `
    float ` + i + `(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(` + u + ".0, " + s + `.0);
      return sampleTexture(` + o + `, uv);
    }
  `;
        }
        var l = ro(r), c = l.newShape, f = l.keptDims, d = c;
        if (d.length < r.length) {
          var p = Do(t, d);
          return `
      ` + Mo(p) + `
      float ` + i + `(int row, int col) {
        return ` + i + "(" + Fo(["row", "col"], f) + `);
      }
    `;
        }
        if (t.shapeInfo.isUniform) return `
      float ` + i + `(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(` + r[1] + `, 1)));
        ` + Ro(t) + `
      }
    `;
        var v = a[0], g = a[1], y = jr(o);
        return g === 1 ? `
    float ` + i + `(int row, int col) {
      float index = dot(vec3(row, col, ` + y + "), vec3(" + r[1] + `, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ` + v + `.0);
      return sampleTexture(` + o + `, uv);
    }
  ` : v === 1 ? `
    float ` + i + `(int row, int col) {
      float index = dot(vec3(row, col, ` + y + "), vec3(" + r[1] + `, 1, 1));
      vec2 uv = vec2((index + 0.5) / ` + g + `.0, 0.5);
      return sampleTexture(` + o + `, uv);
    }
  ` : `
  float ` + i + `(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ` + r[1] + " + col + " + y + `;
    vec2 uv = uvFromFlat(` + v + ", " + g + `, index);
    return sampleTexture(` + o + `, uv);
  }
`;
      }(n);
    case 3:
      return function(t) {
        var r = t.shapeInfo.logicalShape, o = t.name, i = "get" + o.charAt(0).toUpperCase() + o.slice(1), a = r[1] * r[2], s = r[2], u = ro(r), l = u.newShape, c = u.keptDims, f = l;
        if (f.length < r.length) {
          var d = Do(t, f);
          return `
        ` + Mo(d) + `
        float ` + i + `(int row, int col, int depth) {
          return ` + i + "(" + Fo(["row", "col", "depth"], c) + `);
        }
      `;
        }
        if (t.shapeInfo.isUniform) return `
      float ` + i + `(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(` + a + ", " + s + `, 1)));
        ` + Ro(t) + `
      }
    `;
        var p = t.shapeInfo.texShape, v = p[0], g = p[1], y = t.shapeInfo.flatOffset;
        if (g === a && y == null) return `
        float ` + i + `(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(` + s + `, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(` + g + ".0, " + v + `.0);
          return sampleTexture(` + o + `, uv);
        }
      `;
        if (g === s && y == null) return `
    float ` + i + `(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(` + r[1] + `, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(` + g + ".0, " + v + `.0);
      return sampleTexture(` + o + `, uv);
    }
  `;
        var x = jr(o);
        return `
      float ` + i + `(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ` + a + " + col * " + s + " + depth + " + x + `;
        vec2 uv = uvFromFlat(` + v + ", " + g + `, index);
        return sampleTexture(` + o + `, uv);
      }
  `;
      }(n);
    case 4:
      return function(t) {
        var r = t.shapeInfo.logicalShape, o = t.name, i = "get" + o.charAt(0).toUpperCase() + o.slice(1), a = r[3], s = r[2] * a, u = r[1] * s, l = ro(r), c = l.newShape, f = l.keptDims;
        if (c.length < r.length) {
          var d = Do(t, c);
          return `
      ` + Mo(d) + `
      float ` + i + `(int row, int col, int depth, int depth2) {
        return ` + i + "(" + Fo(["row", "col", "depth", "depth2"], f) + `);
      }
    `;
        }
        if (t.shapeInfo.isUniform) return `
      float ` + i + `(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(` + u + ", " + s + ", " + a + `, 1)));
        ` + Ro(t) + `
      }
    `;
        var p = t.shapeInfo.flatOffset, v = t.shapeInfo.texShape, g = v[0], y = v[1];
        if (y === u && p == null) return `
      float ` + i + `(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(` + s + ", " + a + `, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(` + y + ".0, " + g + `.0);
        return sampleTexture(` + o + `, uv);
      }
    `;
        if (y === a && p == null) return `
      float ` + i + `(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(` + r[1] * r[2] + ", " + r[2] + `, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(` + y + ".0, " + g + `.0);
        return sampleTexture(` + o + `, uv);
      }
    `;
        var x = jr(o);
        return `
    float ` + i + `(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ` + u + " + col * " + s + ` +
          depth * ` + a + ` + depth2;
      vec2 uv = uvFromFlat(` + g + ", " + y + ", index + " + x + `);
      return sampleTexture(` + o + `, uv);
    }
  `;
      }(n);
    case 5:
      return function(t) {
        var r = t.shapeInfo.logicalShape, o = t.name, i = "get" + o.charAt(0).toUpperCase() + o.slice(1), a = r[4], s = r[3] * a, u = r[2] * s, l = r[1] * u, c = ro(r), f = c.newShape, d = c.keptDims;
        if (f.length < r.length) {
          var p = Do(t, f);
          return `
      ` + Mo(p) + `
      float ` + i + `(int row, int col, int depth, int depth2, int depth3) {
        return ` + i + "(" + Fo(["row", "col", "depth", "depth2", "depth3"], d) + `);
      }
    `;
        }
        if (t.shapeInfo.isUniform) return `
      float ` + i + `(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(` + l + ", " + u + ", " + s + ", " + a + `)) +
          depth3;
        ` + Ro(t) + `
      }
    `;
        var v = t.shapeInfo.flatOffset, g = t.shapeInfo.texShape, y = g[0], x = g[1];
        if (x === l && v == null) return `
      float ` + i + `(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(` + u + ", " + s + ", " + a + `, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(` + x + ".0, " + y + `.0);
        return sampleTexture(` + o + `, uv);
      }
    `;
        if (x === a && v == null) return `
      float ` + i + `(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(` + r[1] * r[2] * r[3] + `,
               ` + r[2] * r[3] + ", " + r[3] + `, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(` + x + ".0, " + y + `.0);
        return sampleTexture(` + o + `, uv);
      }
    `;
        var w = jr(o);
        return `
    float ` + i + `(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ` + l + " + col * " + u + " + depth * " + s + ` +
          depth2 * ` + a + " + depth3 + " + w + `;
      vec2 uv = uvFromFlat(` + y + ", " + x + `, index);
      return sampleTexture(` + o + `, uv);
    }
  `;
      }(n);
    case 6:
      return function(t) {
        var r = t.shapeInfo.logicalShape, o = t.name, i = "get" + o.charAt(0).toUpperCase() + o.slice(1), a = ro(r), s = a.newShape, u = a.keptDims;
        if (s.length < r.length) {
          var l = Do(t, s);
          return `
      ` + Mo(l) + `
      float ` + i + `(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ` + i + "(" + Fo(["row", "col", "depth", "depth2", "depth3", "depth4"], u) + `);
      }
    `;
        }
        var c = r[5], f = r[4] * c, d = r[3] * f, p = r[2] * d, v = r[1] * p;
        if (t.shapeInfo.isUniform) return `
      float ` + i + `(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(` + v + ", " + p + ", " + d + ", " + f + `)) +
          dot(
            vec2(depth3, depth4),
            vec2(` + c + `, 1)));
        ` + Ro(t) + `
      }
    `;
        var g = t.shapeInfo.flatOffset, y = t.shapeInfo.texShape, x = y[0], w = y[1];
        if (w === v && g == null) return `
      float ` + i + `(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(` + p + ", " + d + ", " + f + ", " + c + `)) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(` + w + ".0, " + x + `.0);
        return sampleTexture(` + o + `, uv);
      }
    `;
        if (w === c && g == null) return `
      float ` + i + `(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(` + r[1] * r[2] * r[3] * r[4] + `,
               ` + r[2] * r[3] * r[4] + `,
               ` + r[3] * r[4] + `,
               ` + r[4] + `)) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(` + w + ".0, " + x + `.0);
        return sampleTexture(` + o + `, uv);
      }
    `;
        var b = jr(o);
        return `
    float ` + i + `(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ` + v + " + col * " + p + " + depth * " + d + ` +
          depth2 * ` + f + " + depth3 * " + c + " + depth4 + " + b + `;
      vec2 uv = uvFromFlat(` + x + ", " + w + `, index);
      return sampleTexture(` + o + `, uv);
    }
  `;
      }(n);
    default:
      throw new Error(e.length + "-D input sampling is not yet supported");
  }
}
function e0(n) {
  var e, t, r;
  switch (n.shapeInfo.logicalShape.length) {
    case 0:
      return e = n.name, t = "get" + e.charAt(0).toUpperCase() + e.slice(1), r = Rt(), `
    vec4 ` + t + `() {
      return ` + r.texture2D + "(" + e + `, halfCR);
    }
  `;
    case 1:
      return function(o) {
        var i = o.name, a = "get" + i.charAt(0).toUpperCase() + i.slice(1), s = o.shapeInfo.texShape, u = [Math.ceil(s[0] / 2), Math.ceil(s[1] / 2)], l = Rt();
        return `
    vec4 ` + a + `(int index) {
      vec2 uv = packedUVfrom1D(
        ` + u[0] + ", " + u[1] + `, index);
      return ` + l.texture2D + "(" + i + `, uv);
    }
  `;
      }(n);
    case 2:
      return function(o) {
        var i = o.shapeInfo.logicalShape, a = o.name, s = "get" + a.charAt(0).toUpperCase() + a.slice(1), u = o.shapeInfo.texShape, l = u[0], c = u[1], f = Rt();
        if (u != null && _t(i, u)) return `
      vec4 ` + s + `(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(` + c + ".0, " + l + `.0);

        return ` + f.texture2D + "(" + a + `, uv);
      }
    `;
        var d = [Math.ceil(u[0] / 2), Math.ceil(u[1] / 2)], p = Math.ceil(i[1] / 2);
        return `
    vec4 ` + s + `(int row, int col) {
      vec2 uv = packedUVfrom2D(` + p + ", " + d[0] + ", " + d[1] + `, row, col);
      return ` + f.texture2D + "(" + a + `, uv);
    }
  `;
      }(n);
    case 3:
      return function(o) {
        var i = o.shapeInfo.logicalShape, a = o.name, s = "get" + a.charAt(0).toUpperCase() + a.slice(1), u = o.shapeInfo.texShape, l = [Math.ceil(u[0] / 2), Math.ceil(u[1] / 2)];
        if (i[0] === 1) {
          var c = i.slice(1), f = Do(o, c);
          return `
        ` + e0(f) + `
        vec4 ` + s + `(int b, int row, int col) {
          return ` + s + "(" + Fo(["b", "row", "col"], [1, 2]) + `);
        }
      `;
        }
        var d = l[0], p = l[1], v = Math.ceil(i[2] / 2), g = v * Math.ceil(i[1] / 2), y = Rt();
        return `
    vec4 ` + s + `(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ` + d + ", " + p + ", " + g + ", " + v + `, b, row, col);
      return ` + y.texture2D + "(" + a + `, uv);
    }
  `;
      }(n);
    default:
      return function(o) {
        for (var i = o.shapeInfo.logicalShape, a = i.length, s = o.name, u = "get" + s.charAt(0).toUpperCase() + s.slice(1), l = o.shapeInfo.texShape, c = [Math.ceil(l[0] / 2), Math.ceil(l[1] / 2)], f = c[0], d = c[1], p = Math.ceil(i[a - 1] / 2), v = p * Math.ceil(i[a - 2] / 2), g = "int b, int row, int col", y = "b * " + v + " + (row / 2) * " + p + " + (col / 2)", x = 2; x < a - 1; x++) g = "int b" + x + ", " + g, v *= i[a - x - 1], y = "b" + x + " * " + v + " + " + y;
        var w = Rt();
        return `
    vec4 ` + u + "(" + g + `) {
      int index = ` + y + `;
      int texR = index / ` + d + `;
      int texC = index - texR * ` + d + `;
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(` + d + ", " + f + `);
      return ` + w.texture2D + "(" + s + `, uv);
    }
  `;
      }(n);
  }
}
var GT = `
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`, WT = `
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`, HT = `
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`, $T = `
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;
function jr(n) {
  return "offset" + n;
}
function Ro(n) {
  var e = n.name, t = ee(n.shapeInfo.logicalShape);
  return t < 2 ? "return " + e + ";" : `
    for (int i = 0; i < ` + t + `; i++) {
      if (i == index) {
        return ` + e + `[i];
      }
    }
  `;
}
function Ue(n) {
  if (n <= 1) return "int";
  if (n === 2) return "ivec2";
  if (n === 3) return "ivec3";
  if (n === 4) return "ivec4";
  if (n === 5) return "ivec5";
  if (n === 6) return "ivec6";
  throw Error("GPU for rank " + n + " is not yet supported");
}
function Do(n, e) {
  var t = JSON.parse(JSON.stringify(n));
  return t.shapeInfo.logicalShape = e, t;
}
function Fo(n, e) {
  return e.map(function(t) {
    return n[t];
  }).join(", ");
}
var qT = function(n, e, t, r) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, k(n.length > 2, function() {
    return "Packed arg" + (t.charAt(0).toUpperCase() + t.slice(1)) + " supports only inputs with rank above 2.";
  });
  var o = n[n.length - 1], i = Math.ceil(o / e);
  this.outputShape = n.slice(0, -1), i > 1 && this.outputShape.push(i), r || this.variableNames.push("bestIndicesA");
  var a, s, u = this.outputShape, l = u.length, c = Ue(l), f = Gt("coords", l);
  if (i === 1) {
    var d = Ue(s = l + 1);
    a = `
        ` + d + " sourceLocR = " + d + "(" + f.join() + `, 0);
        ++` + f[l - 1] + `;
        ` + d + " sourceLocG = " + d + "(" + f.join() + `, 0);
        ++` + f[l - 2] + `;
        ` + d + " sourceLocA = " + d + "(" + f.join() + `, 0);
        --` + f[l - 1] + `;
        ` + d + " sourceLocB = " + d + "(" + f.join() + `, 0);
        --` + f[l - 2] + ";";
  } else s = l, a = `
        ` + c + ` sourceLocR = coords;
        ++` + f[l - 1] + `;
        ` + c + ` sourceLocG = coords;
        ++` + f[l - 2] + `;
        ` + c + ` sourceLocA = coords;
        --` + f[l - 1] + `;
        ` + c + ` sourceLocB = coords;
        --` + f[l - 2] + ";";
  var p = ["x", "y", "z", "w", "u", "v"].slice(0, s), v = "." + p[s - 1], g = p.map(function(R) {
    return "int " + R;
  }), y = Gt("sourceLocR", s - 1).concat("inIdx.r"), x = Gt("sourceLocG", s - 1).concat("inIdx.g"), w = Gt("sourceLocB", s - 1).concat("inIdx.b"), b = Gt("sourceLocA", s - 1).concat("inIdx.a"), _ = t === "max" ? "greaterThan" : "lessThan", E = r ? "" : `
          inIdx = round(vec4(getBestIndicesAChannel(` + y.join() + `),
                             getBestIndicesAChannel(` + x.join() + `),
                             getBestIndicesAChannel(` + w.join() + `),
                             getBestIndicesAChannel(` + b.join() + ")));", C = `vec4(
            getAChannel(` + y.join() + `),
            hasNextCol ? getAChannel(` + x.join() + `) : 0.,
            hasNextRow ? getAChannel(` + w.join() + `) : 0.,
            hasNextRow && hasNextCol ? getAChannel(` + b.join() + ") : 0.)", A = r ? "" : `
      float getBestIndicesAChannel(` + g.join() + `) {
        return getChannel(getBestIndicesA(` + p.join() + `),
                                          vec2(` + p.slice(-2).join() + `));
      }`;
  this.userCode = `
      float getAChannel(` + g.join() + `) {
        return getChannel(getA(` + p.join() + `),
                               vec2(` + p.slice(-2).join() + `));
      }
      ` + A + `
      void main() {
        ` + c + ` coords = getOutputCoords();
        bool hasNextCol = ` + f[l - 1] + " < " + (u[l - 1] - 1) + `;
        bool hasNextRow = ` + f[l - 2] + " < " + (u[l - 2] - 1) + `;
        ` + a + `
        ivec4 srcIdx = ivec4(sourceLocR` + v + ", sourceLocG" + v + `,
          sourceLocB` + v + ", sourceLocA" + v + ") * " + e + `;
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ` + C + `;

        for (int i = 0; i < ` + e + `; i++) {
          inIdx = srcIdx;
          ` + E + `
          vec4 candidate = ` + C + `;
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(` + _ + `(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `;
}, zT = function(n) {
  this.variableNames = ["dy"], this.outputShape = n.inShape;
  var e = n.filterHeight, t = n.filterWidth, r = n.strideHeight, o = n.strideWidth, i = n.dilationHeight, a = n.dilationWidth, s = n.effectiveFilterHeight, u = n.effectiveFilterWidth, l = s - 1 - n.padInfo.top, c = u - 1 - n.padInfo.left, f = 1 / (e * t);
  this.userCode = `
      const ivec2 pads = ivec2(` + l + ", " + c + `);
      const float avgMultiplier = float(` + f + `);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ` + s + `;
            wR += ` + i + `) {
          float dyR = float(dyRCorner + wR) / ` + r + `.0;

          if (dyR < 0.0 || dyR >= ` + n.outHeight + `.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ` + u + `;
            wC+= ` + a + `) {
            float dyC = float(dyCCorner + wC) / ` + o + `.0;

            if (dyC < 0.0 || dyC >= ` + n.outWidth + `.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `;
}, KT = function(n) {
  this.variableNames = ["dy"], this.outputShape = n.inShape;
  var e = n.filterDepth, t = n.filterHeight, r = n.filterWidth, o = n.strideDepth, i = n.strideHeight, a = n.strideWidth, s = n.dilationDepth, u = n.dilationHeight, l = n.dilationWidth, c = n.effectiveFilterDepth, f = n.effectiveFilterHeight, d = n.effectiveFilterWidth, p = c - 1 - n.padInfo.front, v = f - 1 - n.padInfo.top, g = d - 1 - n.padInfo.left, y = 1 / (e * t * r);
  this.userCode = `
      const ivec3 pads = ivec3(` + p + ", " + v + ", " + g + `);
      const float avgMultiplier = float(` + y + `);

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ` + c + `;
            wD += ` + s + `) {
          float dyD = float(dyDCorner + wD) / ` + o + `.0;

          if (dyD < 0.0 || dyD >= ` + n.outDepth + `.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ` + f + `;
              wR += ` + u + `) {
            float dyR = float(dyRCorner + wR) / ` + i + `.0;

            if (dyR < 0.0 || dyR >= ` + n.outHeight + `.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ` + d + `;
                wC += ` + l + `) {
              float dyC = float(dyCCorner + wC) / ` + a + `.0;

              if (dyC < 0.0 || dyC >= ` + n.outWidth + `.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
}, JT = function(n, e, t, r, o, i) {
  this.outputShape = [], this.variableNames = ["x", "mean", "variance"], xe(n, e), xe(n, t);
  var a = "0.0";
  r != null && (xe(n, r), this.variableNames.push("offset"), a = "getOffsetAtOutCoords()");
  var s = "1.0";
  o != null && (xe(n, o), this.variableNames.push("scale"), s = "getScaleAtOutCoords()"), this.outputShape = n, this.userCode = `
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ` + a + `;
        float scale = ` + s + `;
        float inv = scale * inversesqrt(variance + float(` + i + `));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `;
}, XT = function(n, e, t, r, o, i) {
  this.packedInputs = !0, this.packedOutput = !0, this.variableNames = ["x", "mean", "variance"], xe(n, e), xe(n, t);
  var a = "vec4(0.0)";
  r != null && (xe(n, r), this.variableNames.push("offset"), a = "getOffsetAtOutCoords()");
  var s = "vec4(1.0)";
  o != null && (xe(n, o), this.variableNames.push("scale"), s = "getScaleAtOutCoords()"), this.outputShape = n, this.userCode = `
      void main() {
        vec4 offset = ` + a + `;
        vec4 scale = ` + s + `;

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(` + i + `));

        setOutput((x - mean) * inv + offset);
      }
    `;
}, YT = "return areal * breal - aimag * bimag;", QT = "return areal * bimag + aimag * breal;", um = function(n, e, t) {
  this.variableNames = ["AReal", "AImag", "BReal", "BImag"], this.outputShape = xe(e, t), this.userCode = `
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ` + n + `
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `;
}, Ku = "return a + b;", Ju = "return a - b;", lm = "return a * b;", t0 = "return (a < 0.) ? b * a : a;", et = function(n, e, t) {
  this.variableNames = ["A", "B"], this.outputShape = xe(e, t), this.userCode = `
      float binaryOperation(float a, float b) {
        ` + n + `
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `;
}, n0 = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`, sr = function(n, e, t, r) {
  r === void 0 && (r = !1), this.variableNames = ["A", "B"], this.supportsBroadcasting = !0, this.packedInputs = !0, this.packedOutput = !0, this.outputShape = xe(e, t);
  var o = this.outputShape.length, i = "";
  if (r) if (o === 0 || ee(this.outputShape) === 1) i = `
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;
  else if (i = `
          ` + Ue(o) + ` coords = getOutputCoords();
        `, o === 1) i += `
            result.y = (coords + 1) >= ` + this.outputShape[0] + ` ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;
  else {
    var a = Gt("coords", o);
    i += `
            bool nextRowOutOfBounds =
              (` + a[o - 2] + " + 1) >= " + this.outputShape[o - 2] + `;
            bool nextColOutOfBounds =
              (` + a[o - 1] + " + 1) >= " + this.outputShape[o - 1] + `;
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `;
  }
  this.userCode = `
      vec4 binaryOperation(vec4 a, vec4 b) {
        ` + n + `
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ` + i + `

        setOutput(result);
      }
    `;
}, ZT = function() {
  function n(e) {
    this.variableNames = ["A"], this.outputShape = e, this.userCode = `
      uniform float minVal;
      uniform float maxVal;

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `;
  }
  return n.prototype.getCustomSetupFunc = function(e, t) {
    var r = this;
    return function(o, i) {
      r.minLoc == null && (r.minLoc = o.getUniformLocationNoThrow(i, "minVal"), r.maxLoc = o.getUniformLocationNoThrow(i, "maxVal")), o.gl.uniform1f(r.minLoc, e), o.gl.uniform1f(r.maxLoc, t);
    };
  }, n;
}(), jT = function() {
  function n(e) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e, this.userCode = `
      uniform float minVal;
      uniform float maxVal;

      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `;
  }
  return n.prototype.getCustomSetupFunc = function(e, t) {
    var r = this;
    return function(o, i) {
      r.minLoc == null && (r.minLoc = o.getUniformLocationNoThrow(i, "minVal"), r.maxLoc = o.getUniformLocationNoThrow(i, "maxVal")), o.gl.uniform1f(r.minLoc, e), o.gl.uniform1f(r.maxLoc, t);
    };
  }, n;
}(), e4 = function(n) {
  this.variableNames = ["real", "imag"], this.outputShape = n, this.userCode = `
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `;
}, t4 = function(n) {
  this.outputShape = [], this.outputShape = di(n, 1), this.variableNames = n.map(function(s, u) {
    return "T" + u;
  });
  var e = new Array(n.length - 1);
  e[0] = n[0][1];
  for (var t = 1; t < e.length; t++) e[t] = e[t - 1] + n[t][1];
  var r = ["if (yC < " + e[0] + ") setOutput(getT0(yR, yC));"];
  for (t = 1; t < e.length; t++) {
    var o = e[t - 1];
    r.push("else if (yC < " + e[t] + ") setOutput(getT" + t + "(yR, yC-" + o + "));");
  }
  var i = e.length, a = e[e.length - 1];
  r.push("else setOutput(getT" + i + "(yR, yC-" + a + "));"), this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ` + r.join(`
        `) + `
      }
    `;
}, n4 = function(n, e) {
  this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [], this.outputShape = di(n, e);
  var t = this.outputShape, r = t.length, o = Ue(r), i = Gt("coords", r), a = ["x", "y", "z", "w", "u", "v"].slice(0, r);
  this.variableNames = n.map(function(y, x) {
    return "T" + x;
  });
  var s = new Array(n.length - 1);
  s[0] = n[0][e];
  for (var u = 1; u < s.length; u++) s[u] = s[u - 1] + n[u][e];
  var l = a[e], c = a.slice(-2), f = a.join(), d = "if (" + l + " < " + s[0] + `) {
        return getChannel(
            getT0(` + f + "), vec2(" + c.join() + `));
        }`;
  for (u = 1; u < s.length; u++) {
    var p = s[u - 1];
    d += `
        if (` + l + " < " + s[u] + "  && " + l + " >= " + s[u - 1] + `) {
          return getChannel(
            getT` + u + "(" + Sa(a, l, p) + `),
            vec2(` + Sa(c, l, p) + `));
        }`;
  }
  var v = s.length, g = s[s.length - 1];
  d += `
        return getChannel(
          getT` + v + "(" + Sa(a, l, g) + `),
          vec2(` + Sa(c, l, g) + "));", this.userCode = `
      float getValue(` + a.map(function(y) {
    return "int " + y;
  }) + `) {
        ` + d + `
      }

      void main() {
        ` + o + ` coords = getOutputCoords();
        vec4 result = vec4(getValue(` + i + `), 0., 0., 0.);

        ` + i[r - 1] + " = " + i[r - 1] + ` + 1;
        if (` + i[r - 1] + " < " + t[r - 1] + `) {
          result.g = getValue(` + i + `);
        }

        ` + i[r - 2] + " = " + i[r - 2] + ` + 1;
        if (` + i[r - 2] + " < " + t[r - 2] + `) {
          result.a = getValue(` + i + `);
        }

        ` + i[r - 1] + " = " + i[r - 1] + ` - 1;
        if (` + i[r - 2] + " < " + t[r - 2] + ` &&
            ` + i[r - 1] + " < " + t[r - 1] + `) {
          result.b = getValue(` + i + `);
        }
        setOutput(result);
      }
    `;
};
function Sa(n, e, t) {
  var r = n.indexOf(e);
  return n.map(function(o, i) {
    return i === r ? o + " - " + t : o;
  }).join();
}
var r4 = function(n) {
  this.variableNames = ["x", "dy"], this.outputShape = n.filterShape;
  var e = n.strideHeight, t = n.strideWidth, r = n.padInfo.top, o = n.padInfo.left, i = n.dataFormat === "channelsLast";
  this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ` + n.batchSize + `; b++) {
          for (int yR = 0; yR < ` + n.outHeight + `; yR++) {
            int xR = wR + yR * ` + e + " - " + r + `;

            if (xR < 0 || xR >= ` + n.inHeight + `) {
              continue;
            }

            for (int yC = 0; yC < ` + n.outWidth + `; yC++) {
              int xC = wC + yC * ` + t + " - " + o + `;

              if (xC < 0 || xC >= ` + n.inWidth + `) {
                continue;
              }

              if (` + i + `) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `;
}, o4 = function(n) {
  this.variableNames = ["dy", "W"], this.outputShape = n.inShape;
  var e = n.filterHeight, t = n.filterWidth, r = n.strideHeight, o = n.strideWidth, i = n.dataFormat === "channelsLast", a = e - 1 - n.padInfo.top, s = t - 1 - n.padInfo.left, u = i ? 1 : 2, l = i ? 2 : 3, c = i ? 3 : 1;
  this.userCode = `
      const ivec2 pads = ivec2(` + a + ", " + s + `);

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[` + c + `];

        ivec2 dyCorner = ivec2(coords[` + u + "], coords[" + l + `]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ` + e + `; wR++) {
          float dyR = float(dyRCorner + wR) / ` + r + `.0;

          if (dyR < 0.0 || dyR >= ` + n.outHeight + `.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ` + e + ` - 1 - wR;

          for (int wC = 0; wC < ` + t + `; wC++) {
            float dyC = float(dyCCorner + wC) / ` + o + `.0;

            if (dyC < 0.0 || dyC >= ` + n.outWidth + `.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ` + t + ` - 1 - wC;

            for (int d2 = 0; d2 < ` + n.outChannels + `; d2++) {

              if (` + i + `) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `;
}, i4 = function(n) {
  this.variableNames = ["x", "dy"], this.outputShape = n.filterShape;
  var e = n.strideDepth, t = n.strideHeight, r = n.strideWidth, o = n.padInfo.front, i = n.padInfo.top, a = n.padInfo.left;
  this.userCode = `
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ` + n.batchSize + `; b++) {
          for (int yF = 0; yF < ` + n.outDepth + `; yF++) {
            int xF = wF + yF * ` + e + " - " + o + `;

            if (xF < 0 || xF >= ` + n.inDepth + `) {
              continue;
            }

            for (int yR = 0; yR < ` + n.outHeight + `; yR++) {
              int xR = wR + yR * ` + t + " - " + i + `;

              if (xR < 0 || xR >= ` + n.inHeight + `) {
                continue;
              }

              for (int yC = 0; yC < ` + n.outWidth + `; yC++) {
                int xC = wC + yC * ` + r + " - " + a + `;

                if (xC < 0 || xC >= ` + n.inWidth + `) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
}, a4 = function(n) {
  this.variableNames = ["dy", "W"], this.outputShape = n.inShape;
  var e = n.filterDepth, t = n.filterHeight, r = n.filterWidth, o = n.strideDepth, i = n.strideHeight, a = n.strideWidth, s = e - 1 - n.padInfo.front, u = t - 1 - n.padInfo.top, l = r - 1 - n.padInfo.left;
  this.userCode = `
      const ivec3 pads = ivec3(` + s + ", " + u + ", " + l + `);

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ` + e + `; wF++) {
          float dyF = float(dyFCorner + wF) / ` + o + `.0;

          if (dyF < 0.0 || dyF >= ` + n.outDepth + `.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ` + e + ` - 1 - wF;

          for (int wR = 0; wR < ` + t + `; wR++) {
            float dyR = float(dyRCorner + wR) / ` + i + `.0;

            if (dyR < 0.0 || dyR >= ` + n.outHeight + `.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ` + t + ` - 1 - wR;

            for (int wC = 0; wC < ` + r + `; wC++) {
              float dyC = float(dyCCorner + wC) / ` + a + `.0;

              if (dyC < 0.0 || dyC >= ` + n.outWidth + `.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ` + r + ` - 1 - wC;

              for (int d2 = 0; d2 < ` + n.outChannels + `; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
}, s4 = function(n) {
  this.variableNames = ["x", "dy"], this.outputShape = n.filterShape;
  var e = n.strideHeight, t = n.strideWidth, r = n.padInfo.top, o = n.padInfo.left, i = n.outChannels / n.inChannels;
  this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ` + i + ` + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ` + n.batchSize + `; b++) {
          for (int yR = 0; yR < ` + n.outHeight + `; yR++) {
            int xR = wR + yR * ` + e + " - " + r + `;

            if (xR < 0 || xR >= ` + n.inHeight + `) {
              continue;
            }

            for (int yC = 0; yC < ` + n.outWidth + `; yC++) {
              int xC = wC + yC * ` + t + " - " + o + `;

              if (xC < 0 || xC >= ` + n.inWidth + `) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `;
}, u4 = function(n) {
  this.variableNames = ["dy", "W"], this.outputShape = n.inShape;
  var e = n.filterHeight, t = n.filterWidth, r = n.strideHeight, o = n.strideWidth, i = e - 1 - n.padInfo.top, a = t - 1 - n.padInfo.left, s = n.outChannels / n.inChannels;
  this.userCode = `
      const ivec2 pads = ivec2(` + i + ", " + a + `);

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ` + e + `; wR++) {
          float dyR = float(dyRCorner + wR) / ` + r + `.0;

          if (dyR < 0.0 || dyR >= ` + n.outHeight + `.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ` + e + ` - 1 - wR;

          for (int wC = 0; wC < ` + t + `; wC++) {
            float dyC = float(dyCCorner + wC) / ` + o + `.0;

            if (dyC < 0.0 || dyC >= ` + n.outWidth + `.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ` + t + ` - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ` + s + `; dm++) {
              int d2 = d1 * ` + s + ` + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
}, cm = function(n, e, t, r) {
  e === void 0 && (e = !1), t === void 0 && (t = null), r === void 0 && (r = !1), this.variableNames = ["x", "W"], this.outputShape = n.outShape;
  var o = n.padInfo.top, i = n.padInfo.left, a = n.strideHeight, s = n.strideWidth, u = n.dilationHeight, l = n.dilationWidth, c = n.filterHeight, f = n.filterWidth, d = 4 * Math.floor(n.inChannels / 4), p = n.inChannels % 4, v = n.dataFormat === "channelsLast", g = v ? 1 : 2, y = v ? 2 : 3, x = v ? 3 : 1, w = "", b = "";
  t && (w = r ? `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ` + t + `
        }` : `
          float activation(float x) {
            ` + t + `
          }
        `, b = "result = activation(result);");
  var _ = e ? "result += getBiasAtOutCoords();" : "";
  e && this.variableNames.push("bias"), r && this.variableNames.push("preluActivationWeights"), this.userCode = `
      ` + w + `

      const ivec2 strides = ivec2(` + a + ", " + s + `);
      const ivec2 pads = ivec2(` + o + ", " + i + `);

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[` + x + `];

        ivec2 xRCCorner =
            ivec2(coords[` + g + "], coords[" + y + `]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ` + c + `; wR++) {
          int xR = xRCorner + wR * ` + u + `;

          if (xR < 0 || xR >= ` + n.inHeight + `) {
            continue;
          }

          for (int wC = 0; wC < ` + f + `; wC++) {
            int xC = xCCorner + wC * ` + l + `;

            if (xC < 0 || xC >= ` + n.inWidth + `) {
              continue;
            }

            for (int d1 = 0; d1 < ` + d + `; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (` + v + `) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (` + (p === 1) + `) {

              if (` + v + `) {
                dotProd +=
                    getX(batch, xR, xC, ` + d + `) *
                    getW(wR, wC, ` + d + `, d2);
              } else {
                dotProd +=
                    getX(batch, ` + d + `, xR, xC) *
                    getW(wR, wC, ` + d + `, d2);
              }

            } else if (` + (p === 2) + `) {
              vec2 wValues = vec2(
                getW(wR, wC, ` + d + `, d2),
                getW(wR, wC, ` + d + ` + 1, d2)
              );

              if (` + v + `) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ` + d + `),
                  getX(batch, xR, xC, ` + d + ` + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ` + d + `, xR, xC),
                  getX(batch, ` + d + ` + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (` + (p === 3) + `) {
              vec3 wValues = vec3(
                getW(wR, wC, ` + d + `, d2),
                getW(wR, wC, ` + d + ` + 1, d2),
                getW(wR, wC, ` + d + ` + 2, d2)
              );

              if (` + v + `) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ` + d + `),
                  getX(batch, xR, xC, ` + d + ` + 1),
                  getX(batch, xR, xC, ` + d + ` + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ` + d + `, xR, xC),
                  getX(batch, ` + d + ` + 1, xR, xC),
                  getX(batch, ` + d + ` + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ` + _ + `
        ` + b + `
        setOutput(result);
      }
    `;
}, l4 = function(n) {
  this.variableNames = ["x", "W"], this.outputShape = n.outShape;
  var e = n.padInfo.front, t = n.padInfo.top, r = n.padInfo.left, o = n.strideDepth, i = n.strideHeight, a = n.strideWidth, s = n.dilationDepth, u = n.dilationHeight, l = n.dilationWidth, c = n.filterDepth, f = n.filterHeight, d = n.filterWidth, p = 4 * Math.floor(n.inChannels / 4), v = n.inChannels % 4;
  this.userCode = `
      const ivec3 strides = ivec3(` + o + ", " + i + ", " + a + `);
      const ivec3 pads = ivec3(` + e + ", " + t + ", " + r + `);

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ` + c + `; wF++) {
          int xF = xFCorner + wF * ` + s + `;

          if (xF < 0 || xF >= ` + n.inDepth + `) {
            continue;
          }

          for (int wR = 0; wR < ` + f + `; wR++) {
            int xR = xRCorner + wR * ` + u + `;

            if (xR < 0 || xR >= ` + n.inHeight + `) {
              continue;
            }

            for (int wC = 0; wC < ` + d + `; wC++) {
              int xC = xCCorner + wC * ` + l + `;

              if (xC < 0 || xC >= ` + n.inWidth + `) {
                continue;
              }

              for (int d1 = 0; d1 < ` + p + `; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (` + (v === 1) + `) {
                dotProd +=
                  getX(batch, xF, xR, xC, ` + p + `) *
                  getW(wF, wR, wC, ` + p + `, d2);
              } else if (` + (v === 2) + `) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ` + p + `),
                  getX(batch, xF, xR, xC, ` + p + ` + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ` + p + `, d2),
                  getW(wF, wR, wC, ` + p + ` + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (` + (v === 3) + `) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ` + p + `),
                  getX(batch, xF, xR, xC, ` + p + ` + 1),
                  getX(batch, xF, xR, xC, ` + p + ` + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ` + p + `, d2),
                  getW(wF, wR, wC, ` + p + ` + 1, d2),
                  getW(wF, wR, wC, ` + p + ` + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
}, fm = function(n, e, t, r) {
  e === void 0 && (e = !1), t === void 0 && (t = null), r === void 0 && (r = !1), this.variableNames = ["x", "W"], this.outputShape = n.outShape;
  var o = n.inHeight, i = n.inWidth, a = n.padInfo.top, s = n.padInfo.left, u = n.strideHeight, l = n.strideWidth, c = n.dilationHeight, f = n.dilationWidth, d = n.filterHeight, p = n.filterWidth, v = n.outChannels / n.inChannels, g = "", y = "";
  t && (g = r ? `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ` + t + `
        }` : `
          float activation(float x) {
            ` + t + `
          }
        `, y = "result = activation(result);");
  var x = e ? "result += getBiasAtOutCoords();" : "";
  e && this.variableNames.push("bias"), r && this.variableNames.push("preluActivationWeights"), this.userCode = `
      ` + g + `

      const ivec2 strides = ivec2(` + u + ", " + l + `);
      const ivec2 pads = ivec2(` + a + ", " + s + `);

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ` + v + `;
        int q = d2 - d1 * ` + v + `;

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ` + d + `; wR++) {
          int xR = xRCorner + wR * ` + c + `;

          if (xR < 0 || xR >= ` + o + `) {
            continue;
          }

          for (int wC = 0; wC < ` + p + `; wC++) {
            int xC = xCCorner + wC * ` + f + `;

            if (xC < 0 || xC >= ` + i + `) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ` + x + `
        ` + y + `
        setOutput(result);
      }
    `;
}, dm = function(n, e, t, r) {
  e === void 0 && (e = !1), t === void 0 && (t = null), r === void 0 && (r = !1), this.variableNames = ["x", "W"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = n.outShape;
  for (var o = n.inHeight, i = n.inWidth, a = n.padInfo.top, s = n.padInfo.left, u = n.strideHeight, l = n.strideWidth, c = n.dilationHeight, f = n.dilationWidth, d = n.filterHeight, p = n.filterWidth, v = p, g = "int xR; int xC; int xCOffset;", y = 0; y < d; y++) for (var x = 0; x < p; x++) g += `
          vec4 xTexelR` + y + "C" + 2 * x + ` = vec4(0.);
          vec4 wR` + y + "C" + x + ` = vec4(0.);
          vec4 xR` + y + "C" + x + " = vec4(0.);";
  for (y = 0; y < d; y++) for (var w = 0; w < v; w++) {
    if (g += `
          xR = xRCorner + ` + y * c + `;
          xC = xCCorner + ` + (x = 2 * w) * f + `;
        `, l === 1) {
      if (x < p && (g += s % 2 == 1 ? `
                xCOffset = xC + 1;
                if(xR >= 0 && xR < ` + o + " && xCOffset >= 0 && xCOffset < " + i + `) {
                  xTexelR` + y + "C" + x + ` = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if(xCOffset + 1 >= ` + i + `) {
                    xTexelR` + y + "C" + x + `.zw = vec2(0.);
                  }
                } else {
                  xTexelR` + y + "C" + x + ` = vec4(0.);
                }

                xCOffset = xC + 1 - 2;
                if(xR >= 0 && xR < ` + o + " && xCOffset >= 0 && xCOffset < " + i + `) {
                  vec4 previous = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if(xCOffset + 1 >= ` + i + `) {
                    previous.zw = vec2(0.);
                  }

                  xR` + y + "C" + x + " = vec4(previous.zw, xTexelR" + y + "C" + x + `.xy);
                } else {
                  xR` + y + "C" + x + " = vec4(0, 0, xTexelR" + y + "C" + x + `.xy);
                }
              ` : `
                if(xR >= 0 && xR < ` + o + " && xC >= 0 && xC < " + i + `) {
                  xTexelR` + y + "C" + x + ` = getX(batch, xR, xC, d1);
                } else {
                  xTexelR` + y + "C" + x + ` = vec4(0.);
                }

                xR` + y + "C" + x + " = xTexelR" + y + "C" + x + `;
              `, x + 1 < p)) {
        var b = s % 2 == 0 ? w1(f) : f;
        f % 2 == 0 && s % 2 == 1 || f % 2 != 0 && s % 2 != 1 ? (g += `
                  xCOffset = xC + ` + s % 2 + " + " + b + `;

                  if(xR >= 0 && xR < ` + o + ` &&
                    xCOffset >= 0 && xCOffset < ` + i + `) {
                    xTexelR` + y + "C" + (x + 2) + ` = getX(batch, xR, xCOffset, d1);
                  }
                `, f > 1 && (g += `
                    xCOffset -= 2;
                    if(xR >= 0 && xR < ` + o + ` &&
                      xCOffset >= 0 && xCOffset < ` + i + `) {
                      xTexelR` + y + "C" + x + ` = getX(batch, xR, xCOffset, d1);
                    } else {
                      xTexelR` + y + "C" + x + ` = vec4(0.);
                    }
                  `), g += `
                  xR` + y + "C" + (x + 1) + ` = vec4(
                    xTexelR` + y + "C" + x + ".zw, xTexelR" + y + "C" + (x + 2) + `.xy);
                `) : g += `
                  xCOffset = xC + ` + b + `;

                  if(xR >= 0 && xR < ` + o + ` &&
                    xCOffset >= 0 && xCOffset < ` + i + `) {
                    xTexelR` + y + "C" + (x + 2) + ` = getX(batch, xR, xCOffset, d1);
                  }

                  xR` + y + "C" + (x + 1) + " = xTexelR" + y + "C" + (x + 2) + `;
                `;
      }
    } else x < p && (g += `
              if(xR >= 0 && xR < ` + o + `) {
            `, s % 2 == 1 ? (g += `
                xCOffset = xC + 1 - ` + l + `;
                if(xCOffset >= 0 && xCOffset < ` + i + `) {
                  xTexelR` + y + "C" + x + ` = getX(batch, xR, xCOffset, d1);
                } else {
                  xTexelR` + y + "C" + x + ` = vec4(0.);
                }

                if(xC + 1 >= 0 && xC + 1 < ` + i + `) {
                  xTexelR` + y + "C" + (x + 2) + ` = getX(batch, xR, xC + 1, d1);
                } else {
                  xTexelR` + y + "C" + (x + 2) + ` = vec4(0.);
                }

                xR` + y + "C" + x + ` = vec4(
                  xTexelR` + y + "C" + x + ".zw, xTexelR" + y + "C" + (x + 2) + `.zw);
              `, x + 1 < p && (g += `
                  vec4 final = vec4(0.);
                  xCOffset = xC + 1 + ` + l + `;
                  if(xCOffset >= 0 && xCOffset < ` + i + `) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xR` + y + "C" + (x + 1) + " = vec4(xTexelR" + y + "C" + (x + 2) + `.xy, final.xy);
                `)) : (g += `
                if(xC >= 0 && xC < ` + i + `) {
                  xTexelR` + y + "C" + x + ` = getX(batch, xR, xC, d1);
                } else {
                  xTexelR` + y + "C" + x + ` = vec4(0.);
                }

                xCOffset = xC + ` + l + `;
                if(xCOffset >= 0 && xCOffset < ` + i + `) {
                  xTexelR` + y + "C" + (x + 2) + ` = getX(batch, xR, xCOffset, d1);
                } else {
                  xTexelR` + y + "C" + (x + 2) + ` = vec4(0.);
                }

                xR` + y + "C" + x + ` = vec4(
                  xTexelR` + y + "C" + x + ".xy, xTexelR" + y + "C" + (x + 2) + `.xy);
              `, x + 1 < p && (g += `
                  xR` + y + "C" + (x + 1) + ` = vec4(
                    xTexelR` + y + "C" + x + ".zw, xTexelR" + y + "C" + (x + 2) + `.zw);
                `)), g += "}");
    x < p && (g += `
            vec4 wTexelR` + y + "C" + x + " = getW(" + y + ", " + x + `, d1, q);
            wR` + y + "C" + x + " = vec4(wTexelR" + y + "C" + x + ".xz, wTexelR" + y + "C" + x + `.xz);
          `, x + 1 < p && (g += `
              vec4 wTexelR` + y + "C" + (x + 1) + " = getW(" + y + ", " + (x + 1) + `, d1, q);
              wR` + y + "C" + (x + 1) + ` =
                vec4(wTexelR` + y + "C" + (x + 1) + ".xz, wTexelR" + y + "C" + (x + 1) + ".xz);"));
  }
  for (y = 0; y < d; y++) for (x = 0; x < p; x++) g += "dotProd += xR" + y + "C" + x + " * wR" + y + "C" + x + ";";
  var _ = "", E = "";
  t && (_ = r ? `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ` + t + `
        }` : `vec4 activation(vec4 x) {
          ` + t + `
        }`, E = "result = activation(result);");
  var C = e ? "result += getBiasAtOutCoords();" : "";
  e && this.variableNames.push("bias"), r && this.variableNames.push("preluActivationWeights"), this.userCode = `
      ` + _ + `

      const ivec2 strides = ivec2(` + u + ", " + l + `);
      const ivec2 pads = ivec2(` + a + ", " + s + `);

      void main() {

        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2;
        int q = 0;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        vec4 dotProd = vec4(0.);

        ` + g + `

        vec4 result = dotProd;
        ` + C + `
        ` + E + `
        setOutput(result);
      }
    `;
}, c4 = function(n, e, t, r, o) {
  this.variableNames = ["Image", "Boxes", "BoxInd"], this.outputShape = [];
  var i = n[0], a = n[1], s = n[2], u = n[3], l = e[0], c = t[0], f = t[1];
  this.outputShape = [l, c, f, u];
  var d = r === "bilinear" ? 1 : 0, p = [a - 1 + ".0", s - 1 + ".0"], v = p[0], g = p[1], y = c > 1 ? ["" + (a - 1) / (c - 1), "(y2-y1) * height_ratio", "y1*" + v + " + float(y)*(height_scale)"] : ["0.0", "0.0", "0.5 * (y1+y2) * " + v], x = y[0], w = y[1], b = y[2], _ = f > 1 ? ["" + (s - 1) / (f - 1), "(x2-x1) * width_ratio", "x1*" + g + " + float(x)*(width_scale)"] : ["0.0", "0.0", "0.5 * (x1+x2) * " + g], E = _[0], C = _[1], A = _[2];
  this.userCode = `
      const float height_ratio = float(` + x + `);
      const float width_ratio = float(` + E + `);
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ` + i + `) {
          return;
        }

        float height_scale = ` + w + `;
        float width_scale = ` + C + `;

        float in_y = ` + b + `;
        if( in_y < 0.0 || in_y > ` + v + ` ) {
          setOutput(float(` + o + `));
          return;
        }
        float in_x = ` + A + `;
        if( in_x < 0.0 || in_x > ` + g + ` ) {
          setOutput(float(` + o + `));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(` + d + ` == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `;
}, f4 = function(n, e, t) {
  this.variableNames = ["x"], this.outputShape = n;
  var r = n.length, o = n[n.length - 1], i = t ? "<" : ">";
  this.userCode = `
      int getIndex(int i) {
        ` + (t ? "return " + o + " -i - 1;" : "return i;") + `
      }

      void main() {
        ` + Ue(r) + ` coords = getOutputCoords();
        int end = ` + hm(r, "coords") + `;
        float val = 0.0;
        for (int i = ` + o + ` - 1; i >= 0; i -= 1) {
          int idx = getIndex(i);
          if (idx ` + i + ` end) {
            continue;
          }
          if (idx == end && ` + e + `) {
            continue;
          }
          ` + hm(r, "coords") + ` = idx;
          val += getX(` + function(a, s) {
    if (a === 1) return "" + s;
    if (a === 2) return s + ".x, " + s + ".y";
    if (a === 3) return s + ".x, " + s + ".y, " + s + ".z";
    if (a === 4) return s + ".x, " + s + ".y, " + s + ".z, " + s + ".w";
    throw Error("Cumulative sum for rank " + a + " is not yet supported");
  }(r, "coords") + `);
        }
        setOutput(val);
      }
    `;
};
function hm(n, e) {
  if (n === 1) return "" + e;
  if (n === 2) return e + ".y";
  if (n === 3) return e + ".z";
  if (n === 4) return e + ".w";
  throw Error("Cumulative sum for rank " + n + " is not yet supported");
}
var d4 = function(n) {
  this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outPackingScheme = ji.DENSE;
  var e = Gi(n), t = Rt();
  this.outputShape = n, this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ` + ao(["r", "c", "d"], n) + `
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx *
          vec2(` + e[0] + ", " + e[1] + `));
        int index = 4 * (resTexRC.x * ` + e[1] + ` + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ` + t.output + ` = result;
      }
    `;
}, h4 = function(n) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outPackingScheme = ji.DENSE;
  var e = Gi(n), t = Rt();
  this.outputShape = n, this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ` + ao(["r", "c", "d"], n) + `
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx *
          vec2(` + e[0] + ", " + e[1] + `));
        int index = 4 * (resTexRC.x * ` + e[1] + ` + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ` + t.output + ` = result;
      }
    `;
}, p4 = function() {
  function n(e, t, r) {
    this.variableNames = ["x"], this.outputShape = [], this.outputShape = e, this.blockSize = t, this.dataFormat = r, this.userCode = `
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ` + this.getHeightCoordString() + `;
      int w = ` + this.getWidthCoordString() + `;
      int d = ` + this.getDepthCoordString() + `;

      int in_h = h / ` + t + `;
      int offset_h = imod(h, ` + t + `);
      int in_w = w / ` + t + `;
      int offset_w = imod(w, ` + t + `);
      int offset_d = (offset_h * ` + t + ` + offset_w) *
        ` + this.getOutputDepthSize() + `;
      int in_d = d + offset_d;

      float result = ` + this.getInputSamplingString() + `;
      setOutput(result);
    }
  `;
  }
  return n.prototype.getHeightCoordString = function() {
    return this.dataFormat === "NHWC" ? "coords[1]" : "coords[2]";
  }, n.prototype.getWidthCoordString = function() {
    return this.dataFormat === "NHWC" ? "coords[2]" : "coords[3]";
  }, n.prototype.getDepthCoordString = function() {
    return this.dataFormat === "NHWC" ? "coords[3]" : "coords[1]";
  }, n.prototype.getOutputDepthSize = function() {
    return this.dataFormat === "NHWC" ? this.outputShape[3] : this.outputShape[1];
  }, n.prototype.getInputSamplingString = function() {
    return this.dataFormat === "NHWC" ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
  }, n;
}(), m4 = function(n) {
  this.variableNames = ["X"], this.outputShape = [n, n], this.userCode = `
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `;
}, v4 = function(n) {
  this.variableNames = ["A"], this.outTexUsage = en.DOWNLOAD;
  var e = Rt();
  this.outputShape = n, this.userCode = `
      ` + j1 + `

      void main() {
        float x = getAAtOutCoords();
        ` + e.output + ` = encode_float(x);
      }
    `;
}, g4 = function(n) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outTexUsage = en.DOWNLOAD;
  var e = Rt();
  this.outputShape = n, this.userCode = `
      ` + j1 + `

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ` + e.output + ` = encode_float(x);
      }
    `;
}, y4 = function(n, e, t) {
  t === void 0 && (t = !1), this.variableNames = ["A"];
  var r = Rt(), o = e[0], i = e[1];
  this.outputShape = n;
  var a = "result";
  t && (a = "floor(result * 255. + 0.5)"), this.userCode = `
      ` + Af(n) + `

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);
        
        int r = flatIndex / ` + i + `;
        int c = imod(flatIndex, ` + i + `);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(` + i + ".0, " + o + `.0);
        vec4 values = ` + r.texture2D + `(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ` + r.output + " = vec4(" + a + `, 0., 0., 0.);
      }
    `;
}, x4 = function(n, e, t) {
  t === void 0 && (t = !1), this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0;
  var r = Rt(), o = e[0], i = e[1];
  this.outputShape = n;
  var a = "", s = "result";
  t && (s = "floor(result * 255. + 0.5)");
  for (var u = 0; u <= 1; u++) for (var l = 0; l <= 1; l++) {
    var c = 2 * u + l;
    a += `
          localCoords = coords;
          if(localCoords[2] + ` + l + " < " + n[2] + `) {
            localCoords[2] += ` + l + `;
            if(localCoords[1] + ` + u + " < " + n[1] + `) {
              localCoords[1] += ` + u + `;

              flatIndex = getFlatIndex(localCoords);
              offset = imod(flatIndex, 4);

              flatIndex = idiv(flatIndex, 4, 1.);

              r = flatIndex / ` + i + `;
              c = imod(flatIndex, ` + i + `);
              uv = (vec2(c, r) + halfCR) / vec2(` + i + ".0, " + o + `.0);
              values = ` + r.texture2D + `(A, uv);

              if(offset == 0) {
                result[` + c + `] = values[0];
              } else if(offset == 1) {
                result[` + c + `] = values[1];
              } else if(offset == 2) {
                result[` + c + `] = values[2];
              } else {
                result[` + c + `] = values[3];
              }
            }
          }
        `;
  }
  this.userCode = `
      ` + Af(n) + `

      void main() {
        ivec3 coords = getOutputCoords();

        vec4 result = vec4(0.);
        int flatIndex, r, c, offset;
        ivec3 localCoords;
        vec2 uv;
        vec4 values;

        ` + a + `

        ` + r.output + " = " + s + `;
      }
    `;
}, w4 = "return real * expR - imag * expI;", _4 = "return real * expI + imag * expR;", pm = function(n, e, t) {
  this.variableNames = ["real", "imag"];
  var r = e[1];
  this.outputShape = e;
  var o = t ? "2.0 * " + Math.PI : "-2.0 * " + Math.PI, i = t ? r + ".0" : "1.0";
  this.userCode = `
      const float exponentMultiplier = ` + o + `;

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ` + n + `
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(` + r + `);
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ` + r + `; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ` + i + `;
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `;
}, b4 = function() {
  function n(e, t) {
    this.outputShape = [], this.variableNames = ["x"], this.outputShape = e, this.userCode = `
      uniform float value;
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `;
  }
  return n.prototype.getCustomSetupFunc = function(e) {
    var t = this;
    return function(r, o) {
      t.valueLoc == null && (t.valueLoc = r.getUniformLocationNoThrow(o, "value")), r.gl.uniform1f(t.valueLoc, e);
    };
  }, n;
}(), E4 = function(n, e, t) {
  this.variableNames = ["A", "indices"];
  var r = n.slice();
  r[t] = e, this.outputShape = r, this.rank = r.length;
  var o = Ue(this.rank), i = function(a, s) {
    var u = a.length;
    if (u > 4) throw Error("Gather for rank " + u + " is not yet supported");
    if (u === 1) return "int(getIndices(resRC))";
    for (var l = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], c = [], f = 0; f < a.length; f++) f === s ? c.push("int(getIndices(" + l[f] + "))") : c.push("" + l[f]);
    return c.join();
  }(n, t);
  this.userCode = `
      void main() {
        ` + o + ` resRC = getOutputCoords();
        setOutput(getA(` + i + `));
      }
    `;
}, C4 = function(n, e, t) {
  this.sliceDim = n, this.strides = e, this.variableNames = ["x", "indices"], this.outputShape = t;
  var r = Ue(e.length), o = Ue(t.length), i = this.sliceDim > 1 ? "strides[j]" : "strides";
  this.userCode = `
        ` + r + " strides = " + r + "(" + this.strides + `);
         void main() {
          ` + o + ` coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < ` + this.sliceDim + `; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * ` + i + `;
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `;
};
function T4(n, e) {
  var t = Rt();
  return w3(n, e, t.version + `
    precision highp float;
    ` + t.attribute + ` vec3 clipSpacePos;
    ` + t.attribute + ` vec2 uv;
    ` + t.varyingVs + ` vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`);
}
function I4(n, e) {
  return T3(n, e, new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]));
}
function S4(n, e) {
  return I3(n, e, new Uint16Array([0, 1, 2, 2, 1, 3]));
}
function fa(n, e, t, r, o, i, a) {
  A3(t, r);
  var s = S3(n, e), u = n.TEXTURE_2D;
  return ne(n, e, function() {
    return n.bindTexture(u, s);
  }), ne(n, e, function() {
    return n.texParameteri(u, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE);
  }), ne(n, e, function() {
    return n.texParameteri(u, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE);
  }), ne(n, e, function() {
    return n.texParameteri(u, n.TEXTURE_MIN_FILTER, n.NEAREST);
  }), ne(n, e, function() {
    return n.texParameteri(u, n.TEXTURE_MAG_FILTER, n.NEAREST);
  }), ne(n, e, function() {
    return n.texImage2D(u, 0, o, t, r, 0, i, a, null);
  }), ne(n, e, function() {
    return n.bindTexture(n.TEXTURE_2D, null);
  }), s;
}
function A4(n, e, t, r, o) {
  var i = nu(t, r);
  return fa(n, e, i[0], i[1], o.internalFormatFloat, o.textureFormatFloat, n.FLOAT);
}
function R4(n, e, t, r, o) {
  var i = nu(t, r);
  return fa(n, e, i[0], i[1], o.internalFormatHalfFloat, o.textureFormatFloat, o.textureTypeHalfFloat);
}
function k4(n, e, t, r, o) {
  var i = nu(t, r);
  return fa(n, e, i[0], i[1], n.RGBA, n.RGBA, n.UNSIGNED_BYTE);
}
function P4(n, e, t, r, o) {
  var i = ca(t, r);
  return fa(n, e, i[0], i[1], o.internalFormatPackedFloat, n.RGBA, n.FLOAT);
}
function N4(n, e, t, r, o) {
  var i = ca(t, r);
  return fa(n, e, i[0], i[1], o.internalFormatPackedHalfFloat, n.RGBA, o.textureTypeHalfFloat);
}
function M4(n, e, t, r) {
  return ne(n, e, function() {
    return n.bindBuffer(n.ARRAY_BUFFER, r);
  }), tm(n, e, t, "clipSpacePos", r, 3, 20, 0) && tm(n, e, t, "uv", r, 2, 20, 12);
}
function D4(n, e, t, r, o, i, a) {
  var s, u, l;
  ne(n, e, function() {
    return n.bindTexture(n.TEXTURE_2D, t);
  }), i instanceof Uint8Array ? (s = new Uint8Array(r * o * 4), u = n.UNSIGNED_BYTE, l = n.RGBA) : (s = new Float32Array(r * o * 4), u = n.FLOAT, l = a.internalFormatPackedFloat), s.set(i), ne(n, e, function() {
    return n.texImage2D(n.TEXTURE_2D, 0, l, r, o, 0, n.RGBA, u, s);
  }), ne(n, e, function() {
    return n.bindTexture(n.TEXTURE_2D, null);
  });
}
function F4(n, e, t, r) {
  ne(n, e, function() {
    return n.bindTexture(n.TEXTURE_2D, t);
  }), r.data instanceof Uint8Array ? ne(n, e, function() {
    return n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, r.width, r.height, 0, n.RGBA, n.UNSIGNED_BYTE, r.data);
  }) : ne(n, e, function() {
    return n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, n.RGBA, n.UNSIGNED_BYTE, r);
  }), ne(n, e, function() {
    return n.bindTexture(n.TEXTURE_2D, null);
  });
}
function L4(n, e, t, r, o) {
  var i = n.createBuffer();
  ne(n, e, function() {
    return n.bindBuffer(n.PIXEL_PACK_BUFFER, i);
  });
  var a = 16 * t * r;
  return ne(n, e, function() {
    return n.bufferData(n.PIXEL_PACK_BUFFER, a, n.STREAM_READ);
  }), ne(n, e, function() {
    return n.readPixels(0, 0, r, t, n.RGBA, n.FLOAT, 0);
  }), ne(n, e, function() {
    return n.bindBuffer(n.PIXEL_PACK_BUFFER, null);
  }), i;
}
function B4(n, e, t) {
  var r = n, o = new Float32Array(t);
  return r.bindBuffer(r.PIXEL_PACK_BUFFER, e), r.getBufferSubData(r.PIXEL_PACK_BUFFER, 0, o), r.bindBuffer(r.PIXEL_PACK_BUFFER, null), o;
}
function O4(n, e, t, r, o) {
  var i = nu(t, r), a = i[0], s = i[1], u = new Uint8Array(t * r * 4);
  return ne(n, e, function() {
    return n.readPixels(0, 0, a, s, o.downloadTextureFormat, n.UNSIGNED_BYTE, u);
  }), new Float32Array(u.buffer);
}
function U4(n, e, t, r, o, i, a, s) {
  var u = n, l = new Float32Array(function(c, f) {
    var d = ca(c, f);
    return d[0] * d[1] * 4;
  }(i, a));
  return u.bindBuffer(u.PIXEL_PACK_BUFFER, e), u.getBufferSubData(u.PIXEL_PACK_BUFFER, 0, l), u.bindBuffer(u.PIXEL_PACK_BUFFER, null), l;
}
function V4(n, e, t, r) {
  var o = new Float32Array(t * r * 4);
  return ne(n, e, function() {
    return n.readPixels(0, 0, r, t, n.RGBA, n.FLOAT, o);
  }), o;
}
var G4 = function() {
  function n(e) {
    this.outputTexture = null, this.program = null, this.disposed = !1, this.vertexAttrsAreBound = !1, this.itemsToPoll = [];
    var t = V().getNumber("WEBGL_VERSION");
    e != null ? (this.gl = e, m3(t, e)) : this.gl = jn(t);
    var r = "WEBGL_color_buffer_float";
    if (V().getNumber("WEBGL_VERSION") === 1) {
      if (this.textureFloatExtension = Ea(this.gl, this.debug, "OES_texture_float"), gn(this.gl, "OES_texture_half_float")) this.textureHalfFloatExtension = Ea(this.gl, this.debug, "OES_texture_half_float");
      else if (V().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
      if (this.colorBufferFloatExtension = this.gl.getExtension(r), gn(this.gl, "EXT_color_buffer_half_float")) this.colorBufferHalfFloatExtension = Ea(this.gl, this.debug, "EXT_color_buffer_half_float");
      else if (V().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
    } else if (r = "EXT_color_buffer_float", gn(this.gl, r)) this.colorBufferFloatExtension = this.gl.getExtension(r);
    else {
      if (!gn(this.gl, "EXT_color_buffer_half_float")) throw new Error("GL context does not support color renderable floats");
      this.colorBufferHalfFloatExtension = this.gl.getExtension("EXT_color_buffer_half_float");
    }
    this.vertexBuffer = I4(this.gl, this.debug), this.indexBuffer = S4(this.gl, this.debug), this.framebuffer = R3(this.gl, this.debug), this.textureConfig = yf(this.gl, this.textureHalfFloatExtension);
  }
  return Object.defineProperty(n.prototype, "debug", { get: function() {
    return V().getBool("DEBUG");
  }, enumerable: !0, configurable: !0 }), n.prototype.dispose = function() {
    var e = this;
    if (!this.disposed) {
      this.program != null && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), this.outputTexture != null && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
      var t = this.gl;
      ne(t, this.debug, function() {
        return t.finish();
      }), ne(t, this.debug, function() {
        return t.bindFramebuffer(t.FRAMEBUFFER, null);
      }), ne(t, this.debug, function() {
        return t.deleteFramebuffer(e.framebuffer);
      }), ne(t, this.debug, function() {
        return t.bindBuffer(t.ARRAY_BUFFER, null);
      }), ne(t, this.debug, function() {
        return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, null);
      }), ne(t, this.debug, function() {
        return t.deleteBuffer(e.indexBuffer);
      }), this.disposed = !0;
    }
  }, n.prototype.createFloat32MatrixTexture = function(e, t) {
    return this.throwIfDisposed(), A4(this.gl, this.debug, e, t, this.textureConfig);
  }, n.prototype.createFloat16MatrixTexture = function(e, t) {
    return this.throwIfDisposed(), R4(this.gl, this.debug, e, t, this.textureConfig);
  }, n.prototype.createUnsignedBytesMatrixTexture = function(e, t) {
    return this.throwIfDisposed(), k4(this.gl, this.debug, e, t, this.textureConfig);
  }, n.prototype.uploadPixelDataToTexture = function(e, t) {
    this.throwIfDisposed(), F4(this.gl, this.debug, e, t);
  }, n.prototype.uploadDenseMatrixToTexture = function(e, t, r, o) {
    this.throwIfDisposed(), D4(this.gl, this.debug, e, t, r, o, this.textureConfig);
  }, n.prototype.createFloat16PackedMatrixTexture = function(e, t) {
    return this.throwIfDisposed(), N4(this.gl, this.debug, e, t, this.textureConfig);
  }, n.prototype.createPackedMatrixTexture = function(e, t) {
    return this.throwIfDisposed(), P4(this.gl, this.debug, e, t, this.textureConfig);
  }, n.prototype.deleteMatrixTexture = function(e) {
    var t = this;
    this.throwIfDisposed(), this.outputTexture === e && (nm(this.gl, this.debug, this.framebuffer), this.outputTexture = null), ne(this.gl, this.debug, function() {
      return t.gl.deleteTexture(e);
    });
  }, n.prototype.downloadByteEncodedFloatMatrixFromOutputTexture = function(e, t, r) {
    var o = this;
    return this.downloadMatrixDriver(e, function() {
      return O4(o.gl, o.debug, t, r, o.textureConfig);
    });
  }, n.prototype.downloadPackedMatrixFromBuffer = function(e, t, r, o, i, a) {
    return U4(this.gl, e, 0, 0, 0, i, a, this.textureConfig);
  }, n.prototype.downloadFloat32MatrixFromBuffer = function(e, t) {
    return B4(this.gl, e, t);
  }, n.prototype.createBufferFromTexture = function(e, t, r) {
    this.bindTextureToFrameBuffer(e);
    var o = L4(this.gl, this.debug, t, r, this.textureConfig);
    return this.unbindTextureToFrameBuffer(), o;
  }, n.prototype.createAndWaitForFence = function() {
    var e = this.createFence(this.gl);
    return this.pollFence(e);
  }, n.prototype.createFence = function(e) {
    var t, r, o = this;
    if (V().getBool("WEBGL_FENCE_API_ENABLED")) {
      var i = e, a = i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE, 0);
      e.flush(), r = function() {
        var s = i.clientWaitSync(a, 0, 0);
        return s === i.ALREADY_SIGNALED || s === i.CONDITION_SATISFIED;
      }, t = a;
    } else V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (t = this.beginQuery(), this.endQuery(), r = function() {
      return o.isQueryAvailable(t, V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
    }) : r = function() {
      return !0;
    };
    return { query: t, isFencePassed: r };
  }, n.prototype.downloadMatrixFromPackedTexture = function(e, t, r) {
    var o = this;
    return this.downloadMatrixDriver(e, function() {
      return V4(o.gl, o.debug, t, r);
    });
  }, n.prototype.createProgram = function(e) {
    this.throwIfDisposed();
    var t = this.gl, r = _3(t, this.debug, e), o = T4(t, this.debug), i = E3(t, this.debug);
    return ne(t, this.debug, function() {
      return t.attachShader(i, o);
    }), ne(t, this.debug, function() {
      return t.attachShader(i, r);
    }), C3(t, this.debug, i), this.debug && Hu(t, this.debug, i), this.vertexAttrsAreBound || (this.setProgram(i), this.vertexAttrsAreBound = M4(t, this.debug, this.program, this.vertexBuffer)), i;
  }, n.prototype.deleteProgram = function(e) {
    var t = this;
    this.throwIfDisposed(), e === this.program && (this.program = null), e != null && ne(this.gl, this.debug, function() {
      return t.gl.deleteProgram(e);
    });
  }, n.prototype.setProgram = function(e) {
    var t = this;
    this.throwIfDisposed(), this.program = e, this.program != null && this.debug && Hu(this.gl, this.debug, this.program), ne(this.gl, this.debug, function() {
      return t.gl.useProgram(e);
    });
  }, n.prototype.getUniformLocation = function(e, t, r) {
    return r === void 0 && (r = !0), this.throwIfDisposed(), r ? P3(this.gl, this.debug, e, t) : N3(this.gl, e, t);
  }, n.prototype.getAttributeLocation = function(e, t) {
    var r = this;
    return this.throwIfDisposed(), ne(this.gl, this.debug, function() {
      return r.gl.getAttribLocation(e, t);
    });
  }, n.prototype.getUniformLocationNoThrow = function(e, t) {
    return this.throwIfDisposed(), this.gl.getUniformLocation(e, t);
  }, n.prototype.setInputMatrixTexture = function(e, t, r) {
    this.throwIfDisposed(), this.throwIfNoProgram(), M3(this.gl, this.debug, this.program, e, t, r);
  }, n.prototype.setOutputMatrixTexture = function(e, t, r) {
    this.setOutputMatrixTextureDriver(e, r, t);
  }, n.prototype.setOutputPackedMatrixTexture = function(e, t, r) {
    this.throwIfDisposed();
    var o = ca(t, r), i = o[0], a = o[1];
    this.setOutputMatrixTextureDriver(e, i, a);
  }, n.prototype.setOutputMatrixWriteRegion = function(e, t, r, o) {
    this.setOutputMatrixWriteRegionDriver(r, e, o, t);
  }, n.prototype.setOutputPackedMatrixWriteRegion = function(e, t, r, o) {
    throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
  }, n.prototype.debugValidate = function() {
    this.program != null && Hu(this.gl, this.debug, this.program), Ca(this.gl);
  }, n.prototype.executeProgram = function() {
    this.throwIfDisposed(), this.throwIfNoProgram();
    var e = this.gl;
    this.debug && this.debugValidate(), ne(e, this.debug, function() {
      return e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0);
    });
  }, n.prototype.blockUntilAllProgramsCompleted = function() {
    var e = this;
    this.throwIfDisposed(), ne(this.gl, this.debug, function() {
      return e.gl.finish();
    });
  }, n.prototype.getQueryTimerExtension = function() {
    return this.disjointQueryTimerExtension == null && (this.disjointQueryTimerExtension = Ea(this.gl, this.debug, V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2 ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this.disjointQueryTimerExtension;
  }, n.prototype.getQueryTimerExtensionWebGL2 = function() {
    return this.getQueryTimerExtension();
  }, n.prototype.getQueryTimerExtensionWebGL1 = function() {
    return this.getQueryTimerExtension();
  }, n.prototype.beginQuery = function() {
    if (V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
      var e = this.gl, t = this.getQueryTimerExtensionWebGL2(), r = e.createQuery();
      return e.beginQuery(t.TIME_ELAPSED_EXT, r), r;
    }
    var o = this.getQueryTimerExtensionWebGL1(), i = o.createQueryEXT();
    return o.beginQueryEXT(o.TIME_ELAPSED_EXT, i), i;
  }, n.prototype.endQuery = function() {
    if (V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") !== 2) {
      var e = this.getQueryTimerExtensionWebGL1();
      e.endQueryEXT(e.TIME_ELAPSED_EXT);
    } else {
      var t = this.gl, r = this.getQueryTimerExtensionWebGL2();
      t.endQuery(r.TIME_ELAPSED_EXT);
    }
  }, n.prototype.waitForQueryAndGetTime = function(e) {
    return Z(this, void 0, void 0, function() {
      var t = this;
      return j(this, function(r) {
        switch (r.label) {
          case 0:
            return [4, Xp(function() {
              return t.disposed || t.isQueryAvailable(e, V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
            })];
          case 1:
            return r.sent(), [2, this.getQueryTime(e, V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))];
        }
      });
    });
  }, n.prototype.getQueryTime = function(e, t) {
    if (t === 0) return null;
    if (t === 2) {
      var r = this.gl;
      return r.getQueryParameter(e, r.QUERY_RESULT) / 1e6;
    }
    var o = this.getQueryTimerExtensionWebGL1();
    return o.getQueryObjectEXT(e, o.QUERY_RESULT_EXT) / 1e6;
  }, n.prototype.isQueryAvailable = function(e, t) {
    if (t === 0) return !0;
    if (t === 2) {
      var r = this.gl, o = this.getQueryTimerExtensionWebGL2(), i = r.getQueryParameter(e, r.QUERY_RESULT_AVAILABLE);
      return this.disjoint == null && (this.disjoint = this.gl.getParameter(o.GPU_DISJOINT_EXT)), i && !this.disjoint;
    }
    return i = (o = this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(e, o.QUERY_RESULT_AVAILABLE_EXT), this.disjoint == null && (this.disjoint = this.gl.getParameter(o.GPU_DISJOINT_EXT)), i && !this.disjoint;
  }, n.prototype.pollFence = function(e) {
    var t = this;
    return new Promise(function(r) {
      t.addItemToPoll(function() {
        return e.isFencePassed();
      }, function() {
        return r();
      });
    });
  }, n.prototype.pollItems = function() {
    for (var e = function(r) {
      for (var o = 0; o < r.length && r[o](); ++o)
        ;
      return o - 1;
    }(this.itemsToPoll.map(function(r) {
      return r.isDoneFn;
    })), t = 0; t <= e; ++t)
      (0, this.itemsToPoll[t].resolveFn)();
    this.itemsToPoll = this.itemsToPoll.slice(e + 1);
  }, n.prototype.addItemToPoll = function(e, t) {
    var r = this;
    this.itemsToPoll.push({ isDoneFn: e, resolveFn: t }), this.itemsToPoll.length > 1 || Xp(function() {
      return r.pollItems(), r.itemsToPoll.length === 0;
    });
  }, n.prototype.bindTextureToFrameBuffer = function(e) {
    this.throwIfDisposed(), $u(this.gl, this.debug, e, this.framebuffer), this.debug && Ca(this.gl);
  }, n.prototype.unbindTextureToFrameBuffer = function() {
    this.outputTexture != null ? ($u(this.gl, this.debug, this.outputTexture, this.framebuffer), this.debug && Ca(this.gl)) : nm(this.gl, this.debug, this.framebuffer);
  }, n.prototype.downloadMatrixDriver = function(e, t) {
    this.bindTextureToFrameBuffer(e);
    var r = t();
    return this.unbindTextureToFrameBuffer(), r;
  }, n.prototype.setOutputMatrixTextureDriver = function(e, t, r) {
    this.throwIfDisposed();
    var o = this.gl;
    $u(o, this.debug, e, this.framebuffer), this.debug && Ca(o), this.outputTexture = e, ne(o, this.debug, function() {
      return o.viewport(0, 0, t, r);
    }), ne(o, this.debug, function() {
      return o.scissor(0, 0, t, r);
    });
  }, n.prototype.setOutputMatrixWriteRegionDriver = function(e, t, r, o) {
    var i = this;
    this.throwIfDisposed(), ne(this.gl, this.debug, function() {
      return i.gl.scissor(e, t, r, o);
    });
  }, n.prototype.throwIfDisposed = function() {
    if (this.disposed) throw new Error("Attempted to use disposed GPGPUContext.");
  }, n.prototype.throwIfNoProgram = function() {
    if (this.program == null) throw new Error("No GPU program is currently set.");
  }, n;
}();
function mm(n, e) {
  if (n.length !== e.length) throw Error("Binary was compiled with " + n.length + " inputs, but was executed with " + e.length + " inputs");
  n.forEach(function(t, r) {
    var o = t.logicalShape, i = e[r], a = i.shape;
    if (!_t(o, a)) throw Error("Binary was compiled with different shapes than the current args. Shapes " + o + " and " + a + " must match");
    if (!t.isUniform || !i.isUniform) {
      var s = t.texShape, u = i.isUniform ? null : i.texData.texShape;
      if (!_t(s, u)) throw Error("Binary was compiled with different texture shapes than the current args. Shape " + s + " and " + u + " must match");
    }
  });
}
var W4 = function(n, e, t) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = n;
  for (var r = t.filterWidth, o = t.inChannels, i = t.strideWidth, a = t.strideHeight, s = t.padInfo, u = t.outWidth, l = t.dilationWidth, c = t.dilationHeight, f = t.dataFormat, d = s.left, p = s.top, v = o * r, g = Rt(), y = f === "channelsLast", x = y ? 0 : 1, w = y ? 1 : 2, b = "", _ = 0; _ <= 1; _++) for (var E = 0; E <= 1; E++) b += `
          blockIndex = rc.y + ` + E + `;
          pos = rc.x + ` + _ + `;

          if(blockIndex < ` + n[1] + " && pos < " + n[0] + `) {
            offsetY = int(blockIndex / (` + u + ")) * " + a + " - " + p + `;
            d0 = offsetY + ` + c + " * (pos / " + v + `);

            if(d0 < ` + e[x] + ` && d0 >= 0) {

              offsetX = int(mod(float(blockIndex), ` + u + ".) * " + i + ". - " + d + `.);
              d1 = offsetX + ` + l + " * (int(mod(float(pos), " + v + ".) / " + o + `.));

              if(d1 < ` + e[w] + ` && d1 >= 0) {

                ch = int(mod(float(pos), ` + o + `.));

                if (` + y + `) {
                  innerDims = vec2(d1, ch);
                  result[` + (2 * _ + E) + `] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[` + (2 * _ + E) + `] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;
  this.userCode = `
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ` + b + `

        ` + g.output + ` = result;
      }
    `;
}, H4 = function(n, e, t, r, o) {
  this.variableNames = ["x"], this.outputShape = [];
  var i, a = e, s = n[3] - 1;
  this.outputShape = n;
  var u = "float(" + t + ") + float(" + r + ") * sum";
  i = o === 0.5 ? "inversesqrt(" + u + ")" : o === 1 ? "1.0/(" + u + ")" : "exp(log(" + u + ") * float(-" + o + "));", this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -` + a + "; j <= " + a + `; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ` + s + `) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ` + i + `;
        setOutput(val);
      }
    `;
}, $4 = function(n, e, t, r, o) {
  this.variableNames = ["inputImage", "outputImage", "dy"], this.outputShape = [], this.outputShape = n, this.depth = n[3], this.depthRadius = e, this.bias = t, this.alpha = r, this.beta = o, this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ` + this.depth + `; ++d) {
          int depthBegin = int(max(0.0, float(d - ` + e + `)));
          int depthEnd = int(min(float(` + this.depth + `),
              float(d + ` + e + ` + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ` + this.depth + `;

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(` + r + ") * norm + float(" + t + `);

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(` + r + `)
                * float(` + o + `)
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ` + o + `);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `;
}, q4 = function(n, e, t, r, o) {
  this.variableNames = ["x"], this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0;
  var i, a = e, s = n[3] - 1;
  this.outputShape = n;
  var u = "float(" + t + ") + float(" + r + ") * sum";
  i = o === 0.5 ? "inversesqrt(" + u + ")" : o === 1 ? "1.0/(" + u + ")" : "exp(log(" + u + ") * float(-" + o + "));", this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ` + this.outputShape[3] + `;
        bool hasNextRow = c < ` + this.outputShape[2] + `;

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ` + a + `;
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ` + a + "; j <= " + a + `; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(` + s + `));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ` + i + `;
        setOutput(result);
      }
    `;
}, z4 = function(n) {
  this.variableNames = ["dy", "maxPos"], this.outputShape = n.inShape;
  var e = n.strideHeight, t = n.strideWidth, r = n.dilationHeight, o = n.effectiveFilterHeight, i = n.effectiveFilterWidth, a = o - 1 - n.padInfo.top, s = i - 1 - n.padInfo.left, u = o * i - 1;
  this.userCode = `
      const ivec2 pads = ivec2(` + a + ", " + s + `);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ` + o + `;
          wR += ` + r + `) {
          float dyR = float(dyRCorner + wR) / ` + e + `.0;

          if (dyR < 0.0 || dyR >= ` + n.outHeight + `.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ` + i + `; wC++) {
            float dyC = float(dyCCorner + wC) / ` + t + `.0;

            if (dyC < 0.0 || dyC >= ` + n.outWidth + `.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ` + u + ` - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ` + i + ` + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `;
}, K4 = function(n) {
  this.variableNames = ["dy", "maxPos"], this.outputShape = n.inShape;
  var e = n.strideDepth, t = n.strideHeight, r = n.strideWidth, o = n.dilationDepth, i = n.dilationHeight, a = n.dilationWidth, s = n.effectiveFilterDepth, u = n.effectiveFilterHeight, l = n.effectiveFilterWidth, c = s - 1 - n.padInfo.front, f = u - 1 - n.padInfo.top, d = l - 1 - n.padInfo.left, p = s * u * l - 1;
  this.userCode = `
      const ivec3 pads = ivec3(` + c + ", " + f + ", " + d + `);

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ` + s + `;
           wD += ` + o + `) {
          float dyD = float(dyDCorner + wD) / ` + e + `.0;

          if (dyD < 0.0 || dyD >= ` + n.outDepth + `.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ` + u + `;
              wR += ` + i + `) {
            float dyR = float(dyRCorner + wR) / ` + t + `.0;

            if (dyR < 0.0 || dyR >= ` + n.outHeight + `.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ` + l + `;
                wC += ` + a + `) {
              float dyC = float(dyCCorner + wC) / ` + r + `.0;

              if (dyC < 0.0 || dyC >= ` + n.outWidth + `.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ` + p + ` -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ` + u + " * " + l + ` +
                  wR * ` + l + ` + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
}, Xu = function(n, e, t, r, o, i, a) {
  t === void 0 && (t = !1), r === void 0 && (r = !1), o === void 0 && (o = !1), i === void 0 && (i = null), a === void 0 && (a = !1), this.variableNames = ["matrixA", "matrixB"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e;
  var s = t ? n[1] : n[2], u = Math.ceil(s / 2), l = t ? "i * 2, rc.y" : "rc.y, i * 2", c = r ? "rc.z, i * 2" : "i * 2, rc.z", f = t ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"], d = r ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"], p = "", v = "";
  i && (p = a ? `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ` + i + `
        }` : `vec4 activation(vec4 x) {
          ` + i + `
        }`, v = "result = activation(result);");
  var g = o ? "result += getBiasAtOutCoords();" : "";
  o && this.variableNames.push("bias"), a && this.variableNames.push("preluActivationWeights"), this.userCode = `
      ` + p + `

      const float sharedDimension = ` + u + `.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ` + u + `; i++) {
          vec4 a = getMatrixA(rc.x, ` + l + `);
          vec4 b = getMatrixB(rc.x, ` + c + `);

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (` + f[0] + " * " + d[0] + `);
          result += (` + f[1] + " * " + d[1] + `);
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ` + g + `

        ` + v + `

        setOutput(result);
      }
    `;
}, J4 = function() {
  function n(e, t, r) {
    this.variableNames = ["probs"], this.outputShape = [e, r], this.userCode = `
      uniform float seed;

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ` + (t - 1) + `; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(` + (t - 1) + `));
      }
    `;
  }
  return n.prototype.getCustomSetupFunc = function(e) {
    var t = this;
    return function(r, o) {
      t.seedLoc == null && (t.seedLoc = r.getUniformLocation(o, "seed")), r.gl.uniform1f(t.seedLoc, e);
    };
  }, n;
}(), X4 = function(n, e, t, r) {
  this.variableNames = ["indices"], this.outputShape = [n, e], this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(` + r + "), float(" + t + `),
                      float(index == coords.y)));
      }
    `;
}, Y4 = function(n) {
  this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outputShape = n;
  var e = n.length;
  if (e === 0) this.userCode = `
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;
  else {
    var t = Gt("rc", e), r = Ue(e), o = function(s, u, l) {
      if (s === 1) return "rc > " + u[0];
      for (var c = "", f = s - 2; f < s; f++) c += l[f] + " >= " + u[f], f < s - 1 && (c += "||");
      return c;
    }(e, n, t), i = function(s, u, l, c) {
      if (s === 1) return "";
      var f = c.slice(-2);
      return `
    int r = ` + f[0] + `;
    int c = ` + f[1] + `;
    int rp1 = r + 1;
    int cp1 = c + 1;

    bool cEdge = cp1 >= ` + u + `;
    bool rEdge = rp1 >= ` + l + `;
  `;
    }(e, n[n.length - 1], n[n.length - 2], t), a = function(s, u) {
      var l = s.length, c = function(f, d) {
        for (var p = [], v = 0; v <= 1; v++) for (var g = 0; g <= 1; g++) {
          for (var y = (v === 0 ? "r" : "rp1") + ", " + (g === 0 ? "c" : "cp1"), x = 2; x < f; x++) y = d[d.length - 1 - x] + "," + y;
          p.push(y);
        }
        return p;
      }(l, u);
      return l === 1 ? `getA(rc),
            rc + 1 >= ` + s[0] + ` ? 0. : getA(rc + 1),
            0, 0` : "getA(" + c[0] + `),
          cEdge ? 0. : getA(` + c[1] + `),
          rEdge ? 0. : getA(` + c[2] + `),
          rEdge || cEdge ? 0. : getA(` + c[3] + ")";
    }(n, t);
    this.userCode = `
        void main() {
          ` + r + ` rc = getOutputCoords();

          if(` + o + `) {
            setOutput(vec4(0));
          } else {
            ` + i + `

            setOutput(vec4(` + a + `));
          }
        }
      `;
  }
}, Q4 = function(n, e, t) {
  this.variableNames = ["x"], this.outputShape = e.map(function(u, l) {
    return u[0] + n[l] + u[1];
  });
  var r = n.length, o = Ue(r), i = e.map(function(u) {
    return u[0];
  }).join(","), a = e.map(function(u, l) {
    return u[0] + n[l];
  }).join(","), s = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, r);
  this.userCode = r !== 1 ? `
      ` + o + " start = " + o + "(" + i + `);
      ` + o + " end = " + o + "(" + a + `);

      void main() {
        ` + o + ` outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(float(` + t + `));
        } else {
          ` + o + ` coords = outC - start;
          setOutput(getX(` + s + `));
        }
      }
    ` : `
        int start = ` + i + `;
        int end = ` + a + `;

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(float(` + t + `));
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;
}, Z4 = function(n, e, t) {
  this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e.map(function(y, x) {
    return y[0] + n[x] + y[1];
  });
  for (var r = n.length, o = Ue(r), i = e.map(function(y) {
    return y[0];
  }).join(","), a = e.map(function(y, x) {
    return y[0] + n[x];
  }).join(","), s = Gt("rc", r), u = Gt("source", r), l = s[r - 1] + " < " + this.outputShape[r - 1], c = r === 1 ? "source" : "vec2(" + u.slice(-2).join() + ")", f = [o + " rc = outputLoc;", s[r - 1] + ` += 1;
       if(` + l + `) {
      `, r === 1 ? "" : `}
       rc = outputLoc;
       ` + s[r - 2] + ` += 1;
       if(` + s[r - 2] + " < " + this.outputShape[r - 2] + ") {", r === 1 ? "" : "  " + s[r - 1] + ` += 1;
         if(` + l + ") {"], d = r === 1 ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))", p = "", v = 0, g = r === 1 ? 2 : 4; v < g; v++) p += `
        ` + f[v] + `
        if (` + d + `) {
          result[` + v + "] = float(" + t + `);
        } else {
          ` + o + ` source = rc - start;
          result[` + v + "] = getChannel(getX(" + u.join() + "), " + c + `);
        }
      `;
  p += r === 1 ? "} " : "}}", this.userCode = `
      const ` + o + " start = " + o + "(" + i + `);
      const ` + o + " end = " + o + "(" + a + `);

      void main() {
        ` + o + ` outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ` + p + `
        setOutput(result);
      }
    `;
}, Yu = function(n, e, t) {
  if (this.variableNames = ["x"], e === "avg" && t) throw new Error("Cannot compute positions for average pool.");
  var r = n.filterWidth, o = n.strideHeight, i = n.strideWidth, a = n.dilationHeight, s = n.dilationWidth, u = n.effectiveFilterHeight, l = n.effectiveFilterWidth, c = n.padInfo.top, f = n.padInfo.left;
  this.outputShape = n.outShape;
  var d = e === "avg", p = "0.0";
  if (d || (p = "-1.0 / 1e-20"), t) this.userCode = `
        const ivec2 strides = ivec2(` + o + ", " + i + `);
        const ivec2 pads = ivec2(` + c + ", " + f + `);

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ` + u + `;
              wR += ` + a + `) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ` + n.inHeight + `) {
              continue;
            }

            for (int wC = 0; wC < ` + l + `;
                wC += ` + s + `) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ` + n.inWidth + `) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = wR * ` + l + ` + wC;
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
  else {
    var v = e + "(" + e + "(" + e + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
    e === "avg" && (v = "avgValue / count");
    var g = 4 * Math.floor(r / 4), y = r % 4, x = `
      if (` + d + `) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = max(values, minMaxValue);
      }
    `;
    this.userCode = `
      const ivec2 strides = ivec2(` + o + ", " + i + `);
      const ivec2 pads = ivec2(` + c + ", " + f + `);
      const float initializationValue = ` + p + `;
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ` + n.inWidth + `) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(` + p + `);
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ` + u + `;
            wR += ` + a + `) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ` + n.inHeight + `) {
            continue;
          }

          for (int wC = 0; wC < ` + g + `; wC += 4) {
            int xC = xCCorner + wC * ` + s + `;

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ` + s + `, d),
              getValue(batch, xR, xC + 2 * ` + s + `, d),
              getValue(batch, xR, xC + 3 * ` + s + `, d)
            );

            ` + x + `
          }

          int xC = xCCorner + ` + g + `;
          if (` + (y === 1) + `) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ` + x + `
          } else if (` + (y === 2) + `) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ` + s + `, d),
              initializationValue,
              initializationValue
            );

            ` + x + `
          } else if (` + (y === 3) + `) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ` + s + `, d),
              getValue(batch, xR, xC + 2 * ` + s + `, d),
              initializationValue
            );

            ` + x + `
          }
        }
        setOutput(` + v + `);
      }
    `;
  }
}, Qu = function(n, e, t) {
  if (this.variableNames = ["x"], e === "avg" && t) throw new Error("Cannot compute positions for average pool.");
  var r = n.filterWidth, o = n.strideDepth, i = n.strideHeight, a = n.strideWidth, s = n.dilationDepth, u = n.dilationHeight, l = n.dilationWidth, c = n.effectiveFilterDepth, f = n.effectiveFilterHeight, d = n.effectiveFilterWidth, p = n.padInfo.front, v = n.padInfo.top, g = n.padInfo.left;
  this.outputShape = n.outShape;
  var y = e === "avg", x = "0.0";
  if (y || (x = "-1.0 / 1e-20"), t) this.userCode = `
        const ivec3 strides =
            ivec3(` + o + ", " + i + ", " + a + `);
        const ivec3 pads = ivec3(` + p + ", " + v + ", " + g + `);

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ` + c + `;
              wD += ` + s + `) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ` + n.inDepth + `) {
              continue;
            }

            for (int wR = 0; wR < ` + f + `;
                wR += ` + u + `) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ` + n.inHeight + `) {
                continue;
              }

              for (int wC = 0; wC < ` + d + `;
                  wC += ` + l + `) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ` + n.inWidth + `) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition =
                      wD * ` + f + " * " + d + ` +
                      wR * ` + d + ` + wC;;
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
  else {
    var w = e + "(" + e + "(" + e + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
    e === "avg" && (w = "avgValue / count");
    var b = 4 * Math.floor(r / 4), _ = r % 4, E = `
      if (` + y + `) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = max(values, minMaxValue);
      }
    `;
    this.userCode = `
      const ivec3 strides =
        ivec3(` + o + ", " + i + ", " + a + `);
      const ivec3 pads = ivec3(` + p + ", " + v + ", " + g + `);
      const float initializationValue = ` + x + `;
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ` + n.inWidth + `) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(` + x + `);
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ` + c + `;
            wD += ` + s + `) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ` + n.inDepth + `) {
            continue;
          }

          for (int wR = 0; wR < ` + f + `;
            wR += ` + u + `) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ` + n.inHeight + `) {
              continue;
            }

            for (int wC = 0; wC < ` + b + `; wC += 4) {
              int xC = xCCorner + wC * ` + l + `;

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ` + l + `, ch),
                getValue(batch, xD, xR, xC + 2 * ` + l + `, ch),
                getValue(batch, xD, xR, xC + 3 * ` + l + `, ch)
              );

              ` + E + `
            }

            int xC = xCCorner + ` + b + `;
            if (` + (_ === 1) + `) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ` + E + `
            } else if (` + (_ === 2) + `) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ` + l + `, ch),
                initializationValue,
                initializationValue
              );

              ` + E + `
            } else if (` + (_ === 3) + `) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ` + l + `, ch),
                getValue(batch, xD, xR, xC + 2 * ` + l + `, ch),
                initializationValue
              );

              ` + E + `
            }
          }
          setOutput(` + w + `);
        }
      }
    `;
  }
}, j4 = function(n, e) {
  this.variableNames = ["x"];
  var t = n.windowSize, r = n.batchSize, o = n.inSize, i = Math.ceil(o / t);
  this.outputShape = [r, i];
  var a = "0.0", s = "";
  e === "prod" ? a = "1.0" : e === "min" ? (a = "1.0 / 1e-20", s = "min") : e === "max" && (a = "-1.0 / 1e-20", s = "max");
  var u = e + "(" + e + "(" + e + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
  e === "sum" ? u = "sumValue" : e === "prod" ? u = "prodValue" : e === "all" ? u = "allValue" : e === "any" && (u = "anyValue");
  var l = 4 * Math.floor(t / 4), c = t % 4, f = `
      if (` + (e === "sum") + `) {
        sumValue += dot(values, ones);
      } else if (` + (e === "prod") + `) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ` + s + `(values, minMaxValue);
      }
    `, d = "vec4";
  e === "all" ? (a = "1.0", f = `
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `, d = "bvec4") : e === "any" && (a = "0.0", f = `
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `, d = "bvec4");
  var p = "";
  o % t > 0 && (p = `
        if (inIdx < 0 || inIdx >= ` + o + `) {
          return initializationValue;
        }
      `), this.userCode = `
      const float initializationValue = ` + a + `;
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ` + p + `
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ` + t + `;

        vec4 minMaxValue = vec4(` + a + `);
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ` + l + `; i += 4) {
          int inIdx = inOffset + i;
          ` + d + " values = " + d + `(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ` + f + `
        }

        int inIdx = inOffset + ` + l + `;
        if (` + (c === 1) + `) {
          ` + d + " values = " + d + `(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ` + f + `
        } else if (` + (c === 2) + `) {
          ` + d + " values = " + d + `(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ` + f + `
        } else if (` + (c === 3) + `) {
          ` + d + " values = " + d + `(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ` + f + `
        }
        setOutput(` + u + `);
      }
    `;
}, eI = function(n, e) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = n;
  for (var t = "", r = 0; r < 4; r++) {
    var o = "thisRC = rc;";
    r % 2 == 1 && (o += "thisRC.z += 1;"), r > 1 && (o += "thisRC.y += 1;"), t += `
        ` + o + `
        ` + (r > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : "") + `
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[` + r + `] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ` + (r > 0 ? "}" : "") + `
      `;
  }
  this.userCode = `
      
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ` + ao(["r", "c", "d"], e) + `
      return ivec3(r, c, d);
    }
  
      ` + Af(n) + `

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ` + n[1] + `;
        int cols = ` + n[2] + `;

        ` + t + `

        setOutput(result);
      }
    `;
}, tI = function(n, e, t) {
  this.variableNames = ["dy"], this.outputShape = [], this.outputShape = e.shape;
  var r = e.shape, o = r[1], i = r[2], a = n.shape, s = a[1], u = a[2], l = [t && s > 1 ? o - 1 : o, t && u > 1 ? i - 1 : i], c = [t && s > 1 ? s - 1 : s, t && u > 1 ? u - 1 : u], f = l[0] / c[0], d = l[1] / c[1], p = 1 / f, v = 1 / d, g = 2 * Math.ceil(p) + 2, y = 2 * Math.ceil(v) + 2;
  this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(` + f + `);
        const float widthScale = float(` + d + `);

        const float invHeightScale = float(` + p + `);
        const float invWidthScale = float(` + v + `);

        const int winHeight = int(` + g + `);
        const int winWidth = int(` + y + `);

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ` + s + `) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ` + u + `) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ` + (o - 1) + `.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ` + (i - 1) + `.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
}, nI = function(n, e, t, r) {
  this.variableNames = ["A"], this.outputShape = [];
  var o = n[0], i = n[1], a = n[2], s = n[3];
  this.outputShape = [o, e, t, s];
  var u = [r && e > 1 ? i - 1 : i, r && t > 1 ? a - 1 : a], l = [r && e > 1 ? e - 1 : e, r && t > 1 ? t - 1 : t];
  this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ` + u[0] / l[0] + `,
          ` + u[1] / l[1] + `);
      const vec2 inputShapeRC = vec2(` + i + ".0, " + a + `.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `;
}, rI = function(n, e, t, r) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [];
  var o = n[0], i = n[1], a = n[2], s = n[3];
  this.outputShape = [o, e, t, s];
  var u = [r && e > 1 ? i - 1 : i, r && t > 1 ? a - 1 : a], l = [r && e > 1 ? e - 1 : e, r && t > 1 ? t - 1 : t];
  this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ` + u[0] / l[0] + `,
          ` + u[1] / l[1] + `,
          ` + u[1] / l[1] + `);
      const vec3 inputShapeRC = vec3(` + i + ".0, " + a + `.0,
                                     ` + a + `.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ` + (s - 1) + `;
        bool hasNextRow = coords.z < ` + (t - 1) + `;

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `;
}, oI = function(n, e, t) {
  this.variableNames = ["dy"], this.outputShape = [], this.outputShape = e.shape;
  var r = e.shape, o = r[1], i = r[2], a = n.shape, s = a[1], u = a[2], l = [t && s > 1 ? o - 1 : o, t && u > 1 ? i - 1 : i], c = [t && s > 1 ? s - 1 : s, t && u > 1 ? u - 1 : u], f = l[0] / c[0], d = l[1] / c[1], p = 1 / f, v = 1 / d, g = 2 * Math.ceil(p) + 2, y = 2 * Math.ceil(v) + 2;
  this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(` + f + `);
        const float widthScale = float(` + d + `);

        const float invHeightScale = float(` + p + `);
        const float invWidthScale = float(` + v + `);

        const int winHeight = int(` + g + `);
        const int winWidth = int(` + y + `);

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ` + s + `) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ` + u + `) {
              continue;
            }

            float sourceFracRow =
              float(` + l[0] + `) *
                (float(dyR) / float(` + c[0] + `));

            float sourceFracCol =
                float(` + l[1] + `) *
                  (float(dyC) / float(` + c[1] + `));

            int sourceNearestRow = int(min(
                float(int(` + o + `) - 1),
                ` + t + ` ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(` + i + `) - 1),
                ` + t + ` ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
}, iI = function(n, e, t, r) {
  this.variableNames = ["A"], this.outputShape = [];
  var o = n[0], i = n[1], a = n[2], s = n[3];
  this.outputShape = [o, e, t, s];
  var u = [r && e > 1 ? i - 1 : i, r && t > 1 ? a - 1 : a], l = [r && e > 1 ? e - 1 : e, r && t > 1 ? t - 1 : t], c = r ? "0.5" : "0.0";
  this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ` + u[0] / l[0] + `,
          ` + u[1] / l[1] + `);
      const vec2 inputShapeRC = vec2(` + i + ".0, " + a + `.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ` + c + `)));

        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `;
}, aI = function(n, e) {
  this.variableNames = ["x"];
  var t = n.length;
  if (t > 4) throw new Error("WebGL backend: Reverse of rank-" + t + " tensor is not yet supported");
  if (this.outputShape = n, t !== 1) {
    var r = n.map(function(i, a) {
      return function(s) {
        return e.indexOf(s) !== -1 && n[s] !== 1 ? n[s] + " - coords[" + s + "] - 1" : "coords[" + s + "]";
      }(a);
    }).join(","), o = Ue(t);
    this.userCode = `
      void main() {
        ` + o + ` coords = getOutputCoords();
        setOutput(getX(` + r + `));
      }
    `;
  } else this.userCode = `
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(` + n[0] + ` - coord - 1));
        }
      `;
}, sI = function(n, e) {
  this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0;
  var t = n.length;
  if (t > 4) throw new Error("WebGL backend: Reverse of rank-" + t + " tensor is not yet supported");
  this.outputShape = n;
  var r = Gt("rc", t), o = r[t - 1] + " + 1 < " + this.outputShape[t - 1], i = r[t - 2] + " + 1 < " + this.outputShape[t - 2], a = Ue(t);
  function s(u) {
    var l = n.map(function(c, f) {
      return function(d, p) {
        return e.indexOf(d) !== -1 && n[d] !== 1 ? n[d] + " - " + p[d] + " - 1" : "" + p[d];
      }(f, u);
    });
    return "getChannel(getX(" + l.join(",") + "), vec2(" + l.slice(-2).join(",") + "))";
  }
  this.userCode = t === 1 ? `
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(` + n[0] + ` - rc - 1),
            ` + n[0] + ` - rc - 1);
          if(` + o + `){
              result.g = getChannel(getX(` + n[0] + ` - (rc  + 1) - 1),
                ` + n[0] + ` - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      ` : `
        void main() {
          ` + a + ` rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ` + function(u) {
    return s(u);
  }(r.slice()) + `;
          if(` + o + `){
            result.g = ` + function(u) {
    return u[t - 1] = "(" + u[t - 1] + " + 1)", s(u);
  }(r.slice()) + `;
          }
          if(` + i + `) {
            result.b = ` + function(u) {
    return u[t - 2] = "(" + u[t - 2] + " + 1)", s(u);
  }(r.slice()) + `;
            if(` + o + `) {
              result.a = ` + function(u) {
    return u[t - 1] = "(" + u[t - 1] + " + 1)", u[t - 2] = "(" + u[t - 2] + " + 1)", s(u);
  }(r.slice()) + `;
            }
          }
          setOutput(result);
        }
    `;
}, vm = function(n, e, t, r, o, i, a) {
  this.variableNames = ["updates", "indices", "defaultValue"], this.outputShape = i;
  var s = Ue(o.length), u = Ue(i.length), l = "";
  t === 1 ? l = "i" : t === 2 && (l = "i, j");
  var c = "getIndices(" + l + ")", f = "";
  r === 1 ? f = "i" : r === 2 && (f = "i, coords[1]");
  var d = "getUpdates(" + f + ")", p = e > 1 ? "strides[j]" : "strides";
  this.userCode = `
        ` + s + " strides = " + s + "(" + o + `);

        void main() {
          ` + u + ` coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ` + n + `; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ` + e + `; j++) {
              int index = round(` + c + `);
              flattenedIndex += index * ` + p + `;
            }
            if (flattenedIndex == coords[0]) {
              sum += ` + d + `;
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `;
}, uI = function(n, e) {
  this.variableNames = ["x", "segmentIds"];
  var t = n.windowSize, r = n.batchSize, o = n.inSize, i = n.numSegments, a = i * Math.ceil(o / t);
  this.outputShape = [r, a];
  var s = 4 * Math.floor(t / 4), u = t % 4, l = `
        sumValue += dot(values, segFilter);
    `, c = "";
  o % t > 0 && (c = `
        if (inIdx < 0 || inIdx >= ` + o + `) {
          return initializationValue;
        }
      `);
  var f = "";
  o % t > 0 && (f = `
        if (inIdx < 0 || inIdx >= ` + o + `) {
          return -1.0;
        }
      `), this.userCode = `
      const float initializationValue = 0.0;

      float getValue(int batch, int inIdx) {
        ` + c + `
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ` + f + `
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ` + i + ")) * float(" + t + `));
        int currentSeg = int(mod(float(outIdx), float(` + i + `)));

        float sumValue = 0.0;

        for (int i = 0; i < ` + s + `; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ` + l + `
        }

        int inIdx = inOffset + ` + s + `;
        if (` + (u === 1) + `) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ` + l + `
        } else if (` + (u === 2) + `) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ` + l + `
        } else if (` + (u === 3) + `) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ` + l + `
        }
        setOutput(sumValue);
      }
    `;
}, lI = function(n, e, t) {
  var r, o;
  if (this.variableNames = ["c", "a", "b"], this.outputShape = e, t > 4) throw Error("Where for rank " + t + " is not yet supported");
  if (t === 1) o = "resRC", r = "resRC";
  else {
    for (var i = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], a = [], s = [], u = 0; u < e.length; u++) s.push("" + i[u]), u < n && a.push("" + i[u]);
    r = a.join(), o = s.join();
  }
  var l = Ue(t);
  this.userCode = `
      void main() {
        ` + l + ` resRC = getOutputCoords();
        float cVal = getC(` + r + `);
        if (cVal >= 1.0) {
          setOutput(getA(` + o + `));
        } else {
          setOutput(getB(` + o + `));
        }
      }
    `;
}, cI = function() {
  function n(e) {
    this.variableNames = ["source"], this.outputShape = e, this.rank = e.length;
    var t, r = Ue(this.rank), o = "uniform int start[" + this.rank + "];", i = function(a) {
      if (a === 1) return "sourceLoc";
      if (a <= 6) return Zu.slice(0, a).map(function(s) {
        return "sourceLoc." + s;
      }).join(",");
      throw Error("Slicing for rank " + a + " is not yet supported");
    }(this.rank);
    t = `
        ` + r + ` sourceLoc;
        ` + r + ` coords = getOutputCoords();
        ` + e.map(function(a, s) {
      return "sourceLoc." + Zu[s] + " = start[" + s + "] + coords." + Zu[s] + ";";
    }).join(`
`) + `
      `, this.userCode = `
      ` + o + `
      void main() {
        ` + t + `
        setOutput(getSource(` + i + `));
      }
    `;
  }
  return n.prototype.getCustomSetupFunc = function(e) {
    var t = this;
    if (e.length !== this.rank) throw Error("The rank (" + this.rank + ") of the program must match the length of start (" + e.length + ")");
    return function(r, o) {
      t.startLoc == null && (t.startLoc = r.getUniformLocationNoThrow(o, "start"), t.startLoc == null) || r.gl.uniform1iv(t.startLoc, e);
    };
  }, n;
}(), Zu = ["x", "y", "z", "w", "u", "v"], fI = function() {
  function n(e) {
    this.variableNames = ["source"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e, this.rank = e.length;
    var t = Ue(this.rank), r = Gt("coords", this.rank), o = Gt("sourceLoc", this.rank), i = this.rank === 1 ? "sourceLoc" : "vec2(" + o.slice(-2).join() + ")", a = "getChannel(getSource(" + o.join() + "), " + i + ")", s = `
      result.x = ` + a + `;
      if (++` + r[this.rank - 1] + " < " + e[this.rank - 1] + `) {
        ++` + o[this.rank - 1] + `;
        result.y = ` + a + `;
        --` + o[this.rank - 1] + `;
      }
    `, u = this.rank === 1 ? "" : `
      --` + r[this.rank - 1] + `;
      if (++` + r[this.rank - 2] + " < " + e[this.rank - 2] + `) {
        ++` + o[this.rank - 2] + `;
        result.z = ` + a + `;
        if (++` + r[this.rank - 1] + " < " + e[this.rank - 1] + `) {
          ++` + o[this.rank - 1] + `;
          result.w = ` + a + `;
        }
      }
    `, l = this.rank <= 4 ? `sourceLoc = coords +
            ` + t + "(" + e.map(function(c, f) {
      return "start[" + f + "]";
    }).join() + ");" : e.map(function(c, f) {
      return o[f] + " = " + r[f] + " + start[" + f + "];";
    }).join(`
`);
    this.userCode = `
      uniform int start[` + this.rank + `];
      void main() {
        ` + t + ` coords = getOutputCoords();
        ` + t + ` sourceLoc;
        ` + l + `
        vec4 result = vec4(0.);
        ` + s + `
        ` + u + `
        setOutput(result);
      }
    `;
  }
  return n.prototype.getCustomSetupFunc = function(e) {
    var t = this;
    if (e.length !== this.rank) throw Error("The rank (" + this.rank + ") of the program must match the length of start (" + e.length + ")");
    return function(r, o) {
      t.startLoc == null && (t.startLoc = r.getUniformLocationNoThrow(o, "start"), t.startLoc == null) || r.gl.uniform1iv(t.startLoc, e);
    };
  }, n;
}(), dI = function(n, e, t) {
  this.variableNames = ["x"], this.outputShape = t;
  var r = t.length, o = Ue(t.length), i = Ue(t.length), a = "";
  if (r === 1) a = "coords * strides + begin";
  else {
    var s = 0;
    a = t.map(function(u, l) {
      return s++, t.length === 1 ? "coords * strides[" + l + "] + begin[" + l + "]" : "coords[" + (s - 1) + "] * strides[" + l + "] + begin[" + l + "]";
    }).join(",");
  }
  this.userCode = `
      ` + o + " begin = " + o + "(" + n + `);
      ` + o + " strides = " + o + "(" + e + `);

      void main() {
        ` + i + ` coords = getOutputCoords();
        setOutput(getX(` + a + `));
      }
    `;
}, hI = function() {
  function n(e) {
    this.gpgpu = e, this.numUsedTextures = 0, this.numFreeTextures = 0, this.freeTextures = {}, this.logEnabled = !1, this.usedTextures = {};
  }
  return n.prototype.acquireTexture = function(e, t, r) {
    var o, i = gm(t, r), a = ym(e, i, r);
    if (a in this.freeTextures || (this.freeTextures[a] = []), a in this.usedTextures || (this.usedTextures[a] = []), this.freeTextures[a].length > 0) {
      this.numFreeTextures--, this.numUsedTextures++, this.log();
      var s = this.freeTextures[a].shift();
      return this.usedTextures[a].push(s), s;
    }
    return this.numUsedTextures++, this.log(), i === jt.PACKED_2X2_FLOAT32 ? o = this.gpgpu.createPackedMatrixTexture(e[0], e[1]) : i === jt.PACKED_2X2_FLOAT16 ? o = this.gpgpu.createFloat16PackedMatrixTexture(e[0], e[1]) : i === jt.UNPACKED_FLOAT32 ? o = this.gpgpu.createFloat32MatrixTexture(e[0], e[1]) : i === jt.UNPACKED_FLOAT16 ? o = this.gpgpu.createFloat16MatrixTexture(e[0], e[1]) : i === jt.PACKED_4X1_UNSIGNED_BYTE && (o = this.gpgpu.createUnsignedBytesMatrixTexture(e[0], e[1])), this.usedTextures[a].push(o), o;
  }, n.prototype.releaseTexture = function(e, t, r, o) {
    if (this.freeTextures != null) {
      var i = ym(t, gm(r, o), o);
      i in this.freeTextures || (this.freeTextures[i] = []), this.freeTextures[i].push(e), this.numFreeTextures++, this.numUsedTextures--;
      var a = this.usedTextures[i], s = a.indexOf(e);
      if (s < 0) throw new Error("Cannot release a texture that was never provided by this texture manager");
      a.splice(s, 1), this.log();
    }
  }, n.prototype.log = function() {
    if (this.logEnabled) {
      var e = this.numFreeTextures + this.numUsedTextures;
      console.log("Free/Used", this.numFreeTextures + " / " + this.numUsedTextures, "(" + e + ")");
    }
  }, n.prototype.getNumUsedTextures = function() {
    return this.numUsedTextures;
  }, n.prototype.getNumFreeTextures = function() {
    return this.numFreeTextures;
  }, n.prototype.dispose = function() {
    var e = this;
    if (this.freeTextures != null) {
      for (var t in this.freeTextures) this.freeTextures[t].forEach(function(r) {
        e.gpgpu.deleteMatrixTexture(r);
      });
      for (var t in this.usedTextures) this.usedTextures[t].forEach(function(o) {
        e.gpgpu.deleteMatrixTexture(o);
      });
      this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0;
    }
  }, n;
}();
function gm(n, e) {
  if (n === en.UPLOAD) return jt.PACKED_2X2_FLOAT32;
  if (n === en.RENDER || n == null) return function(t) {
    return V().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? t ? jt.PACKED_2X2_FLOAT32 : jt.UNPACKED_FLOAT32 : t ? jt.PACKED_2X2_FLOAT16 : jt.UNPACKED_FLOAT16;
  }(e);
  if (n === en.DOWNLOAD || n === en.PIXELS) return jt.PACKED_4X1_UNSIGNED_BYTE;
  throw new Error("Unknown logical texture type " + n);
}
function ym(n, e, t) {
  return n[0] + "_" + n[1] + "_" + e + "_" + t;
}
var pI = function(n, e) {
  this.variableNames = ["A"];
  for (var t = new Array(n.length), r = 0; r < t.length; r++) t[r] = n[r] * e[r];
  this.outputShape = t, this.rank = t.length;
  var o = Ue(this.rank), i = function(a) {
    var s = a.length;
    if (s > 5) throw Error("Tile for rank " + s + " is not yet supported");
    if (s === 1) return "imod(resRC, " + a[0] + ")";
    for (var u = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"], l = [], c = 0; c < a.length; c++) l.push("imod(" + u[c] + ", " + a[c] + ")");
    return l.join();
  }(n);
  this.userCode = `
      void main() {
        ` + o + ` resRC = getOutputCoords();
        setOutput(getA(` + i + `));
      }
    `;
}, mI = function(n, e) {
  this.variableNames = ["A"];
  for (var t = new Array(n.length), r = 0; r < t.length; r++) t[r] = n[e[r]];
  this.outputShape = t, this.rank = t.length;
  var o = Ue(this.rank), i = function(a) {
    var s = a.length;
    if (s > 6) throw Error("Transpose for rank " + s + " is not yet supported");
    for (var u = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"], l = new Array(s), c = 0; c < a.length; c++) l[a[c]] = u[c];
    return l.join();
  }(e);
  this.userCode = `
    void main() {
      ` + o + ` resRC = getOutputCoords();
      setOutput(getA(` + i + `));
    }
    `;
}, vI = function(n, e) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0;
  for (var t = new Array(n.length), r = 0; r < t.length; r++) t[r] = n[e[r]];
  if (this.outputShape = t, this.rank = t.length, this.rank > 6) throw Error("Packed transpose for rank " + this.rank + " is not yet supported.");
  var o = Ue(this.rank), i = Z1("rc", this.rank), a = new Array(this.rank);
  for (r = 0; r < e.length; r++) a[e[r]] = i[r];
  var s = "vec2(" + a.slice(-2).join() + ")", u = "++" + i[this.rank - 1] + " < " + t[this.rank - 1], l = "getChannel(getA(" + a.join() + "), " + s + ")";
  this.userCode = `
    void main() {
      ` + o + ` rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ` + l + `;
      if(` + u + `) {
        result[1] = ` + l + `;
      }
      --` + i[this.rank - 1] + `;
      if(++` + i[this.rank - 2] + " < " + t[this.rank - 2] + `) {
        result[2] = ` + l + `;
        if(` + u + `) {
          result[3] = ` + l + `;
        }
      }
      setOutput(result);
    }
    `;
}, Rf = 1.7580993408473768, kf = 1.0507009873554805, pe = function(n, e) {
  this.variableNames = ["A"], this.outputShape = n, this.userCode = `
      float unaryOperation(float x) {
        ` + e + `
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `;
}, Nn = "if (isnan(x)) return x;", gI = "return x;", xm = "return abs(x);", r0 = Nn + `
  return (x < 0.0) ? 0.0 : x;
`, o0 = Nn + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`, i0 = "return (x >= 0.0) ? x : (exp(x) - 1.0);", yI = `
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ` + Rf + `;
  float scale = ` + kf + `;
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`, wm = "return -x;", _m = "return ceil(x);", bm = "return floor(x);", Em = "return exp(x);", Cm = "return exp(x) - 1.0;", xI = Nn + `
  return sin(x);
`, wI = Nn + `
  return cos(x);
`, _I = Nn + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`, bI = Nn + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`, EI = Nn + `
  return atan(x);
`, CI = Nn + "return log(x + sqrt(x * x + 1.0));", TI = Nn + `
  if (x < 1.0) return NAN;
  return log(x + sqrt(x * x - 1.0));`, II = Nn + `
  if ((x < -1.0) || (x > 1.0)) return NAN;
  return (log(1.0 + x) - log(1.0 - x)) / 2.0;`, Aa = "return x;", SI = "return x;", a0 = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, s0 = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, u0 = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`, Di = function(n, e) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = n, this.userCode = `
      vec4 unaryOperation(vec4 x) {
        ` + e + `
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `;
}, AI = function(n) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outputShape = n;
  var e = n.length, t = Gt("rc", e), r = Ue(e), o = function(s, u) {
    if (s === 1) return "rc";
    for (var l = "", c = 0; c < s; c++) l += u[c], c < s - 1 && (l += ",");
    return l;
  }(e, t), i = t.slice(-2), a = e <= 1 ? "rc" : "vec2(" + i.join(",") + ")";
  this.userCode = `
      void main() {
        ` + r + ` rc = getOutputCoords();
        vec4 packedInput = getA(` + o + `);

        setOutput(getChannel(packedInput, ` + a + `));
      }
    `;
}, Ra = {};
function ka(n, e) {
  if (e === void 0 && (e = !1), n === "linear") return e ? SI : gI;
  if (n === "relu") return e ? a0 : r0;
  if (n === "elu") return e ? u0 : i0;
  if (n === "relu6") return e ? s0 : o0;
  if (n === "prelu") return e ? n0 : t0;
  throw new Error("Activation " + n + " has not been implemented for the WebGL backend.");
}
var RI = 600, kI = function(n) {
  function e(t) {
    var r, o = n.call(this) || this;
    if (o.pendingRead = /* @__PURE__ */ new WeakMap(), o.pendingDisposal = /* @__PURE__ */ new WeakSet(), o.dataRefCount = /* @__PURE__ */ new WeakMap(), o.numBytesInGPU = 0, o.uploadWaitMs = 0, o.downloadWaitMs = 0, o.warnedAboutMemory = !1, o.pendingDeletes = 0, o.disposed = !1, !V().getBool("HAS_WEBGL")) throw new Error("WebGL is not supported on this device");
    if (t == null) {
      var i = jn(V().getNumber("WEBGL_VERSION"));
      o.binaryCache = ((r = V().getNumber("WEBGL_VERSION")) in Ra || (Ra[r] = {}), Ra[r]), o.gpgpu = new G4(i), o.canvas = i.canvas, o.gpgpuCreatedLocally = !0;
    } else o.gpgpu = t, o.binaryCache = {}, o.gpgpuCreatedLocally = !1, o.canvas = t.gl.canvas;
    return o.textureManager = new hI(o.gpgpu), o.numMBBeforeWarning = V().global.screen == null ? 1024 : V().global.screen.height * V().global.screen.width * window.devicePixelRatio * RI / 1024 / 1024, o.texData = new H1(o, D), o;
  }
  return Pn(e, n), e.prototype.numDataIds = function() {
    return this.texData.numDataIds() + (this.cpuBackend ? this.cpuBackend.numDataIds() : 0) - this.pendingDeletes;
  }, e.prototype.write = function(t, r, o) {
    if (V().getBool("DEBUG") && this.checkNumericalProblems(t), o === "complex64" && t != null) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    var i = {};
    return this.texData.set(i, { shape: r, dtype: o, values: t, usage: en.UPLOAD }), i;
  }, e.prototype.move = function(t, r, o, i) {
    if (V().getBool("DEBUG") && this.checkNumericalProblems(r), i === "complex64") throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    this.texData.set(t, { shape: o, dtype: i, values: r, usage: en.UPLOAD });
  }, e.prototype.readSync = function(t) {
    var r = this.texData.get(t), o = r.values, i = r.dtype, a = r.complexTensors, s = r.slice, u = r.shape, l = r.isPacked;
    if (s != null) {
      var c = void 0;
      c = l ? new Di(u, Aa) : new pe(u, Aa);
      var f = this.runWebGLProgram(c, [{ dataId: t, shape: u, dtype: i }], i), d = this.readSync(f.dataId);
      return this.disposeData(f.dataId), d;
    }
    if (o != null) return this.convertAndCacheOnCPU(t);
    if (i === "string") return o;
    var p, v, g = this.activeTimers != null;
    return g && (p = Wn()), i === "complex64" ? v = jl(a.real.dataSync(), a.imag.dataSync()) : v = this.getValuesFromTexture(t), g && (this.downloadWaitMs += Wn() - p), this.convertAndCacheOnCPU(t, v);
  }, e.prototype.read = function(t) {
    return Z(this, void 0, void 0, function() {
      var r, o, i, a, s, u, l, c, f, d, p, v, g, y, x, w, b, _, E, C, A, R;
      return j(this, function(I) {
        switch (I.label) {
          case 0:
            if (this.pendingRead.has(t)) return r = this.pendingRead.get(t), [2, new Promise(function(S) {
              return r.push(S);
            })];
            if (o = this.texData.get(t), i = o.values, a = o.shape, s = o.slice, u = o.dtype, l = o.complexTensors, c = o.isPacked, s != null) return f = void 0, f = c ? new Di(a, Aa) : new pe(a, Aa), d = this.runWebGLProgram(f, [{ dataId: t, shape: a, dtype: u }], u), p = this.read(d.dataId), this.disposeData(d.dataId), [2, p];
            if (i != null) return [2, this.convertAndCacheOnCPU(t)];
            if (!V().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && V().getNumber("WEBGL_VERSION") === 2) throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
            return v = null, u !== "complex64" && V().get("WEBGL_BUFFER_SUPPORTED") && (g = this.decode(t), y = this.texData.get(g.dataId), v = (R = this.gpgpu).createBufferFromTexture.apply(R, [y.texture].concat(Gi(a)))), this.pendingRead.set(t, []), u === "complex64" ? [3, 2] : [4, this.gpgpu.createAndWaitForFence()];
          case 1:
            I.sent(), I.label = 2;
          case 2:
            return u !== "complex64" ? [3, 4] : [4, Promise.all([l.real.data(), l.imag.data()])];
          case 3:
            return w = I.sent(), b = w[0], _ = w[1], x = jl(b, _), [3, 5];
          case 4:
            v == null ? x = this.getValuesFromTexture(t) : (E = ee(a), x = this.gpgpu.downloadFloat32MatrixFromBuffer(v, E)), I.label = 5;
          case 5:
            return g != null && this.disposeData(g.dataId), C = this.convertAndCacheOnCPU(t, x), A = this.pendingRead.get(t), this.pendingRead.delete(t), A.forEach(function(S) {
              return S(C);
            }), this.pendingDisposal.has(t) && (this.pendingDisposal.delete(t), this.disposeData(t), this.pendingDeletes--), [2, C];
        }
      });
    });
  }, e.prototype.checkNumericalProblems = function(t) {
    if (t != null) for (var r = 0; r < t.length; r++) {
      var o = t[r];
      if (!y3(o))
        throw V().getBool("WEBGL_RENDER_FLOAT32_CAPABLE") ? Error("The value " + o + " cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'") : Error("The value " + o + " cannot be represented on this device.");
    }
  }, e.prototype.getValuesFromTexture = function(t) {
    var r, o = this.texData.get(t), i = o.shape, a = o.dtype, s = o.isPacked, u = ee(i);
    if (V().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
      var l = this.decode(t), c = this.texData.get(l.dataId), f = (r = this.gpgpu).downloadMatrixFromPackedTexture.apply(r, [c.texture].concat(Gi(i))).subarray(0, u);
      return this.disposeData(l.dataId), f;
    }
    var d = V().getBool("WEBGL_PACK") && s === !0, p = d ? qu(i) : i, v = d ? new g4(p) : new v4(p), g = this.runWebGLProgram(v, [{ shape: p, dtype: a, dataId: t }], "float32"), y = this.texData.get(g.dataId), x = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(y.texture, y.texShape[0], y.texShape[1]).subarray(0, u);
    return this.disposeData(g.dataId), x;
  }, e.prototype.time = function(t) {
    return Z(this, void 0, void 0, function() {
      var r, o, i, a, s, u, l;
      return j(this, function(c) {
        switch (c.label) {
          case 0:
            return r = this.activeTimers, o = [], i = !1, this.programTimersStack == null ? (this.programTimersStack = o, i = !0) : this.activeTimers.push(o), this.activeTimers = o, t(), a = ci(this.activeTimers.map(function(f) {
              return f.query;
            })).filter(function(f) {
              return f != null;
            }), s = ci(this.activeTimers.map(function(f) {
              return f.name;
            })).filter(function(f) {
              return f != null;
            }), this.activeTimers = r, i && (this.programTimersStack = null), u = { uploadWaitMs: this.uploadWaitMs, downloadWaitMs: this.downloadWaitMs, kernelMs: null, wallMs: null }, V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? [4, Promise.all(a)] : [3, 2];
          case 1:
            return l = c.sent(), u.kernelMs = ZC(l), u.getExtraProfileInfo = function() {
              return l.map(function(f, d) {
                return { name: s[d], ms: f };
              }).map(function(f) {
                return f.name + ": " + f.ms;
              }).join(", ");
            }, [3, 3];
          case 2:
            u.kernelMs = { error: "WebGL query timers are not supported in this environment." }, c.label = 3;
          case 3:
            return this.uploadWaitMs = 0, this.downloadWaitMs = 0, [2, u];
        }
      });
    });
  }, e.prototype.memory = function() {
    return { unreliable: !1, numBytesInGPU: this.numBytesInGPU };
  }, e.prototype.startTimer = function() {
    return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? this.gpgpu.beginQuery() : { startMs: Wn(), endMs: null };
  }, e.prototype.endTimer = function(t) {
    return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? (this.gpgpu.endQuery(), t) : (t.endMs = Wn(), t);
  }, e.prototype.getQueryTime = function(t) {
    return Z(this, void 0, void 0, function() {
      var r;
      return j(this, function(o) {
        return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? [2, this.gpgpu.waitForQueryAndGetTime(t)] : [2, (r = t).endMs - r.startMs];
      });
    });
  }, e.prototype.disposeData = function(t) {
    if (!this.pendingDisposal.has(t)) {
      if (this.pendingRead.has(t)) return this.pendingDisposal.add(t), void this.pendingDeletes++;
      if (this.texData.has(t)) {
        this.releaseGPUData(t);
        var r = this.texData.get(t).complexTensors;
        r != null && (r.real.dispose(), r.imag.dispose()), this.texData.delete(t);
      }
    }
  }, e.prototype.releaseGPUData = function(t) {
    var r = this.texData.get(t), o = r.texture, i = r.dtype, a = r.texShape, s = r.usage, u = r.isPacked, l = r.slice, c = l && l.origDataId || t, f = this.dataRefCount.get(c);
    f > 1 ? this.dataRefCount.set(c, f - 1) : (this.dataRefCount.delete(c), o != null && (this.numBytesInGPU -= this.computeBytes(a, i), this.textureManager.releaseTexture(o, a, s, u)));
    var d = this.texData.get(t);
    d.texture = null, d.texShape = null, d.isPacked = !1, d.slice = null;
  }, e.prototype.getTexture = function(t) {
    return this.uploadToGPU(t), this.texData.get(t).texture;
  }, e.prototype.getDataInfo = function(t) {
    return this.texData.get(t);
  }, e.prototype.getCPUBackend = function() {
    return V().getBool("WEBGL_CPU_FORWARD") ? (this.cpuBackend == null && (this.cpuBackend = D.findBackend("cpu")), this.cpuBackend) : null;
  }, e.prototype.shouldExecuteOnCPU = function(t, r) {
    var o = this;
    return r === void 0 && (r = 128), this.getCPUBackend() != null && t.every(function(i) {
      return o.texData.get(i.dataId).texture == null && i.size < r;
    });
  }, e.prototype.getGPGPUContext = function() {
    return this.gpgpu;
  }, e.prototype.complex = function(t, r) {
    var o = this.makeOutput(t.shape, "complex64");
    return this.texData.get(o.dataId).complexTensors = { real: D.keep(t.clone()), imag: D.keep(r.clone()) }, o;
  }, e.prototype.real = function(t) {
    return this.texData.get(t.dataId).complexTensors.real.clone();
  }, e.prototype.imag = function(t) {
    return this.texData.get(t.dataId).complexTensors.imag.clone();
  }, e.prototype.slice = function(t, r, o) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.slice(t, r, o);
    if (ee(o) === 0) return Tt([], o, t.dtype);
    var i = this.texData.get(t.dataId).isPacked, a = G1(t.shape, r, o);
    if (i || !a) {
      var s = V().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new fI(o) : new cI(o), u = s.getCustomSetupFunc(r);
      return this.compileAndRun(s, [t], null, u);
    }
    return this.uploadToGPU(t.dataId), this.shallowSlice(t, r, o);
  }, e.prototype.shallowSlice = function(t, r, o) {
    var i = this.texData.get(t.dataId), a = this.makeOutput(o, t.dtype), s = this.texData.get(a.dataId);
    Object.assign(s, i), s.shape = o, s.dtype = t.dtype;
    var u = W1(r, t.strides);
    i.slice && (u += i.slice.flatOffset), s.slice = { flatOffset: u, origDataId: i.slice && i.slice.origDataId || t.dataId };
    var l = this.dataRefCount.get(s.slice.origDataId) || 1;
    return this.dataRefCount.set(s.slice.origDataId, l + 1), a;
  }, e.prototype.stridedSlice = function(t, r, o, i) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.stridedSlice(t, r, o, i);
    var a = Ef(r, o, i);
    if (a.some(function(u) {
      return u === 0;
    })) return Tt([], a);
    var s = new dI(r, i, a);
    return this.compileAndRun(s, [t]);
  }, e.prototype.reverse = function(t, r) {
    var o = V().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new sI(t.shape, r) : new aI(t.shape, r);
    return this.compileAndRun(o, [t]);
  }, e.prototype.concat = function(t, r) {
    if (t[0].dtype === "complex64") {
      var o = t.map(function(p) {
        return mn(p);
      }), i = t.map(function(p) {
        return $n(p);
      });
      return Et(this.concat(o, r), this.concat(i, r));
    }
    if (this.shouldExecuteOnCPU(t)) return this.cpuBackend.concat(t, r);
    if (t.length === 1) return t[0];
    if (t.length > V().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
      var a = Math.floor(t.length / 2), s = this.concat(t.slice(0, a), r), u = this.concat(t.slice(a), r);
      return this.concat([s, u], r);
    }
    if (V().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && t[0].rank > 1) {
      var l = new n4(t.map(function(p) {
        return p.shape;
      }), r);
      return this.compileAndRun(l, t);
    }
    var c = di(t.map(function(p) {
      return p.shape;
    }), r), f = t.map(function(p) {
      return p.as2D(-1, ee(p.shape.slice(r)));
    }), d = new t4(f.map(function(p) {
      return p.shape;
    }));
    return this.compileAndRun(d, f).reshape(c);
  }, e.prototype.neg = function(t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.neg(t);
    if (V().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, wm, t.dtype);
    var r = new pe(t.shape, wm);
    return this.compileAndRun(r, [t]);
  }, e.prototype.batchMatMul = function(t, r, o, i) {
    var a = o ? t.shape[2] : t.shape[1], s = i ? r.shape[1] : r.shape[2], u = o ? t.shape[1] : t.shape[2], l = t.shape[0];
    if ((a === 1 || s === 1) && u > 1e3) {
      o && (t = t.transpose([0, 2, 1])), i && (r = r.transpose([0, 2, 1]));
      var c = s === 1 ? t : t.as3D(l, u, 1), f = s === 1 ? 2 : 1, d = s === 1 ? r.as3D(l, 1, u) : r;
      return this.multiply(c, d).sum(f, !0);
    }
    var p = Ct(t.dtype, r.dtype), v = new Xu(t.shape, [l, a, s], o, i);
    return this.compileAndRun(v, [t, r], p);
  }, e.prototype.fusedBatchMatMul = function(t) {
    var r = t.a, o = t.b, i = t.transposeA, a = t.transposeB, s = t.bias, u = t.activation, l = t.preluActivationWeights, c = i ? r.shape[2] : r.shape[1], f = a ? o.shape[1] : o.shape[2], d = r.shape[0], p = Ct(r.dtype, o.dtype), v = s != null, g = l != null, y = u ? ka(u, !0) : null, x = new Xu(r.shape, [d, c, f], i, a, v, y, g), w = [r, o];
    return s && w.push(s), l && w.push(l), this.compileAndRun(x, w, p);
  }, e.prototype.multiply = function(t, r) {
    if (t.dtype === "complex64") {
      var o = this.texData.get(t.dataId), i = this.texData.get(r.dataId), a = new um(YT, t.shape, r.shape), s = new um(QT, t.shape, r.shape), u = [this.makeComplexComponentTensorInfo(t, o.complexTensors.real), this.makeComplexComponentTensorInfo(t, o.complexTensors.imag), this.makeComplexComponentTensorInfo(r, i.complexTensors.real), this.makeComplexComponentTensorInfo(r, i.complexTensors.imag)], l = this.compileAndRun(a, u), c = this.compileAndRun(s, u), f = this.complex(l, c);
      return l.dispose(), c.dispose(), f;
    }
    if (this.shouldExecuteOnCPU([t, r])) return this.cpuBackend.multiply(t, r);
    if (V().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, r, lm, t.dtype);
    var d = new et(lm, t.shape, r.shape);
    return this.compileAndRun(d, [t, r], t.dtype);
  }, e.prototype.batchNormalization = function(t, r, o, i, a, s) {
    var u = [t, r, o], l = null;
    s != null && (l = s.shape, u.push(s));
    var c = null;
    if (a != null && (c = a.shape, u.push(a)), V().getBool("WEBGL_PACK_NORMALIZATION")) {
      var f = new XT(t.shape, r.shape, o.shape, l, c, i);
      return this.compileAndRun(f, u);
    }
    var d = new JT(t.shape, r.shape, o.shape, l, c, i);
    return this.compileAndRun(d, u);
  }, e.prototype.localResponseNormalization4D = function(t, r, o, i, a) {
    var s = V().getBool("WEBGL_PACK_NORMALIZATION") ? new q4(t.shape, r, o, i, a) : new H4(t.shape, r, o, i, a);
    return this.compileAndRun(s, [t]);
  }, e.prototype.LRNGrad = function(t, r, o, i, a, s, u) {
    var l = new $4(r.shape, i, a, s, u);
    return this.compileAndRun(l, [r, o, t]);
  }, e.prototype.tile = function(t, r) {
    if (t.dtype === "string") {
      var o = this.readSync(t.dataId).map(function(a) {
        return ts(a);
      });
      return Y1(he(t.shape, t.dtype, o), r);
    }
    var i = new pI(t.shape, r);
    return this.compileAndRun(i, [t]);
  }, e.prototype.pad = function(t, r, o) {
    var i = V().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Z4(t.shape, r, o) : new Q4(t.shape, r, o);
    return this.compileAndRun(i, [t]);
  }, e.prototype.transpose = function(t, r) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.transpose(t, r);
    var o = V().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new vI(t.shape, r) : new mI(t.shape, r);
    return this.compileAndRun(o, [t]);
  }, e.prototype.gather = function(t, r, o) {
    if (this.shouldExecuteOnCPU([t, r])) return this.cpuBackend.gather(t, r, o);
    var i = new E4(t.shape, r.size, o);
    return this.compileAndRun(i, [t, r]);
  }, e.prototype.batchToSpaceND = function(t, r, o) {
    k(t.rank <= 4, function() {
      return "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet";
    });
    var i = r.reduce(function(f, d) {
      return f * d;
    }), a = ss(t.shape, r, i), s = us(a.length, r.length), u = ls(t.shape, r, i), l = B1(o, r.length), c = O1(u, o, r.length);
    return t.reshape(a).transpose(s).reshape(u).slice(l, c);
  }, e.prototype.spaceToBatchND = function(t, r, o) {
    k(t.rank <= 4, function() {
      return "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet";
    });
    var i = r.reduce(function(d, p) {
      return d * p;
    }), a = [[0, 0]];
    a.push.apply(a, o);
    for (var s = 1 + r.length; s < t.shape.length; ++s) a.push([0, 0]);
    var u = t.pad(a), l = ss(u.shape, r, i, !1), c = us(l.length, r.length, !1), f = ls(u.shape, r, i, !1);
    return u.reshape(l).transpose(c).reshape(f);
  }, e.prototype.reduce = function(t, r, o) {
    var i = t.shape[0], a = t.shape[1], s = zu(a), u = new j4({ windowSize: s, inSize: a, batchSize: i }, r), l = this.compileAndRun(u, [t], o);
    return l.shape[1] === 1 ? l : this.reduce(l, r, o);
  }, e.prototype.argReduce = function(t, r, o) {
    o === void 0 && (o = null);
    var i = t.shape[0], a = t.shape[1];
    o != null && (i = o.shape[0], a = o.shape[1]);
    var s = zu(a), u = new UT({ windowSize: s, inSize: a, batchSize: i }, r, o == null), l = [t];
    o != null && l.push(o);
    var c = this.compileAndRun(u, l, "int32");
    return c.shape[1] === 1 ? c : this.argReduce(t, r, c);
  }, e.prototype.argReducePacked = function(t, r, o) {
    o === void 0 && (o = null);
    var i = o != null ? o.shape : t.shape, a = zu(i[i.length - 1]), s = new qT(i, a, r, o == null), u = o == null ? [t] : [t, o], l = this.compileAndRun(s, u, "int32");
    return l.rank === t.rank ? this.argReducePacked(t, r, l) : l;
  }, e.prototype.sum = function(t, r) {
    Zt("sum", r, t.rank);
    var o = St(t.shape, r), i = o[0], a = ee(o[1]), s = t.as2D(-1, a), u = Ou(t.dtype);
    return this.reduce(s, "sum", u).reshape(i);
  }, e.prototype.prod = function(t, r) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.prod(t, r);
    var o = St(t.shape, r), i = o[0], a = ee(o[1]), s = t.as2D(-1, a), u = Ou(t.dtype);
    return this.reduce(s, "prod", u).reshape(i);
  }, e.prototype.unsortedSegmentSum = function(t, r, o) {
    var i = 0, a = er([i], t.rank), s = t;
    a != null && (s = t.transpose(a), i = tr(1, t.rank)[0]);
    var u = function(p, v, g) {
      for (var y = [], x = p.length, w = 0; w < x; w++) w !== v ? y.push(p[w]) : y.push(g);
      return y;
    }(s.shape, i, o), l = ee([s.shape[i]]), c = s.as2D(-1, l), f = Ou(t.dtype), d = this.segOpCompute(c, "unsortedSegmentSum", r, f, o).reshape(u);
    return a != null && (d = d.transpose(xf(a))), d;
  }, e.prototype.segOpCompute = function(t, r, o, i, a) {
    var s = t.shape[0], u = t.shape[1], l = function(d, p) {
      var v, g = !1;
      for (d <= V1 ? (v = d, g = !0) : v = $l(d, Math.floor(Math.sqrt(d))); !g; ) v > p || v === d ? g = !0 : v = $l(d, v + 1);
      return v;
    }(u, a), c = new uI({ windowSize: l, inSize: u, batchSize: s, numSegments: a }), f = this.compileAndRun(c, [t, o], i);
    return f.shape[1] === a ? f : (o = as(0, a).tile([u / l]), this.segOpCompute(f, r, o, i, a));
  }, e.prototype.argMinMaxReduce = function(t, r, o) {
    var i = [r];
    if (Zt("arg" + o.charAt(0).toUpperCase() + o.slice(1), i, t.rank), !V().getBool("WEBGL_PACK_REDUCE") || t.rank <= 2) {
      var a = St(t.shape, i), s = a[0], u = ee(a[1]), l = t.as2D(-1, u);
      return this.argReduce(l, o).reshape(s);
    }
    return this.argReducePacked(t, o);
  }, e.prototype.argMin = function(t, r) {
    return this.argMinMaxReduce(t, r, "min");
  }, e.prototype.argMax = function(t, r) {
    return this.argMinMaxReduce(t, r, "max");
  }, e.prototype.cumsum = function(t, r, o, i) {
    if (r !== t.rank - 1) throw new Error("WebGL cumsum shader expects an inner-most axis=" + (t.rank - 1) + " but got axis=" + r);
    var a = new f4(t.shape, o, i);
    return this.compileAndRun(a, [t]);
  }, e.prototype.equal = function(t, r) {
    if (V().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, r, `
  return vec4(equal(a, b));
`, "bool");
    var o = new et("return float(a == b);", t.shape, r.shape);
    return this.compileAndRun(o, [t, r], "bool");
  }, e.prototype.notEqual = function(t, r) {
    if (V().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, r, `
  return vec4(notEqual(a, b));
`, "bool");
    var o = new et("return float(a != b);", t.shape, r.shape);
    return this.compileAndRun(o, [t, r], "bool");
  }, e.prototype.less = function(t, r) {
    if (this.shouldExecuteOnCPU([t, r])) return this.cpuBackend.less(t, r);
    if (V().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, r, `
  return vec4(lessThan(a, b));
`, "bool");
    var o = new et("return float(a < b);", t.shape, r.shape);
    return this.compileAndRun(o, [t, r], "bool");
  }, e.prototype.lessEqual = function(t, r) {
    if (V().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, r, `
  return vec4(lessThanEqual(a, b));
`, "bool");
    var o = new et("return float(a <= b);", t.shape, r.shape);
    return this.compileAndRun(o, [t, r], "bool");
  }, e.prototype.greater = function(t, r) {
    if (this.shouldExecuteOnCPU([t, r])) return this.cpuBackend.greater(t, r);
    if (V().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, r, `
  return vec4(greaterThan(a, b));
`, "bool");
    var o = new et("return float(a > b);", t.shape, r.shape);
    return this.compileAndRun(o, [t, r], "bool");
  }, e.prototype.greaterEqual = function(t, r) {
    if (V().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, r, `
  return vec4(greaterThanEqual(a, b));
`, "bool");
    var o = new et("return float(a >= b);", t.shape, r.shape);
    return this.compileAndRun(o, [t, r], "bool");
  }, e.prototype.logicalNot = function(t) {
    var r = new pe(t.shape, "return float(!(x >= 1.0));");
    return this.compileAndRun(r, [t]);
  }, e.prototype.logicalAnd = function(t, r) {
    if (V().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, r, `
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`, "bool");
    var o = new et("return float(a >= 1.0 && b >= 1.0);", t.shape, r.shape);
    return this.compileAndRun(o, [t, r], "bool");
  }, e.prototype.logicalOr = function(t, r) {
    if (V().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, r, `
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`, "bool");
    var o = new et("return float(a >= 1.0 || b >= 1.0);", t.shape, r.shape);
    return this.compileAndRun(o, [t, r], "bool");
  }, e.prototype.select = function(t, r, o) {
    var i = new lI(t.rank, r.shape, r.rank);
    return this.compileAndRun(i, [t, r, o], Ct(r.dtype, o.dtype));
  }, e.prototype.where = function(t) {
    os("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
    var r = t.dataSync();
    return Sf(t.shape, r);
  }, e.prototype.topk = function(t, r, o) {
    return Q1(t.dataSync(), t.shape, t.dtype, r);
  }, e.prototype.min = function(t, r) {
    Zt("min", r, t.rank);
    var o = St(t.shape, r), i = o[0], a = ee(o[1]), s = t.as2D(-1, a);
    return this.reduce(s, "min", s.dtype).reshape(i);
  }, e.prototype.minimum = function(t, r) {
    if (this.shouldExecuteOnCPU([t, r])) return this.cpuBackend.minimum(t, r);
    var o = V().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new sr(`
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;

  return result;
`, t.shape, r.shape) : new et(`
  if (isnan(a)) return a;
  if (isnan(b)) return b;

  return min(a, b);
`, t.shape, r.shape);
    return this.compileAndRun(o, [t, r]);
  }, e.prototype.mod = function(t, r) {
    var o = V().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new sr(`
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;

  return result;
`, t.shape, r.shape) : new et(`if (b == 0.0) return NAN;
  return mod(a, b);`, t.shape, r.shape);
    return this.compileAndRun(o, [t, r]);
  }, e.prototype.max = function(t, r) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.max(t, r);
    Zt("max", r, t.rank);
    var o = St(t.shape, r), i = o[0], a = ee(o[1]), s = t.as2D(-1, a);
    return this.reduce(s, "max", s.dtype).reshape(i);
  }, e.prototype.maximum = function(t, r) {
    if (this.shouldExecuteOnCPU([t, r])) return this.cpuBackend.maximum(t, r);
    var o = V().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new sr(`
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;

  return result;
`, t.shape, r.shape) : new et(`
  if (isnan(a)) return a;
  if (isnan(b)) return b;

  return max(a, b);
`, t.shape, r.shape);
    return this.compileAndRun(o, [t, r]);
  }, e.prototype.all = function(t, r) {
    Zt("all", r, t.rank);
    var o = St(t.shape, r), i = o[0], a = ee(o[1]), s = t.as2D(-1, a);
    return this.reduce(s, "all", s.dtype).reshape(i);
  }, e.prototype.any = function(t, r) {
    Zt("any", r, t.rank);
    var o = St(t.shape, r), i = o[0], a = ee(o[1]), s = t.as2D(-1, a);
    return this.reduce(s, "any", s.dtype).reshape(i);
  }, e.prototype.realDivide = function(t, r) {
    if (V().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
      return this.packedBinaryOp(t, r, `
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`, "float32", !0);
    var o = new et(`
if (a == b) {
  return 1.0;
};
return a / b;`, t.shape, r.shape);
    return this.compileAndRun(o, [t, r], "float32");
  }, e.prototype.floorDiv = function(t, r) {
    if (V().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, r, `
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`, "int32");
    var o = new et(`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`, t.shape, r.shape);
    return this.compileAndRun(o, [t, r], "int32");
  }, e.prototype.add = function(t, r) {
    if (t.dtype === "complex64" && r.dtype === "complex64") return this.complexSeparableBinaryOp(t, r, Ku);
    if (this.shouldExecuteOnCPU([t, r])) return this.cpuBackend.add(t, r);
    var o = Ct(t.dtype, r.dtype);
    if (V().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, r, Ku, o);
    var i = new et(Ku, t.shape, r.shape);
    return this.compileAndRun(i, [t, r], o);
  }, e.prototype.packedUnaryOp = function(t, r, o) {
    var i = new Di(t.shape, r);
    return this.compileAndRun(i, [t], o);
  }, e.prototype.packedBinaryOp = function(t, r, o, i, a) {
    a === void 0 && (a = !1);
    var s = new sr(o, t.shape, r.shape, a);
    return this.compileAndRun(s, [t, r], i);
  }, e.prototype.complexSeparableBinaryOp = function(t, r, o) {
    var i = this, a = this.texData.get(t.dataId), s = this.texData.get(r.dataId), u = [[a.complexTensors.real, s.complexTensors.real], [a.complexTensors.imag, s.complexTensors.imag]].map(function(d) {
      var p = d[0], v = d[1], g = i.makeComplexComponentTensorInfo(t, p), y = i.makeComplexComponentTensorInfo(r, v), x = new et(o, t.shape, r.shape);
      return i.compileAndRun(x, [g, y], Ct(p.dtype, v.dtype));
    }), l = u[0], c = u[1], f = this.complex(l, c);
    return l.dispose(), c.dispose(), f;
  }, e.prototype.makeComplexComponentTensorInfo = function(t, r) {
    return { dataId: r.dataId, dtype: r.dtype, shape: t.shape };
  }, e.prototype.addN = function(t) {
    if (t.length === 1) return t[0];
    if (t.length > V().get("WEBGL_MAX_TEXTURES_IN_SHADER")) {
      var r = Math.floor(t.length / 2), o = this.addN(t.slice(0, r)), i = this.addN(t.slice(r));
      return this.addN([o, i]);
    }
    var a = t.map(function(l) {
      return l.dtype;
    }).reduce(function(l, c) {
      return Ct(l, c);
    }), s = t.map(function(l) {
      return l.shape;
    }), u = V().getBool("WEBGL_PACK") ? new OT(t[0].shape, s) : new BT(t[0].shape, s);
    return this.compileAndRun(u, t, a);
  }, e.prototype.subtract = function(t, r) {
    if (t.dtype === "complex64" && r.dtype === "complex64") return this.complexSeparableBinaryOp(t, r, Ju);
    if (this.shouldExecuteOnCPU([t, r])) return this.cpuBackend.subtract(t, r);
    var o = Ct(t.dtype, r.dtype);
    if (V().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, r, Ju, t.dtype);
    var i = new et(Ju, t.shape, r.shape);
    return this.compileAndRun(i, [t, r], o);
  }, e.prototype.pow = function(t, r) {
    var o = V().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new sr(`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;

  return result;
`, t.shape, r.shape) : new et(`
if(a < 0.0 && floor(b) < b){
  return NAN;
}
if (b == 0.0) {
  return 1.0;
}
return (round(mod(b, 2.0)) != 1) ?
    pow(abs(a), b) : sign(a) * pow(abs(a), b);
`, t.shape, r.shape), i = Ct(t.dtype, r.dtype);
    return this.compileAndRun(o, [t, r], i);
  }, e.prototype.ceil = function(t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.ceil(t);
    if (V().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, _m, t.dtype);
    var r = new pe(t.shape, _m);
    return this.compileAndRun(r, [t]);
  }, e.prototype.floor = function(t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.floor(t);
    if (V().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, bm, t.dtype);
    var r = new pe(t.shape, bm);
    return this.compileAndRun(r, [t]);
  }, e.prototype.sign = function(t) {
    var r = new pe(t.shape, `
  if (isnan(x)) { return 0.0; }
  return sign(x);
`);
    return this.compileAndRun(r, [t]);
  }, e.prototype.isNaN = function(t) {
    var r = new pe(t.shape, "return float(isnan(x));");
    return this.compileAndRun(r, [t], "bool");
  }, e.prototype.isInf = function(t) {
    var r = new pe(t.shape, "return float(isinf(x));");
    return this.compileAndRun(r, [t], "bool");
  }, e.prototype.isFinite = function(t) {
    var r = new pe(t.shape, "return float(!isnan(x) && !isinf(x));");
    return this.compileAndRun(r, [t], "bool");
  }, e.prototype.round = function(t) {
    var r = new pe(t.shape, `
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`);
    return this.compileAndRun(r, [t]);
  }, e.prototype.exp = function(t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.exp(t);
    if (V().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, Em, t.dtype);
    var r = new pe(t.shape, Em);
    return this.compileAndRun(r, [t]);
  }, e.prototype.expm1 = function(t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.expm1(t);
    if (V().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, Cm, t.dtype);
    var r = new pe(t.shape, Cm);
    return this.compileAndRun(r, [t]);
  }, e.prototype.softmax = function(t, r) {
    var o = gt([r], t.shape), i = this.max(t, o), a = qt(i.shape, o), s = this.subtract(t, i.reshape(a)), u = this.exp(s), l = this.sum(u, o).reshape(a);
    return this.realDivide(u, l);
  }, e.prototype.log = function(t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.log(t);
    if (V().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, `
  vec4 result = log(x);
  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));
  result.r = isNaN.r == 1.0 ? NAN : result.r;
  result.g = isNaN.g == 1.0 ? NAN : result.g;
  result.b = isNaN.b == 1.0 ? NAN : result.b;
  result.a = isNaN.a == 1.0 ? NAN : result.a;

  return result;
`, t.dtype);
    var r = new pe(t.shape, `if (x < 0.0) return NAN;
  return log(x);`);
    return this.compileAndRun(r, [t]);
  }, e.prototype.log1p = function(t) {
    var r = new pe(t.shape, "return log(1.0 + x);");
    return this.compileAndRun(r, [t]);
  }, e.prototype.sqrt = function(t) {
    var r = new pe(t.shape, "return sqrt(x);");
    return this.compileAndRun(r, [t]);
  }, e.prototype.rsqrt = function(t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.rsqrt(t);
    var r = new pe(t.shape, "return inversesqrt(x);");
    return this.compileAndRun(r, [t]);
  }, e.prototype.reciprocal = function(t) {
    var r = new pe(t.shape, "return 1.0 / x;");
    return this.compileAndRun(r, [t]);
  }, e.prototype.relu = function(t) {
    var r;
    return r = V().getBool("WEBGL_PACK") ? new Di(t.shape, a0) : new pe(t.shape, r0), this.compileAndRun(r, [t]);
  }, e.prototype.relu6 = function(t) {
    var r;
    return r = V().getBool("WEBGL_PACK") ? new Di(t.shape, s0) : new pe(t.shape, o0), this.compileAndRun(r, [t]);
  }, e.prototype.prelu = function(t, r) {
    var o = V().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new sr(n0, t.shape, r.shape) : new et(t0, t.shape, r.shape);
    return this.compileAndRun(o, [t, r]);
  }, e.prototype.elu = function(t) {
    if (V().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, u0, t.dtype);
    var r = new pe(t.shape, i0);
    return this.compileAndRun(r, [t]);
  }, e.prototype.eluDer = function(t, r) {
    var o = V().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new sr(`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`, t.shape, r.shape) : new et("return (b >= 1.0) ? a : a * (b + 1.0);", t.shape, r.shape);
    return this.compileAndRun(o, [t, r]);
  }, e.prototype.selu = function(t) {
    var r = new pe(t.shape, yI);
    return this.compileAndRun(r, [t]);
  }, e.prototype.int = function(t) {
    var r = new pe(t.shape, "return float(int(x));");
    return this.compileAndRun(r, [t], "int32");
  }, e.prototype.clip = function(t, r, o) {
    var i, a = (i = V().getBool("WEBGL_PACK_CLIP") ? new jT(t.shape) : new ZT(t.shape)).getCustomSetupFunc(r, o);
    return this.compileAndRun(i, [t], null, a);
  }, e.prototype.abs = function(t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.abs(t);
    if (V().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, xm, t.dtype);
    var r = new pe(t.shape, xm);
    return this.compileAndRun(r, [t]);
  }, e.prototype.complexAbs = function(t) {
    var r = this.texData.get(t.dataId), o = new e4(t.shape), i = [this.makeComplexComponentTensorInfo(t, r.complexTensors.real), this.makeComplexComponentTensorInfo(t, r.complexTensors.imag)];
    return this.compileAndRun(o, i);
  }, e.prototype.sigmoid = function(t) {
    var r = new pe(t.shape, "return 1.0 / (1.0 + exp(-1.0 * x));");
    return this.compileAndRun(r, [t]);
  }, e.prototype.softplus = function(t) {
    var r = new pe(t.shape, `
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`);
    return this.compileAndRun(r, [t]);
  }, e.prototype.sin = function(t) {
    var r = new pe(t.shape, xI);
    return this.compileAndRun(r, [t]);
  }, e.prototype.cos = function(t) {
    var r = new pe(t.shape, wI);
    return this.compileAndRun(r, [t]);
  }, e.prototype.tan = function(t) {
    var r = new pe(t.shape, "return tan(x);");
    return this.compileAndRun(r, [t]);
  }, e.prototype.asin = function(t) {
    var r = new pe(t.shape, _I);
    return this.compileAndRun(r, [t]);
  }, e.prototype.acos = function(t) {
    var r = new pe(t.shape, bI);
    return this.compileAndRun(r, [t]);
  }, e.prototype.atan = function(t) {
    var r = new pe(t.shape, EI);
    return this.compileAndRun(r, [t]);
  }, e.prototype.atan2 = function(t, r) {
    var o = V().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new sr(`
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;

  return result;
`, t.shape, r.shape) : new et(`
  if (isnan(a)) return a;
  if (isnan(b)) return b;

  return atan(a, b);
`, t.shape, r.shape);
    return this.compileAndRun(o, [t, r]);
  }, e.prototype.sinh = function(t) {
    var r = new pe(t.shape, `
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`);
    return this.compileAndRun(r, [t]);
  }, e.prototype.cosh = function(t) {
    var r = new pe(t.shape, `
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`);
    return this.compileAndRun(r, [t]);
  }, e.prototype.tanh = function(t) {
    var r = new pe(t.shape, `
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`);
    return this.compileAndRun(r, [t]);
  }, e.prototype.asinh = function(t) {
    var r = new pe(t.shape, CI);
    return this.compileAndRun(r, [t]);
  }, e.prototype.acosh = function(t) {
    var r = new pe(t.shape, TI);
    return this.compileAndRun(r, [t]);
  }, e.prototype.atanh = function(t) {
    var r = new pe(t.shape, II);
    return this.compileAndRun(r, [t]);
  }, e.prototype.erf = function(t) {
    var r = new pe(t.shape, `
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = 0.3275911;
  float a1 = 0.254829592;
  float a2 = -0.284496736;
  float a3 = 1.421413741;
  float a4 = -1.453152027;
  float a5 = 1.061405429;

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`);
    return this.compileAndRun(r, [t]);
  }, e.prototype.step = function(t, r) {
    var o = new pe(t.shape, function(i) {
      return i === void 0 && (i = 0), Nn + `
    return x > 0.0 ? 1.0 : float(` + i + `);
  `;
    }(r));
    return this.compileAndRun(o, [t]);
  }, e.prototype.conv2dByMatMul = function(t, r, o, i, a, s) {
    var u = t.shape, l = this.texData.get(t.dataId), c = o.inChannels, f = u[0] * u[1] * u[2], d = o.outChannels, p = o.dataFormat === "channelsLast", v = (f === 1 || d === 1) && c > 1e3, g = u[2] % 2 != 0 && !!l.isPacked;
    if (v || !V().getBool("WEBGL_LAZILY_UNPACK") || !V().getBool("WEBGL_PACK_BINARY_OPERATIONS") || !g) {
      var y = p ? u[0] * u[1] * u[2] : u[0] * u[2] * u[3], x = this.reshape(t, [1, y, o.inChannels]), w = this.reshape(r, [1, o.inChannels, o.outChannels]);
      return this.reshape(this.fusedBatchMatMul({ a: x, b: w, transposeA: !1, transposeB: !1, bias: i, activation: a, preluActivationWeights: s }), o.outShape);
    }
    var b = p ? u[0] * u[1] * (u[2] + 1) : u[0] * u[2] * (u[3] + 1), _ = { dataId: t.dataId, shape: [1, b, o.inChannels], dtype: t.dtype }, E = l.shape;
    l.shape = l.shape.slice(), l.shape[l.shape.length - 2]++, k(Ia(l.shape, _.shape), function() {
      return "packed reshape " + l.shape + " to " + _.shape + " isn't free";
    });
    var C = this.reshape(r, [1, o.inChannels, o.outChannels]), A = this.fusedBatchMatMul({ a: _, b: C, transposeA: !1, transposeB: !1, bias: i, activation: a, preluActivationWeights: s }), R = this.texData.get(A.dataId);
    return k(R.isPacked, function() {
      return "batchMatMul result is expected to be packed";
    }), l.shape = E, R.shape = o.outShape, D.makeTensorFromDataId(A.dataId, o.outShape, A.dtype);
  }, e.prototype.conv2dWithIm2Row = function(t, r, o, i, a, s) {
    var u = o.filterWidth, l = o.filterHeight, c = o.inChannels, f = o.outWidth, d = o.outHeight, p = o.dataFormat === "channelsLast", v = u * l * c, g = d * f, y = [v, g], x = t.squeeze([0]), w = r.reshape([1, v, -1]), b = new W4(y, x.shape, o), _ = this.compileAndRun(b, [x]).reshape([1, y[0], y[1]]), E = i != null, C = s != null, A = a ? ka(a, !0) : null, R = new Xu(_.shape, [1, g, o.outChannels], !0, !1, E, A, C), I = [_, w];
    i && I.push(i), C && I.push(s);
    var S = this.compileAndRun(R, I);
    return p ? S.reshape([1, d, f, o.outChannels]) : S.reshape([1, o.outChannels, d, f]);
  }, e.prototype.fusedConv2d = function(t) {
    var r = t.input, o = t.filter, i = t.convInfo, a = t.bias, s = t.activation, u = t.preluActivationWeights;
    if (i.filterHeight === 1 && i.filterWidth === 1 && i.dilationHeight === 1 && i.dilationWidth === 1 && i.strideHeight === 1 && i.strideWidth === 1 && (i.padInfo.type === "SAME" || i.padInfo.type === "VALID")) return this.conv2dByMatMul(r, o, i, a, s, u);
    if (V().getBool("WEBGL_CONV_IM2COL") && r.shape[0] === 1) return this.conv2dWithIm2Row(r, o, i, a, s, u);
    var l = a != null, c = u != null, f = s ? ka(s, !1) : null, d = new cm(i, l, f, c), p = [r, o];
    return a && p.push(a), u && p.push(u), this.compileAndRun(d, p);
  }, e.prototype.conv2d = function(t, r, o) {
    if (o.filterHeight === 1 && o.filterWidth === 1 && o.dilationHeight === 1 && o.dilationWidth === 1 && o.strideHeight === 1 && o.strideWidth === 1 && (o.padInfo.type === "SAME" || o.padInfo.type === "VALID")) return this.conv2dByMatMul(t, r, o);
    if (V().getBool("WEBGL_CONV_IM2COL") && t.shape[0] === 1) return this.conv2dWithIm2Row(t, r, o);
    var i = new cm(o);
    return this.compileAndRun(i, [t, r]);
  }, e.prototype.conv2dDerInput = function(t, r, o) {
    var i = new o4(o);
    return this.compileAndRun(i, [t, r]);
  }, e.prototype.conv2dDerFilter = function(t, r, o) {
    var i = new r4(o);
    return this.compileAndRun(i, [t, r]);
  }, e.prototype.fusedDepthwiseConv2D = function(t) {
    var r, o = t.input, i = t.filter, a = t.convInfo, s = t.bias, u = t.activation, l = t.preluActivationWeights, c = V().getBool("WEBGL_PACK_DEPTHWISECONV") && a.strideWidth <= 2 && a.outChannels / a.inChannels == 1, f = u ? ka(u, c) : null, d = [o, i], p = s != null, v = l != null;
    return p && d.push(s), v && d.push(l), c ? (r = new dm(a, p, f, v), this.compileAndRun(r, d)) : (r = new fm(a, p, f, v), this.compileAndRun(r, d));
  }, e.prototype.depthwiseConv2D = function(t, r, o) {
    var i;
    return V().getBool("WEBGL_PACK_DEPTHWISECONV") && o.strideWidth <= 2 && o.outChannels / o.inChannels == 1 ? (i = new dm(o), this.compileAndRun(i, [t, r])) : (i = new fm(o), this.compileAndRun(i, [t, r]));
  }, e.prototype.depthwiseConv2DDerInput = function(t, r, o) {
    var i = new u4(o);
    return this.compileAndRun(i, [t, r]);
  }, e.prototype.depthwiseConv2DDerFilter = function(t, r, o) {
    var i = new s4(o);
    return this.compileAndRun(i, [t, r]);
  }, e.prototype.conv3d = function(t, r, o) {
    var i = new l4(o);
    return this.compileAndRun(i, [t, r]);
  }, e.prototype.conv3dDerInput = function(t, r, o) {
    var i = new a4(o);
    return this.compileAndRun(i, [t, r]);
  }, e.prototype.conv3dDerFilter = function(t, r, o) {
    var i = new i4(o);
    return this.compileAndRun(i, [t, r]);
  }, e.prototype.maxPool = function(t, r) {
    var o = new Yu(r, "max", !1);
    return this.compileAndRun(o, [t]);
  }, e.prototype.avgPool = function(t, r) {
    var o = new Yu(r, "avg", !1);
    return this.compileAndRun(o, [t], "float32");
  }, e.prototype.maxPoolBackprop = function(t, r, o, i) {
    var a = new Yu(i, "max", !0), s = this.compileAndRun(a, [r]), u = new z4(i), l = this.compileAndRun(u, [t, s], r.dtype);
    return s.dispose(), l;
  }, e.prototype.avgPoolBackprop = function(t, r, o) {
    var i = new zT(o);
    return this.compileAndRun(i, [t], r.dtype);
  }, e.prototype.cast = function(t, r) {
    return z1(t, r, this);
  }, e.prototype.unstack = function(t, r) {
    for (var o = t.shape[r], i = new Array(t.rank - 1), a = 0, s = 0; s < t.rank; s++) s !== r && (i[a++] = t.shape[s]);
    var u = new Array(t.rank).fill(0), l = t.shape.slice();
    l[r] = 1;
    var c = new Array(o);
    for (s = 0; s < c.length; s++) u[r] = s, c[s] = this.slice(t, u, l).reshape(i);
    return c;
  }, e.prototype.avgPool3d = function(t, r) {
    var o = new Qu(r, "avg", !1);
    return this.compileAndRun(o, [t], "float32");
  }, e.prototype.avgPool3dBackprop = function(t, r, o) {
    var i = new KT(o);
    return this.compileAndRun(i, [t], r.dtype);
  }, e.prototype.maxPool3d = function(t, r) {
    var o = new Qu(r, "max", !1);
    return this.compileAndRun(o, [t], "float32");
  }, e.prototype.maxPool3dBackprop = function(t, r, o, i) {
    var a = new Qu(i, "max", !0), s = this.compileAndRun(a, [r]), u = new K4(i), l = this.compileAndRun(u, [t, s], r.dtype);
    return s.dispose(), l;
  }, e.prototype.reshape = function(t, r) {
    var o = this.texData.get(t.dataId);
    if (o.isPacked && !Ia(t.shape, r) && (o.texture === null || !Ia(o.shape, r))) {
      var i = this.packedReshape(t, r);
      return D.makeTensorFromDataId(i.dataId, i.shape, i.dtype);
    }
    return Zl(t, r);
  }, e.prototype.resizeBilinear = function(t, r, o, i) {
    var a = V().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new rI(t.shape, r, o, i) : new nI(t.shape, r, o, i);
    return this.compileAndRun(a, [t], "float32");
  }, e.prototype.resizeBilinearBackprop = function(t, r, o) {
    var i = new tI(t, r, o);
    return this.compileAndRun(i, [t]);
  }, e.prototype.resizeNearestNeighbor = function(t, r, o, i) {
    var a = new iI(t.shape, r, o, i);
    return this.compileAndRun(a, [t]);
  }, e.prototype.resizeNearestNeighborBackprop = function(t, r, o) {
    var i = new oI(t, r, o);
    return this.compileAndRun(i, [t]);
  }, e.prototype.multinomial = function(t, r, o, i) {
    var a = r ? t : wr(t), s = a.shape[0], u = a.shape[1], l = new J4(s, u, o), c = l.getCustomSetupFunc(i);
    return this.compileAndRun(l, [a], "int32", c);
  }, e.prototype.oneHot = function(t, r, o, i) {
    var a = new X4(t.size, r, o, i);
    return this.compileAndRun(a, [t]);
  }, e.prototype.diag = function(t) {
    var r = new m4(t.size);
    return this.compileAndRun(r, [t]);
  }, e.prototype.nonMaxSuppression = function(t, r, o, i, a) {
    return os("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead"), Tf(t.dataSync(), r.dataSync(), o, i, a);
  }, e.prototype.cropAndResize = function(t, r, o, i, a, s) {
    var u = new c4(t.shape, r.shape, i, a, s);
    return this.compileAndRun(u, [t, r, o], "float32");
  }, e.prototype.depthToSpace = function(t, r, o) {
    k(r > 1, function() {
      return "blockSize should be > 1 for depthToSpace, but was: " + r;
    });
    var i = t.shape[0], a = o === "NHWC" ? t.shape[1] : t.shape[2], s = o === "NHWC" ? t.shape[2] : t.shape[3], u = o === "NHWC" ? t.shape[3] : t.shape[1], l = a * r, c = s * r, f = u / (r * r), d = new p4(o === "NHWC" ? [i, l, c, f] : [i, f, l, c], r, o);
    return this.compileAndRun(d, [t]);
  }, e.prototype.split = function(t, r, o) {
    return X1(t, r, o);
  }, e.prototype.scatterND = function(t, r, o) {
    var i = cs(0, t, o), a = i.sliceRank, s = i.numUpdates, u = i.sliceSize, l = i.strides, c = i.outputSize, f = [c / u, u], d = t.reshape([s, a]), p = r.reshape([s, u]);
    if (c === 0) return Zl(Tt([]), o);
    var v = K(0), g = new vm(s, a, d.rank, p.rank, l, f);
    return this.compileAndRun(g, [p, d, v]).reshape(o);
  }, e.prototype.sparseToDense = function(t, r, o, i) {
    var a = cs(0, t, o), s = a.sliceRank, u = a.numUpdates, l = a.strides, c = a.outputSize, f = new vm(u, s, t.rank, r.rank, l, [c, 1]);
    return this.compileAndRun(f, [r, t, i]).reshape(o);
  }, e.prototype.fft = function(t) {
    return this.fftImpl(t, !1);
  }, e.prototype.ifft = function(t) {
    return this.fftImpl(t, !0);
  }, e.prototype.fftImpl = function(t, r) {
    var o = this.texData.get(t.dataId), i = new pm(w4, t.shape, r), a = new pm(_4, t.shape, r), s = [this.makeComplexComponentTensorInfo(t, o.complexTensors.real), this.makeComplexComponentTensorInfo(t, o.complexTensors.imag)], u = this.compileAndRun(i, s), l = this.compileAndRun(a, s), c = this.complex(u, l).as2D(t.shape[0], t.shape[1]);
    return u.dispose(), l.dispose(), c;
  }, e.prototype.gatherND = function(t, r) {
    var o = r.shape, i = o[o.length - 1], a = U1(t, r), s = a[0], u = a[1], l = a[2], c = a[3], f = r.reshape([u, i]), d = t.reshape([t.size / l, l]), p = new C4(i, c, [u, l]);
    return this.compileAndRun(p, [d, f]).reshape(s);
  }, e.prototype.fill = function(t, r, o) {
    if ((o = o || ua(r)) === "string") {
      var i = es(o, ee(t));
      return i.fill(r), D.makeTensor(i, t, o, this);
    }
    var a = new b4(t, r), s = a.getCustomSetupFunc(r);
    return this.compileAndRun(a, [], o, s);
  }, e.prototype.onesLike = function(t) {
    if (t.dtype === "string") throw new Error("onesLike is not supported under string dtype");
    return this.fill(t.shape, 1, t.dtype);
  }, e.prototype.zerosLike = function(t) {
    return this.fill(t.shape, t.dtype === "string" ? "" : 0, t.dtype);
  }, e.prototype.linspace = function(t, r, o) {
    return K1(t, r, o);
  }, e.prototype.makeTensorInfo = function(t, r) {
    var o = this.write(null, t, r);
    return this.texData.get(o).usage = null, { dataId: o, shape: t, dtype: r };
  }, e.prototype.makeOutput = function(t, r) {
    var o = this.makeTensorInfo(t, r).dataId;
    return D.makeTensorFromDataId(o, t, r, this);
  }, e.prototype.unpackTensor = function(t) {
    var r = new AI(t.shape);
    return this.runWebGLProgram(r, [t], t.dtype);
  }, e.prototype.packTensor = function(t) {
    var r = new Y4(t.shape);
    return this.runWebGLProgram(r, [t], t.dtype, null, !0);
  }, e.prototype.packedReshape = function(t, r) {
    var o = [ns(t.shape)].concat(rs(t.shape)), i = { dtype: t.dtype, shape: o, dataId: t.dataId }, a = [ns(r)].concat(rs(r)), s = new eI(a, o), u = this.runWebGLProgram(s, [i], t.dtype, null, !0);
    return { dataId: u.dataId, shape: r, dtype: u.dtype };
  }, e.prototype.decode = function(t) {
    var r, o = this.texData.get(t), i = o.isPacked, a = o.shape, s = o.dtype, u = qu(a);
    return r = i ? new h4(u) : new d4(u), { dtype: s, shape: a, dataId: this.runWebGLProgram(r, [{ shape: u, dtype: s, dataId: t }], s, null, !0).dataId };
  }, e.prototype.runWebGLProgram = function(t, r, o, i, a) {
    var s = this;
    a === void 0 && (a = !1);
    var u = this.makeTensorInfo(t.outputShape, o), l = this.texData.get(u.dataId);
    if (t.packedOutput && (l.isPacked = !0), t.outPackingScheme === ji.DENSE) {
      var c = Gi(t.outputShape);
      l.texShape = c.map(function(b) {
        return 2 * b;
      });
    }
    if (t.outTexUsage != null && (l.usage = t.outTexUsage), ee(u.shape) === 0) return l.values = Qi(u.dtype, 0), u;
    var f = [], d = r.map(function(b) {
      if (b.dtype === "complex64") throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
      var _ = s.texData.get(b.dataId);
      if (_.texture == null) {
        if (!t.packedInputs && ee(b.shape) <= V().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) return { shape: b.shape, texData: null, isUniform: !0, uniformValues: _.values };
        t.packedInputs && (_.isPacked = !0, _.shape = b.shape);
      } else if (!!_.isPacked != !!t.packedInputs) b = _.isPacked ? s.unpackTensor(b) : s.packTensor(b), f.push(b), _ = s.texData.get(b.dataId);
      else if (_.isPacked && !Ia(_.shape, b.shape)) {
        var E = b, C = b.shape;
        b.shape = _.shape, b = s.packedReshape(b, C), f.push(b), _ = s.texData.get(b.dataId), E.shape = C;
      }
      return s.uploadToGPU(b.dataId), { shape: b.shape, texData: _, isUniform: !1 };
    });
    this.uploadToGPU(u.dataId);
    var p, v = { shape: u.shape, texData: l, isUniform: !1 }, g = function(b, _, E) {
      var C = "";
      _.concat(E).forEach(function(I) {
        var S = I.texData != null && I.texData.slice != null && I.texData.slice.flatOffset > 0, M = I.isUniform ? "uniform" : I.texData.texShape;
        C += I.shape + "_" + M + "_" + S;
      });
      var A = b.userCode, R = b.constructor.name;
      return R += "_" + C + "_" + A;
    }(t, d, v), y = this.getAndSaveBinary(g, function() {
      return function(b, _, E, C) {
        var A = _.userCode, R = E.map(function(W, q) {
          var z = { logicalShape: W.shape, texShape: W.isUniform ? null : W.texData.texShape, isUniform: W.isUniform, isPacked: !W.isUniform && W.texData.isPacked, flatOffset: null };
          return W.texData != null && W.texData.slice != null && W.texData.slice.flatOffset > 0 && (z.flatOffset = W.texData.slice.flatOffset), { name: _.variableNames[q], shapeInfo: z };
        }), I = R.map(function(W) {
          return W.shapeInfo;
        }), S = { logicalShape: C.shape, texShape: C.texData.texShape, isUniform: !1, isPacked: C.texData.isPacked, flatOffset: null }, M = VT(R, S, A, _.packedInputs), P = b.createProgram(M), B = null, O = b.getUniformLocation(P, "NAN", !1);
        V().getNumber("WEBGL_VERSION") === 1 && (B = b.getUniformLocation(P, "INFINITY", !1));
        for (var U = {}, G = 0; G < _.variableNames.length; G++) {
          var H = _.variableNames[G];
          U[H] = b.getUniformLocation(P, H, !1), U["offset" + H] = b.getUniformLocation(P, "offset" + H, !1);
        }
        return { program: _, source: M, webGLProgram: P, uniformLocations: U, inShapeInfos: I, outShapeInfo: S, infLoc: B, nanLoc: O };
      }(s.gpgpu, t, d, v);
    }), x = this.activeTimers != null;
    if (x && (p = this.startTimer()), function(b, _, E, C, A) {
      mm(_.inShapeInfos, E), mm([_.outShapeInfo], [C]);
      var R = C.texData.texture, I = C.texData.texShape;
      C.texData.isPacked ? b.setOutputPackedMatrixTexture(R, I[0], I[1]) : b.setOutputMatrixTexture(R, I[0], I[1]), b.setProgram(_.webGLProgram), V().getNumber("WEBGL_VERSION") === 1 && _.infLoc !== null && b.gl.uniform1f(_.infLoc, 1 / 0), _.nanLoc !== null && b.gl.uniform1f(_.nanLoc, NaN), E.forEach(function(S, M) {
        var P = _.program.variableNames[M], B = _.uniformLocations[P], O = _.uniformLocations["offset" + P];
        if (B != null) if (S.isUniform) if (ee(S.shape) < 2) b.gl.uniform1f(B, S.uniformValues[0]);
        else {
          var U = S.uniformValues;
          U instanceof Float32Array || (U = new Float32Array(U)), b.gl.uniform1fv(B, U);
        }
        else S.texData.slice != null && O != null && b.gl.uniform1i(O, S.texData.slice.flatOffset), b.setInputMatrixTexture(S.texData.texture, B, M);
      }), A != null && A(b, _.webGLProgram), b.executeProgram();
    }(this.gpgpu, y, d, v, i), f.forEach(function(b) {
      return s.disposeData(b.dataId);
    }), x && (p = this.endTimer(p), this.activeTimers.push({ name: t.constructor.name, query: this.getQueryTime(p) })), !V().getBool("WEBGL_LAZILY_UNPACK") && l.isPacked && a === !1) {
      var w = this.unpackTensor(u);
      return this.disposeData(u.dataId), w;
    }
    return u;
  }, e.prototype.compileAndRun = function(t, r, o, i, a) {
    a === void 0 && (a = !1), o = o || r[0].dtype;
    var s = this.runWebGLProgram(t, r, o, i, a);
    return D.makeTensorFromDataId(s.dataId, s.shape, s.dtype);
  }, e.prototype.getAndSaveBinary = function(t, r) {
    return t in this.binaryCache || (this.binaryCache[t] = r()), this.binaryCache[t];
  }, e.prototype.getTextureManager = function() {
    return this.textureManager;
  }, e.prototype.dispose = function() {
    var t = this;
    this.disposed || (V().getBool("IS_TEST") || Object.keys(this.binaryCache).forEach(function(r) {
      t.gpgpu.deleteProgram(t.binaryCache[r].webGLProgram), delete t.binaryCache[r];
    }), this.textureManager.dispose(), this.canvas != null && typeof HTMLCanvasElement < "u" && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = !0);
  }, e.prototype.floatPrecision = function() {
    var t = this;
    return this.floatPrecisionValue == null && (this.floatPrecisionValue = X(function() {
      if (!V().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
        var r = V().getBool("DEBUG");
        V().set("DEBUG", !1);
        var o = t.abs(K(1e-8)).dataSync()[0];
        if (V().set("DEBUG", r), o > 0) return 32;
      }
      return 16;
    })), this.floatPrecisionValue;
  }, e.prototype.epsilon = function() {
    return this.floatPrecision() === 32 ? 1e-7 : 1e-4;
  }, e.prototype.uploadToGPU = function(t) {
    var r, o = this.texData.get(t), i = o.shape, a = o.dtype, s = o.values, u = o.texture, l = o.usage, c = o.isPacked;
    if (u == null) {
      var f, d = this.activeTimers != null;
      d && (f = Wn());
      var p = o.texShape;
      if (p == null && (p = L3(i, c), o.texShape = p), s != null) {
        var v = qu(i), g = void 0, y = p[1], x = p[0], w = s instanceof Uint8Array;
        c ? (y = (r = ca(p[0], p[1]))[0], x = r[1], g = new x4(v, [x, y], w)) : g = new y4(v, [x, y], w);
        var b = this.makeTensorInfo([x, y], a);
        this.texData.get(b.dataId).usage = w ? en.PIXELS : en.UPLOAD, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId), y, x, s);
        var _ = this.runWebGLProgram(g, [b], a, null, !0), E = this.texData.get(_.dataId);
        o.texture = E.texture, o.texShape = E.texShape, o.isPacked = E.isPacked, o.usage = E.usage, this.disposeData(b.dataId), this.texData.delete(_.dataId), o.values = null, d && (this.uploadWaitMs += Wn() - f);
      } else {
        var C = this.acquireTexture(p, l, a, c);
        o.texture = C;
      }
    }
  }, e.prototype.convertAndCacheOnCPU = function(t, r) {
    var o = this.texData.get(t), i = o.dtype;
    return this.releaseGPUData(t), r != null && (o.values = function(a, s) {
      if (s === "float32" || s === "complex64") return a;
      if (s === "int32" || s === "bool") {
        for (var u = s === "int32" ? new Int32Array(a.length) : new Uint8Array(a.length), l = 0; l < u.length; ++l) u[l] = Math.round(a[l]);
        return u;
      }
      throw new Error("Unknown dtype " + s);
    }(r, i)), o.values;
  }, e.prototype.acquireTexture = function(t, r, o, i) {
    if (this.numBytesInGPU += this.computeBytes(t, o), !this.warnedAboutMemory && this.numBytesInGPU > 1024 * this.numMBBeforeWarning * 1024) {
      var a = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
      this.warnedAboutMemory = !0, console.warn("High memory usage in GPU: " + a + " MB, most likely due to a memory leak");
    }
    return this.textureManager.acquireTexture(t, r, i);
  }, e.prototype.computeBytes = function(t, r) {
    return t[0] * t[1] * _1(r);
  }, e;
}($1);
A1() && D.registerBackend("webgl", function() {
  return new kI();
}, 2);
var PI = N({ square_: function(n) {
  var e = T(n, "x", "square"), t = [e];
  return D.runKernelFunc(function(r, o) {
    return o([e]), r.square(e);
  }, { x: e }, null, "Square", {}, t, []);
} }), ta = "SquaredDifference", l0 = N({ squaredDifference_: function(n, e) {
  var t, r = T(n, "a", "squaredDifference"), o = T(e, "b", "squaredDifference");
  t = Qe(r, o), r = t[0], o = t[1], xe(r.shape, o.shape);
  var i = { a: r, b: o }, a = [r, o];
  return D.runKernelFunc(function(s, u) {
    var l = s.squaredDifference(r, o);
    return u([r, o]), l;
  }, i, function(s, u) {
    var l = u[0], c = u[1], f = K(2);
    return { a: function() {
      return s.mul(l.sub(c).mul(f));
    }, b: function() {
      return s.mul(c.sub(l).mul(f));
    } };
  }, ta, {}, a, []);
} }), NI = N({ abs_: function(n) {
  var e = T(n, "x", "abs");
  return e.dtype === "complex64" ? D.runKernelFunc(function(t) {
    return t.complexAbs(e);
  }, { $x: e }) : D.runKernelFunc(function(t, r) {
    var o = t.abs(e);
    return r([e]), o;
  }, { x: e }, function(t, r) {
    var o = r[0];
    return { x: function() {
      return t.mul(o.toFloat().step(-1));
    } };
  }, "Abs");
} }), MI = N({ acos_: function(n) {
  var e = T(n, "x", "acos");
  return D.runKernelFunc(function(t, r) {
    var o = t.acos(e);
    return r([e]), o;
  }, { $x: e }, function(t, r) {
    var o = r[0];
    return { $x: function() {
      return t.divStrict(K(1).sub(o.toFloat().square()).sqrt()).neg();
    } };
  });
} }), DI = N({ acosh_: function(n) {
  var e = T(n, "x", "acosh");
  return D.runKernelFunc(function(t, r) {
    var o = t.acosh(e);
    return r([e]), o;
  }, { $x: e }, function(t, r) {
    var o = r[0];
    return { $x: function() {
      return t.divStrict(o.toFloat().square().sub(1).sqrt());
    } };
  });
} }), FI = N({ asin_: function(n) {
  var e = T(n, "x", "asin");
  return D.runKernelFunc(function(t, r) {
    var o = t.asin(e);
    return r([e]), o;
  }, { $x: e }, function(t, r) {
    var o = r[0];
    return { $x: function() {
      return t.divStrict(K(1).sub(o.toFloat().square()).sqrt());
    } };
  });
} }), LI = N({ asinh_: function(n) {
  var e = T(n, "x", "asinh");
  return D.runKernelFunc(function(t, r) {
    var o = t.asinh(e);
    return r([e]), o;
  }, { $x: e }, function(t, r) {
    var o = r[0];
    return { $x: function() {
      return t.divStrict(K(1).add(o.toFloat().square()).sqrt());
    } };
  });
} }), BI = N({ atan_: function(n) {
  var e = T(n, "x", "atan");
  return D.runKernelFunc(function(t, r) {
    var o = t.atan(e);
    return r([e]), o;
  }, { $x: e }, function(t, r) {
    var o = r[0];
    return { $x: function() {
      return t.div(o.toFloat().square().add(1));
    } };
  });
} }), OI = N({ atanh_: function(n) {
  var e = T(n, "x", "atanh");
  return D.runKernelFunc(function(t, r) {
    var o = t.atanh(e);
    return r([e]), o;
  }, { $x: e }, function(t, r) {
    var o = r[0];
    return { $x: function() {
      return t.div(K(1).sub(o.toFloat().square()));
    } };
  });
} }), UI = N({ ceil_: function(n) {
  var e = T(n, "x", "ceil");
  return D.runKernelFunc(function(t) {
    return t.ceil(e);
  }, { $x: e }, function(t) {
    return { $x: function() {
      return Ie(t);
    } };
  });
} }), Pf = N({ clipByValue_: function(n, e, t) {
  var r = T(n, "x", "clipByValue");
  k(e <= t, function() {
    return "Error in clip: min (" + e + ") must be less than or equal to max (" + t + ").";
  });
  var o = [r], i = { min: e, max: t };
  return D.runKernelFunc(function(a, s) {
    var u = a.clip(r, e, t);
    return s([r]), u;
  }, { x: r }, function(a, s) {
    var u = s[0];
    return { x: function() {
      return a.where(u.greaterEqual(e).logicalAnd(u.lessEqual(t)), Ie(a));
    } };
  }, "ClipByValue", i, o);
} }), VI = N({ cos_: function(n) {
  var e = T(n, "x", "cos"), t = [e];
  return D.runKernelFunc(function(r, o) {
    var i = r.cos(e);
    return o([e]), i;
  }, { x: e }, function(r, o) {
    var i = o[0];
    return { x: function() {
      return i.toFloat().sin().neg().mul(r);
    } };
  }, "Cos", {}, t);
} }), GI = N({ cosh_: function(n) {
  var e = T(n, "x", "cosh");
  return D.runKernelFunc(function(t, r) {
    var o = t.cosh(e);
    return r([e]), o;
  }, { $x: e }, function(t, r) {
    var o = r[0];
    return { $x: function() {
      return o.toFloat().sinh().mulStrict(t);
    } };
  });
} }), WI = N({ erf_: function(n) {
  var e = T(n, "x", "erf");
  return k(e.dtype === "int32" || e.dtype === "float32", function() {
    return "Input dtype must be `int32` or `float32`.";
  }), e.dtype === "int32" && (e = e.toFloat()), D.runKernelFunc(function(t, r) {
    var o = t.erf(e);
    return r([e]), o;
  }, { $x: e }, function(t, r) {
    var o = r[0];
    return { $x: function() {
      return t.mul(o.square().neg().exp().mul(2 / Math.sqrt(Math.PI)));
    } };
  });
} }), ec = N({ exp_: function(n) {
  var e = T(n, "x", "exp");
  return D.runKernelFunc(function(t, r) {
    var o = t.exp(e);
    return r([o]), o;
  }, { x: e }, function(t, r) {
    return { x: function() {
      return t.mulStrict(r[0]);
    } };
  }, "Exp", {}, [], [!0]);
} }), HI = N({ expm1_: function(n) {
  var e = T(n, "x", "expm1");
  return D.runKernelFunc(function(t, r) {
    var o = t.expm1(e);
    return r([e]), o;
  }, { $x: e }, function(t, r) {
    var o = r[0];
    return { $x: function() {
      return t.mul(o.exp());
    } };
  });
} }), $I = N({ floor_: function(n) {
  var e = T(n, "x", "floor");
  return D.runKernelFunc(function(t) {
    return t.floor(e);
  }, { $x: e }, function(t) {
    return { $x: function() {
      return Ie(t);
    } };
  });
} }), qI = N({ log_: function(n) {
  var e = T(n, "x", "log"), t = [e];
  return D.runKernelFunc(function(r, o) {
    var i = r.log(e);
    return o([e]), i;
  }, { x: e }, function(r, o) {
    var i = o[0];
    return { x: function() {
      return r.div(i.toFloat());
    } };
  }, "Log", {}, t);
} }), zI = N({ log1p_: function(n) {
  var e = T(n, "x", "log1p");
  return D.runKernelFunc(function(t, r) {
    var o = t.log1p(e);
    return r([e]), o;
  }, { $x: e }, function(t, r) {
    var o = r[0];
    return { $x: function() {
      return t.div(o.add(1));
    } };
  });
} }), KI = N({ logSigmoid_: function(n) {
  var e = T(n, "x", "logSigmoid");
  return D.runKernelFunc(function(t, r) {
    var o = t.softplus(e.neg()).neg();
    return r([e]), o;
  }, { $x: e }, function(t, r) {
    var o = r[0];
    return { $x: function() {
      return t.mul(o.neg().sigmoid());
    } };
  });
} }), ps = N({ neg_: function(n) {
  var e = T(n, "x", "neg"), t = [e];
  return D.runKernelFunc(function(r) {
    return r.neg(e);
  }, { x: e }, function(r) {
    return { x: function() {
      return r.neg();
    } };
  }, "Neg", {}, t);
} }), JI = N({ reciprocal_: function(n) {
  var e = T(n, "x", "reciprocal");
  return D.runKernelFunc(function(t, r) {
    var o = t.reciprocal(e);
    return r([e]), o;
  }, { $x: e }, function(t, r) {
    var o = r[0];
    return { $x: function() {
      return t.div(o.square().neg());
    } };
  });
} }), XI = N({ round_: function(n) {
  var e = T(n, "x", "round");
  return D.runKernelFunc(function(t) {
    return t.round(e);
  }, { $x: e }, function(t) {
    return { $x: function() {
      return Ie(t);
    } };
  });
} }), c0 = N({ rsqrt_: function(n) {
  var e = T(n, "x", "rsqrt"), t = [e];
  return D.runKernelFunc(function(r, o) {
    var i = r.rsqrt(e);
    return o([e]), i;
  }, { x: e }, function(r, o) {
    var i = o[0];
    return { x: function() {
      return r.div(i.pow(1.5).mul(2)).neg();
    } };
  }, "Rsqrt", {}, t);
} }), f0 = N({ sigmoid_: function(n) {
  var e = T(n, "x", "sigmoid");
  return D.runKernelFunc(function(t, r) {
    var o = t.sigmoid(e);
    return r([o]), o;
  }, { x: e }, function(t, r) {
    var o = r[0];
    return { x: function() {
      return t.mul(o.mul(K(1).sub(o)));
    } };
  }, "Sigmoid");
} }), YI = N({ sign_: function(n) {
  var e = T(n, "x", "sign");
  return D.runKernelFunc(function(t) {
    return t.sign(e);
  }, { $x: e }, function(t) {
    return { $x: function() {
      return Ie(t);
    } };
  });
} }), QI = N({ isNaN_: function(n) {
  var e = T(n, "x", "isNaN");
  return D.runKernelFunc(function(t) {
    return t.isNaN(e);
  }, { $x: e }, function(t) {
    return { $x: function() {
      return Ie(t);
    } };
  });
} }), ZI = N({ isInf_: function(n) {
  var e = T(n, "x", "isInf");
  return D.runKernelFunc(function(t) {
    return t.isInf(e);
  }, { $x: e }, function(t) {
    return { $x: function() {
      return Ie(t);
    } };
  });
} }), jI = N({ isFinite_: function(n) {
  var e = T(n, "x", "isFinite");
  return D.runKernelFunc(function(t) {
    return t.isFinite(e);
  }, { $x: e }, function(t) {
    return { $x: function() {
      return Ie(t);
    } };
  });
} }), eS = N({ sin_: function(n) {
  var e = T(n, "x", "sin"), t = [e];
  return D.runKernelFunc(function(r, o) {
    var i = r.sin(e);
    return o([e]), i;
  }, { x: e }, function(r, o) {
    var i = o[0];
    return { x: function() {
      return i.toFloat().cos().mul(r);
    } };
  }, "Sin", {}, t);
} }), tS = N({ sinh_: function(n) {
  var e = T(n, "x", "sinh");
  return D.runKernelFunc(function(t, r) {
    var o = t.sinh(e);
    return r([e]), o;
  }, { $x: e }, function(t, r) {
    var o = r[0];
    return { $x: function() {
      return o.toFloat().cosh().mulStrict(t);
    } };
  });
} }), nS = N({ softplus_: function(n) {
  var e = T(n, "x", "softplus");
  return D.runKernelFunc(function(t, r) {
    var o = t.softplus(e);
    return r([e]), o;
  }, { $x: e }, function(t, r) {
    var o = r[0];
    return { $x: function() {
      return t.mul(o.sigmoid());
    } };
  });
} }), rS = N({ sqrt_: function(n) {
  var e = T(n, "x", "sqrt");
  return D.runKernelFunc(function(t, r) {
    var o = t.sqrt(e);
    return r([e]), o;
  }, { $x: e }, function(t, r) {
    var o = r[0];
    return { $x: function() {
      return t.div(o.toFloat().sqrt().mul(2));
    } };
  });
} }), oS = N({ step_: function(n, e) {
  e === void 0 && (e = 0);
  var t = T(n, "x", "step");
  return D.runKernelFunc(function(r) {
    return r.step(t, e);
  }, { $x: t }, function(r) {
    return { $x: function() {
      return Ie(r);
    } };
  });
} }), iS = N({ tan_: function(n) {
  var e = T(n, "x", "tan");
  return D.runKernelFunc(function(t, r) {
    var o = t.tan(e);
    return r([e]), o;
  }, { $x: e }, function(t, r) {
    var o = r[0];
    return { $x: function() {
      return t.div(o.cos().square());
    } };
  });
} }), aS = N({ tanh_: function(n) {
  var e = T(n, "x", "tanh");
  return D.runKernelFunc(function(t, r) {
    var o = t.tanh(e);
    return r([o]), o;
  }, { x: e }, function(t, r) {
    var o = r[0];
    return { x: function() {
      return K(1).sub(o.square()).mulStrict(t);
    } };
  }, "Tanh", {}, null, [!0]);
} });
function d0(n, e, t, r, o, i) {
  var a, s, u = T(n, "x", "batchNorm"), l = T(e, "mean", "batchNorm"), c = T(t, "variance", "batchNorm");
  return o != null && (a = T(o, "scale", "batchNorm")), r != null && (s = T(r, "offset", "batchNorm")), k(u.rank === 2, function() {
    return "Error in batchNorm3D: x must be rank 3 but got rank " + u.rank + ".";
  }), k(l.rank === 2 || l.rank === 1, function() {
    return "Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank " + l.rank + ".";
  }), k(c.rank === 2 || c.rank === 1, function() {
    return "Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank " + c.rank + ".";
  }), a != null && k(a.rank === 2 || a.rank === 1, function() {
    return "Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank " + a.rank + ".";
  }), s != null && k(s.rank === 2 || s.rank === 1, function() {
    return "Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank " + s.rank + ".";
  }), da(u, l, c, s, a, i);
}
function h0(n, e, t, r, o, i) {
  var a, s, u = T(n, "x", "batchNorm"), l = T(e, "mean", "batchNorm"), c = T(t, "variance", "batchNorm");
  return o != null && (a = T(o, "scale", "batchNorm")), r != null && (s = T(r, "offset", "batchNorm")), k(u.rank === 3, function() {
    return "Error in batchNorm3D: x must be rank 3 but got rank " + u.rank + ".";
  }), k(l.rank === 3 || l.rank === 1, function() {
    return "Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank " + l.rank + ".";
  }), k(c.rank === 3 || c.rank === 1, function() {
    return "Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank " + c.rank + ".";
  }), a != null && k(a.rank === 3 || a.rank === 1, function() {
    return "Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank " + a.rank + ".";
  }), s != null && k(s.rank === 3 || s.rank === 1, function() {
    return "Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank " + s.rank + ".";
  }), da(u, l, c, s, a, i);
}
function p0(n, e, t, r, o, i) {
  var a, s, u = T(n, "x", "batchNorm"), l = T(e, "mean", "batchNorm"), c = T(t, "variance", "batchNorm");
  return o != null && (a = T(o, "scale", "batchNorm")), r != null && (s = T(r, "offset", "batchNorm")), k(u.rank === 4, function() {
    return "Error in batchNorm4D: x must be rank 4 but got rank " + u.rank + ".";
  }), k(l.rank === 4 || l.rank === 1, function() {
    return "Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank " + l.rank + ".";
  }), k(c.rank === 4 || c.rank === 1, function() {
    return "Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank " + c.rank + ".";
  }), a != null && k(a.rank === 4 || a.rank === 1, function() {
    return "Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank " + a.rank + ".";
  }), s != null && k(s.rank === 4 || s.rank === 1, function() {
    return "Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank " + s.rank + ".";
  }), da(u, l, c, s, a, i);
}
function da(n, e, t, r, o, i) {
  i == null && (i = 1e-3);
  var a, s, u, l = T(n, "x", "batchNorm"), c = T(e, "mean", "batchNorm"), f = T(t, "variance", "batchNorm");
  o != null && (a = T(o, "scale", "batchNorm")), r != null && (s = T(r, "offset", "batchNorm")), k(c.rank === f.rank, function() {
    return "Batch normalization gradient requires mean and variance to have equal ranks.";
  }), k(s == null || c.rank === s.rank, function() {
    return "Batch normalization gradient requires mean and offset to have equal ranks.";
  }), k(a == null || c.rank === a.rank, function() {
    return "Batch normalization gradient requires mean and scale to have equal ranks.";
  }), u = l.rank === 0 || l.rank === 1 ? l.as4D(1, 1, 1, l.size) : l.rank === 2 ? l.as4D(1, 1, l.shape[0], l.shape[1]) : l.rank === 3 ? l.as4D(1, l.shape[0], l.shape[1], l.shape[2]) : l;
  var d = [l, c, f, a];
  return D.runKernelFunc(function(p, v) {
    var g = p.batchNormalization(u, Pa(c), Pa(f), i, Pa(a), Pa(s));
    return v([l, c, f, a]), g;
  }, { x: l, mean: c, variance: f, scale: a, offset: s }, function(p, v) {
    var g = v, y = g[0], x = g[1], w = g[2], b = g[3], _ = b ?? K(1), E = mt(x.shape, u.shape), C = [];
    if (x.rank === 1) {
      for (var A = 0; A < u.shape.length - 1; ++A) C.push(u.shape[A]);
      C.push(1);
    }
    var R = y.sub(x), I = p.mul(_), S = c0(w.add(K(i))), M = S.mul(S).mul(S).mul(K(-0.5));
    return { x: function() {
      return x.rank === 1 ? p.mul(zo(S.as4D(1, 1, 1, x.shape[0]), C)).mul(_).reshape(y.shape) : p.mul(S).mul(_).reshape(y.shape);
    }, mean: function() {
      var P = S.mul(K(-1)).mul(I);
      return x.rank === 1 && (P = P.sum(E)), P.reshape(x.shape);
    }, variance: function() {
      var P = M.mul(R).mul(I);
      return x.rank === 1 && (P = P.sum(E)), P.reshape(x.shape);
    }, scale: function() {
      var P = R.mul(S), B = p.mul(P);
      return x.rank === 1 && (B = B.sum(E)), B.reshape(x.shape);
    }, offset: function() {
      var P = p;
      return x.rank === 1 && (P = P.sum(E)), P.reshape(x.shape);
    } };
  }, "BatchNormalization", { varianceEpsilon: i }, d).reshape(l.shape);
}
function Pa(n) {
  return n == null ? null : n.rank === 0 ? n.as1D() : n.rank === 1 ? n : n.rank === 2 ? n.as4D(1, 1, n.shape[0], n.shape[1]) : n.rank === 3 ? n.as4D(1, n.shape[0], n.shape[1], n.shape[2]) : n;
}
function iu() {
  R1("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon");
}
var sS = N({ batchNormalization2d_: function(n, e, t, r, o, i) {
  return r === void 0 && (r = 1e-3), iu(), d0(n, e, t, i, o, r);
} }), uS = N({ batchNormalization3d_: function(n, e, t, r, o, i) {
  return r === void 0 && (r = 1e-3), iu(), h0(n, e, t, i, o, r);
} }), lS = N({ batchNormalization4d_: function(n, e, t, r, o, i) {
  return r === void 0 && (r = 1e-3), iu(), p0(n, e, t, i, o, r);
} }), cS = N({ batchNormalization_: function(n, e, t, r, o, i) {
  return r === void 0 && (r = 1e-3), iu(), da(n, e, t, i, o, r);
} }), m0 = N({ batchNorm_: da }), fS = N({ batchNorm2d_: d0 }), dS = N({ batchNorm3d_: h0 }), hS = N({ batchNorm4d_: p0 }), au = N({ logicalAnd_: function(n, e) {
  var t = T(n, "a", "logicalAnd", "bool"), r = T(e, "b", "logicalAnd", "bool");
  return xe(t.shape, r.shape), D.runKernelFunc(function(o) {
    return o.logicalAnd(t, r);
  }, { a: t, b: r }, null, "LogicalAnd");
} }), pS = N({ logicalNot_: function(n) {
  var e = T(n, "x", "logicalNot", "bool");
  return D.runKernelFunc(function(t) {
    return t.logicalNot(e);
  }, { $x: e });
} }), v0 = N({ logicalOr_: function(n, e) {
  var t = T(n, "a", "logicalOr", "bool"), r = T(e, "b", "logicalOr", "bool");
  return xe(t.shape, r.shape), D.runKernelFunc(function(o) {
    return o.logicalOr(t, r);
  }, { $a: t, $b: r });
} }), mS = N({ logicalXor_: function(n, e) {
  var t = T(n, "a", "logicalXor", "bool"), r = T(e, "b", "logicalXor", "bool");
  return xe(t.shape, r.shape), v0(n, e).logicalAnd(au(n, e).logicalNot());
} }), mo = N({ where_: function(n, e, t) {
  var r = T(e, "a", "where"), o = T(t, "b", "where"), i = T(n, "condition", "where", "bool");
  return De(r.shape, o.shape, "Error in where: "), i.rank === 1 ? k(i.shape[0] === r.shape[0], function() {
    return "The first dimension of `a` must match the size of `condition`.";
  }) : De(i.shape, o.shape, "Error in where: "), D.runKernelFunc(function(a, s) {
    var u = a.select(i, r, o);
    return s([i]), u;
  }, { $condition: i, $a: r, $b: o }, function(a, s) {
    var u = s[0];
    return { $condition: function() {
      return Ie(u).toFloat();
    }, $a: function() {
      return a.mul(u.cast(a.dtype));
    }, $b: function() {
      return a.mul(u.logicalNot().cast(a.dtype));
    } };
  });
} }), g0 = function(n) {
  return Z(this, void 0, void 0, function() {
    var e, t, r;
    return j(this, function(o) {
      switch (o.label) {
        case 0:
          return [4, (e = T(n, "condition", "whereAsync", "bool")).data()];
        case 1:
          return t = o.sent(), r = Sf(e.shape, t), n !== e && e.dispose(), [2, r];
      }
    });
  });
}, ge = N({ add_: function(n, e) {
  var t, r = T(n, "a", "add"), o = T(e, "b", "add");
  t = Qe(r, o), r = t[0], o = t[1];
  var i = xe(r.shape, o.shape);
  return D.runKernelFunc(function(a) {
    return a.add(r, o);
  }, { a: r, b: o }, function(a) {
    return { a: function() {
      var s = a, u = mt(r.shape, i);
      return u.length > 0 && (s = s.sum(u)), s.reshape(r.shape);
    }, b: function() {
      var s = a, u = mt(o.shape, i);
      return u.length > 0 && (s = s.sum(u)), s.reshape(o.shape);
    } };
  }, "Add");
} }), vS = N({ addN_: function(n) {
  k(Array.isArray(n), function() {
    return "The argument passed to tf.addN() must be a list of tensors";
  }), k(n.length >= 1, function() {
    return "Must pass at least one tensor to tf.addN(), but got " + n.length;
  });
  var e = n.map(function(o, i) {
    return T(o, "tensors" + i, "addN");
  }), t = e[0];
  e.forEach(function(o) {
    if (o.dtype !== t.dtype) throw new Error("All tensors passed to tf.addN() must have the same dtype");
  }), e.forEach(function(o) {
    if (!_t(o.shape, t.shape)) throw new Error("All tensors passed to tf.addN() must have the same shape");
  });
  var r = e;
  return D.runKernelFunc(function(o) {
    return o.addN(e);
  }, r, function(o) {
    var i = {};
    return e.forEach(function(a, s) {
      i[s] = function() {
        return o.clone();
      };
    }), i;
  }, "AddN");
} }), gS = N({ addStrict_: function(n, e) {
  var t = T(n, "a", "addStrict"), r = T(e, "b", "addStrict");
  return De(t.shape, r.shape, "Error in addStrict: "), t.add(r);
} }), yS = N({ atan2_: function(n, e) {
  var t, r = T(n, "a", "atan2"), o = T(e, "b", "atan2");
  t = Qe(r, o), r = t[0], o = t[1];
  var i = xe(r.shape, o.shape);
  return D.runKernelFunc(function(a, s) {
    var u = a.atan2(r, o);
    return s([r, o]), u;
  }, { $a: r, $b: o }, function(a, s) {
    var u = s[0], l = s[1];
    return { $a: function() {
      var c = ge(u.square(), l.square()), f = a.mul(l.div(c)), d = mt(u.shape, i);
      return d.length > 0 && (f = f.sum(d)), f.reshape(u.shape);
    }, $b: function() {
      var c = ge(u.square(), l.square()), f = ps(a.mul(u.div(c))), d = mt(l.shape, i);
      return d.length > 0 && (f = f.sum(d)), f.reshape(l.shape);
    } };
  });
} }), En = N({ div_: function(n, e) {
  var t, r = T(n, "a", "div"), o = T(e, "b", "div");
  if (t = Qe(r, o), r = t[0], o = t[1], r.dtype === "int32" && o.dtype === "int32") return y0(r, o);
  var i = xe(r.shape, o.shape);
  return D.runKernelFunc(function(a, s) {
    var u = a.realDivide(r, o);
    return s([r, o]), u;
  }, { a: r, b: o }, function(a, s) {
    var u = s[0], l = s[1];
    return { a: function() {
      var c = a.div(l.toFloat()), f = mt(u.shape, i);
      return f.length > 0 ? c.sum(f).reshape(u.shape) : c;
    }, b: function() {
      var c = a.mul(u.toFloat()), f = mt(l.shape, i);
      f.length > 0 && (c = c.sum(f).reshape(l.shape));
      var d = l.square();
      return c.div(d.toFloat()).neg();
    } };
  }, "Div");
} }), xS = N({ divNoNan_: function(n, e) {
  var t, r = T(n, "a", "div"), o = T(e, "b", "div");
  r = (t = Qe(r, o))[0], o = t[1];
  var i = En(r, o), a = Ie(i), s = o.equal(a);
  return mo(s, a, i);
} }), wS = N({ divStrict_: function(n, e) {
  var t = T(n, "a", "div"), r = T(e, "b", "div");
  return De(t.shape, r.shape, "Error in divideStrict: "), t.div(r);
} }), y0 = N({ floorDiv_: function(n, e) {
  var t, r = T(n, "a", "floorDiv"), o = T(e, "b", "floorDiv");
  t = Qe(r, o), r = t[0], o = t[1];
  var i = xe(r.shape, o.shape);
  return D.runKernelFunc(function(a, s) {
    var u = a.floorDiv(r, o);
    return s([r, o]), u;
  }, { a: r, b: o }, function(a, s) {
    var u = s[0], l = s[1];
    return { a: function() {
      var c = a.div(l.toFloat()), f = mt(u.shape, i);
      return f.length > 0 ? c.sum(f).reshape(u.shape) : c;
    }, b: function() {
      var c = a.mul(u.toFloat()), f = mt(l.shape, i);
      f.length > 0 && (c = c.sum(f).reshape(l.shape));
      var d = l.square();
      return c.div(d.toFloat()).neg();
    } };
  }, "FloorDiv");
} }), Nf = N({ maximum_: function(n, e) {
  var t, r = T(n, "a", "maximum"), o = T(e, "b", "maximum");
  return t = Qe(r, o), r = t[0], o = t[1], r.dtype === "bool" && (r = r.toInt(), o = o.toInt()), xe(r.shape, o.shape), D.runKernelFunc(function(i, a) {
    var s = i.maximum(r, o);
    return a([r, o]), s;
  }, { a: r, b: o }, function(i, a) {
    var s = a[0], u = a[1];
    return { a: function() {
      return i.mul(s.greaterEqual(u).toFloat());
    }, b: function() {
      return i.mul(s.less(u).toFloat());
    } };
  }, "Maximum");
} }), _S = N({ maximumStrict_: function(n, e) {
  var t = T(n, "a", "maximumStrict"), r = T(e, "b", "maximumStrict");
  return De(t.shape, r.shape, "Error in maximumStrict: "), t.maximum(r);
} }), x0 = N({ minimum_: function(n, e) {
  var t, r = T(n, "a", "minimum"), o = T(e, "b", "minimum");
  return t = Qe(r, o), r = t[0], o = t[1], r.dtype === "bool" && (r = r.toInt(), o = o.toInt()), xe(r.shape, o.shape), D.runKernelFunc(function(i, a) {
    var s = i.minimum(r, o);
    return a([r, o]), s;
  }, { a: r, b: o }, function(i, a) {
    var s = a[0], u = a[1];
    return { a: function() {
      return i.mul(s.lessEqual(u).toFloat());
    }, b: function() {
      return i.mul(s.greater(u).toFloat());
    } };
  }, "Minimum");
} }), bS = N({ minimumStrict_: function(n, e) {
  var t = T(n, "a", "minimumStrict"), r = T(e, "b", "minimumStrict");
  return De(t.shape, r.shape, "Error in minimumStrict: "), t.minimum(r);
} }), ES = N({ mod_: function(n, e) {
  var t, r = T(n, "a", "mod"), o = T(e, "b", "mod");
  t = Qe(r, o), r = t[0], o = t[1];
  var i = xe(r.shape, o.shape);
  return D.runKernelFunc(function(a, s) {
    var u = a.mod(r, o);
    return s([r, o]), u;
  }, { $a: r, $b: o }, function(a, s) {
    var u = s[0], l = s[1];
    return { $a: function() {
      var c = mt(u.shape, i);
      return c.length > 0 ? a.sum(c).reshape(u.shape) : a;
    }, $b: function() {
      var c = a.mul(u.div(l).floor().neg()), f = mt(l.shape, i);
      return f.length > 0 ? c.sum(f).reshape(l.shape) : c;
    } };
  });
} }), CS = N({ modStrict_: function(n, e) {
  var t = T(n, "a", "modStrict"), r = T(e, "b", "modStrict");
  return De(t.shape, r.shape, "Error in modStrict: "), t.mod(r);
} }), Nt = N({ mul_: function(n, e) {
  var t, r = T(n, "a", "mul"), o = T(e, "b", "mul");
  t = Qe(r, o), r = t[0], o = t[1];
  var i = xe(r.shape, o.shape);
  return D.runKernelFunc(function(a, s) {
    var u = a.multiply(r, o);
    return s([r, o]), u;
  }, { a: r, b: o }, function(a, s) {
    var u = s[0], l = s[1];
    return { a: function() {
      var c = a.mul(l.toFloat()), f = mt(u.shape, i);
      return f.length > 0 ? c.sum(f).reshape(u.shape) : c;
    }, b: function() {
      var c = a.mul(u.toFloat()), f = mt(l.shape, i);
      return f.length > 0 ? c.sum(f).reshape(l.shape) : c;
    } };
  }, "Mul");
} }), TS = N({ mulStrict_: function(n, e) {
  var t = T(n, "a", "mul"), r = T(e, "b", "mul");
  return De(t.shape, r.shape, "Error in multiplyStrict: "), t.mul(r);
} }), ms = N({ pow_: function(n, e) {
  var t, r = T(n, "base", "pow"), o = T(e, "exp", "pow");
  t = Qe(r, o), r = t[0], o = t[1];
  var i = xe(r.shape, o.shape), a = [r, o];
  return D.runKernelFunc(function(s, u) {
    var l = s.pow(r, o);
    return u([r, o, l]), l;
  }, { a: r, b: o }, function(s, u) {
    var l = u[0], c = u[1], f = u[2];
    return { a: function() {
      var d = c.toFloat(), p = s.mul(d.mul(l.pow(d.sub(K(1))))), v = mt(l.shape, i);
      return v.length > 0 && (p = p.sum(v)), p.reshape(l.shape);
    }, b: function() {
      var d = l.greater(0), p = l.log().where(d, Ie(l)), v = s.mul(f.mul(p)), g = mt(c.shape, i);
      return g.length > 0 && (v = v.sum(g)), v.reshape(c.shape);
    } };
  }, "Pow", {}, a, [!0]);
} }), IS = N({ powStrict_: function(n, e) {
  return De(n.shape, e.shape, "Error in powStrict: "), n.pow(e);
} }), SS = N({ squaredDifferenceStrict_: function(n, e) {
  var t = T(n, "a", "squaredDifferenceStrict"), r = T(e, "b", "squaredDifferenceStrict");
  return De(t.shape, r.shape, "Error in squaredDifferenceStrict: "), t.squaredDifference(r);
} }), vt = N({ sub_: function(n, e) {
  var t, r = T(n, "a", "sub"), o = T(e, "b", "sub");
  t = Qe(r, o), r = t[0], o = t[1];
  var i = xe(r.shape, o.shape);
  return D.runKernelFunc(function(a) {
    return a.subtract(r, o);
  }, { a: r, b: o }, function(a) {
    return { a: function() {
      var s = a, u = mt(r.shape, i);
      return u.length > 0 && (s = s.sum(u)), s.reshape(r.shape);
    }, b: function() {
      var s = a, u = mt(o.shape, i);
      return u.length > 0 && (s = s.sum(u)), s.neg().reshape(o.shape);
    } };
  }, "Sub");
} }), AS = N({ subStrict_: function(n, e) {
  var t = T(n, "a", "subStrict"), r = T(e, "b", "subStrict");
  return De(t.shape, r.shape, "Error in subStrict: "), t.sub(r);
} }), w0 = N({ equal_: function(n, e) {
  var t, r = T(n, "a", "equal"), o = T(e, "b", "equal");
  return t = Qe(r, o), r = t[0], o = t[1], xe(r.shape, o.shape), D.runKernelFunc(function(i) {
    return i.equal(r, o);
  }, { $a: r, $b: o });
} }), RS = N({ equalStrict_: function(n, e) {
  var t = T(n, "a", "equalStrict"), r = T(e, "b", "equalStrict");
  return De(t.shape, r.shape, "Error in equalStrict: "), t.equal(r);
} }), kS = N({ greater_: function(n, e) {
  var t, r = T(n, "a", "greater"), o = T(e, "b", "greater");
  return t = Qe(r, o), r = t[0], o = t[1], xe(r.shape, o.shape), D.runKernelFunc(function(i) {
    return i.greater(r, o);
  }, { a: r, b: o }, null, "Greater");
} }), _0 = N({ greaterEqual_: function(n, e) {
  var t, r = T(n, "a", "greaterEqual"), o = T(e, "b", "greaterEqual");
  return t = Qe(r, o), r = t[0], o = t[1], xe(r.shape, o.shape), D.runKernelFunc(function(i, a) {
    var s = i.greaterEqual(r, o);
    return a([r, o]), s;
  }, { a: r, b: o }, function(i, a) {
    var s = a[0], u = a[1];
    return { a: function() {
      return Ie(s);
    }, b: function() {
      return Ie(u);
    } };
  }, "GreaterEqual");
} }), PS = N({ greaterEqualStrict_: function(n, e) {
  var t = T(n, "a", "greaterEqualStrict"), r = T(e, "b", "greaterEqualStrict");
  return De(t.shape, r.shape, "Error in greaterEqualStrict: "), t.greaterEqual(r);
} }), NS = N({ greaterStrict_: function(n, e) {
  var t = T(n, "a", "greaterStrict"), r = T(e, "b", "greaterStrict");
  return De(t.shape, r.shape, "Error in greaterStrict: "), t.greater(r);
} }), MS = N({ less_: function(n, e) {
  var t, r = T(n, "a", "less"), o = T(e, "b", "less");
  return t = Qe(r, o), r = t[0], o = t[1], xe(r.shape, o.shape), D.runKernelFunc(function(i) {
    return i.less(r, o);
  }, { a: r, b: o }, null, "Less");
} }), DS = N({ lessEqual_: function(n, e) {
  var t, r = T(n, "a", "lessEqual"), o = T(e, "b", "lessEqual");
  return t = Qe(r, o), r = t[0], o = t[1], xe(r.shape, o.shape), D.runKernelFunc(function(i, a) {
    var s = i.lessEqual(r, o);
    return a([r, o]), s;
  }, { a: r, b: o }, null, "LessEqual");
} }), FS = N({ lessEqualStrict_: function(n, e) {
  var t = T(n, "a", "lessEqualStrict"), r = T(e, "b", "lessEqualStrict");
  return De(t.shape, r.shape, "Error in lessEqualStrict: "), t.lessEqual(r);
} }), LS = N({ lessStrict_: function(n, e) {
  var t = T(n, "a", "lessStrict"), r = T(e, "b", "lessStrict");
  return De(t.shape, r.shape, "Error in lessStrict: "), t.less(r);
} }), BS = N({ notEqual_: function(n, e) {
  var t, r = T(n, "a", "notEqual"), o = T(e, "b", "notEqual");
  return t = Qe(r, o), r = t[0], o = t[1], xe(r.shape, o.shape), D.runKernelFunc(function(i) {
    return i.notEqual(r, o);
  }, { a: r, b: o }, null, "NotEqual");
} }), OS = N({ notEqualStrict_: function(n, e) {
  var t = T(n, "a", "notEqualStrict"), r = T(e, "b", "notEqualStrict");
  return De(t.shape, r.shape, "Error in notEqualStrict: "), t.notEqual(r);
} });
function Tm(n, e) {
  for (var t = [], r = n; r < e; ++r) t.push(r);
  return t;
}
function Im(n) {
  for (var e = [], t = 0; t < n.length; ++t) for (var r = 0; r < n[t].length; ++r) e.push(n[t][r]);
  return e;
}
var Mf = N({ gather_: function(n, e, t) {
  t === void 0 && (t = 0);
  var r = T(n, "x", "gather"), o = T(e, "indices", "gather", "int32");
  t = gt(t, r.shape)[0];
  var i = function(a, s, u) {
    for (var l = a.shape[u], c = [], f = 1, d = 1, p = 0; p < u; p++) c.push(a.shape[p]), f *= a.shape[p];
    for (p = 0; p < s.rank; p++) c.push(s.shape[p]);
    for (p = u + 1; p < a.rank; p++) c.push(a.shape[p]), d *= a.shape[p];
    return { batchSize: f, sliceSize: d, dimSize: l, outputShape: c };
  }(r, o, t);
  return D.runKernelFunc(function(a, s) {
    var u = a.gather(r, o.flatten(), t);
    return s([o]), u;
  }, { x: r, indices: o }, function(a, s) {
    var u = s[0];
    return { x: function() {
      var l = r.shape, c = u.size, f = l.slice(0, t), d = f.length, p = l.slice(t, l.length).slice(1), v = p.length, g = Tm(0, d), y = Tm(d + 1, d + 1 + v), x = Im([f, [c], p]), w = a.reshape(x), b = u.reshape([c]), _ = Im([[d], g, y]), E = w.transpose(_), C = b0(E, b, r.shape[t]), A = xf(_);
      return C = C.transpose(A);
    }, indices: function() {
      return u;
    } };
  }, "Gather", { axis: t }).reshape(i.outputShape);
} }), b0 = N({ unsortedSegmentSum_: function(n, e, t) {
  var r = T(n, "x", "unsortedSegmentSum"), o = T(e, "segmentIds", "unsortedSegmentSum", "int32");
  return k(it(t), function() {
    return "numSegments must be of dtype int";
  }), D.runKernelFunc(function(i, a) {
    var s = i.unsortedSegmentSum(r, o, t);
    return a([o]), s;
  }, { $x: r }, function(i, a) {
    var s = a[0];
    return { $x: function() {
      return function(u, l) {
        for (var c = Nf(l, Ie(l)), f = Mf(u, c), d = _0(l, K(0, "int32")), p = f.rank - d.rank, v = 0; v < p; ++v) d = pn(d, v + 1);
        d = au(d, Si(f.shape, "bool"));
        var g = Ie(f);
        return mo(d, f, g);
      }(i, s);
    } };
  });
} }), US = function(n, e, t) {
  return Z(this, void 0, void 0, function() {
    var r, o, i, a, s, u, l, c, f, d, p, v, g;
    return j(this, function(y) {
      switch (y.label) {
        case 0:
          for (r = T(n, "tensor", "boolMask"), o = T(e, "mask", "boolMask", "bool"), i = t ?? 0, a = o.rank, s = r.shape, k(a > 0, function() {
            return "mask cannot be scalar";
          }), De(s.slice(i, i + a), o.shape, "mask's shape must match the first K dimensions of tensor's shape,"), u = 1, l = i; l < i + a; l++) u *= s[l];
          return c = s.slice(0, i).concat([u], s.slice(i + a)), f = r.reshape(c), d = o.reshape([-1]), [4, g0(d)];
        case 1:
          return p = y.sent(), v = p.squeeze([1]), g = Mf(f, v, i), n !== r && r.dispose(), e !== o && o.dispose(), v.dispose(), f.dispose(), d.dispose(), p.dispose(), [2, g];
      }
    });
  });
};
function E0(n, e, t, r, o, i, a) {
  i === void 0 && (i = "NHWC"), k(n.length === e.rank, function() {
    return "Length of inShape (" + n.length + ") and rank of dy (" + e.rank + ") must match";
  });
  var s = n, u = e, l = !1;
  e.rank === 3 && (l = !0, u = e.as4D(1, e.shape[0], e.shape[1], e.shape[2]), s = [1, n[0], n[1], n[2]]), k(s.length === 4, function() {
    return "Error in conv2dDerInput: inShape must be length 4, but got length " + s.length + ".";
  }), k(u.rank === 4, function() {
    return "Error in conv2dDerInput: dy must be rank 4, but got rank " + u.rank;
  }), k(t.rank === 4, function() {
    return "Error in conv2dDerInput: filter must be rank 4, but got rank " + t.rank;
  });
  var c = i === "NHWC" ? s[3] : s[1], f = i === "NHWC" ? u.shape[3] : u.shape[1];
  k(c === t.shape[2], function() {
    return "Error in conv2dDerInput: depth of input (" + c + ") must match input depth for filter " + t.shape[2] + ".";
  }), k(f === t.shape[3], function() {
    return "Error in conv2dDerInput: depth of output (" + f + ") must match output depth for filter " + t.shape[3] + ".";
  }), a != null && k(it(o), function() {
    return "Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + o + ".";
  });
  var d = Cf(i), p = _o(s, t.shape, r, 1, o, a, !1, d), v = D.runKernelFunc(function(g, y) {
    var x = g.conv2dDerInput(u, t, p);
    return y([t, u]), x;
  }, { dy4D: u, filter: t }, function(g, y) {
    var x = y[0], w = y[1];
    return { dy4D: function() {
      return bn(g, x, r, o, i, 1, a);
    }, filter: function() {
      return Df(g, w, x.shape, r, o, i, a);
    } };
  });
  return l ? v.as3D(v.shape[1], v.shape[2], v.shape[3]) : v;
}
function ju(n) {
  var e = function(i) {
    return typeof i == "number" ? [i, i, i] : i.length === 2 ? [i[0], i[1], 1] : i;
  }(n), t = e[0], r = e[1], o = e[2];
  return t === 1 && r === 1 && o === 1;
}
function C0(n, e, t, r, o) {
  k(n.length === e.rank, function() {
    return "Length of inShape (" + n.length + ") and rank of dy (" + e.rank + ") must match";
  });
  var i = n, a = e, s = !1;
  e.rank === 4 && (s = !0, a = e.as5D(1, e.shape[0], e.shape[1], e.shape[2], e.shape[3]), i = [1, n[0], n[1], n[2], n[3]]);
  var u = i[4], l = a.shape[4];
  k(i.length === 5, function() {
    return "Error in conv3dDerInput: inShape must be length 5, but got length " + i.length + ".";
  }), k(a.rank === 5, function() {
    return "Error in conv3dDerInput: dy must be rank 5, but got rank " + a.rank;
  }), k(t.rank === 5, function() {
    return "Error in conv3dDerInput: filter must be rank 5, but got rank " + t.rank;
  }), k(u === t.shape[3], function() {
    return "Error in conv3dDerInput: depth of input (" + u + ") must match input depth for filter " + t.shape[3] + ".";
  }), k(l === t.shape[4], function() {
    return "Error in conv3dDerInput: depth of output (" + l + ") must match output depth for filter " + t.shape[4] + ".";
  });
  var c = ds(i, t.shape, r, 1, o), f = D.runKernelFunc(function(d) {
    return d.conv3dDerInput(a, t, c);
  }, { dy5D: a });
  return s ? f.as4D(f.shape[1], f.shape[2], f.shape[3], f.shape[4]) : f;
}
var VS = N({ conv1d_: function(n, e, t, r, o, i, a) {
  o === void 0 && (o = "NWC"), i === void 0 && (i = 1);
  var s = T(n, "x", "conv1d"), u = T(e, "filter", "conv1d"), l = s, c = !1;
  s.rank === 2 && (c = !0, l = s.as3D(1, s.shape[0], s.shape[1])), k(l.rank === 3, function() {
    return "Error in conv1d: input must be rank 3, but got rank " + l.rank + ".";
  }), k(u.rank === 3, function() {
    return "Error in conv1d: filter must be rank 3, but got rank " + u.rank + ".";
  }), a != null && k(it(r), function() {
    return "Error in conv1d: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + r + ".";
  }), k(l.shape[2] === u.shape[1], function() {
    return "Error in conv1d: depth of input (" + l.shape[2] + ") must match input depth for filter " + u.shape[1] + ".";
  }), k(zt(t, i), function() {
    return "Error in conv1D: Either stride or dilation must be 1. Got stride " + t + " and dilation '" + i + "'";
  }), k(o === "NWC", function() {
    return "Error in conv1d: got dataFormat of " + o + " but only NWC is currently supported.";
  });
  var f = u.as4D(1, u.shape[0], u.shape[1], u.shape[2]), d = l.as4D(l.shape[0], 1, l.shape[1], l.shape[2]), p = bn(d, f, [1, t], r, "NHWC", [1, i], a);
  return c ? p.as2D(p.shape[2], p.shape[3]) : p.as3D(p.shape[0], p.shape[2], p.shape[3]);
} }), bn = N({ conv2d_: function(n, e, t, r, o, i, a) {
  o === void 0 && (o = "NHWC"), i === void 0 && (i = [1, 1]);
  var s = T(n, "x", "conv2d"), u = T(e, "filter", "conv2d"), l = s, c = !1;
  s.rank === 3 && (c = !0, l = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), k(l.rank === 4, function() {
    return "Error in conv2d: input must be rank 4, but got rank " + l.rank + ".";
  }), k(u.rank === 4, function() {
    return "Error in conv2d: filter must be rank 4, but got rank " + u.rank + ".";
  }), a != null && k(it(r), function() {
    return "Error in conv2d: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + r + ".";
  });
  var f = o === "NHWC" ? l.shape[3] : l.shape[1];
  k(f === u.shape[2], function() {
    return "Error in conv2d: depth of input (" + f + ") must match input depth for filter " + u.shape[2] + ".";
  }), k(zt(t, i), function() {
    return "Error in conv2D: Either strides or dilations must be 1. Got strides " + t + " and dilations '" + i + "'";
  });
  var d = Cf(o), p = _o(l.shape, u.shape, t, i, r, a, !1, d), v = [u, l], g = D.runKernelFunc(function(y, x) {
    var w = y.conv2d(l, u, p);
    return x([u, l]), w;
  }, { x: l, filter: u }, function(y, x) {
    var w = x, b = w[0], _ = w[1];
    return k(hi(i), function() {
      return "Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + i + "'";
    }), { x: function() {
      return T0(_.shape, y, b, t, r, o);
    }, filter: function() {
      return Df(_, y, b.shape, t, r, o);
    } };
  }, "Conv2D", p, v);
  return c ? g.as3D(g.shape[1], g.shape[2], g.shape[3]) : g;
} }), GS = N({ conv3d_: function(n, e, t, r, o, i) {
  o === void 0 && (o = "NDHWC"), i === void 0 && (i = [1, 1, 1]);
  var a = T(n, "x", "conv3d"), s = T(e, "filter", "conv3d"), u = a, l = !1;
  a.rank === 4 && (l = !0, u = a.as5D(1, a.shape[0], a.shape[1], a.shape[2], a.shape[3])), k(u.rank === 5, function() {
    return "Error in conv3d: input must be rank 5, but got rank " + u.rank + ".";
  }), k(s.rank === 5, function() {
    return "Error in conv3d: filter must be rank 5, but got rank " + s.rank + ".";
  }), k(u.shape[4] === s.shape[3], function() {
    return "Error in conv3d: depth of input (" + u.shape[4] + ") must match input depth for filter " + s.shape[3] + ".";
  }), k(function(d, p) {
    return ju(d) || ju(p);
  }(t, i), function() {
    return "Error in conv3D: Either strides or dilations must be 1. Got strides " + t + " and dilations '" + i + "'";
  }), k(o === "NDHWC", function() {
    return "Error in conv3d: got dataFormat of " + o + " but only NDHWC is currently supported.";
  });
  var c = ds(u.shape, s.shape, t, i, r), f = D.runKernelFunc(function(d, p) {
    var v = d.conv3d(u, s, c);
    return p([u, s]), v;
  }, { x: u, $filter: s }, function(d, p) {
    k(ju(i), function() {
      return "Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + i + "'";
    });
    var v = p[0], g = p[1];
    return { x: function() {
      return C0(v.shape, d, g, t, r);
    }, $filter: function() {
      return function(y, x, w, b, _) {
        var E = y;
        y.rank === 4 && (E = y.as5D(1, y.shape[0], y.shape[1], y.shape[2], y.shape[3]));
        var C = x;
        C.rank === 4 && (C = x.as5D(1, x.shape[0], x.shape[1], x.shape[2], x.shape[3])), k(E.rank === 5, function() {
          return "Error in conv3dDerFilter: input must be rank 5, but got shape " + E.shape + ".";
        }), k(C.rank === 5, function() {
          return "Error in conv3dDerFilter: dy must be rank 5, but got shape " + C.shape + ".";
        }), k(w.length === 5, function() {
          return "Error in conv3dDerFilter: filterShape must be length 5, but got " + w + ".";
        }), k(E.shape[4] === w[3], function() {
          return "Error in conv3dDerFilter: depth of input " + E.shape[4] + ") must match input depth in filter (" + w[3] + ".";
        }), k(C.shape[4] === w[4], function() {
          return "Error in conv3dDerFilter: depth of dy (" + C.shape[4] + ") must match output depth for filter (" + w[4] + ").";
        });
        var A = ds(E.shape, w, b, 1, _);
        return D.runKernelFunc(function(R) {
          return R.conv3dDerFilter(E, C, A);
        }, { x5D: E, dy5D: C });
      }(v, d, g.shape, t, r);
    } };
  });
  return l ? f.as4D(f.shape[1], f.shape[2], f.shape[3], f.shape[4]) : f;
} }), Df = N({ conv2dDerFilter_: function(n, e, t, r, o, i, a) {
  i === void 0 && (i = "NHWC");
  var s = n;
  n.rank === 3 && (s = n.as4D(1, n.shape[0], n.shape[1], n.shape[2]));
  var u = e;
  u.rank === 3 && (u = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])), k(s.rank === 4, function() {
    return "Error in conv2dDerFilter: input must be rank 4, but got shape " + s.shape + ".";
  }), k(u.rank === 4, function() {
    return "Error in conv2dDerFilter: dy must be rank 4, but got shape " + u.shape + ".";
  }), k(t.length === 4, function() {
    return "Error in conv2dDerFilter: filterShape must be length 4, but got " + t + ".";
  });
  var l = i === "NHWC" ? s.shape[3] : s.shape[1], c = i === "NHWC" ? u.shape[3] : u.shape[1];
  k(l === t[2], function() {
    return "Error in conv2dDerFilter: depth of input " + l + ") must match input depth in filter (" + t[2] + ".";
  }), k(c === t[3], function() {
    return "Error in conv2dDerFilter: depth of dy (" + c + ") must match output depth for filter (" + t[3] + ").";
  }), a != null && k(it(o), function() {
    return "Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + o + ".";
  });
  var f = Cf(i), d = _o(s.shape, t, r, 1, o, a, !1, f);
  return D.runKernelFunc(function(p) {
    return p.conv2dDerFilter(s, u, d);
  }, { x4D: s, dy4D: u });
} }), T0 = N({ conv2dDerInput_: E0 }), su = N({ depthwiseConv2d_: function(n, e, t, r, o, i, a) {
  i === void 0 && (i = [1, 1]);
  var s = T(n, "x", "depthwiseConv2d"), u = T(e, "filter", "depthwiseConv2d"), l = s, c = !1;
  s.rank === 3 && (c = !0, l = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), k(l.rank === 4, function() {
    return "Error in depthwiseConv2d: input must be rank 4, but got rank " + l.rank + ".";
  }), k(u.rank === 4, function() {
    return "Error in depthwiseConv2d: filter must be rank 4, but got rank " + u.rank + ".";
  }), k(l.shape[3] === u.shape[2], function() {
    return "Error in depthwiseConv2d: number of input channels (" + l.shape[3] + ") must match the inChannels dimension in filter " + u.shape[2] + ".";
  }), i == null && (i = [1, 1]), k(zt(t, i), function() {
    return "Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides " + t + " and dilations '" + i + "'";
  }), a != null && k(it(r), function() {
    return "Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + r + ".";
  });
  var f = _o(l.shape, u.shape, t, i, r, a, !0), d = [l, u], p = D.runKernelFunc(function(v, g) {
    var y = v.depthwiseConv2D(l, u, f);
    return g([l, u]), y;
  }, { x: l, filter: u }, function(v, g) {
    k(hi(i), function() {
      return "Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" + i + "'";
    });
    var y = g[0], x = g[1];
    return { x: function() {
      return I0(y.shape, v, x, f);
    }, filter: function() {
      return S0(y, v, x.shape, f);
    } };
  }, "DepthwiseConv2dNative", f, d);
  return c ? p.as3D(p.shape[1], p.shape[2], p.shape[3]) : p;
} }), I0 = N({ depthwiseConv2dDerInput_: function(n, e, t, r) {
  var o = e, i = !1;
  e.rank === 3 && (i = !0, o = e.as4D(1, e.shape[0], e.shape[1], e.shape[2]));
  var a = D.runKernelFunc(function(s) {
    return s.depthwiseConv2DDerInput(o, t, r);
  }, { dy4D: o });
  return i ? a.as3D(a.shape[1], a.shape[2], a.shape[3]) : a;
} }), S0 = N({ depthwiseConv2dDerFilter_: function(n, e, t, r) {
  var o = n;
  n.rank === 3 && (o = n.as4D(1, n.shape[0], n.shape[1], n.shape[2]));
  var i = e;
  return i.rank === 3 && (i = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])), D.runKernelFunc(function(a) {
    return a.depthwiseConv2DDerFilter(o, i, r);
  }, { x4D: o, dy4D: i });
} }), Ff = N({ separableConv2d_: function(n, e, t, r, o, i, a) {
  i === void 0 && (i = [1, 1]), a === void 0 && (a = "NHWC");
  var s = T(n, "x", "separableConv2d"), u = T(e, "depthwiseFilter", "separableConv2d"), l = T(t, "pointwiseFilter", "separableConv2d"), c = s, f = !1;
  if (s.rank === 3 && (f = !0, c = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), a === "NCHW") throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
  k(c.rank === 4, function() {
    return "Error in separableConv2d: input must be rank 4, but got rank " + c.rank + ".";
  }), k(u.rank === 4, function() {
    return "Error in separableConv2d: depthwise filter must be rank 4, but got rank " + u.rank + ".";
  }), k(l.rank === 4, function() {
    return "Error in separableConv2d: pointwise filter must be rank 4, but got rank " + u.rank + ".";
  }), k(l.shape[0] === 1, function() {
    return "Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got " + l.shape[0] + ".";
  }), k(l.shape[1] === 1, function() {
    return "Error in separableConv2d: the second dimension of pointwise filter must be 1, but got " + l.shape[1] + ".";
  });
  var d = u.shape[2], p = u.shape[3];
  k(l.shape[2] === d * p, function() {
    return "Error in separableConv2d: the third dimension of pointwise filter must be " + d * p + ", but got " + l.shape[2] + ".";
  });
  var v = su(c, u, r, o, a, i), g = bn(v, l, 1, "valid", a);
  return f ? g.as3D(g.shape[1], g.shape[2], g.shape[3]) : g;
} }), WS = N({ conv2dTranspose_: function(n, e, t, r, o, i) {
  return E0(t, T(n, "x", "conv2dTranspose"), T(e, "filter", "conv2dTranspose"), r, o, "NHWC", i);
} }), HS = N({ conv3dTranspose_: function(n, e, t, r, o) {
  return C0(t, T(n, "x", "conv3dTranspose"), T(e, "filter", "conv3dTranspose"), r, o);
} }), uu = N({ matMul_: function(n, e, t, r) {
  var o;
  t === void 0 && (t = !1), r === void 0 && (r = !1);
  var i = T(n, "a", "matMul"), a = T(e, "b", "matMul");
  o = Qe(i, a), i = o[0], a = o[1];
  var s = t ? i.shape[i.rank - 2] : i.shape[i.rank - 1], u = r ? a.shape[a.rank - 1] : a.shape[a.rank - 2], l = t ? i.shape[i.rank - 1] : i.shape[i.rank - 2], c = r ? a.shape[a.rank - 2] : a.shape[a.rank - 1], f = i.shape.slice(0, -2), d = a.shape.slice(0, -2), p = ee(f), v = ee(d);
  k(i.rank >= 2 && a.rank >= 2 && i.rank === a.rank, function() {
    return "Error in matMul: inputs must have the same rank of at least 2, got ranks " + i.rank + " and " + a.rank + ".";
  }), k(_t(f, d), function() {
    return "Error in matMul: outer dimensions (" + f + ") and (" + d + ") of Tensors with shapes " + i.shape + " and " + a.shape + " must match.";
  }), k(s === u, function() {
    return "Error in matMul: inner shapes (" + s + ") and (" + u + ") of Tensors with shapes " + i.shape + " and " + a.shape + " and transposeA=" + t + " and transposeB=" + r + " must match.";
  });
  var g = i.shape.slice(0, -2).concat([l, c]), y = t ? i.as3D(p, s, l) : i.as3D(p, l, s), x = r ? a.as3D(v, c, u) : a.as3D(v, u, c), w = { transposeA: t, transposeB: r };
  return D.runKernelFunc(function(b, _) {
    var E = b.batchMatMul(y, x, t, r);
    return _([y, x]), E;
  }, { a: y, b: x }, function(b, _) {
    var E = _, C = E[0], A = E[1];
    return t || r ? !t && r ? { a: function() {
      return b.matMul(A, !1, !1);
    }, b: function() {
      return b.matMul(C, !0, !1);
    } } : t && !r ? { a: function() {
      return A.matMul(b, !1, !0);
    }, b: function() {
      return C.matMul(b, !1, !1);
    } } : { a: function() {
      return A.matMul(b, !0, !0);
    }, b: function() {
      return b.matMul(C, !0, !0);
    } } : { a: function() {
      return b.matMul(A, !1, !0);
    }, b: function() {
      return C.matMul(b, !0, !1);
    } };
  }, "BatchMatMul", w).reshape(g);
} }), $S = N({ dot_: function(n, e) {
  var t = T(n, "t1", "dot"), r = T(e, "t2", "dot");
  k(!(t.rank !== 1 && t.rank !== 2 || r.rank !== 1 && r.rank !== 2), function() {
    return "Error in dot: inputs must all be rank 1 or 2, but got ranks " + t.rank + " and " + r.rank + ".";
  });
  var o = t.rank === 1 ? t.size : t.shape[1], i = r.rank === 1 ? r.size : r.shape[0];
  return k(o === i, function() {
    return "Error in dot: inner dimensions of inputs must match, but got " + o + " and " + i + ".";
  }), t.rank === 1 && r.rank === 1 ? t.as2D(1, -1).matMul(r.as2D(-1, 1)).asScalar() : t.rank === 1 && r.rank === 2 ? t.as2D(1, -1).matMul(r.as2D(r.shape[0], r.shape[1])).as1D() : t.rank === 2 && r.rank === 1 ? t.matMul(r.as2D(-1, 1)).as1D() : t.matMul(r.as2D(r.shape[0], r.shape[1]));
} }), qS = N({ outerProduct_: function(n, e) {
  var t = T(n, "v1", "outerProduct"), r = T(e, "v2", "outerProduct");
  return k(t.rank === 1 && r.rank === 1, function() {
    return "Error in outerProduct: inputs must be rank 1, but got ranks " + t.rank + " and " + r.rank + ".";
  }), t.as2D(-1, 1).matMul(r.as2D(1, -1));
} }), ha = N({ reverse_: function(n, e) {
  var t = T(n, "x", "reverse");
  if (t.rank === 0) return t.clone();
  var r = gt(e, t.shape);
  return D.runKernelFunc(function(o) {
    return o.reverse(t, r);
  }, { $x: t }, function(o) {
    return { $x: function() {
      return o.reverse(r);
    } };
  }).reshapeAs(t);
} }), zS = N({ reverse1d_: function(n) {
  var e = T(n, "x", "reverse");
  return k(e.rank === 1, function() {
    return "Error in reverse1D: x must be rank 1 but got rank " + e.rank + ".";
  }), ha(e, 0);
} }), KS = N({ reverse2d_: function(n, e) {
  var t = T(n, "x", "reverse");
  return k(t.rank === 2, function() {
    return "Error in reverse2D: x must be rank 2 but got rank " + t.rank + ".";
  }), ha(t, e);
} }), JS = N({ reverse3d_: function(n, e) {
  var t = T(n, "x", "reverse");
  return k(t.rank === 3, function() {
    return "Error in reverse3D: x must be rank 3 but got rank " + t.rank + ".";
  }), ha(t, e);
} }), XS = N({ reverse4d_: function(n, e) {
  var t = T(n, "x", "reverse");
  return k(t.rank === 4, function() {
    return "Error in reverse4D: x must be rank 4 but got rank " + t.rank + ".";
  }), ha(t, e);
} });
function A0(n, e, t, r, o, i) {
  var a = T(n, "x", "maxPool"), s = a, u = !1;
  a.rank === 3 && (u = !0, s = a.as4D(1, a.shape[0], a.shape[1], a.shape[2])), k(s.rank === 4, function() {
    return "Error in maxPool: input must be rank 4 but got rank " + s.rank + ".";
  }), k(zt(t, r), function() {
    return "Error in maxPool: Either strides or dilations must be 1. Got strides " + t + " and dilations '" + r + "'";
  }), i != null && k(it(o), function() {
    return "Error in maxPool: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + o + ".";
  });
  var l = ea(s.shape, e, t, r, o, i);
  if (l.filterWidth === 1 && l.filterHeight === 1 && _t(l.inShape, l.outShape)) return a.clone();
  var c = [s], f = D.runKernelFunc(function(d, p) {
    var v = d.maxPool(s, l);
    return p([s, v]), v;
  }, { x: s }, function(d, p) {
    var v = p[0], g = p[1];
    return { x: function() {
      return function(y, x, w, b, _, E, C, A) {
        var R = T(y, "dy", "maxPoolBackprop"), I = T(x, "input", "maxPoolBackprop"), S = T(w, "output", "maxPoolBackprop");
        k(I.rank === R.rank, function() {
          return "Rank of input (" + I.rank + ") does not match rank of dy (" + R.rank + ")";
        }), k(zt(_, E), function() {
          return "Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides " + _ + " and dilations '" + E + "'";
        }), k(R.rank === 4, function() {
          return "Error in maxPoolBackprop: dy must be rank 4 but got rank " + R.rank + ".";
        }), k(I.rank === 4, function() {
          return "Error in maxPoolBackprop: input must be rank 4 but got rank " + I.rank + ".";
        });
        var M = ea(I.shape, b, _, E, C, A);
        return D.runKernelFunc(function(P) {
          return P.maxPoolBackprop(R, I, S, M);
        }, { $dy: R, $input: I });
      }(d, v, g, e, t, r, o);
    } };
  }, "MaxPool", l, c);
  return u ? f.as3D(f.shape[1], f.shape[2], f.shape[3]) : f;
}
function R0(n, e, t, r, o, i) {
  var a = T(n, "x", "avgPool", "float32");
  k(zt(t, r), function() {
    return "Error in avgPool: Either strides or dilations must be 1. Got strides " + t + " and dilations '" + r + "'";
  });
  var s = a, u = !1;
  a.rank === 3 && (u = !0, s = a.as4D(1, a.shape[0], a.shape[1], a.shape[2])), k(s.rank === 4, function() {
    return "Error in avgPool: x must be rank 4 but got rank " + s.rank + ".";
  }), i != null && k(it(o), function() {
    return "Error in avgPool: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + o + ".";
  });
  var l = ea(s.shape, e, t, r, o, i);
  if (l.filterWidth === 1 && l.filterHeight === 1 && _t(l.inShape, l.outShape)) return a.clone();
  var c = D.runKernelFunc(function(f) {
    return f.avgPool(s, l);
  }, { x: s }, function(f) {
    return { x: function() {
      return function(d, p, v, g, y, x) {
        var w = T(d, "dy", "avgPoolBackprop"), b = T(p, "input", "avgPoolBackprop");
        k(b.rank === w.rank, function() {
          return "Rank of input (" + b.rank + ") does not match rank of dy (" + w.rank + ")";
        }), k(zt(g, y), function() {
          return "Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides " + g + " and dilations '" + y + "'";
        });
        var _ = b, E = w, C = !1;
        b.rank === 3 && (C = !0, _ = b.as4D(1, b.shape[0], b.shape[1], b.shape[2]), E = w.as4D(1, w.shape[0], w.shape[1], w.shape[2])), k(E.rank === 4, function() {
          return "Error in avgPoolBackprop: dy must be rank 4 but got rank " + E.rank + ".";
        }), k(_.rank === 4, function() {
          return "Error in avgPoolBackprop: input must be rank 4 but got rank " + _.rank + ".";
        });
        var A = ea(_.shape, v, g, y, x), R = D.runKernelFunc(function(I) {
          return I.avgPoolBackprop(E, _, A);
        }, { dy4D: E, input4D: _ });
        return C ? R.as3D(R.shape[1], R.shape[2], R.shape[3]) : R;
      }(f, s, e, t, r, o);
    } };
  }, "AvgPool", l);
  return c = c.cast(a.dtype), u ? c.as3D(c.shape[1], c.shape[2], c.shape[3]) : c;
}
var wt = N({ maxPool_: function(n, e, t, r, o) {
  return A0(n, e, t, 1, r, o);
} }), pa = N({ avgPool_: function(n, e, t, r, o) {
  return R0(n, e, t, 1, r, o);
} }), YS = N({ pool_: function(n, e, t, r, o, i) {
  o == null && (o = [1, 1]), i == null && (i = 1), r === 0 && (r = "valid");
  var a = T(n, "x", "maxPool"), s = a, u = !1;
  a.rank === 3 && (u = !0, s = a.as4D(1, a.shape[0], a.shape[1], a.shape[2])), k(zt(i, o), function() {
    return "Error in pool: Either strides or dilations must be 1. Got strides " + i + " and dilations '" + o + "'";
  });
  var l, c = ea(s.shape, e, i, o, r), f = [c.dilationHeight, c.dilationWidth];
  l = r === "same" ? function(_, E) {
    var C = _.map(function(I, S) {
      return I + (I - 1) * (E[S] - 1);
    }).map(function(I) {
      return I - 1;
    }), A = C.map(function(I) {
      return Math.floor(I / 2);
    }), R = C.map(function(I, S) {
      return I - A[S];
    });
    return C.map(function(I, S) {
      return [A[S], R[S]];
    });
  }([c.filterHeight, c.filterWidth], f) : [[0, 0], [0, 0]];
  var d = f[0] === 1 && f[1] === 1, p = function(_, E, C) {
    var A = C.map(function(O) {
      return O[0];
    }), R = C.map(function(O) {
      return O[1];
    }), I = _.concat(A, R), S = E.map(function(O, U) {
      return (O - I[U] % O) % O;
    }), M = R.map(function(O, U) {
      return O + S[U];
    }), P = E.map(function(O, U) {
      return [A[U], M[U]];
    }), B = E.map(function(O, U) {
      return [0, S[U]];
    });
    return [P, B];
  }([c.inHeight, c.inWidth], f, l), v = p[0], g = p[1], y = d ? r : "valid", x = d ? s : F1(s, f, v), w = (t === "avg" ? function() {
    return R0(x, e, i, 1, y);
  } : function() {
    return A0(x, e, i, 1, y);
  })(), b = d ? w : N1(w, f, g);
  return u ? b.as3D(b.shape[1], b.shape[2], b.shape[3]) : b;
} }), QS = N({ maxPool3d_: function(n, e, t, r, o, i, a) {
  i === void 0 && (i = "NDHWC");
  var s = T(n, "x", "maxPool3d"), u = s, l = !1;
  s.rank === 4 && (l = !0, u = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3])), a == null && (a = [1, 1, 1]), k(u.rank === 5, function() {
    return "Error in maxPool3d: x must be rank 5 but got rank " + u.rank + ".";
  }), k(i === "NDHWC", function() {
    return "Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of " + i;
  }), k(zt(t, a), function() {
    return "Error in maxPool3d: Either strides or dilations must be 1. Got strides " + t + " and dilations '" + a + "'";
  }), o != null && k(it(r), function() {
    return "Error in maxPool3d: pad must be an integer when using, dimRoundingMode " + o + " but got pad " + r + ".";
  });
  var c = fs(u.shape, e, t, a, r, o, i), f = D.runKernelFunc(function(d, p) {
    var v = d.maxPool3d(u, c);
    return p([u, v]), v;
  }, { x: u }, function(d, p) {
    var v = p[0], g = p[1];
    return { x: function() {
      return function(y, x, w, b, _, E, C, A) {
        var R = T(y, "dy", "maxPool3dBackprop"), I = T(x, "input", "maxPool3dBackprop"), S = T(w, "output", "maxPool3dBackprop"), M = R, P = I, B = S, O = !1;
        I.rank === 4 && (O = !0, M = R.as5D(1, R.shape[0], R.shape[1], R.shape[2], R.shape[3]), P = I.as5D(1, I.shape[0], I.shape[1], I.shape[2], I.shape[3]), B = S.as5D(1, S.shape[0], S.shape[1], S.shape[2], S.shape[3])), k(M.rank === 5, function() {
          return "Error in maxPool3dBackprop: dy must be rank 5 but got rank " + M.rank + ".";
        }), k(P.rank === 5, function() {
          return "Error in maxPool3dBackprop: input must be rank 5 but got rank " + P.rank + ".";
        }), k(B.rank === 5, function() {
          return "Error in maxPool3dBackprop: output must be rank 5 but got rank " + B.rank + ".";
        }), E == null && (E = [1, 1, 1]), k(zt(_, E), function() {
          return "Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides " + _ + " and dilations '" + E + "'";
        }), A != null && k(it(C), function() {
          return "Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode " + A + " but got pad " + C + ".";
        });
        var U = fs(P.shape, b, _, E, C, A), G = D.runKernelFunc(function(H) {
          return H.maxPool3dBackprop(M, P, B, U);
        }, { dy5D: M, input5D: P });
        return O ? G.as4D(G.shape[1], G.shape[2], G.shape[3], G.shape[4]) : G;
      }(d, v, g, e, t, a, r, o);
    } };
  });
  return l ? f.as4D(f.shape[1], f.shape[2], f.shape[3], f.shape[4]) : f;
} }), ZS = N({ avgPool3d_: function(n, e, t, r, o, i, a) {
  i === void 0 && (i = "NDHWC");
  var s = T(n, "x", "avgPool3d", "float32"), u = s, l = !1;
  s.rank === 4 && (l = !0, u = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3])), a == null && (a = [1, 1, 1]), k(u.rank === 5, function() {
    return "Error in avgPool3d: x must be rank 5 but got rank " + u.rank + ".";
  }), k(i === "NDHWC", function() {
    return "Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of " + i;
  }), k(zt(t, a), function() {
    return "Error in avgPool3d: Either strides or dilations must be 1. Got strides " + t + " and dilations '" + a + "'";
  }), o != null && k(it(r), function() {
    return "Error in avgPool3d: pad must be an integer when using, dimRoundingMode " + o + " but got pad " + r + ".";
  });
  var c = fs(u.shape, e, t, a, r, o, i), f = D.runKernelFunc(function(d) {
    return d.avgPool3d(u, c);
  }, { x: u }, function(d) {
    return { x: function() {
      return function(p, v, g, y, x, w, b) {
        var _ = T(p, "dy", "avgPool3dBackprop"), E = T(v, "input", "avgPool3dBackprop"), C = _, A = E, R = !1;
        E.rank === 4 && (R = !0, C = _.as5D(1, _.shape[0], _.shape[1], _.shape[2], _.shape[3]), A = E.as5D(1, E.shape[0], E.shape[1], E.shape[2], E.shape[3])), k(C.rank === 5, function() {
          return "Error in avgPool3dBackprop: dy must be rank 5 but got rank " + C.rank + ".";
        }), k(A.rank === 5, function() {
          return "Error in avgPool3dBackprop: input must be rank 5 but got rank " + A.rank + ".";
        }), x == null && (x = [1, 1, 1]), k(zt(y, x), function() {
          return "Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides " + y + " and dilations '" + x + "'";
        }), b != null && k(it(w), function() {
          return "Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode " + b + " but got pad " + w + ".";
        });
        var I = fs(A.shape, g, y, x, w, b), S = D.runKernelFunc(function(M) {
          return M.avgPool3dBackprop(C, A, I);
        }, { dy5D: C, input5D: A });
        return R ? S.as4D(S.shape[1], S.shape[2], S.shape[3], S.shape[4]) : S;
      }(d, u, e, t, a, r, o);
    } };
  });
  return f = f.cast(u.dtype), l ? f.as4D(f.shape[1], f.shape[2], f.shape[3], f.shape[4]) : f;
} }), Qn = N({ slice_: function(n, e, t) {
  var r, o, i = T(n, "x", "slice");
  if (i.rank === 0) throw new Error("Slicing scalar is not possible");
  (r = typeof e == "number" ? [e].concat(new Array(i.rank - 1).fill(0)) : e.length < i.rank ? e.concat(new Array(i.rank - e.length).fill(0)) : e.slice()).forEach(function(u) {
    k(u !== -1, function() {
      return "slice() does not support negative begin indexing.";
    });
  }), o = (o = t == null ? new Array(i.rank).fill(-1) : typeof t == "number" ? [t].concat(new Array(i.rank - 1).fill(-1)) : t.length < i.rank ? t.concat(new Array(i.rank - t.length).fill(-1)) : t).map(function(u, l) {
    return u >= 0 ? u : (k(u === -1, function() {
      return "Negative size values should be exactly -1 but got " + u + " for the slice() size at index " + l + ".";
    }), i.shape[l] - r[l]);
  }), IT(i, r, o);
  var a = i.shape, s = { begin: r, size: o };
  return D.runKernelFunc(function(u) {
    return u.slice(i, r, o);
  }, { x: i }, function(u) {
    for (var l = [], c = 0; c < u.rank; c++) l.push([r[c], a[c] - r[c] - o[c]]);
    return { x: function() {
      return u.pad(l);
    } };
  }, "Slice", s);
} }), jS = N({ slice1d_: function(n, e, t) {
  var r = T(n, "x", "slice1d");
  return k(r.rank === 1, function() {
    return "slice1d expects a rank-1 tensor, but got a rank-" + r.rank + " tensor";
  }), Qn(r, [e], [t]);
} }), eA = N({ slice2d_: function(n, e, t) {
  var r = T(n, "x", "slice2d");
  return k(r.rank === 2, function() {
    return "slice2d expects a rank-2 tensor, but got a rank-" + r.rank + " tensor";
  }), Qn(r, e, t);
} }), k0 = N({ slice3d_: function(n, e, t) {
  var r = T(n, "x", "slice3d");
  return k(r.rank === 3, function() {
    return "slice3d expects a rank-3 tensor, but got a rank-" + r.rank + " tensor";
  }), Qn(r, e, t);
} }), tA = N({ slice4d_: function(n, e, t) {
  var r = T(n, "x", "slice4d");
  return k(r.rank === 4, function() {
    return "slice4d expects a rank-4 tensor, but got a rank-" + r.rank + " tensor";
  }), Qn(r, e, t);
} });
function P0(n, e, t, r, o) {
  return e.rank < t.rank && (e = e.reshape(qt(e.shape, r))), n.rank < t.rank && (n = n.reshape(qt(n.shape, r))), { x: function() {
    var i = n.mul(t.equal(e).cast(n.dtype));
    return o == null ? i : i.transpose(o);
  } };
}
var nA = N({ all_: function(n, e, t) {
  e === void 0 && (e = null), t === void 0 && (t = !1);
  var r = T(n, "x", "all", "bool"), o = gt(e, r.shape), i = o, a = er(i, r.rank);
  a != null && (r = r.transpose(a), i = tr(i.length, r.rank));
  var s = D.runKernelFunc(function(l) {
    return l.all(r, i);
  }, { $x: r });
  if (t) {
    var u = qt(s.shape, o);
    return s.reshape(u);
  }
  return s;
} }), rA = N({ any_: function(n, e, t) {
  e === void 0 && (e = null), t === void 0 && (t = !1);
  var r = T(n, "x", "any", "bool"), o = gt(e, r.shape), i = o, a = er(i, r.rank);
  a != null && (r = r.transpose(a), i = tr(i.length, r.rank));
  var s = D.runKernelFunc(function(l) {
    return l.any(r, i);
  }, { $x: r });
  if (t) {
    var u = qt(s.shape, o);
    return s.reshape(u);
  }
  return s;
} }), oA = N({ argMax_: function(n, e) {
  e === void 0 && (e = 0);
  var t = T(n, "x", "argMax");
  e == null && (e = 0);
  var r = gt(e, t.shape), o = er(r, t.rank);
  o != null && (t = t.transpose(o), r = tr(r.length, t.rank));
  var i = { axis: r[0] }, a = [t];
  return D.runKernelFunc(function(s, u) {
    var l = s.argMax(t, r[0]);
    return u([t]), l;
  }, { x: t }, function(s, u) {
    var l = u[0];
    return { x: function() {
      return Ie(l);
    } };
  }, "ArgMax", i, a);
} }), iA = N({ argMin_: function(n, e) {
  e === void 0 && (e = 0);
  var t = T(n, "x", "argMin");
  e == null && (e = 0);
  var r = gt(e, t.shape), o = er(r, t.rank);
  return o != null && (t = t.transpose(o), r = tr(r.length, t.rank)), D.runKernelFunc(function(i, a) {
    var s = i.argMin(t, r[0]);
    return a([t]), s;
  }, { $x: t }, function(i, a) {
    var s = a[0];
    return { $x: function() {
      return Ie(s);
    } };
  });
} }), aA = N({ logSumExp_: function(n, e, t) {
  e === void 0 && (e = null), t === void 0 && (t = !1);
  var r = T(n, "x", "logSumExp"), o = gt(e, r.shape), i = r.max(o, !0), a = r.sub(i).exp().sum(o).log(), s = i.reshape(a.shape).add(a);
  if (t) {
    var u = qt(s.shape, o);
    return s.reshape(u);
  }
  return s;
} }), lu = N({ max_: function(n, e, t) {
  e === void 0 && (e = null), t === void 0 && (t = !1);
  var r = T(n, "x", "max"), o = r, i = gt(e, r.shape), a = i, s = er(a, r.rank);
  s != null && (r = r.transpose(s), a = tr(a.length, r.rank));
  var u = [r], l = D.runKernelFunc(function(f, d) {
    var p = f.max(r, a);
    return d([o, p]), p;
  }, { x: r }, function(f, d) {
    return P0(f, d[1], d[0], i, s);
  }, "Max", { axes: a }, u, [!0]);
  if (t) {
    var c = qt(l.shape, i);
    l = l.reshape(c);
  }
  return l;
} }), sA = N({ mean_: function(n, e, t) {
  e === void 0 && (e = null), t === void 0 && (t = !1);
  var r = T(n, "x", "mean"), o = gt(e, r.shape), i = ee(St(r.shape, o)[1]);
  return ou(function(a) {
    var s = K(i);
    return { value: (s.dtype === a.dtype ? a : a.cast(s.dtype)).div(s).sum(e, t), gradFunc: function(u) {
      var l = a.shape.slice();
      return o.forEach(function(c) {
        l[c] = 1;
      }), u.reshape(l).mul(Si(a.shape, "float32")).div(i);
    } };
  })(r);
} }), uA = N({ min_: function(n, e, t) {
  e === void 0 && (e = null), t === void 0 && (t = !1);
  var r = T(n, "x", "min"), o = r, i = gt(e, r.shape), a = i, s = er(a, r.rank);
  s != null && (r = r.transpose(s), a = tr(a.length, r.rank));
  var u = [r], l = D.runKernelFunc(function(f, d) {
    var p = f.min(r, a);
    return d([o, p]), p;
  }, { x: r }, function(f, d) {
    return P0(f, d[1], d[0], i, s);
  }, "Min", { axes: a }, u, [!0]);
  if (t) {
    var c = qt(l.shape, i);
    l = l.reshape(c);
  }
  return l;
} }), lA = N({ moments_: function(n, e, t) {
  e === void 0 && (e = null), t === void 0 && (t = !1);
  var r = gt(e, (n = T(n, "x", "moments")).shape), o = n.mean(r, t), i = o.shape;
  t || (i = qt(o.shape, r));
  var a = n.toFloat().sub(o.reshape(i)).square();
  return { mean: o, variance: a.mean(r, t) };
} }), N0 = N({ sum_: function(n, e, t) {
  e === void 0 && (e = null), t === void 0 && (t = !1);
  var r = T(n, "x", "sum");
  r.dtype === "bool" && (r = r.toInt());
  var o = gt(e, r.shape);
  return ou(function(i) {
    var a = er(o, i.rank), s = o, u = i;
    a != null && (u = i.transpose(a), s = tr(s.length, i.rank));
    var l = function(p) {
      var v = i.shape.slice();
      return o.forEach(function(g) {
        v[g] = 1;
      }), p.reshape(v).mul(Si(i.shape, "float32"));
    }, c = { axes: s }, f = D.runKernelFunc(function(p) {
      return p.sum(u, s);
    }, { x: u }, function(p) {
      return { x: function() {
        return l(p);
      } };
    }, "Sum", c);
    if (t) {
      var d = qt(f.shape, o);
      f = f.reshape(d);
    }
    return { value: f, gradFunc: l };
  })(r);
} }), cA = N({ prod_: function(n, e, t) {
  e === void 0 && (e = null), t === void 0 && (t = !1);
  var r = T(n, "x", "prod");
  r.dtype === "bool" && (r = r.toInt());
  var o = gt(e, r.shape), i = er(o, r.rank), a = o, s = r;
  i != null && (s = r.transpose(i), a = tr(a.length, r.rank));
  var u = D.runKernelFunc(function(c) {
    return c.prod(s, a);
  }, { permutedX: s });
  if (t) {
    var l = qt(u.shape, o);
    u = u.reshape(l);
  }
  return u;
} }), M0 = N({ elu_: function(n) {
  var e = T(n, "x", "elu");
  return D.runKernelFunc(function(t, r) {
    var o = t.elu(e);
    return r([o]), o;
  }, { $x: e }, function(t, r) {
    var o = r[0];
    return { $x: function() {
      return D.runKernelFunc(function(i) {
        return i.eluDer(t, o);
      }, { dy: t, y: o });
    } };
  });
} }), fA = N({ leakyRelu_: function(n, e) {
  e === void 0 && (e = 0.2);
  var t = T(n, "x", "leakyRelu");
  return Nf(K(e).mul(t), t);
} }), D0 = N({ prelu_: function(n, e) {
  var t = T(n, "x", "prelu"), r = T(e, "alpha", "prelu");
  return D.runKernelFunc(function(o, i) {
    var a = o.prelu(t, r);
    return i([t, r]), a;
  }, { x: t, alpha: r }, function(o, i) {
    var a = i[0], s = i[1], u = a.greater(0);
    return { x: function() {
      return mo(u, o, o.mul(s));
    }, alpha: function() {
      var l = mo(u, Ie(o), o.mul(a)), c = mt(s.shape, o.shape);
      return c.length > 0 && (l = l.sum(c)), l.reshape(s.shape);
    } };
  }, "Prelu");
} }), Xe = N({ relu_: function(n) {
  var e = T(n, "x", "relu");
  return e.dtype === "bool" ? e.toInt() : D.runKernelFunc(function(t, r) {
    var o = t.relu(e);
    return r([e]), o;
  }, { x: e }, function(t, r) {
    var o = r[0];
    return { x: function() {
      return t.mulStrict(o.step().toFloat());
    } };
  }, "Relu");
} }), F0 = N({ relu6_: function(n) {
  var e = T(n, "x", "relu6");
  return e.dtype === "bool" ? e.toInt() : D.runKernelFunc(function(t, r) {
    var o = t.relu6(e);
    return r([e]), o;
  }, { x: e }, function(t, r) {
    var o = r[0], i = o.lessEqual(6).mul(o.step());
    return { x: function() {
      return t.mulStrict(i.toFloat());
    } };
  }, "Relu6");
} }), dA = N({ selu_: function(n) {
  var e = T(n, "x", "selu");
  return D.runKernelFunc(function(t, r) {
    var o = t.selu(e);
    return r([e]), o;
  }, { $x: e }, function(t, r) {
    var o = r[0];
    return { $x: function() {
      var i = o.greater(K(0)), a = K(Rf), s = K(kf), u = t.mul(s), l = t.mul(a).mul(o.toFloat().exp());
      return mo(i, u, l);
    } };
  });
} }), Hr = N({ transpose_: function(n, e) {
  var t = T(n, "x", "transpose");
  if (e == null && (e = t.shape.map(function(o, i) {
    return i;
  }).reverse()), k(t.rank === e.length, function() {
    return "Error in transpose: rank of input " + t.rank + " must match length of perm " + e + ".";
  }), e.forEach(function(o) {
    k(o >= 0 && o < t.rank, function() {
      return "All entries in 'perm' must be between 0 and " + (t.rank - 1) + " but got " + e;
    });
  }), t.rank <= 1) return t.clone();
  var r = { perm: e };
  return D.runKernelFunc(function(o) {
    return o.transpose(t, e);
  }, { x: t }, function(o) {
    var i = xf(e);
    return { x: function() {
      return o.transpose(i);
    } };
  }, "Transpose", r);
} }), hA = N({ localResponseNormalization_: function(n, e, t, r, o) {
  e === void 0 && (e = 5), t === void 0 && (t = 1), r === void 0 && (r = 1), o === void 0 && (o = 0.5);
  var i = T(n, "x", "localResponseNormalization");
  k(i.rank === 4 || i.rank === 3, function() {
    return `Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ` + i.rank + ".";
  }), k(it(e), function() {
    return "Error in localResponseNormalization: depthRadius must be an integer but got depthRadius " + e + ".";
  });
  var a = i, s = !1;
  i.rank === 3 && (s = !0, a = i.as4D(1, i.shape[0], i.shape[1], i.shape[2]));
  var u = D.runKernelFunc(function(l, c) {
    var f = l.localResponseNormalization4D(a, e, t, r, o);
    return c([a, f]), f;
  }, { x4D: a }, function(l, c) {
    var f = c[0], d = c[1];
    return { x4D: function() {
      return D.runKernelFunc(function(p) {
        return p.LRNGrad(l, f, d, e, t, r, o);
      }, {});
    } };
  });
  return s ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;
} }), L0 = N({ norm_: function(n, e, t, r) {
  e === void 0 && (e = "euclidean"), t === void 0 && (t = null), r === void 0 && (r = !1);
  var o = function s(u, l, c) {
    if (c === void 0 && (c = null), u.rank === 0) return u.abs();
    if (u.rank !== 1 && c === null) return s(u.reshape([-1]), l, c);
    if (u.rank === 1 || typeof c == "number" || Array.isArray(c) && c.length === 1) {
      if (l === 1) return u.abs().sum(c);
      if (l === 1 / 0) return u.abs().max(c);
      if (l === -1 / 0) return u.abs().min(c);
      if (l === "euclidean" || l === 2) return u.abs().pow(K(2, "int32")).sum(c).sqrt();
      throw new Error("Error in norm: invalid ord value: " + l);
    }
    if (Array.isArray(c) && c.length === 2) {
      if (l === 1) return u.abs().sum(c[0]).max(c[1] - 1);
      if (l === 1 / 0) return u.abs().sum(c[1]).max(c[0]);
      if (l === -1 / 0) return u.abs().sum(c[1]).min(c[0]);
      if (l === "fro" || l === "euclidean") return u.square().sum(c).sqrt();
      throw new Error("Error in norm: invalid ord value: " + l);
    }
    throw new Error("Error in norm: invalid axis: " + c);
  }(n = T(n, "x", "norm"), e, t), i = o.shape;
  if (r) {
    var a = gt(t, n.shape);
    i = qt(o.shape, a);
  }
  return o.reshape(i);
} }), pA = N({ basicLSTMCell_: function(n, e, t, r, o, i) {
  var a = T(n, "forgetBias", "basicLSTMCell"), s = T(e, "lstmKernel", "basicLSTMCell"), u = T(t, "lstmBias", "basicLSTMCell"), l = T(r, "data", "basicLSTMCell"), c = T(o, "c", "basicLSTMCell"), f = T(i, "h", "basicLSTMCell"), d = l.concat(f, 1).matMul(s).add(u), p = d.shape[0], v = d.shape[1] / 4, g = [p, v], y = d.slice([0, 0], g), x = d.slice([0, v], g), w = d.slice([0, 2 * v], g), b = d.slice([0, 3 * v], g), _ = y.sigmoid().mulStrict(x.tanh()).addStrict(c.mulStrict(a.add(w).sigmoid())), E = _.tanh().mulStrict(b.sigmoid());
  return [_, E];
} }), mA = N({ multiRNNCell_: function(n, e, t, r) {
  for (var o = T(e, "data", "multiRNNCell"), i = is(t, "c", "multiRNNCell"), a = is(r, "h", "multiRNNCell"), s = o, u = [], l = 0; l < n.length; l++) {
    var c = n[l](s, i[l], a[l]);
    u.push(c[0]), u.push(c[1]), s = c[1];
  }
  var f = [], d = [];
  for (l = 0; l < u.length; l += 2) f.push(u[l]), d.push(u[l + 1]);
  return [f, d];
} }), vA = N({ movingAverage_: function(n, e, t, r, o) {
  o === void 0 && (o = !0);
  var i = T(n, "v", "movingAverage"), a = T(e, "x", "movingAverage"), s = T(t, "decay", "movingAverage");
  h3(i, a), k(_t(i.shape, a.shape), function() {
    return "Shape mismatch in v and x";
  });
  var u = K(1), l = u.sub(s), c = a.sub(i).mul(l);
  if (o) {
    k(r != null, function() {
      return "When using zeroDebias: true, step is required.";
    });
    var f = T(r, "step", "movingAverage");
    c = c.div(u.sub(ms(s, f)));
  }
  return i.add(c);
} }), gA = N({ stridedSlice_: function(n, e, t, r, o, i, a, s, u) {
  if (o === void 0 && (o = 0), i === void 0 && (i = 0), a === void 0 && (a = 0), s === void 0 && (s = 0), u === void 0 && (u = 0), r == null && (r = new Array(e.length)), a !== 0) throw new Error("ellipsis mask is not yet supported");
  var l = T(n, "x", "stridedSlice"), c = im(s), f = l.shape.slice();
  c.forEach(function(y) {
    e[y] = 0, t[y] = 1, f.splice(y, 0, 1);
  }), l = l.reshape(f);
  for (var d = 0; d < l.rank; d++) e[d] = ST(o, e, r, l.shape, d), t[d] = AT(i, t, r, l.shape, d), r[d] = r[d] || 1;
  var p = im(u);
  p.forEach(function(y) {
    t[y] = e[y] + 1, r[y] = 1;
  });
  var v = Ef(e, t, r), g = v.filter(function(y, x) {
    return p.indexOf(x) === -1;
  });
  return r.every(function(y) {
    return y === 1;
  }) ? Qn(l, e, v).reshape(g) : D.runKernelFunc(function(y) {
    return y.stridedSlice(l, e, t, r);
  }, { $x: l }).reshape(g);
} }), yA = N({ topk_: function(n, e, t) {
  e === void 0 && (e = 1), t === void 0 && (t = !0);
  var r = T(n, "x", "topk");
  if (r.rank === 0) throw new Error("topk() expects the input to be of rank 1 or higher");
  var o = r.shape[r.shape.length - 1];
  if (e > o) throw new Error("'k' passed to topk() must be <= the last dimension (" + o + ") but got " + e);
  var i = D.runKernelFunc(function(a) {
    return a.topk(r, e, t);
  }, { $x: r });
  return { values: i[0], indices: i[1] };
} }), xA = N({ scatterND_: function(n, e, t) {
  var r = T(n, "indices", "scatterND", "int32"), o = T(e, "updates", "scatterND");
  return TT(o, r, t), D.runKernelFunc(function(i) {
    return i.scatterND(r, o, t);
  }, { indices: r, updates: o }, null, "ScatterNd", { shape: t });
} }), Lf = N({ fft_: function(n) {
  k(n.dtype === "complex64", function() {
    return "The dtype for tf.spectral.fft() must be complex64 but got " + n.dtype + ".";
  });
  var e = n.shape[n.shape.length - 1], t = n.size / e, r = n.as2D(t, e);
  return D.runKernelFunc(function(o) {
    return o.fft(r);
  }, { input: n }).reshape(n.shape);
} }), vs = N({ ifft_: function(n) {
  k(n.dtype === "complex64", function() {
    return "The dtype for tf.spectral.ifft() must be complex64 but got " + n.dtype + ".";
  });
  var e = n.shape[n.shape.length - 1], t = n.size / e, r = n.as2D(t, e);
  return D.runKernelFunc(function(o) {
    return o.ifft(r);
  }, { input: n }).reshape(n.shape);
} }), Bf = N({ rfft_: function(n, e) {
  k(n.dtype === "float32", function() {
    return "The dtype for rfft() must be real value but got " + n.dtype;
  });
  var t, r = n.shape[n.shape.length - 1], o = n.size / r;
  if (e != null && e < r) {
    var i = n.shape.map(function(x) {
      return 0;
    }), a = n.shape.map(function(x) {
      return x;
    });
    a[n.shape.length - 1] = e, t = n.slice(i, a), r = e;
  } else if (e != null && e > r) {
    var s = n.shape.map(function(x) {
      return x;
    });
    s[n.shape.length - 1] = e - r, t = n.concat(Ge(s), n.shape.length - 1), r = e;
  } else t = n;
  var u = t.zerosLike(), l = Et(t, u).as2D(o, r), c = Lf(l), f = Math.floor(r / 2) + 1, d = mn(c), p = $n(c), v = d.split([f, r - f], d.shape.length - 1), g = p.split([f, r - f], p.shape.length - 1), y = t.shape.slice();
  return y[t.shape.length - 1] = f, Et(v[0], g[0]).reshape(y);
} }), B0 = N({ irfft_: function(n) {
  var e = n.shape[n.shape.length - 1], t = n.size / e;
  if (e <= 2) {
    var r = n.as2D(t, e), o = vs(r);
    return mn(o);
  }
  var i = [t, 2 * (e - 1)], a = mn(n).as2D(t, e), s = $n(n).as2D(t, e), u = a.slice([0, 1], [t, e - 2]).reverse(1), l = s.slice([0, 1], [t, e - 2]).reverse(1).mul(K(-1)), c = a.concat(u, 1), f = s.concat(l, 1);
  return r = Et(c, f).as2D(i[0], i[1]), o = vs(r), mn(o);
} }), wA = Object.freeze({ fft: Lf, ifft: vs, rfft: Bf, irfft: B0 }), _A = N({ sparseToDense_: function(n, e, t, r) {
  r === void 0 && (r = 0);
  var o = T(n, "sparseIndices", "sparseToDense", "int32"), i = T(e, "sparseValues", "sparseToDense"), a = T(r, "defaultValue", "sparseToDense", i.dtype);
  return function(s, u, l, c) {
    if (s.dtype !== "int32") throw new Error("tf.sparseToDense() expects the indices to be int32 type, but the dtype was " + s.dtype + ".");
    if (s.rank > 2) throw new Error("sparseIndices should be a scalar, vector, or matrix, but got shape " + s.shape + ".");
    var f = s.rank > 0 ? s.shape[0] : 1, d = s.rank > 1 ? s.shape[1] : 1;
    if (l.length !== d) throw new Error("outputShape has incorrect number of elements:, " + l.length + ", should be: " + d + ".");
    var p = u.size;
    if (u.rank !== 0 && (u.rank !== 1 || p !== f)) throw new Error("sparseValues has incorrect shape " + u.shape + ", should be [] or [" + f + "]");
    if (u.dtype !== c.dtype) throw new Error("sparseValues.dtype must match defaultValues.dtype");
  }(o, i, t, a), D.runKernelFunc(function(s) {
    return s.sparseToDense(o, i, t, a);
  }, { $sparseIndices: o, $sparseValues: i, $defaultValue: a });
} }), bA = N({ gatherND_: function(n, e) {
  var t = T(e, "indices", "gatherND", "int32"), r = T(n, "x", "gatherND");
  return D.runKernelFunc(function(o) {
    return o.gatherND(r, t);
  }, { x: r, indices: t }, null, "GatherNd");
} }), EA = N({ diag_: function(n) {
  var e = T(n, "x", "diag").flatten(), t = n.shape.concat(n.shape);
  return D.runKernelFunc(function(r) {
    return r.diag(e);
  }, { $x: e }).reshape(t);
} }), CA = N({ dropout_: function(n, e, t, r) {
  var o = T(n, "x", "dropout");
  if (k(o.dtype === "float32", function() {
    return "x has to be a floating point tensor since it's going to be scaled, but got a " + o.dtype + " tensor instead.";
  }), k(e >= 0 && e < 1, function() {
    return "rate must be a float in the range [0, 1), but got " + e + ".";
  }), e === 0) return n instanceof Je ? o.clone() : o;
  var i = function(u, l) {
    if (l == null) return u.shape.slice();
    if (_t(u.shape, l)) return l;
    if (u.shape.length === l.length) {
      for (var c = [], f = 0; f < u.shape.length; f++) l[f] == null && u.shape[f] != null ? c.push(u.shape[f]) : c.push(l[f]);
      return c;
    }
    return l;
  }(o, t), a = 1 - e, s = D1(i, 0, 1, "float32", r).add(a).floor().div(a);
  return o.mul(s);
} });
function O0(n, e, t) {
  for (var r = 1 - n % 2, o = new Float32Array(n), i = 0; i < n; ++i) {
    var a = 2 * Math.PI * i / (n + r - 1);
    o[i] = e - t * Math.cos(a);
  }
  return ut(o, "float32");
}
var Of = N({ hannWindow_: function(n) {
  return O0(n, 0.5, 0.5);
} }), U0 = N({ hammingWindow_: function(n) {
  return O0(n, 0.54, 0.46);
} }), Uf = N({ frame_: function(n, e, t, r, o) {
  r === void 0 && (r = !1), o === void 0 && (o = 0);
  for (var i = 0, a = []; i + e <= n.size; ) a.push(Qn(n, i, e)), i += t;
  if (r) for (; i < n.size; ) {
    var s = i + e - n.size, u = ht([Qn(n, i, e - s), Jn([s], o)]);
    a.push(u), i += t;
  }
  return a.length === 0 ? Or([], [0, e]) : ht(a).as2D(a.length, e);
} }), V0 = N({ stft_: function(n, e, t, r, o) {
  var i;
  o === void 0 && (o = Of), r == null && (i = e, r = Math.floor(Math.pow(2, Math.ceil(Math.log(i) / Math.log(2)))));
  for (var a = Uf(n, e, t), s = Nt(a, o(e)), u = [], l = 0; l < a.shape[0]; l++) u.push(Bf(s.slice([l, 0], [1, e]), r));
  return ht(u);
} }), TA = Object.freeze({ hannWindow: Of, hammingWindow: U0, frame: Uf, stft: V0 }), kt, IA = function(n, e, t) {
  return t === void 0 && (t = 1), Z(this, void 0, void 0, function() {
    var r, o, i, a, s, u, l, c, f, d, p, v, g, y;
    return j(this, function(x) {
      switch (x.label) {
        case 0:
          return r = T(n, "predictions", "inTopK"), o = T(e, "targets", "inTopK"), k(r.rank > 1, function() {
            return "inTopK() expects the predictions to be of rank 2 or higher, but got " + r.rank;
          }), k(r.rank - 1 === o.rank, function() {
            return "predictions rank should be 1 larger than targets rank, but got predictions rank " + r.rank + " and targets rank " + o.rank;
          }), De(r.shape.slice(0, r.shape.length - 1), o.shape, "predictions's shape should be align with the targets' shape, except the last dimension."), i = r.shape[r.shape.length - 1], k(t > 0 && t <= i, function() {
            return "'k' passed to inTopK() must be > 0 && <= the predictions last dimension (" + i + "), but got " + t;
          }), [4, r.data()];
        case 1:
          return a = x.sent(), [4, o.data()];
        case 2:
          for (s = x.sent(), u = [a.length / i, i], c = u[1], f = Qi("bool", l = u[0]), d = 0; d < l; d++) {
            for (p = d * c, v = a.subarray(p, p + c), g = [], y = 0; y < v.length; y++) g.push({ value: v[y], index: y });
            for (g.sort(function(w, b) {
              return b.value - w.value;
            }), f[d] = 0, y = 0; y < t; y++) if (g[y].index === s[d]) {
              f[d] = 1;
              break;
            }
          }
          return n !== r && r.dispose(), e !== o && o.dispose(), [2, Tt(f, o.shape, "bool")];
      }
    });
  });
};
(function(n) {
  n[n.NONE = 0] = "NONE", n[n.MEAN = 1] = "MEAN", n[n.SUM = 2] = "SUM", n[n.SUM_BY_NONZERO_WEIGHTS = 3] = "SUM_BY_NONZERO_WEIGHTS";
})(kt || (kt = {}));
var SA = N({ absoluteDifference_: function(n, e, t, r) {
  r === void 0 && (r = kt.SUM_BY_NONZERO_WEIGHTS);
  var o = T(n, "labels", "absoluteDifference"), i = T(e, "predictions", "absoluteDifference"), a = null;
  t != null && (a = T(t, "weights", "absoluteDifference")), De(o.shape, i.shape, "Error in absoluteDifference: ");
  var s = o.sub(i).abs();
  return _r(s, a, r);
} }), _r = N({ computeWeightedLoss_: function(n, e, t) {
  t === void 0 && (t = kt.SUM_BY_NONZERO_WEIGHTS);
  var r = T(n, "losses", "computeWeightedLoss"), o = null;
  e != null && (o = T(e, "weights", "computeWeightedLoss"));
  var i = o == null ? r : r.mul(o);
  if (t === kt.NONE) return i;
  if (t === kt.SUM) return i.sum();
  if (t === kt.MEAN) {
    if (o == null) return i.mean();
    var a = r.size / o.size, s = i.sum().div(o.sum());
    return a > 1 ? s.div(K(a)) : s;
  }
  if (t === kt.SUM_BY_NONZERO_WEIGHTS) {
    if (o == null) return i.sum().div(K(r.size));
    var u = o.mul(Si(r.shape)).notEqual(K(0)).sum().toFloat();
    return i.sum().div(u);
  }
  throw Error("Unknown reduction: " + t);
} }), AA = N({ cosineDistance_: function(n, e, t, r, o) {
  o === void 0 && (o = kt.SUM_BY_NONZERO_WEIGHTS);
  var i = T(n, "labels", "cosineDistance"), a = T(e, "predictions", "cosineDistance"), s = null;
  r != null && (s = T(r, "weights", "cosineDistance")), De(i.shape, a.shape, "Error in cosineDistance: ");
  var u = K(1).sub(i.mul(a).sum(t, !0));
  return _r(u, s, o);
} }), RA = N({ hingeLoss_: function(n, e, t, r) {
  r === void 0 && (r = kt.SUM_BY_NONZERO_WEIGHTS);
  var o = T(n, "labels", "hingeLoss"), i = T(e, "predictions", "hingeLoss"), a = null;
  t != null && (a = T(t, "weights", "hingeLoss")), De(o.shape, i.shape, "Error in hingeLoss: ");
  var s = K(1);
  o = K(2).mul(o).sub(s);
  var u = s.sub(o.mul(i)).relu();
  return _r(u, a, r);
} }), kA = N({ huberLoss_: function(n, e, t, r, o) {
  r === void 0 && (r = 1), o === void 0 && (o = kt.SUM_BY_NONZERO_WEIGHTS);
  var i = T(n, "labels", "huberLoss"), a = T(e, "predictions", "huberLoss"), s = null;
  t != null && (s = T(t, "weights", "huberLoss")), De(i.shape, a.shape, "Error in huberLoss: ");
  var u = K(r), l = a.sub(i).abs(), c = x0(l, u), f = l.sub(c), d = K(0.5).mul(c.square()).add(u.mul(f));
  return _r(d, s, o);
} }), PA = N({ logLoss_: function(n, e, t, r, o) {
  r === void 0 && (r = 1e-7), o === void 0 && (o = kt.SUM_BY_NONZERO_WEIGHTS);
  var i = T(n, "labels", "logLoss"), a = T(e, "predictions", "logLoss"), s = null;
  t != null && (s = T(t, "weights", "logLoss")), De(i.shape, a.shape, "Error in logLoss: ");
  var u = K(1), l = K(r), c = i.mul(a.add(l).log()).neg().sub(u.sub(i).mul(u.sub(a).add(l).log()));
  return _r(c, s, o);
} }), NA = N({ meanSquaredError_: function(n, e, t, r) {
  r === void 0 && (r = kt.SUM_BY_NONZERO_WEIGHTS);
  var o = T(n, "labels", "meanSquaredError"), i = T(e, "predictions", "meanSquaredError"), a = null;
  t != null && (a = T(t, "weights", "meanSquaredError")), De(o.shape, i.shape, "Error in meanSquaredError: ");
  var s = o.squaredDifference(i);
  return _r(s, a, r);
} }), MA = N({ sigmoidCrossEntropy_: function(n, e, t, r, o) {
  r === void 0 && (r = 0), o === void 0 && (o = kt.SUM_BY_NONZERO_WEIGHTS);
  var i = T(n, "multiClassLabels", "sigmoidCrossEntropy"), a = T(e, "logits", "sigmoidCrossEntropy"), s = null;
  if (t != null && (s = T(t, "weights", "sigmoidCrossEntropy")), De(i.shape, a.shape, "Error in sigmoidCrossEntropy: "), r > 0) {
    var u = K(r), l = K(1), c = K(0.5);
    i = i.mul(l.sub(u)).add(c.mul(u));
  }
  var f = function(d, p) {
    var v = T(d, "labels", "sigmoidCrossEntropyWithLogits"), g = T(p, "logits", "sigmoidCrossEntropyWithLogits");
    De(v.shape, g.shape, "Error in sigmoidCrossEntropyWithLogits: ");
    var y = g.relu(), x = g.mul(v), w = g.abs().neg().exp().log1p();
    return y.sub(x).add(w);
  }(i, a);
  return _r(f, s, o);
} }), DA = N({ softmaxCrossEntropy_: function(n, e, t, r, o) {
  r === void 0 && (r = 0), o === void 0 && (o = kt.SUM_BY_NONZERO_WEIGHTS);
  var i = T(n, "onehotLabels", "softmaxCrossEntropy"), a = T(e, "logits", "softmaxCrossEntropy"), s = null;
  if (t != null && (s = T(t, "weights", "softmaxCrossEntropy")), De(i.shape, a.shape, "Error in softmaxCrossEntropy: "), r > 0) {
    var u = K(r), l = K(1), c = K(i.shape[1]);
    i = i.mul(l.sub(u)).add(u.div(c));
  }
  var f = function(d, p, v) {
    if (v === void 0 && (v = -1), v === -1 && (v = p.rank - 1), v !== p.rank - 1) throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank " + p.rank + " and dim was " + v);
    return ou(function(g, y, x) {
      var w = y.logSumExp([v], !0), b = y.toFloat().sub(w);
      return x([g, b]), { value: b.mul(g).neg().sum([v]), gradFunc: function(_, E) {
        var C = E[0], A = E[1], R = qt(_.shape, [v]);
        return [_.reshape(R).mul(C.toFloat().sub(A.exp())), _.reshape(R).mul(A.exp().sub(C.toFloat()))];
      } };
    })(d, p);
  }(i, a);
  return _r(f, s, o);
} }), FA = Object.freeze({ get Reduction() {
  return kt;
}, absoluteDifference: SA, computeWeightedLoss: _r, cosineDistance: AA, hingeLoss: RA, huberLoss: kA, logLoss: PA, meanSquaredError: NA, sigmoidCrossEntropy: MA, softmaxCrossEntropy: DA });
function Sm(n, e) {
  return e === void 0 && (e = !1), D.tidy(function() {
    if (n.shape.length !== 2) throw new Error("qr2d() requires a 2D Tensor, but got a " + n.shape.length + "D Tensor.");
    for (var t = n.shape[0], r = n.shape[1], o = M1(t), i = n.clone(), a = Or([[1]], [1, 1]), s = a.clone(), u = t >= r ? r : t, l = function(f) {
      var d, p = i, v = s, g = o;
      d = D.tidy(function() {
        var y = i.slice([f, f], [t - f, 1]), x = y.norm(), w = i.slice([f, f], [1, 1]), b = Or([[-1]]).where(w.greater(0), Or([[1]])), _ = w.sub(b.mul(x)), E = y.div(_);
        s = E.shape[0] === 1 ? a.clone() : a.concat(E.slice([1, 0], [E.shape[0] - 1, E.shape[1]]), 0);
        var C = b.matMul(_).div(x).neg(), A = i.slice([f, 0], [t - f, r]), R = C.mul(s);
        if (f === 0) i = A.sub(R.matMul(s.transpose().matMul(A)));
        else {
          var I = A.sub(R.matMul(s.transpose().matMul(A)));
          i = i.slice([0, 0], [f, r]).concat(I, 0);
        }
        var S = o.slice([0, f], [t, o.shape[1] - f]);
        if (f === 0) o = S.sub(S.matMul(s).matMul(R.transpose()));
        else {
          var M = S.sub(S.matMul(s).matMul(R.transpose()));
          o = o.slice([0, 0], [t, f]).concat(M, 1);
        }
        return [s, i, o];
      }), s = d[0], i = d[1], o = d[2], Ht([p, v, g]);
    }, c = 0; c < u; ++c) l(c);
    return !e && t > r && (o = o.slice([0, 0], [t, r]), i = i.slice([0, 0], [r, r])), [o, i];
  });
}
var LA = N({ bandPart_: function(n, e, t) {
  if (e % 1 != 0) throw new Error("bandPart(): numLower must be an integer, got " + e + ".");
  if (t % 1 != 0) throw new Error("bandPart(): numUpper must be an integer, got " + t + ".");
  var r = T(n, "a", "bandPart");
  if (r.rank < 2) throw new Error("bandPart(): Rank must be at least 2, got " + r.rank + ".");
  var o = r.shape, i = r.shape.slice(-2), a = i[0], s = i[1];
  if (!(e <= a)) throw new Error("bandPart(): numLower (" + e + ") must not be greater than the number of rows (" + a + ").");
  if (!(t <= s)) throw new Error("bandPart(): numUpper (" + t + ") must not be greater than the number of columns (" + s + ").");
  e < 0 && (e = a), t < 0 && (t = s);
  var u = as(0, a, 1, "int32").reshape([-1, 1]), l = as(0, s, 1, "int32"), c = vt(u, l), f = au(c.lessEqual(K(+e, "int32")), c.greaterEqual(K(-t, "int32"))), d = Ge([a, s], r.dtype);
  return on(pt(r.reshape([-1, a, s])).map(function(p) {
    return mo(f, p, d);
  })).reshape(o);
} }), BA = N({ gramSchmidt_: function(n) {
  var e;
  if (Array.isArray(n)) {
    e = !1, k(n != null && n.length > 0, function() {
      return "Gram-Schmidt process: input must not be null, undefined, or empty";
    });
    for (var t = n[0].shape[0], r = function(u) {
      k(n[u].shape[0] === t, function() {
        return "Gram-Schmidt: Non-unique lengths found in the input vectors: (" + n[u].shape[0] + " vs. " + t + ")";
      });
    }, o = 1; o < n.length; ++o) r(o);
  } else e = !0, n = _f(n, n.shape[0], 0).map(function(u) {
    return L1(u, [0]);
  });
  k(n.length <= n[0].shape[0], function() {
    return "Gram-Schmidt: Number of vectors (" + n.length + ") exceeds number of dimensions (" + n[0].shape[0] + ").";
  });
  var i = [], a = n, s = function(u) {
    i.push(D.tidy(function() {
      var l = a[u];
      if (u > 0) for (var c = 0; c < u; ++c) {
        var f = N0(i[c].mulStrict(l)).mul(i[c]);
        l = l.sub(f);
      }
      return l.div(L0(l, "euclidean"));
    }));
  };
  for (o = 0; o < n.length; ++o) s(o);
  return e ? on(i, 0) : i;
} }), OA = N({ qr_: function(n, e) {
  if (e === void 0 && (e = !1), n.rank < 2) throw new Error("qr() requires input tensor to have a rank >= 2, but got rank " + n.rank);
  if (n.rank === 2) return Sm(n, e);
  var t = n.shape.slice(0, n.shape.length - 2).reduce(function(a, s) {
    return a * s;
  }), r = pt(n.reshape([t, n.shape[n.shape.length - 2], n.shape[n.shape.length - 1]]), 0), o = [], i = [];
  return r.forEach(function(a) {
    var s = Sm(a, e), u = s[0], l = s[1];
    o.push(u), i.push(l);
  }), [on(o, 0).reshape(n.shape), on(i, 0).reshape(n.shape)];
} }), UA = Object.freeze({ bandPart: LA, gramSchmidt: BA, qr: OA });
function cu(n, e, t, r, o, i) {
  r == null && (r = 0.5), o == null && (o = Number.NEGATIVE_INFINITY), i == null && (i = 0);
  var a = n.shape[0];
  return t = Math.min(t, a), k(0 <= r && r <= 1, function() {
    return "iouThreshold must be in [0, 1], but was '" + r + "'";
  }), k(n.rank === 2, function() {
    return "boxes must be a 2D tensor, but was of rank '" + n.rank + "'";
  }), k(n.shape[1] === 4, function() {
    return "boxes must have 4 columns, but 2nd dimension was " + n.shape[1];
  }), k(e.rank === 1, function() {
    return "scores must be a 1D tensor";
  }), k(e.shape[0] === a, function() {
    return "scores has incompatible shape with boxes. Expected " + a + ", but was " + e.shape[0];
  }), k(0 <= i && i <= 1, function() {
    return "softNmsSigma must be in [0, 1], but was '" + i + "'";
  }), { maxOutputSize: t, iouThreshold: r, scoreThreshold: o, softNmsSigma: i };
}
var VA = N({ resizeBilinear_: function(n, e, t) {
  t === void 0 && (t = !1);
  var r = T(n, "images", "resizeBilinear");
  k(r.rank === 3 || r.rank === 4, function() {
    return "Error in resizeBilinear: x must be rank 3 or 4, but got rank " + r.rank + ".";
  }), k(e.length === 2, function() {
    return "Error in resizeBilinear: new shape must 2D, but got shape " + e + ".";
  });
  var o = r, i = !1;
  r.rank === 3 && (i = !0, o = r.as4D(1, r.shape[0], r.shape[1], r.shape[2]));
  var a = e[0], s = e[1], u = D.runKernelFunc(function(l, c) {
    return c([o]), l.resizeBilinear(o, a, s, t);
  }, { x: o }, function(l, c) {
    return { x: function() {
      return D.runKernelFunc(function(f) {
        return f.resizeBilinearBackprop(l, c[0], t);
      }, {});
    } };
  }, "ResizeBilinear", { alignCorners: t, newHeight: a, newWidth: s });
  return i ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;
} }), GA = N({ resizeNearestNeighbor_: function(n, e, t) {
  t === void 0 && (t = !1);
  var r = T(n, "images", "resizeNearestNeighbor");
  k(r.rank === 3 || r.rank === 4, function() {
    return "Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank " + r.rank + ".";
  }), k(e.length === 2, function() {
    return "Error in resizeNearestNeighbor: new shape must 2D, but got shape " + e + ".";
  }), k(r.dtype === "float32" || r.dtype === "int32", function() {
    return "`images` must have `int32` or `float32` as dtype";
  });
  var o = r, i = !1;
  r.rank === 3 && (i = !0, o = r.as4D(1, r.shape[0], r.shape[1], r.shape[2]));
  var a = e[0], s = e[1], u = D.runKernelFunc(function(l, c) {
    return c([o]), l.resizeNearestNeighbor(o, a, s, t);
  }, { batchImages: o }, function(l, c) {
    return { batchImages: function() {
      return D.runKernelFunc(function(f) {
        return f.resizeNearestNeighborBackprop(l, c[0], t);
      }, {});
    } };
  });
  return i ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;
} }), WA = N({ nonMaxSuppression_: function(n, e, t, r, o) {
  r === void 0 && (r = 0.5), o === void 0 && (o = Number.NEGATIVE_INFINITY);
  var i = T(n, "boxes", "nonMaxSuppression"), a = T(e, "scores", "nonMaxSuppression"), s = cu(i, a, t, r, o);
  t = s.maxOutputSize, r = s.iouThreshold, o = s.scoreThreshold;
  var u = { maxOutputSize: t, iouThreshold: r, scoreThreshold: o };
  return D.runKernelFunc(function(l) {
    return l.nonMaxSuppression(i, a, t, r, o);
  }, { boxes: i, scores: a }, null, "NonMaxSuppressionV3", u);
} }), HA = function(n, e, t, r, o) {
  return r === void 0 && (r = 0.5), o === void 0 && (o = Number.NEGATIVE_INFINITY), Z(this, void 0, void 0, function() {
    var i, a, s, u, l, c, f;
    return j(this, function(d) {
      switch (d.label) {
        case 0:
          return i = T(n, "boxes", "nonMaxSuppressionAsync"), a = T(e, "scores", "nonMaxSuppressionAsync"), s = cu(i, a, t, r, o), t = s.maxOutputSize, r = s.iouThreshold, o = s.scoreThreshold, [4, Promise.all([i.data(), a.data()])];
        case 1:
          return u = d.sent(), l = u[0], c = u[1], f = Tf(l, c, t, r, o), i !== n && i.dispose(), a !== e && a.dispose(), [2, f];
      }
    });
  });
}, $A = N({ nonMaxSuppressionWithScore_: function(n, e, t, r, o, i) {
  r === void 0 && (r = 0.5), o === void 0 && (o = Number.NEGATIVE_INFINITY), i === void 0 && (i = 0);
  var a = T(n, "boxes", "nonMaxSuppression"), s = T(e, "scores", "nonMaxSuppression"), u = cu(a, s, t, r, o, i), l = { maxOutputSize: t = u.maxOutputSize, iouThreshold: r = u.iouThreshold, scoreThreshold: o = u.scoreThreshold, softNmsSigma: i = u.softNmsSigma }, c = D.runKernel("NonMaxSuppressionV5", { boxes: a, scores: s }, l);
  return { selectedIndices: c[0], selectedScores: c[1] };
} }), qA = function(n, e, t, r, o, i) {
  return r === void 0 && (r = 0.5), o === void 0 && (o = Number.NEGATIVE_INFINITY), i === void 0 && (i = 0), Z(this, void 0, void 0, function() {
    var a, s, u, l, c, f, d;
    return j(this, function(p) {
      switch (p.label) {
        case 0:
          return a = T(n, "boxes", "nonMaxSuppressionAsync"), s = T(e, "scores", "nonMaxSuppressionAsync"), u = cu(a, s, t, r, o, i), t = u.maxOutputSize, r = u.iouThreshold, o = u.scoreThreshold, i = u.softNmsSigma, [4, Promise.all([a.data(), s.data()])];
        case 1:
          return l = p.sent(), c = l[0], f = l[1], d = If(c, f, t, r, o, i), a !== n && a.dispose(), s !== e && s.dispose(), [2, d];
      }
    });
  });
}, zA = N({ cropAndResize_: function(n, e, t, r, o, i) {
  var a = T(n, "image", "cropAndResize"), s = T(e, "boxes", "cropAndResize", "float32"), u = T(t, "boxInd", "cropAndResize", "int32");
  o = o || "bilinear", i = i || 0;
  var l = s.shape[0];
  return k(a.rank === 4, function() {
    return "Error in cropAndResize: image must be rank 4,but got rank " + a.rank + ".";
  }), k(s.rank === 2 && s.shape[1] === 4, function() {
    return "Error in cropAndResize: boxes must be have size [" + l + ",4] but had shape " + s.shape + ".";
  }), k(u.rank === 1 && u.shape[0] === l, function() {
    return "Error in cropAndResize: boxInd must be have size [" + l + "] but had shape " + s.shape + ".";
  }), k(r.length === 2, function() {
    return "Error in cropAndResize: cropSize must be of length 2, but got length " + r.length + ".";
  }), k(r[0] >= 1 && r[1] >= 1, function() {
    return "cropSize must be atleast [1,1], but was " + r;
  }), k(o === "bilinear" || o === "nearest", function() {
    return "method must be bilinear or nearest, but was " + o;
  }), D.runKernelFunc(function(c, f) {
    return c.cropAndResize(a, s, u, r, o, i);
  }, { images: a, boxes: s, boxInd: u }, null, "CropAndResize", { method: o, extrapolationValue: i, cropSize: r });
} }), Vf = Object.freeze({ resizeBilinear: VA, resizeNearestNeighbor: GA, nonMaxSuppression: WA, nonMaxSuppressionAsync: HA, nonMaxSuppressionWithScore: $A, nonMaxSuppressionWithScoreAsync: qA, cropAndResize: zA }), Gf = function(n, e) {
  return !(n > 0) || e === "linear";
}, Wf = function(n, e, t) {
  if (t == null || t === "linear") return n;
  if (t === "relu") return n.mul(e.step());
  throw new Error("Gradient for activation " + t + " has not been implemented yet.");
}, Hf = function(n, e) {
  var t = e, r = mt(n.shape, e.shape);
  return r.length > 0 && (t = t.sum(r)), t.reshape(n.shape);
}, $f = function(n, e, t) {
  if (e === "linear") return n;
  if (e === "relu") return Xe(n);
  if (e === "elu") return M0(n);
  if (e === "relu6") return F0(n);
  if (e === "prelu") return D0(n, t);
  throw new Error("Unknown fused activation " + e + ".");
}, KA = N({ fusedMatMul_: function(n) {
  var e, t = n.a, r = n.b, o = n.transposeA, i = o !== void 0 && o, a = n.transposeB, s = a !== void 0 && a, u = n.bias, l = n.activation, c = l === void 0 ? "linear" : l, f = n.preluActivationWeights;
  if (Gf(D.state.gradientDepth, c) === !1) {
    var d = uu(t, r, i, s);
    return u != null && (d = ge(d, u)), $f(d, c, f);
  }
  var p = T(t, "a", "fused matMul"), v = T(r, "b", "fused matMul");
  e = Qe(p, v), p = e[0], v = e[1];
  var g = i ? p.shape[p.rank - 2] : p.shape[p.rank - 1], y = s ? v.shape[v.rank - 1] : v.shape[v.rank - 2], x = i ? p.shape[p.rank - 1] : p.shape[p.rank - 2], w = s ? v.shape[v.rank - 2] : v.shape[v.rank - 1], b = p.shape.slice(0, -2), _ = v.shape.slice(0, -2), E = ee(b), C = ee(_);
  k(p.rank >= 2 && v.rank >= 2 && p.rank === v.rank, function() {
    return "Error in fused matMul: inputs must have the same rank of at least 2, got ranks " + p.rank + " and " + v.rank + ".";
  }), k(_t(b, _), function() {
    return "Error in fused matMul: outer dimensions (" + b + ") and (" + _ + ") of Tensors with shapes " + p.shape + " and " + v.shape + " must match.";
  }), k(g === y, function() {
    return "Error in fused matMul: inner shapes (" + g + ") and (" + y + ") of Tensors with shapes " + p.shape + " and " + v.shape + " and transposeA=" + i + " and transposeB=" + s + " must match.";
  });
  var A, R, I = p.shape.slice(0, -2).concat([x, w]), S = i ? p.as3D(E, g, x) : p.as3D(E, x, g), M = s ? v.as3D(C, w, y) : v.as3D(C, y, w);
  u != null && xe(I, (A = Qe(A = T(u, "bias", "fused matMul"), p)[0]).shape), f != null && (R = T(f, "prelu weights", "fused matMul"));
  var P = { a: S, b: M };
  u != null && (P.bias = A), f != null && (P.preluActivationWeights = R);
  var B = [S, M];
  return D.runKernelFunc(function(O, U) {
    var G = O.fusedBatchMatMul({ a: S, b: M, transposeA: i, transposeB: s, bias: A, activation: c, preluActivationWeights: R });
    return U([S, M, G]), G;
  }, P, function(O, U) {
    var G = U[0], H = U[1], W = U[2], q = Wf(O, W, c), z = {};
    return u != null && (z = { bias: function() {
      return Hf(A, q);
    } }), Object.assign(i || s ? !i && s ? { a: function() {
      return q.matMul(H, !1, !1);
    }, b: function() {
      return q.matMul(G, !0, !1);
    } } : i && !s ? { a: function() {
      return H.matMul(q, !1, !0);
    }, b: function() {
      return G.matMul(q, !1, !1);
    } } : { a: function() {
      return H.matMul(q, !0, !0);
    }, b: function() {
      return q.matMul(G, !0, !0);
    } } : { a: function() {
      return q.matMul(H, !1, !0);
    }, b: function() {
      return G.matMul(q, !0, !1);
    } }, z);
  }, "_FusedMatMul", { transposeA: i, transposeB: s, activation: c }, B, [!0]).reshape(I);
} }), JA = N({ fusedConv2d_: function(n) {
  var e = n.x, t = n.filter, r = n.strides, o = n.pad, i = n.dataFormat, a = i === void 0 ? "NHWC" : i, s = n.dilations, u = s === void 0 ? [1, 1] : s, l = n.dimRoundingMode, c = n.bias, f = n.activation, d = f === void 0 ? "linear" : f, p = n.preluActivationWeights;
  if (d = d || "linear", Gf(D.state.gradientDepth, d) === !1) {
    var v = bn(e, t, r, o, a, u, l);
    return c != null && (v = ge(v, c)), $f(v, d, p);
  }
  var g = T(e, "x", "conv2d"), y = T(t, "filter", "conv2d"), x = g, w = !1;
  g.rank === 3 && (w = !0, x = g.as4D(1, g.shape[0], g.shape[1], g.shape[2])), k(x.rank === 4, function() {
    return "Error in fused conv2d: input must be rank 4, but got rank " + x.rank + ".";
  }), k(y.rank === 4, function() {
    return "Error in fused conv2d: filter must be rank 4, but got rank " + y.rank + ".";
  }), l != null && k(it(o), function() {
    return "Error in fused conv2d: pad must be an integer when using, dimRoundingMode " + l + " but got pad " + o + ".";
  }), k(x.shape[3] === y.shape[2], function() {
    return "Error in conv2d: depth of input (" + x.shape[3] + ") must match input depth for filter " + y.shape[2] + ".";
  }), k(zt(r, u), function() {
    return "Error in conv2D: Either strides or dilations must be 1. Got strides " + r + " and dilations '" + u + "'";
  }), k(a === "NHWC", function() {
    return "Error in conv2d: got dataFormat of " + a + " but only NHWC is currently supported.";
  });
  var b, _, E = _o(x.shape, y.shape, r, u, o, l);
  c != null && (b = Qe(b = T(c, "bias", "fused conv2d"), g)[0], xe(E.outShape, b.shape)), p != null && (_ = T(p, "prelu weights", "fused conv2d"));
  var C = { x, filter: y };
  c != null && (C.bias = b), p != null && (C.preluActivationWeights = _);
  var A = [y, x], R = D.runKernelFunc(function(I, S) {
    var M = I.fusedConv2d({ input: x, filter: y, convInfo: E, bias: b, activation: d, preluActivationWeights: _ });
    return S([y, x, M]), M;
  }, C, function(I, S) {
    var M = S, P = M[0], B = M[1], O = M[2], U = Wf(I, O, d);
    k(hi(u), function() {
      return "Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + u + "'";
    });
    var G = {};
    return c != null && (G = { bias: function() {
      return Hf(b, U);
    } }), Object.assign({ x: function() {
      return T0(B.shape, U, P, r, o);
    }, filter: function() {
      return Df(B, U, P.shape, r, o);
    } }, G);
  }, "FusedConv2D", { convInfo: E, activation: d }, A, [!0]);
  return w ? R.as3D(R.shape[1], R.shape[2], R.shape[3]) : R;
} }), XA = N({ fusedDepthwiseConv2d_: function(n) {
  var e = n.x, t = n.filter, r = n.strides, o = n.pad, i = n.dataFormat, a = i === void 0 ? "NHWC" : i, s = n.dilations, u = s === void 0 ? [1, 1] : s, l = n.dimRoundingMode, c = n.bias, f = n.activation, d = f === void 0 ? "linear" : f, p = n.preluActivationWeights;
  if (Gf(D.state.gradientDepth, d) === !1) {
    var v = su(e, t, r, o, a, u, l);
    return c != null && (v = ge(v, c)), $f(v, d, p);
  }
  var g = T(e, "x", "depthwiseConv2d"), y = T(t, "filter", "depthwiseConv2d"), x = g, w = !1;
  g.rank === 3 && (w = !0, x = g.as4D(1, g.shape[0], g.shape[1], g.shape[2])), k(x.rank === 4, function() {
    return "Error in fused depthwiseConv2d: input must be rank 4, but got rank " + x.rank + ".";
  }), k(y.rank === 4, function() {
    return "Error in fused depthwiseConv2d: filter must be rank 4, but got rank " + y.rank + ".";
  }), k(x.shape[3] === y.shape[2], function() {
    return "Error in fused depthwiseConv2d: number of input channels (" + x.shape[3] + ") must match the inChannels dimension in filter " + y.shape[2] + ".";
  }), u == null && (u = [1, 1]), k(zt(r, u), function() {
    return "Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides " + r + " and dilations '" + u + "'";
  }), l != null && k(it(o), function() {
    return "Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode " + l + " but got pad " + o + ".";
  });
  var b, _, E = _o(x.shape, y.shape, r, u, o, l, !0);
  c != null && (b = Qe(b = T(c, "bias", "fused conv2d"), g)[0], xe(E.outShape, b.shape)), p != null && (_ = T(p, "prelu weights", "fused depthwiseConv2d"));
  var C = { x, filter: y };
  c != null && (C.bias = b), p != null && (C.preluActivationWeights = _);
  var A = [y, x], R = D.runKernelFunc(function(I, S) {
    var M = I.fusedDepthwiseConv2D({ input: x, filter: y, convInfo: E, bias: b, activation: d, preluActivationWeights: _ });
    return S([y, x, M]), M;
  }, C, function(I, S) {
    k(hi(u), function() {
      return "Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" + u + "'";
    });
    var M = S[0], P = S[1], B = S[2], O = Wf(I, B, d), U = {};
    return c != null && (U = { bias: function() {
      return Hf(b, O);
    } }), Object.assign({ x: function() {
      return I0(P.shape, O, M, E);
    }, filter: function() {
      return S0(P, O, M.shape, E);
    } }, U);
  }, "FusedDepthwiseConv2D", { convInfo: E, activation: d }, A, [!0]);
  return w ? R.as3D(R.shape[1], R.shape[2], R.shape[3]) : R;
} }), YA = Object.freeze({ matMul: KA, conv2d: JA, depthwiseConv2d: XA }), QA = Object.freeze({ image: Vf, linalg: UA, losses: FA, spectral: wA, fused: YA, signal: TA, square: PI, squaredDifference: l0, conv1d: VS, conv2d: bn, conv3d: GS, depthwiseConv2d: su, separableConv2d: Ff, conv2dTranspose: WS, conv3dTranspose: HS, op: N, batchNormalization2d: sS, batchNormalization3d: uS, batchNormalization4d: lS, batchNormalization: cS, batchNorm: m0, batchNorm2d: fS, batchNorm3d: dS, batchNorm4d: hS, booleanMaskAsync: US, complex: Et, real: mn, imag: $n, concat: ht, concat1d: Y3, concat2d: Q3, concat3d: Z3, concat4d: j3, split: _f, matMul: uu, dot: $S, outerProduct: qS, reverse: ha, reverse1d: zS, reverse2d: KS, reverse3d: JS, reverse4d: XS, maxPool: wt, avgPool: pa, pool: YS, maxPool3d: QS, avgPool3d: ZS, slice: Qn, slice1d: jS, slice2d: eA, slice3d: k0, slice4d: tA, abs: NI, acos: MI, acosh: DI, asin: FI, asinh: LI, atan: BI, atanh: OI, ceil: UI, clipByValue: Pf, cos: VI, cosh: GI, erf: WI, exp: ec, expm1: HI, floor: $I, log: qI, log1p: zI, logSigmoid: KI, neg: ps, reciprocal: JI, round: XI, rsqrt: c0, sigmoid: f0, sign: YI, isNaN: QI, isInf: ZI, isFinite: jI, sin: eS, sinh: tS, softplus: nS, sqrt: rS, step: oS, tan: iS, tanh: aS, all: nA, any: rA, argMax: oA, argMin: iA, logSumExp: aA, max: lu, mean: sA, min: uA, moments: lA, sum: N0, prod: cA, equal: w0, equalStrict: RS, greater: kS, greaterEqual: _0, greaterEqualStrict: PS, greaterStrict: NS, less: MS, lessEqual: DS, lessEqualStrict: FS, lessStrict: LS, notEqual: BS, notEqualStrict: OS, add: ge, addN: vS, addStrict: gS, atan2: yS, div: En, divNoNan: xS, divStrict: wS, floorDiv: y0, maximum: Nf, maximumStrict: _S, minimum: x0, minimumStrict: bS, mod: ES, modStrict: CS, mul: Nt, mulStrict: TS, pow: ms, powStrict: IS, squaredDifferenceStrict: SS, sub: vt, subStrict: AS, elu: M0, leakyRelu: fA, prelu: D0, relu: Xe, relu6: F0, selu: dA, logicalAnd: au, logicalNot: pS, logicalOr: v0, logicalXor: mS, where: mo, whereAsync: g0, buffer: he, print: uT, batchToSpaceND: N1, broadcastTo: lT, cast: cT, clone: fT, cumsum: dT, depthToSpace: hT, expandDims: pn, eye: M1, multinomial: pT, oneHot: Yl, pad: wo, pad1d: mT, pad2d: vT, pad3d: gT, pad4d: yT, rand: xT, randomNormal: wT, randomGamma: _T, randomUniform: D1, reshape: Cn, spaceToBatchND: F1, squeeze: L1, stack: on, tile: zo, truncatedNormal: bT, unstack: pt, setdiff1dAsync: ET, fill: Jn, linspace: X3, ones: Si, range: as, scalar: K, tensor: Tt, tensor1d: ut, tensor2d: Or, tensor3d: wf, tensor4d: Vt, tensor5d: z3, tensor6d: K3, variable: J3, zeros: Ge, onesLike: P1, zerosLike: Ie, transpose: Hr, softmax: wr, logSoftmax: kT, localResponseNormalization: hA, norm: L0, gather: Mf, unsortedSegmentSum: b0, basicLSTMCell: pA, multiRNNCell: mA, movingAverage: vA, stridedSlice: gA, topk: yA, scatterND: xA, fft: Lf, ifft: vs, rfft: Bf, irfft: B0, sparseToDense: _A, gatherND: bA, diag: EA, dropout: CA, hannWindow: Of, hammingWindow: U0, frame: Uf, stft: V0, inTopKAsync: IA });
function $(n, e) {
  Array.isArray(n) || (n = [n]), n.forEach(function(t) {
    t != null && k(t.dtype !== "complex64", function() {
      return e + " does not support complex64 tensors.";
    });
  });
}
function el(n, e, t, r) {
  if (t === "linear") return n.linear(e);
  if (t === "relu") return n.relu(e);
  if (t === "elu") return n.elu(e);
  if (t === "relu6") return n.relu6(e);
  if (t === "prelu") return n.prelu(e, r);
  throw new Error("Activation " + t + " has not been implemented for the CPU backend.");
}
var ZA = function(n) {
  function e() {
    var t = n.call(this) || this;
    return t.blockSize = 48, t.firstUse = !0, t.data = new H1(t, D), t;
  }
  return Pn(e, n), e.prototype.write = function(t, r, o) {
    this.firstUse && (this.firstUse = !1, V().get("IS_NODE") && os(`
============================
Hi there . Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.
============================`));
    var i = {};
    return this.data.set(i, { values: t, dtype: o }), i;
  }, e.prototype.move = function(t, r, o, i) {
    this.data.set(t, { values: r, dtype: i });
  }, e.prototype.numDataIds = function() {
    return this.data.numDataIds();
  }, e.prototype.read = function(t) {
    return Z(this, void 0, void 0, function() {
      return j(this, function(r) {
        return [2, this.readSync(t)];
      });
    });
  }, e.prototype.readSync = function(t) {
    var r = this.data.get(t), o = r.dtype, i = r.complexTensors;
    return o === "complex64" ? jl(this.readSync(i.real.dataId), this.readSync(i.imag.dataId)) : this.data.get(t).values;
  }, e.prototype.bufferSync = function(t) {
    var r = this.readSync(t.dataId), o = r;
    if (t.dtype === "string") try {
      o = r.map(function(i) {
        return ts(i);
      });
    } catch {
      throw new Error("Failed to decode encoded string bytes into utf-8");
    }
    return he(t.shape, t.dtype, o);
  }, e.prototype.makeOutput = function(t, r, o) {
    var i = this.write(t, r, o);
    return D.makeTensorFromDataId(i, r, o, this);
  }, e.prototype.disposeData = function(t) {
    if (this.data.has(t)) {
      var r = this.data.get(t).complexTensors;
      r != null && (r.real.dispose(), r.imag.dispose()), this.data.delete(t);
    }
  }, e.prototype.time = function(t) {
    return Z(this, void 0, void 0, function() {
      var r;
      return j(this, function(o) {
        return r = Wn(), t(), [2, { kernelMs: Wn() - r }];
      });
    });
  }, e.prototype.memory = function() {
    return { unreliable: !0, reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."] };
  }, e.prototype.complex = function(t, r) {
    var o = this.makeOutput(null, t.shape, "complex64");
    return this.data.get(o.dataId).complexTensors = { real: D.keep(t.clone()), imag: D.keep(r.clone()) }, o;
  }, e.prototype.real = function(t) {
    return this.data.get(t.dataId).complexTensors.real.clone();
  }, e.prototype.imag = function(t) {
    return this.data.get(t.dataId).complexTensors.imag.clone();
  }, e.prototype.slice = function(t, r, o) {
    if ($(t, "slice"), G1(t.shape, r, o)) {
      var i = W1(r, t.strides), a = ee(o);
      return Tt(this.readSync(t.dataId).subarray(i, i + a), o, t.dtype);
    }
    for (var s = he(o, t.dtype), u = this.bufferSync(t), l = 0; l < s.size; ++l) {
      var c = s.indexToLoc(l).map(function(f, d) {
        return f + r[d];
      });
      s.values[l] = u.get.apply(u, c);
    }
    return s.toTensor();
  }, e.prototype.stridedSlice = function(t, r, o, i) {
    $(t, "stridedSlice");
    var a = Ef(r, o, i);
    if (a.some(function(p) {
      return p === 0;
    })) return Tt([], a);
    for (var s = he(a, t.dtype), u = this.bufferSync(t), l = 0; l < s.size; l++) {
      for (var c = s.indexToLoc(l), f = new Array(c.length), d = 0; d < f.length; d++) f[d] = c[d] * i[d] + r[d];
      s.set.apply(s, [u.get.apply(u, f)].concat(c));
    }
    return s.toTensor();
  }, e.prototype.diag = function(t) {
    for (var r = this.readSync(t.dataId), o = he([t.size, t.size], t.dtype), i = o.values, a = 0; a < r.length; a++) i[a * t.size + a] = r[a];
    return o.toTensor();
  }, e.prototype.unstack = function(t, r) {
    for (var o = t.shape[r], i = new Array(t.rank - 1), a = 0, s = 0; s < t.rank; s++) s !== r && (i[a++] = t.shape[s]);
    var u = new Array(t.rank).fill(0), l = t.shape.slice();
    l[r] = 1;
    var c = new Array(o);
    for (s = 0; s < c.length; s++) u[r] = s, c[s] = this.slice(t, u, l).reshape(i);
    return c;
  }, e.prototype.reverse = function(t, r) {
    $(t, "reverse");
    for (var o = he(t.shape, t.dtype), i = this.bufferSync(t), a = function(u) {
      var l = o.indexToLoc(u), c = l.slice();
      r.forEach(function(f) {
        return c[f] = t.shape[f] - 1 - c[f];
      }), o.set.apply(o, [i.get.apply(i, c)].concat(l));
    }, s = 0; s < o.size; s++) a(s);
    return o.toTensor();
  }, e.prototype.concat = function(t, r) {
    var o = this;
    if (t[0].dtype === "complex64") {
      var i = t.map(function(p) {
        return mn(p);
      }), a = t.map(function(p) {
        return $n(p);
      });
      return Et(this.concat(i, r), this.concat(a, r));
    }
    var s = t.map(function(p) {
      var v = ee(p.shape.slice(r));
      return p.as2D(-1, v);
    }), u = di(s.map(function(p) {
      return p.shape;
    }), 1), l = he(u, t[0].dtype).values;
    if (s[0].shape[0] === 1) {
      var c = 0;
      s.forEach(function(p) {
        l.set(o.readSync(p.dataId), c), c += p.size;
      });
    } else {
      var f = 0;
      s.forEach(function(p) {
        for (var v = o.readSync(p.dataId), g = 0, y = 0; y < p.shape[0]; ++y) for (var x = y * u[1] + f, w = 0; w < p.shape[1]; ++w) l[x + w] = v[g++];
        f += p.shape[1];
      });
    }
    var d = di(t.map(function(p) {
      return p.shape;
    }), r);
    return Tt(l, d, t[0].dtype);
  }, e.prototype.neg = function(t) {
    return $(t, "neg"), this.multiply(K(-1), t);
  }, e.prototype.add = function(t, r) {
    return t.dtype === "complex64" || r.dtype === "complex64" ? this.broadcastedBinaryComplexOp(t.cast("complex64"), r.cast("complex64"), function(o, i, a, s) {
      return { real: o + a, imag: i + s };
    }) : this.broadcastedBinaryOp(t, r, Ct(t.dtype, r.dtype), function(o, i) {
      return o + i;
    });
  }, e.prototype.addN = function(t) {
    var r = this;
    $(t, "addN");
    for (var o = t.map(function(c) {
      return r.readSync(c.dataId);
    }), i = he(t[0].shape, t[0].dtype), a = i.values, s = 0; s < t.length; s++) for (var u = o[s], l = 0; l < a.length; l++) a[l] += u[l];
    return i.toTensor();
  }, e.prototype.softmax = function(t, r) {
    var o = gt([r], t.shape), i = this.max(t, o), a = qt(i.shape, o), s = this.subtract(t, i.reshape(a)), u = this.exp(s), l = this.sum(u, o).reshape(a);
    return this.realDivide(u, l);
  }, e.prototype.subtract = function(t, r) {
    return t.dtype === "complex64" || r.dtype === "complex64" ? this.broadcastedBinaryComplexOp(t.cast("complex64"), r.cast("complex64"), function(o, i, a, s) {
      return { real: o - a, imag: i - s };
    }) : this.broadcastedBinaryOp(t, r, Ct(t.dtype, r.dtype), function(o, i) {
      return o - i;
    });
  }, e.prototype.pow = function(t, r) {
    return $([t, r], "pow"), this.broadcastedBinaryOp(t, r, t.dtype, function(o, i) {
      return Math.pow(o, i);
    });
  }, e.prototype.batchMatMul = function(t, r, o, i) {
    $([t, r], "matMul");
    for (var a = o ? t.shape[1] : t.shape[2], s = o ? t.shape[2] : t.shape[1], u = i ? r.shape[1] : r.shape[2], l = t.shape[0], c = this.readSync(t.dataId), f = this.readSync(r.dataId), d = o ? [t.strides[0], 1, t.strides[1]] : [t.strides[0], t.strides[1], 1], p = d[0], v = d[1], g = d[2], y = i ? [1, r.strides[1], r.strides[0]] : [r.strides[1], 1, r.strides[0]], x = y[0], w = y[1], b = y[2], _ = s * u, E = he([l, s, u], t.dtype), C = E.values, A = this.blockSize, R = 0; R < l; R++) for (var I = 0; I < s; I += A) for (var S = 0; S < u; S += A) for (var M = 0; M < a; M += A) for (var P = Math.min(I + A, s), B = Math.min(S + A, u), O = Math.min(M + A, a), U = I; U < P; U++) for (var G = S; G < B; G++) {
      for (var H = 0, W = M; W < O; W++) H += c[R * p + U * v + W * g] * f[W * x + G * w + R * b];
      C[R * _ + (U * u + G)] += H;
    }
    return E.toTensor();
  }, e.prototype.fusedBatchMatMul = function(t) {
    var r = t.a, o = t.b, i = t.transposeA, a = t.transposeB, s = t.bias, u = t.activation, l = t.preluActivationWeights, c = this.batchMatMul(r, o, i, a);
    return s && (c = this.add(c, s)), u && (c = el(this, c, u, l)), c;
  }, e.prototype.multiply = function(t, r) {
    return t.dtype === "complex64" || r.dtype === "complex64" ? this.broadcastedBinaryComplexOp(t.cast("complex64"), r.cast("complex64"), function(o, i, a, s) {
      return { real: o * a - i * s, imag: o * s + i * a };
    }) : this.broadcastedBinaryOp(t, r, Ct(t.dtype, r.dtype), function(o, i) {
      return o * i;
    });
  }, e.prototype.realDivide = function(t, r) {
    return $([t, r], "realDivide"), this.broadcastedBinaryOp(t, r, "float32", function(o, i) {
      return o / i;
    });
  }, e.prototype.floorDiv = function(t, r) {
    return $([t, r], "floorDiv"), this.broadcastedBinaryOp(t, r, "int32", function(o, i) {
      return Math.floor(o / i);
    });
  }, e.prototype.sum = function(t, r) {
    $(t, "sum"), Zt("sum", r, t.rank);
    for (var o = St(t.shape, r), i = o[0], a = o[1], s = Ge(i, Ct(t.dtype, "int32")), u = ee(a), l = this.readSync(s.dataId), c = this.readSync(t.dataId), f = 0; f < l.length; ++f) {
      for (var d = f * u, p = 0, v = 0; v < u; ++v) p += c[d + v];
      l[f] = p;
    }
    return s;
  }, e.prototype.prod = function(t, r) {
    $(t, "sum");
    for (var o = St(t.shape, r), i = o[0], a = o[1], s = Ge(i, Ct(t.dtype, "int32")), u = ee(a), l = this.readSync(s.dataId), c = this.readSync(t.dataId), f = 0; f < l.length; ++f) {
      for (var d = f * u, p = 1, v = 0; v < u; ++v) p *= c[d + v];
      l[f] = p;
    }
    return s;
  }, e.prototype.unsortedSegmentSum = function(t, r, o) {
    $(t, "unsortedSegmentSum");
    for (var i = [], a = t.rank - r.rank, s = 0; s < a; ++s) r = r.expandDims(s + 1);
    for (s = 0; s < o; ++s) {
      var u = K(s, "int32"), l = w0(u, r).asType("float32").mul(t).sum(0);
      i.push(l);
    }
    return on(i);
  }, e.prototype.argMin = function(t, r) {
    $(t, "argMin");
    var o = [r];
    Zt("argMin", o, t.rank);
    for (var i = St(t.shape, o), a = i[0], s = i[1], u = Ge(a, "int32"), l = ee(s), c = this.readSync(u.dataId), f = this.readSync(t.dataId), d = 0; d < c.length; ++d) {
      for (var p = d * l, v = f[p], g = 0, y = 0; y < l; ++y) {
        var x = f[p + y];
        x < v && (v = x, g = y);
      }
      c[d] = g;
    }
    return u;
  }, e.prototype.argMax = function(t, r) {
    $(t, "argMax");
    var o = [r];
    Zt("argMax", o, t.rank);
    for (var i = St(t.shape, o), a = i[0], s = i[1], u = Ge(a, "int32"), l = ee(s), c = this.readSync(u.dataId), f = this.readSync(t.dataId), d = 0; d < c.length; ++d) {
      for (var p = d * l, v = f[p], g = 0, y = 0; y < l; ++y) {
        var x = f[p + y];
        x > v && (v = x, g = y);
      }
      c[d] = g;
    }
    return u;
  }, e.prototype.cumsum = function(t, r, o, i) {
    if ($(t, "cumsum"), r !== t.rank - 1) throw new Error("backend.cumsum in CPU expects an inner-most axis=" + (t.rank - 1) + " but got axis=" + r);
    for (var a = Ct(t.dtype, "int32"), s = Ge(t.shape, a), u = this.readSync(s.dataId), l = this.readSync(t.dataId), c = t.shape[t.rank - 1], f = i ? function(y, x) {
      return y + c - x - 1;
    } : function(y, x) {
      return y + x;
    }, d = 0; d < l.length; d += c) for (var p = 0; p < c; p++) {
      var v = f(d, p);
      if (p === 0) u[v] = o ? 0 : l[v];
      else {
        var g = f(d, p - 1);
        u[v] = o ? l[g] + u[g] : l[v] + u[g];
      }
    }
    return s;
  }, e.prototype.equal = function(t, r) {
    return $([t, r], "equal"), this.broadcastedBinaryOp(t, r, "bool", function(o, i) {
      return o === i ? 1 : 0;
    });
  }, e.prototype.notEqual = function(t, r) {
    return $([t, r], "notEqual"), this.broadcastedBinaryOp(t, r, "bool", function(o, i) {
      return o !== i ? 1 : 0;
    });
  }, e.prototype.less = function(t, r) {
    return $([t, r], "less"), this.broadcastedBinaryOp(t, r, "bool", function(o, i) {
      return o < i ? 1 : 0;
    });
  }, e.prototype.lessEqual = function(t, r) {
    return $([t, r], "lessEqual"), this.broadcastedBinaryOp(t, r, "bool", function(o, i) {
      return o <= i ? 1 : 0;
    });
  }, e.prototype.greater = function(t, r) {
    return $([t, r], "greater"), this.broadcastedBinaryOp(t, r, "bool", function(o, i) {
      return o > i ? 1 : 0;
    });
  }, e.prototype.greaterEqual = function(t, r) {
    return $([t, r], "greaterEqual"), this.broadcastedBinaryOp(t, r, "bool", function(o, i) {
      return o >= i ? 1 : 0;
    });
  }, e.prototype.logicalNot = function(t) {
    $(t, "logicalNot");
    for (var r = this.readSync(t.dataId), o = new Uint8Array(r.length), i = 0; i < r.length; ++i) o[i] = r[i] ? 0 : 1;
    return this.makeOutput(o, t.shape, "bool");
  }, e.prototype.logicalAnd = function(t, r) {
    return $([t, r], "logicalAnd"), this.broadcastedBinaryOp(t, r, "bool", function(o, i) {
      return o && i;
    });
  }, e.prototype.logicalOr = function(t, r) {
    return $([t, r], "logicalOr"), this.broadcastedBinaryOp(t, r, "bool", function(o, i) {
      return o || i;
    });
  }, e.prototype.select = function(t, r, o) {
    $([t, r, o], "select");
    for (var i = this.readSync(t.dataId), a = this.readSync(r.dataId), s = this.readSync(o.dataId), u = Ge(r.shape, Ct(r.dtype, o.dtype)), l = this.readSync(u.dataId), c = 0, f = t.rank === 0 || t.rank > 1 || r.rank === 1 ? 1 : ee(r.shape.slice(1)), d = 0; d < i.length; d++) for (var p = 0; p < f; p++) i[d] === 1 ? l[c++] = a[d] : l[c++] = s[d];
    return u;
  }, e.prototype.where = function(t) {
    $([t], "where");
    var r = this.readSync(t.dataId);
    return Sf(t.shape, r);
  }, e.prototype.topk = function(t, r, o) {
    return $(t, "topk"), Q1(this.readSync(t.dataId), t.shape, t.dtype, r);
  }, e.prototype.min = function(t, r) {
    $(t, "min"), Zt("min", r, t.rank);
    for (var o = St(t.shape, r), i = o[0], a = o[1], s = Ge(i, t.dtype), u = ee(a), l = this.readSync(s.dataId), c = this.readSync(t.dataId), f = 0; f < l.length; ++f) {
      for (var d = f * u, p = c[d], v = 0; v < u; ++v) {
        var g = c[d + v];
        g < p && (p = g);
      }
      l[f] = p;
    }
    return s;
  }, e.prototype.minimum = function(t, r) {
    return $([t, r], "minimum"), this.broadcastedBinaryOp(t, r, t.dtype, function(o, i) {
      return Math.min(o, i);
    });
  }, e.prototype.mod = function(t, r) {
    return $([t, r], "mod"), this.broadcastedBinaryOp(t, r, t.dtype, function(o, i) {
      var a = o % i;
      return o < 0 && i < 0 || o >= 0 && i >= 0 ? a : (a + i) % i;
    });
  }, e.prototype.max = function(t, r) {
    $(t, "max"), Zt("max", r, t.rank);
    for (var o = St(t.shape, r), i = o[0], a = o[1], s = Ge(i, t.dtype), u = ee(a), l = this.readSync(s.dataId), c = this.readSync(t.dataId), f = 0; f < l.length; ++f) {
      for (var d = f * u, p = c[d], v = 0; v < u; ++v) {
        var g = c[d + v];
        g > p && (p = g);
      }
      l[f] = p;
    }
    return s;
  }, e.prototype.maximum = function(t, r) {
    return $([t, r], "maximum"), this.broadcastedBinaryOp(t, r, t.dtype, function(o, i) {
      return Math.max(o, i);
    });
  }, e.prototype.all = function(t, r) {
    $(t, "all"), Zt("all", r, t.rank);
    for (var o = St(t.shape, r), i = o[0], a = o[1], s = Ge(i, t.dtype), u = ee(a), l = this.readSync(s.dataId), c = this.readSync(t.dataId), f = 0; f < l.length; ++f) {
      for (var d = f * u, p = c[d], v = 0; v < u; ++v) {
        var g = c[d + v];
        p = p && g;
      }
      l[f] = p;
    }
    return s;
  }, e.prototype.any = function(t, r) {
    $(t, "any"), Zt("any", r, t.rank);
    for (var o = St(t.shape, r), i = o[0], a = o[1], s = Ge(i, t.dtype), u = ee(a), l = this.readSync(s.dataId), c = this.readSync(t.dataId), f = 0; f < l.length; ++f) {
      for (var d = f * u, p = c[d], v = 0; v < u; ++v) {
        var g = c[d + v];
        p = p || g;
      }
      l[f] = p;
    }
    return s;
  }, e.prototype.squaredDifference = function(t, r) {
    return $([t, r], "squaredDifference"), this.broadcastedBinaryOp(t, r, t.dtype, function(o, i) {
      var a = o - i;
      return a * a;
    });
  }, e.prototype.ceil = function(t) {
    $(t, "ceil");
    for (var r = this.readSync(t.dataId), o = new Float32Array(r.length), i = 0; i < r.length; ++i) o[i] = Math.ceil(r[i]);
    return this.makeOutput(o, t.shape, "float32");
  }, e.prototype.floor = function(t) {
    $(t, "floor");
    for (var r = this.readSync(t.dataId), o = new Float32Array(r.length), i = 0; i < r.length; ++i) o[i] = Math.floor(r[i]);
    return this.makeOutput(o, t.shape, "float32");
  }, e.prototype.sign = function(t) {
    $(t, "x");
    for (var r = this.readSync(t.dataId), o = new Float32Array(r.length), i = 0; i < r.length; ++i) r[i] < 0 ? o[i] = -1 : r[i] > 0 ? o[i] = 1 : o[i] = 0;
    return this.makeOutput(o, t.shape, "float32");
  }, e.prototype.isNaN = function(t) {
    $(t, "x");
    for (var r = this.readSync(t.dataId), o = new Uint8Array(r.length), i = 0; i < r.length; ++i) Number.isNaN(r[i]) && (o[i] = 1);
    return this.makeOutput(o, t.shape, "bool");
  }, e.prototype.isInf = function(t) {
    $(t, "x");
    for (var r = this.readSync(t.dataId), o = new Uint8Array(r.length), i = 0; i < r.length; ++i) Math.abs(r[i]) === 1 / 0 && (o[i] = 1);
    return this.makeOutput(o, t.shape, "bool");
  }, e.prototype.isFinite = function(t) {
    $(t, "x");
    for (var r = this.readSync(t.dataId), o = new Uint8Array(r.length), i = 0; i < r.length; ++i) Number.isFinite(r[i]) && (o[i] = 1);
    return this.makeOutput(o, t.shape, "bool");
  }, e.prototype.round = function(t) {
    $(t, "round");
    for (var r = this.readSync(t.dataId), o = new Float32Array(r.length), i = 0; i < r.length; ++i) {
      var a = Math.floor(r[i]);
      r[i] - a < 0.5 ? o[i] = Math.floor(r[i]) : r[i] - a > 0.5 ? o[i] = Math.ceil(r[i]) : o[i] = a % 2 == 0 ? a : a + 1;
    }
    return this.makeOutput(o, t.shape, "float32");
  }, e.prototype.exp = function(t) {
    $(t, "exp");
    for (var r = this.readSync(t.dataId), o = new Float32Array(r.length), i = 0; i < r.length; ++i) o[i] = Math.exp(r[i]);
    return this.makeOutput(o, t.shape, "float32");
  }, e.prototype.expm1 = function(t) {
    $(t, "expm1");
    for (var r = this.readSync(t.dataId), o = new Float32Array(r.length), i = 0; i < r.length; ++i) o[i] = Math.expm1(r[i]);
    return this.makeOutput(o, t.shape, "float32");
  }, e.prototype.log = function(t) {
    $(t, "log");
    for (var r = this.readSync(t.dataId), o = new Float32Array(r.length), i = 0; i < r.length; ++i) {
      var a = r[i];
      o[i] = Math.log(a);
    }
    return this.makeOutput(o, t.shape, "float32");
  }, e.prototype.log1p = function(t) {
    $(t, "log1p");
    for (var r = this.readSync(t.dataId), o = new Float32Array(r.length), i = 0; i < r.length; ++i) {
      var a = r[i];
      o[i] = Math.log1p(a);
    }
    return this.makeOutput(o, t.shape, "float32");
  }, e.prototype.sqrt = function(t) {
    $(t, "sqrt");
    for (var r = this.readSync(t.dataId), o = new Float32Array(r.length), i = 0; i < r.length; ++i) {
      var a = r[i];
      o[i] = Math.sqrt(a);
    }
    return this.makeOutput(o, t.shape, "float32");
  }, e.prototype.rsqrt = function(t) {
    $(t, "rsqrt");
    for (var r = this.readSync(t.dataId), o = new Float32Array(r.length), i = 0; i < r.length; ++i) {
      var a = r[i];
      o[i] = 1 / Math.sqrt(a);
    }
    return this.makeOutput(o, t.shape, "float32");
  }, e.prototype.reciprocal = function(t) {
    $(t, "reciprocal");
    for (var r = this.readSync(t.dataId), o = new Float32Array(r.length), i = 0; i < r.length; ++i) o[i] = 1 / r[i];
    return this.makeOutput(o, t.shape, "float32");
  }, e.prototype.linear = function(t) {
    return t;
  }, e.prototype.relu = function(t) {
    $(t, "relu");
    for (var r = Ge(t.shape, t.dtype), o = this.readSync(r.dataId), i = this.readSync(t.dataId), a = 0; a < i.length; ++a) o[a] = Math.max(0, i[a]);
    return r;
  }, e.prototype.relu6 = function(t) {
    $(t, "relu");
    for (var r = Ge(t.shape, t.dtype), o = this.readSync(r.dataId), i = this.readSync(t.dataId), a = 0; a < i.length; ++a) o[a] = Math.min(Math.max(0, i[a]), 6);
    return r;
  }, e.prototype.prelu = function(t, r) {
    return $([t, r], "prelu"), this.broadcastedBinaryOp(t, r, t.dtype, function(o, i) {
      return o < 0 ? i * o : o;
    });
  }, e.prototype.elu = function(t) {
    $(t, "elu");
    for (var r = new Float32Array(t.size), o = this.readSync(t.dataId), i = 0; i < o.length; ++i) {
      var a = o[i];
      r[i] = a >= 0 ? a : Math.exp(a) - 1;
    }
    return this.makeOutput(r, t.shape, "float32");
  }, e.prototype.eluDer = function(t, r) {
    $([t, r], "eluDer");
    for (var o = new Float32Array(r.size), i = this.readSync(r.dataId), a = this.readSync(t.dataId), s = 0; s < i.length; ++s) {
      var u = i[s];
      o[s] = u >= 1 ? a[s] : a[s] * (u + 1);
    }
    return this.makeOutput(o, r.shape, "float32");
  }, e.prototype.selu = function(t) {
    $(t, "selu");
    for (var r = Rf, o = kf, i = new Float32Array(t.size), a = this.readSync(t.dataId), s = 0; s < a.length; ++s) {
      var u = a[s];
      i[s] = u >= 0 ? o * u : r * (Math.exp(u) - 1);
    }
    return this.makeOutput(i, t.shape, "float32");
  }, e.prototype.clip = function(t, r, o) {
    $(t, "clip");
    for (var i = new Float32Array(t.size), a = this.readSync(t.dataId), s = 0; s < a.length; ++s) {
      var u = a[s];
      i[s] = u > o ? o : u < r ? r : u;
    }
    return this.makeOutput(i, t.shape, "float32");
  }, e.prototype.abs = function(t) {
    for (var r = new Float32Array(t.size), o = this.readSync(t.dataId), i = 0; i < o.length; ++i) r[i] = Math.abs(o[i]);
    return this.makeOutput(r, t.shape, "float32");
  }, e.prototype.complexAbs = function(t) {
    for (var r = new Float32Array(t.size), o = this.readSync(t.dataId), i = 0; i < t.size; ++i) {
      var a = o[2 * i], s = o[2 * i + 1];
      r[i] = Math.hypot(a, s);
    }
    return this.makeOutput(r, t.shape, "float32");
  }, e.prototype.int = function(t) {
    $(t, "int");
    for (var r = new Int32Array(t.size), o = this.readSync(t.dataId), i = 0; i < o.length; ++i) r[i] = o[i];
    return this.makeOutput(r, t.shape, "int32");
  }, e.prototype.sigmoid = function(t) {
    $(t, "sigmoid");
    for (var r = new Float32Array(t.size), o = this.readSync(t.dataId), i = 0; i < o.length; ++i) r[i] = 1 / (1 + Math.exp(-o[i]));
    return this.makeOutput(r, t.shape, "float32");
  }, e.prototype.softplus = function(t) {
    $(t, "softplus");
    for (var r = Math.log(11920928955078125e-23) + 2, o = new Float32Array(t.size), i = this.readSync(t.dataId), a = 0; a < i.length; ++a) {
      var s = i[a] > -r, u = i[a] < r, l = Math.exp(i[a]), c = void 0;
      c = u ? l : s ? i[a] : Math.log(1 + l), o[a] = c;
    }
    return this.makeOutput(o, t.shape, "float32");
  }, e.prototype.sin = function(t) {
    $(t, "sin");
    for (var r = new Float32Array(t.size), o = this.readSync(t.dataId), i = 0; i < o.length; ++i) r[i] = Math.sin(o[i]);
    return this.makeOutput(r, t.shape, "float32");
  }, e.prototype.cos = function(t) {
    $(t, "cos");
    for (var r = new Float32Array(t.size), o = this.readSync(t.dataId), i = 0; i < o.length; ++i) r[i] = Math.cos(o[i]);
    return this.makeOutput(r, t.shape, "float32");
  }, e.prototype.tan = function(t) {
    $(t, "tan");
    for (var r = new Float32Array(t.size), o = this.readSync(t.dataId), i = 0; i < o.length; ++i) r[i] = Math.tan(o[i]);
    return this.makeOutput(r, t.shape, "float32");
  }, e.prototype.asin = function(t) {
    $(t, "asin");
    for (var r = new Float32Array(t.size), o = this.readSync(t.dataId), i = 0; i < o.length; ++i) r[i] = Math.asin(o[i]);
    return this.makeOutput(r, t.shape, "float32");
  }, e.prototype.acos = function(t) {
    $(t, "acos");
    for (var r = new Float32Array(t.size), o = this.readSync(t.dataId), i = 0; i < o.length; ++i) r[i] = Math.acos(o[i]);
    return this.makeOutput(r, t.shape, "float32");
  }, e.prototype.atan = function(t) {
    $(t, "atan");
    for (var r = new Float32Array(t.size), o = this.readSync(t.dataId), i = 0; i < o.length; ++i) r[i] = Math.atan(o[i]);
    return this.makeOutput(r, t.shape, "float32");
  }, e.prototype.atan2 = function(t, r) {
    return $([t, r], "atan2"), this.broadcastedBinaryOp(t, r, t.dtype, function(o, i) {
      return Math.atan2(o, i);
    });
  }, e.prototype.sinh = function(t) {
    $(t, "sinh");
    for (var r = new Float32Array(t.size), o = this.readSync(t.dataId), i = 0; i < o.length; ++i) r[i] = Math.sinh(o[i]);
    return this.makeOutput(r, t.shape, "float32");
  }, e.prototype.cosh = function(t) {
    $(t, "cosh");
    for (var r = new Float32Array(t.size), o = this.readSync(t.dataId), i = 0; i < o.length; ++i) r[i] = Math.cosh(o[i]);
    return this.makeOutput(r, t.shape, "float32");
  }, e.prototype.tanh = function(t) {
    $(t, "tanh");
    for (var r = new Float32Array(t.size), o = this.readSync(t.dataId), i = 0; i < o.length; ++i) r[i] = jC(o[i]);
    return this.makeOutput(r, t.shape, "float32");
  }, e.prototype.asinh = function(t) {
    $(t, "asinh");
    for (var r = new Float32Array(t.size), o = this.readSync(t.dataId), i = 0; i < o.length; ++i) r[i] = Math.asinh(o[i]);
    return this.makeOutput(r, t.shape, "float32");
  }, e.prototype.acosh = function(t) {
    $(t, "acosh");
    for (var r = new Float32Array(t.size), o = this.readSync(t.dataId), i = 0; i < o.length; ++i) r[i] = Math.acosh(o[i]);
    return this.makeOutput(r, t.shape, "float32");
  }, e.prototype.atanh = function(t) {
    $(t, "atanh");
    for (var r = new Float32Array(t.size), o = this.readSync(t.dataId), i = 0; i < o.length; ++i) r[i] = Math.atanh(o[i]);
    return this.makeOutput(r, t.shape, "float32");
  }, e.prototype.erf = function(t) {
    $(t, "erf");
    for (var r = new Float32Array(t.size), o = this.readSync(t.dataId), i = 0; i < o.length; ++i) {
      var a = Math.sign(o[i]), s = Math.abs(o[i]), u = 1 / (1 + 0.3275911 * s);
      r[i] = a * (1 - ((((1.061405429 * u - 1.453152027) * u + 1.421413741) * u - 0.284496736) * u + 0.254829592) * u * Math.exp(-s * s));
    }
    return this.makeOutput(r, t.shape, "float32");
  }, e.prototype.step = function(t, r) {
    r === void 0 && (r = 0), $(t, "step");
    for (var o = new Float32Array(t.size), i = this.readSync(t.dataId), a = 0; a < i.length; ++a) {
      var s = i[a];
      isNaN(s) ? o[a] = NaN : o[a] = s > 0 ? 1 : r;
    }
    return this.makeOutput(o, t.shape, "float32");
  }, e.prototype.fusedConv2d = function(t) {
    var r = t.input, o = t.filter, i = t.convInfo, a = t.bias, s = t.activation, u = t.preluActivationWeights, l = this.conv2d(r, o, i);
    return a && (l = this.add(l, a)), s && (l = el(this, l, s, u)), l;
  }, e.prototype.conv2d = function(t, r, o) {
    $([t, r], "conv2d");
    for (var i = o.filterHeight, a = o.filterWidth, s = o.dilationHeight, u = o.dilationWidth, l = o.padInfo.left, c = o.padInfo.top, f = o.dataFormat === "channelsLast", d = he(o.outShape, t.dtype), p = t.strides[0], v = f ? t.strides[1] : t.strides[2], g = f ? t.strides[2] : 1, y = f ? 1 : t.strides[1], x = d.strides[0], w = f ? d.strides[1] : d.strides[2], b = f ? d.strides[2] : 1, _ = f ? 1 : d.strides[1], E = this.readSync(t.dataId), C = this.readSync(r.dataId), A = d.values, R = 0; R < o.batchSize; ++R) for (var I = R * p, S = R * x, M = 0; M < o.outHeight; ++M) for (var P = S + M * w, B = M * o.strideHeight - c, O = 0; O < i; O++) {
      var U = B + O * s;
      if (!(U < 0 || U >= o.inHeight)) for (var G = O * r.strides[0], H = I + U * v, W = 0; W < o.outWidth; ++W) for (var q = P + W * b, z = W * o.strideWidth - l, J = 0; J < a; J++) {
        var ie = z + J * u;
        if (!(ie < 0 || ie >= o.inWidth)) for (var ce = H + ie * g, me = G + J * r.strides[1], ve = 0; ve < o.inChannels; ++ve) {
          for (var ye = E[ce + ve * y], Ce = 0; Ce < o.outChannels; ++Ce) A[q + Ce * _] += ye * C[me + Ce];
          me += o.outChannels;
        }
      }
    }
    return d.toTensor();
  }, e.prototype.conv3d = function(t, r, o) {
    for (var i = o.filterDepth, a = o.filterHeight, s = o.filterWidth, u = o.dilationDepth, l = o.dilationHeight, c = o.dilationWidth, f = o.padInfo.front, d = o.padInfo.left, p = o.padInfo.top, v = he(o.outShape, t.dtype), g = this.readSync(t.dataId), y = this.readSync(r.dataId), x = v.values, w = 0; w < o.batchSize; ++w) for (var b = w * t.strides[0], _ = w * v.strides[0], E = 0; E < o.outDepth; ++E) for (var C = _ + E * v.strides[1], A = E * o.strideDepth - f, R = 0; R < i; R++) {
      var I = A + R * u;
      if (!(I < 0 || I >= o.inDepth)) for (var S = R * r.strides[0], M = b + I * t.strides[1], P = 0; P < o.outHeight; ++P) for (var B = C + P * v.strides[2], O = P * o.strideHeight - p, U = 0; U < a; U++) {
        var G = O + U * l;
        if (!(G < 0 || G >= o.inHeight)) for (var H = S + U * r.strides[1], W = M + G * t.strides[2], q = 0; q < o.outWidth; ++q) for (var z = B + q * o.outChannels, J = q * o.strideWidth - d, ie = 0; ie < s; ie++) {
          var ce = J + ie * c;
          if (!(ce < 0 || ce >= o.inWidth)) for (var me = H + ie * r.strides[2], ve = W + ce * o.inChannels, ye = me, Ce = 0; Ce < o.inChannels; ++Ce) {
            for (var _e = g[ve + Ce], Te = 0; Te < o.outChannels; ++Te) x[z + Te] += _e * y[ye + Te];
            ye += o.outChannels;
          }
        }
      }
    }
    return v.toTensor();
  }, e.prototype.conv2dDerInput = function(t, r, o) {
    $([t, r], "conv2dDerInput");
    for (var i = he(o.inShape, "float32"), a = i.values, s = this.readSync(t.dataId), u = this.readSync(r.dataId), l = r.strides, c = l[0], f = l[1], d = l[2], p = o.batchSize, v = o.filterHeight, g = o.filterWidth, y = o.inChannels, x = o.inHeight, w = o.inWidth, b = o.outChannels, _ = o.outHeight, E = o.outWidth, C = o.strideHeight, A = o.strideWidth, R = o.dataFormat, I = v - 1 - o.padInfo.top, S = g - 1 - o.padInfo.left, M = R === "channelsLast", P = i.strides[0], B = M ? i.strides[1] : i.strides[2], O = M ? i.strides[2] : 1, U = M ? 1 : i.strides[1], G = t.strides[0], H = M ? t.strides[1] : t.strides[2], W = M ? t.strides[2] : 1, q = M ? 1 : t.strides[1], z = 0; z < p; ++z) for (var J = 0; J < y; ++J) for (var ie = 0; ie < x; ++ie) for (var ce = ie - I, me = Math.max(0, Math.ceil(ce / C)), ve = Math.min(_, (v + ce) / C), ye = 0; ye < w; ++ye) {
      for (var Ce = ye - S, _e = Math.max(0, Math.ceil(Ce / A)), Te = Math.min(E, (g + Ce) / A), rt = 0, be = me; be < ve; ++be) for (var Fe = be * C - ce, ke = _e; ke < Te; ++ke) for (var Ze = G * z + H * be + W * ke, ze = c * (v - 1 - Fe) + f * (g - 1 - (ke * A - Ce)) + d * J, Ke = 0; Ke < b; ++Ke)
        rt += s[Ze + q * Ke] * u[ze + Ke];
      a[P * z + B * ie + O * ye + U * J] = rt;
    }
    return i.toTensor();
  }, e.prototype.conv3dDerInput = function(t, r, o) {
    for (var i = he(o.inShape, "float32"), a = i.values, s = i.strides, u = s[0], l = s[1], c = s[2], f = s[3], d = this.readSync(t.dataId), p = t.strides, v = p[0], g = p[1], y = p[2], x = p[3], w = this.readSync(r.dataId), b = r.strides, _ = b[0], E = b[1], C = b[2], A = b[3], R = o.batchSize, I = o.filterDepth, S = o.filterHeight, M = o.filterWidth, P = o.inChannels, B = o.inDepth, O = o.inHeight, U = o.inWidth, G = o.outChannels, H = o.outDepth, W = o.outHeight, q = o.outWidth, z = o.strideDepth, J = o.strideHeight, ie = o.strideWidth, ce = I - 1 - o.padInfo.front, me = S - 1 - o.padInfo.top, ve = M - 1 - o.padInfo.left, ye = 0; ye < R; ++ye) for (var Ce = 0; Ce < P; ++Ce) for (var _e = 0; _e < B; ++_e) for (var Te = _e - ce, rt = Math.max(0, Math.ceil(Te / z)), be = Math.min(H, (I + Te) / z), Fe = 0; Fe < O; ++Fe) for (var ke = Fe - me, Ze = Math.max(0, Math.ceil(ke / J)), ze = Math.min(W, (S + ke) / J), Ke = 0; Ke < U; ++Ke) {
      for (var Mn = Ke - ve, Dn = Math.max(0, Math.ceil(Mn / ie)), Jt = Math.min(q, (M + Mn) / ie), Co = 0, rr = rt; rr < be; ++rr) for (var Tr = rr * z - Te, or = Ze; or < ze; ++or) for (var To = or * J - ke, ir = Dn; ir < Jt; ++ir) for (var yu = v * ye + g * rr + y * or + x * ir, Io = _ * (I - 1 - Tr) + E * (S - 1 - To) + C * (M - 1 - (ir * ie - Mn)) + A * Ce, Fn = 0; Fn < G; ++Fn)
        Co += d[yu + Fn] * w[Io + Fn];
      a[u * ye + l * _e + c * Fe + f * Ke + Ce] = Co;
    }
    return i.toTensor();
  }, e.prototype.conv2dDerFilter = function(t, r, o) {
    $([t, r], "conv2dDerFilter");
    for (var i = o.strideHeight, a = o.strideWidth, s = o.filterHeight, u = o.filterWidth, l = o.dataFormat === "channelsLast", c = he(o.filterShape, "float32"), f = o.padInfo.left, d = o.padInfo.top, p = this.bufferSync(t), v = this.bufferSync(r), g = 0; g < s; ++g) for (var y = Math.max(0, Math.ceil((d - g) / i)), x = Math.min(o.outHeight, (o.inHeight + d - g) / i), w = 0; w < u; ++w) for (var b = Math.max(0, Math.ceil((f - w) / a)), _ = Math.min(o.outWidth, (o.inWidth + f - w) / a), E = 0; E < o.inChannels; ++E) for (var C = 0; C < o.outChannels; ++C) {
      for (var A = 0, R = 0; R < o.batchSize; ++R) for (var I = y; I < x; ++I) for (var S = g + I * i - d, M = b; M < _; ++M) {
        var P = w + M * a - f;
        A += l ? p.get(R, S, P, E) * v.get(R, I, M, C) : p.get(R, E, S, P) * v.get(R, C, I, M);
      }
      c.set(A, g, w, E, C);
    }
    return c.toTensor();
  }, e.prototype.conv3dDerFilter = function(t, r, o) {
    for (var i = o.strideDepth, a = o.strideHeight, s = o.strideWidth, u = o.filterDepth, l = o.filterHeight, c = o.filterWidth, f = he(o.filterShape, "float32"), d = f.values, p = f.strides, v = p[0], g = p[1], y = p[2], x = p[3], w = this.readSync(r.dataId), b = r.strides, _ = b[0], E = b[1], C = b[2], A = b[3], R = this.readSync(t.dataId), I = t.strides, S = I[0], M = I[1], P = I[2], B = I[3], O = o.padInfo.front, U = o.padInfo.left, G = o.padInfo.top, H = 0; H < u; ++H) for (var W = Math.max(0, Math.ceil((O - H) / i)), q = Math.min(o.outDepth, (o.inDepth + O - H) / i), z = H * v, J = 0; J < l; ++J) for (var ie = Math.max(0, Math.ceil((G - J) / a)), ce = Math.min(o.outHeight, (o.inHeight + G - J) / a), me = J * g + z, ve = 0; ve < c; ++ve) for (var ye = Math.max(0, Math.ceil((U - ve) / s)), Ce = Math.min(o.outWidth, (o.inWidth + U - ve) / s), _e = ve * y + me, Te = 0; Te < o.inChannels; ++Te) for (var rt = Te * x + _e, be = 0; be < o.outChannels; ++be) {
      for (var Fe = 0, ke = 0; ke < o.batchSize; ++ke) for (var Ze = ke * S, ze = ke * _, Ke = W; Ke < q; ++Ke) for (var Mn = (H + Ke * i - O) * M + Ze, Dn = Ke * E + ze, Jt = ie; Jt < ce; ++Jt) for (var Co = (J + Jt * a - G) * P + Mn, rr = Jt * C + Dn, Tr = ye; Tr < Ce; ++Tr) {
        var or = Tr * A + rr;
        Fe += R[(ve + Tr * s - U) * B + Co + Te] * w[or + be];
      }
      d[rt + be] = Fe;
    }
    return f.toTensor();
  }, e.prototype.fusedDepthwiseConv2D = function(t) {
    var r = t.input, o = t.filter, i = t.convInfo, a = t.bias, s = t.activation, u = t.preluActivationWeights, l = this.depthwiseConv2D(r, o, i);
    return a && (l = this.add(l, a)), s && (l = el(this, l, s, u)), l;
  }, e.prototype.depthwiseConv2D = function(t, r, o) {
    $([t, r], "depthwiseConv2D");
    for (var i = o.filterHeight, a = o.filterWidth, s = o.dilationHeight, u = o.dilationWidth, l = o.padInfo.left, c = o.padInfo.top, f = o.outChannels / o.inChannels, d = he(o.outShape, t.dtype), p = this.readSync(t.dataId), v = this.readSync(r.dataId), g = d.values, y = 0; y < o.batchSize; ++y) for (var x = y * t.strides[0], w = y * d.strides[0], b = 0; b < o.outHeight; ++b) for (var _ = w + b * d.strides[1], E = b * o.strideHeight - l, C = 0; C < i; ++C) {
      var A = E + C * s;
      if (!(A < 0 || A >= o.inHeight)) for (var R = C * r.strides[0], I = x + A * t.strides[1], S = 0; S < o.outWidth; ++S) for (var M = _ + S * d.strides[2], P = S * o.strideWidth - c, B = 0; B < a; ++B) {
        var O = P + B * u;
        if (!(O < 0 || O >= o.inWidth)) for (var U = R + B * r.strides[1], G = I + O * o.inChannels, H = M, W = U, q = 0; q < o.inChannels; ++q) {
          for (var z = p[G + q], J = 0; J < f; ++J) g[H + J] += z * v[W + J];
          H += f, W += f;
        }
      }
    }
    return d.toTensor();
  }, e.prototype.depthwiseConv2DDerInput = function(t, r, o) {
    $([t, r], "depthwiseConv2DDerInput");
    for (var i = he(o.inShape, "float32"), a = i.values, s = i.strides, u = s[0], l = s[1], c = s[2], f = this.readSync(t.dataId), d = t.strides, p = d[0], v = d[1], g = d[2], y = this.readSync(r.dataId), x = r.strides, w = x[0], b = x[1], _ = x[2], E = o.batchSize, C = o.filterHeight, A = o.filterWidth, R = o.inChannels, I = o.inHeight, S = o.inWidth, M = o.outChannels, P = o.outHeight, B = o.outWidth, O = o.strideHeight, U = o.strideWidth, G = C - 1 - o.padInfo.top, H = A - 1 - o.padInfo.left, W = M / R, q = 0; q < E; ++q) for (var z = 0; z < R; ++z) for (var J = 0; J < I; ++J) for (var ie = J - G, ce = Math.max(0, Math.ceil(ie / O)), me = Math.min(P, (C + ie) / O), ve = 0; ve < S; ++ve) {
      for (var ye = ve - H, Ce = Math.max(0, Math.ceil(ye / U)), _e = Math.min(B, (A + ye) / U), Te = 0, rt = ce; rt < me; ++rt) for (var be = rt * O - ie, Fe = Ce; Fe < _e; ++Fe) for (var ke = p * q + v * rt + g * Fe, Ze = w * (C - 1 - be) + b * (A - 1 - (Fe * U - ye)) + _ * z, ze = 0; ze < W; ++ze)
        Te += f[ke + (z * W + ze)] * y[Ze + ze];
      a[u * q + l * J + c * ve + z] = Te;
    }
    return i.toTensor();
  }, e.prototype.depthwiseConv2DDerFilter = function(t, r, o) {
    $([t, r], "depthwiseConv2DDerFilter");
    for (var i = o.strideHeight, a = o.strideWidth, s = o.filterHeight, u = o.filterWidth, l = he(o.filterShape, "float32"), c = o.padInfo.left, f = o.padInfo.top, d = o.outChannels / o.inChannels, p = this.bufferSync(t), v = this.bufferSync(r), g = 0; g < s; ++g) for (var y = Math.max(0, Math.ceil((f - g) / i)), x = Math.min(o.outHeight, (o.inHeight + f - g) / i), w = 0; w < u; ++w) for (var b = Math.max(0, Math.ceil((c - w) / a)), _ = Math.min(o.outWidth, (o.inWidth + c - w) / a), E = 0; E < o.outChannels; ++E) {
      for (var C = Math.trunc(E / d), A = E % d, R = 0, I = 0; I < o.batchSize; ++I) for (var S = y; S < x; ++S) for (var M = g + S * i - f, P = b; P < _; ++P) {
        var B = w + P * a - c;
        R += p.get(I, M, B, C) * v.get(I, S, P, E);
      }
      l.set(R, g, w, C, A);
    }
    return l.toTensor();
  }, e.prototype.tile = function(t, r) {
    return $(t, "tile"), Y1(this.bufferSync(t), r);
  }, e.prototype.pad = function(t, r, o) {
    $(t, "pad");
    var i = r.map(function(d, p) {
      return d[0] + t.shape[p] + d[1];
    }), a = r.map(function(d) {
      return d[0];
    }), s = this.bufferSync(t), u = he(i, t.dtype);
    o !== 0 && u.values.fill(o);
    for (var l = 0; l < t.size; l++) {
      var c = s.indexToLoc(l), f = c.map(function(d, p) {
        return d + a[p];
      });
      u.set.apply(u, [s.get.apply(s, c)].concat(f));
    }
    return u.toTensor();
  }, e.prototype.transpose = function(t, r) {
    $(t, "transpose");
    for (var o = new Array(t.rank), i = 0; i < o.length; i++) o[i] = t.shape[r[i]];
    var a = this.readSync(t.dataId), s = he(o, t.dtype), u = this.bufferSync(t);
    for (i = 0; i < t.size; ++i) {
      for (var l = u.indexToLoc(i), c = new Array(l.length), f = 0; f < c.length; f++) c[f] = l[r[f]];
      var d = s.locToIndex(c);
      s.values[d] = a[i];
    }
    return s.toTensor();
  }, e.prototype.gather = function(t, r, o) {
    $([t, r], "gather");
    var i = t.shape.slice(), a = this.readSync(r.dataId);
    i[o] = a.length;
    for (var s = he(i, t.dtype), u = this.bufferSync(t), l = 0; l < s.size; ++l) {
      var c = s.indexToLoc(l), f = c.slice();
      f[o] = a[c[o]];
      var d = u.locToIndex(f);
      s.values[l] = u.values[d];
    }
    return s.toTensor();
  }, e.prototype.batchToSpaceND = function(t, r, o) {
    $([t], "batchToSpaceND");
    var i = r.reduce(function(f, d) {
      return f * d;
    }), a = ss(t.shape, r, i), s = us(a.length, r.length), u = ls(t.shape, r, i), l = B1(o, r.length), c = O1(u, o, r.length);
    return t.reshape(a).transpose(s).reshape(u).slice(l, c);
  }, e.prototype.spaceToBatchND = function(t, r, o) {
    $([t], "spaceToBatchND");
    var i = r.reduce(function(d, p) {
      return d * p;
    }), a = [[0, 0]];
    a.push.apply(a, o);
    for (var s = 1 + r.length; s < t.shape.length; ++s) a.push([0, 0]);
    var u = t.pad(a), l = ss(u.shape, r, i, !1), c = us(l.length, r.length, !1), f = ls(u.shape, r, i, !1);
    return u.reshape(l).transpose(c).reshape(f);
  }, e.prototype.pool = function(t, r, o) {
    $(t, "pool");
    for (var i = r.strideHeight, a = r.strideWidth, s = r.dilationHeight, u = r.dilationWidth, l = r.effectiveFilterHeight, c = r.effectiveFilterWidth, f = r.padInfo.top, d = r.padInfo.left, p = o === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, v = this.readSync(t.dataId), g = he(r.outShape, t.dtype), y = g.values, x = r.outShape[1] * r.outShape[2] * r.outShape[3], w = r.outShape[2] * r.outShape[3], b = r.outShape[3], _ = 0; _ < r.batchSize; ++_) for (var E = _ * x, C = _ * t.strides[0], A = 0; A < r.inChannels; ++A) for (var R = 0; R < r.outHeight; ++R) for (var I = R * i - f, S = Math.max(0, I), M = Math.min(r.inHeight, l + I), P = E + R * w, B = 0; B < r.outWidth; ++B) {
      for (var O = B * a - d, U = Math.max(0, O), G = Math.min(r.inWidth, c + O), H = p, W = 0, q = 0, z = S; z < M; z += s) {
        for (var J = C + z * t.strides[1], ie = U; ie < G; ie += u) {
          var ce = v[J + ie * t.strides[2] + A];
          o === "max" && ce > H ? H = ce : o === "avg" && (W += ce, q++);
        }
        if (isNaN(H)) break;
      }
      y[P + B * b + A] = o === "avg" ? W / q : H;
    }
    return g.toTensor();
  }, e.prototype.maxPool = function(t, r) {
    return this.pool(t, r, "max");
  }, e.prototype.maxPoolPositions = function(t, r) {
    for (var o = he(r.outShape, "int32"), i = r.strideHeight, a = r.strideWidth, s = r.dilationHeight, u = r.dilationWidth, l = r.effectiveFilterHeight, c = r.effectiveFilterWidth, f = r.padInfo.top, d = r.padInfo.left, p = this.bufferSync(t), v = 0; v < r.batchSize; ++v) for (var g = 0; g < r.inChannels; ++g) for (var y = 0; y < r.outHeight; ++y) {
      for (var x = y * i - f, w = x; w < 0; ) w += s;
      for (var b = Math.min(r.inHeight, l + x), _ = 0; _ < r.outWidth; ++_) {
        for (var E = _ * a - d, C = E; C < 0; ) C += u;
        for (var A = Math.min(r.inWidth, c + E), R = Number.NEGATIVE_INFINITY, I = -1, S = w; S < b; S += s) for (var M = S - x, P = C; P < A; P += u) {
          var B = P - E, O = p.get(v, S, P, g);
          O > R && (R = O, I = M * c + B);
        }
        o.set(I, v, y, _, g);
      }
    }
    return o.toTensor();
  }, e.prototype.maxPoolBackprop = function(t, r, o, i) {
    $([r, o], "maxPoolBackprop");
    for (var a = this.maxPoolPositions(r, i), s = i.strideHeight, u = i.strideWidth, l = i.dilationHeight, c = i.dilationWidth, f = i.effectiveFilterHeight, d = i.effectiveFilterWidth, p = d - 1 - i.padInfo.left, v = f - 1 - i.padInfo.top, g = he(r.shape, "float32"), y = this.bufferSync(a), x = this.bufferSync(t), w = 0; w < i.batchSize; ++w) for (var b = 0; b < i.inChannels; ++b) for (var _ = 0; _ < i.inHeight; ++_) for (var E = 0; E < i.inWidth; ++E) {
      for (var C = _ - v, A = E - p, R = 0, I = 0; I < f; I += l) {
        var S = (C + I) / s;
        if (!(S < 0 || S >= i.outHeight || Math.floor(S) !== S)) for (var M = 0; M < d; M += c) {
          var P = (A + M) / u;
          if (!(P < 0 || P >= i.outWidth || Math.floor(P) !== P)) {
            var B = f * d - 1 - y.get(w, S, P, b) === I * d + M ? 1 : 0;
            B !== 0 && (R += x.get(w, S, P, b) * B);
          }
        }
      }
      g.set(R, w, _, E, b);
    }
    return g.toTensor();
  }, e.prototype.avgPoolBackprop = function(t, r, o) {
    $([t, r], "avgPoolBackprop");
    for (var i = o.strideHeight, a = o.strideWidth, s = o.filterHeight, u = o.filterWidth, l = o.dilationHeight, c = o.dilationWidth, f = o.effectiveFilterHeight, d = o.effectiveFilterWidth, p = d - 1 - o.padInfo.left, v = f - 1 - o.padInfo.top, g = he(r.shape, "float32"), y = 1 / (s * u), x = this.bufferSync(t), w = 0; w < o.batchSize; ++w) for (var b = 0; b < o.inChannels; ++b) for (var _ = 0; _ < o.inHeight; ++_) for (var E = 0; E < o.inWidth; ++E) {
      for (var C = _ - v, A = E - p, R = 0, I = 0; I < f; I += l) {
        var S = (C + I) / i;
        if (!(S < 0 || S >= o.outHeight || Math.floor(S) !== S)) for (var M = 0; M < d; M += c) {
          var P = (A + M) / a;
          P < 0 || P >= o.outWidth || Math.floor(P) !== P || (R += x.get(w, S, P, b));
        }
      }
      g.set(R * y, w, _, E, b);
    }
    return g.toTensor();
  }, e.prototype.pool3d = function(t, r, o) {
    $(t, "pool3d");
    for (var i = r.strideDepth, a = r.strideHeight, s = r.strideWidth, u = r.dilationDepth, l = r.dilationHeight, c = r.dilationWidth, f = r.effectiveFilterDepth, d = r.effectiveFilterHeight, p = r.effectiveFilterWidth, v = r.padInfo.front, g = r.padInfo.top, y = r.padInfo.left, x = o === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, w = this.readSync(t.dataId), b = he(r.outShape, t.dtype), _ = b.values, E = r.outShape[1] * r.outShape[2] * r.outShape[3] * r.outShape[4], C = r.outShape[2] * r.outShape[3] * r.outShape[4], A = r.outShape[3] * r.outShape[4], R = r.outShape[4], I = 0; I < r.batchSize; ++I) for (var S = I * E, M = I * t.strides[0], P = 0; P < r.inChannels; ++P) for (var B = 0; B < r.outDepth; ++B) {
      for (var O = B * i - v, U = O; U < 0; ) U += u;
      for (var G = Math.min(r.inDepth, f + O), H = S + B * C, W = 0; W < r.outHeight; ++W) {
        for (var q = W * a - g, z = q; z < 0; ) z += l;
        for (var J = Math.min(r.inHeight, d + q), ie = H + W * A, ce = 0; ce < r.outWidth; ++ce) {
          for (var me = ce * s - y, ve = me; ve < 0; ) ve += c;
          for (var ye = Math.min(r.inWidth, p + me), Ce = ie + ce * R, _e = x, Te = 0, rt = 0, be = U; be < G; be += u) {
            for (var Fe = M + be * t.strides[1], ke = z; ke < J; ke += l) {
              for (var Ze = Fe + ke * t.strides[2], ze = ve; ze < ye; ze += c) {
                var Ke = w[Ze + ze * t.strides[3] + P];
                if (o === "max" && Ke > _e ? _e = Ke : o === "avg" && (Te += Ke, rt++), isNaN(_e)) break;
              }
              if (isNaN(_e)) break;
            }
            if (isNaN(_e)) break;
          }
          _[Ce + P] = o === "avg" ? Te / rt : _e;
        }
      }
    }
    return b.toTensor();
  }, e.prototype.avgPool3d = function(t, r) {
    return $(t, "avgPool3d"), this.pool3d(t, r, "avg").toFloat();
  }, e.prototype.avgPool3dBackprop = function(t, r, o) {
    $([t, r], "avgPool3dBackprop");
    for (var i = o.strideDepth, a = o.strideHeight, s = o.strideWidth, u = o.filterDepth, l = o.filterHeight, c = o.filterWidth, f = o.dilationDepth, d = o.dilationHeight, p = o.dilationWidth, v = o.effectiveFilterDepth, g = o.effectiveFilterHeight, y = o.effectiveFilterWidth, x = v - 1 - o.padInfo.front, w = y - 1 - o.padInfo.left, b = g - 1 - o.padInfo.top, _ = he(r.shape, "float32"), E = 1 / (u * l * c), C = this.bufferSync(t), A = 0; A < o.batchSize; ++A) for (var R = 0; R < o.inChannels; ++R) for (var I = 0; I < o.inDepth; ++I) for (var S = 0; S < o.inHeight; ++S) for (var M = 0; M < o.inWidth; ++M) {
      for (var P = I - x, B = S - b, O = M - w, U = 0, G = 0; G < v; G += f) {
        var H = (P + G) / i;
        if (!(H < 0 || H >= o.outDepth || Math.floor(H) !== H)) for (var W = 0; W < g; W += d) {
          var q = (B + W) / a;
          if (!(q < 0 || q >= o.outHeight || Math.floor(q) !== q)) for (var z = 0; z < y; z += p) {
            var J = (O + z) / s;
            J < 0 || J >= o.outWidth || Math.floor(J) !== J || (U += C.get(A, H, q, J, R));
          }
        }
      }
      _.set(U * E, A, I, S, M, R);
    }
    return _.toTensor();
  }, e.prototype.maxPool3d = function(t, r) {
    return $(t, "maxPool3d"), this.pool3d(t, r, "max").toFloat();
  }, e.prototype.maxPool3dPositions = function(t, r) {
    for (var o = he(r.outShape, "int32"), i = r.strideDepth, a = r.strideHeight, s = r.strideWidth, u = r.dilationDepth, l = r.dilationHeight, c = r.dilationWidth, f = r.effectiveFilterDepth, d = r.effectiveFilterHeight, p = r.effectiveFilterWidth, v = r.padInfo.front, g = r.padInfo.top, y = r.padInfo.left, x = this.bufferSync(t), w = 0; w < r.batchSize; ++w) for (var b = 0; b < r.inChannels; ++b) for (var _ = 0; _ < r.outDepth; ++_) {
      for (var E = _ * i - v, C = E; C < 0; ) C += u;
      for (var A = Math.min(r.inDepth, f + E), R = 0; R < r.outHeight; ++R) {
        for (var I = R * a - g, S = I; S < 0; ) S += l;
        for (var M = Math.min(r.inHeight, d + I), P = 0; P < r.outWidth; ++P) {
          for (var B = P * s - y, O = B; O < 0; ) O += c;
          for (var U = Math.min(r.inWidth, p + B), G = Number.NEGATIVE_INFINITY, H = -1, W = C; W < A; W += u) for (var q = W - E, z = S; z < M; z += l) for (var J = z - I, ie = O; ie < U; ie += c) {
            var ce = ie - B, me = x.get(w, W, z, ie, b);
            me >= G && (G = me, H = q * d * p + J * d + ce);
          }
          o.set(H, w, _, R, P, b);
        }
      }
    }
    return o.toTensor();
  }, e.prototype.maxPool3dBackprop = function(t, r, o, i) {
    $([r, o], "maxPool3dBackprop");
    for (var a = this.maxPool3dPositions(r, i), s = i.strideDepth, u = i.strideHeight, l = i.strideWidth, c = i.dilationDepth, f = i.dilationHeight, d = i.dilationWidth, p = i.effectiveFilterDepth, v = i.effectiveFilterHeight, g = i.effectiveFilterWidth, y = p - 1 - i.padInfo.front, x = g - 1 - i.padInfo.left, w = v - 1 - i.padInfo.top, b = he(r.shape, "float32"), _ = this.bufferSync(a), E = this.bufferSync(t), C = 0; C < i.batchSize; ++C) for (var A = 0; A < i.inChannels; ++A) for (var R = 0; R < i.inDepth; ++R) for (var I = 0; I < i.inHeight; ++I) for (var S = 0; S < i.inWidth; ++S) {
      for (var M = R - y, P = I - w, B = S - x, O = 0, U = 0; U < p; U += c) {
        var G = (M + U) / s;
        if (!(G < 0 || G >= i.outDepth || Math.floor(G) !== G)) for (var H = 0; H < v; H += f) {
          var W = (P + H) / u;
          if (!(W < 0 || W >= i.outHeight || Math.floor(W) !== W)) for (var q = 0; q < g; q += d) {
            var z = (B + q) / l;
            if (!(z < 0 || z >= i.outWidth || Math.floor(z) !== z)) {
              var J = p * v * g - 1 - _.get(C, G, W, z, A) === U * v * g + H * g + q ? 1 : 0;
              J !== 0 && (O += E.get(C, G, W, z, A) * J);
            }
          }
        }
      }
      b.set(O, C, R, I, S, A);
    }
    return b.toTensor();
  }, e.prototype.cast = function(t, r) {
    return z1(t, r, this);
  }, e.prototype.reshape = function(t, r) {
    return Zl(t, r);
  }, e.prototype.avgPool = function(t, r) {
    return $(t, "avgPool"), this.pool(t, r, "avg").toFloat();
  }, e.prototype.resizeBilinear = function(t, r, o, i) {
    $(t, "resizeBilinear");
    for (var a = t.shape, s = a[0], u = a[1], l = a[2], c = a[3], f = this.readSync(t.dataId), d = new Float32Array(ee([s, r, o, c])), p = [i && r > 1 ? u - 1 : u, i && o > 1 ? l - 1 : l], v = [i && r > 1 ? r - 1 : r, i && o > 1 ? o - 1 : o], g = 0, y = p[0] / v[0], x = p[1] / v[1], w = 0; w < s; w++) for (var b = 0; b < r; b++) for (var _ = y * b, E = Math.floor(_), C = _ - E, A = Math.min(u - 1, Math.ceil(_)), R = w * t.strides[0] + E * t.strides[1], I = w * t.strides[0] + A * t.strides[1], S = 0; S < o; S++) for (var M = x * S, P = Math.floor(M), B = M - P, O = Math.min(l - 1, Math.ceil(M)), U = R + P * t.strides[2], G = I + P * t.strides[2], H = R + O * t.strides[2], W = I + O * t.strides[2], q = 0; q < c; q++) {
      var z = f[U + q], J = f[G + q], ie = z + (f[H + q] - z) * B, ce = ie + (J + (f[W + q] - J) * B - ie) * C;
      d[g++] = ce;
    }
    return Tt(d, [s, r, o, c]);
  }, e.prototype.resizeBilinearBackprop = function(t, r, o) {
    $([t, r], "resizeBilinearBackprop");
    for (var i = r.shape, a = i[0], s = i[1], u = i[2], l = i[3], c = t.shape, f = c[1], d = c[2], p = new Float32Array(a * s * u * l), v = [o && f > 1 ? s - 1 : s, o && d > 1 ? u - 1 : u], g = [o && f > 1 ? f - 1 : f, o && d > 1 ? d - 1 : d], y = v[0] / g[0], x = v[1] / g[1], w = this.readSync(t.dataId), b = 0, _ = 0; _ < a; _++) for (var E = _ * r.strides[0], C = 0; C < f; C++) for (var A = C * y, R = Math.floor(A), I = Math.min(Math.ceil(A), s - 1), S = E + R * r.strides[1], M = E + I * r.strides[1], P = A - R, B = 1 - P, O = 0; O < d; O++) for (var U = O * x, G = Math.floor(U), H = Math.min(Math.ceil(U), u - 1), W = U - G, q = 1 - W, z = S + G * r.strides[2], J = S + H * r.strides[2], ie = M + G * r.strides[2], ce = M + H * r.strides[2], me = B * q, ve = B * W, ye = P * q, Ce = P * W, _e = 0; _e < l; _e++) {
      var Te = w[b++];
      p[z + _e] += Te * me, p[J + _e] += Te * ve, p[ie + _e] += Te * ye, p[ce + _e] += Te * Ce;
    }
    return Vt(p, [a, u, s, l], r.dtype);
  }, e.prototype.resizeNearestNeighbor = function(t, r, o, i) {
    $(t, "resizeNearestNeighbor");
    for (var a = t.shape, s = a[0], u = a[1], l = a[2], c = a[3], f = this.readSync(t.dataId), d = new Float32Array(s * r * o * c), p = [i && r > 1 ? u - 1 : u, i && o > 1 ? l - 1 : l], v = [i && r > 1 ? r - 1 : r, i && o > 1 ? o - 1 : o], g = p[0] / v[0], y = p[1] / v[1], x = 0, w = 0; w < s; w++) for (var b = w * t.strides[0], _ = 0; _ < r; _++) for (var E = g * _, C = b + Math.min(u - 1, i ? Math.round(E) : Math.floor(E)) * t.strides[1], A = 0; A < o; A++) for (var R = y * A, I = C + Math.min(l - 1, i ? Math.round(R) : Math.floor(R)) * t.strides[2], S = 0; S < c; S++) {
      var M = f[I + S];
      d[x++] = M;
    }
    return Tt(d, [s, r, o, c], t.dtype);
  }, e.prototype.resizeNearestNeighborBackprop = function(t, r, o) {
    $([t, r], "resizeNearestNeighborBackprop");
    for (var i = r.shape, a = i[0], s = i[1], u = i[2], l = i[3], c = t.shape, f = c[1], d = c[2], p = new Float32Array(a * s * u * l), v = this.readSync(t.dataId), g = [o && f > 1 ? s - 1 : s, o && d > 1 ? u - 1 : u], y = [o && f > 1 ? f - 1 : f, o && d > 1 ? d - 1 : d], x = g[0] / y[0], w = g[1] / y[1], b = 1 / x, _ = 1 / w, E = 2 * Math.ceil(b) + 2, C = 2 * Math.ceil(_) + 2, A = 0; A < a; A++) for (var R = A * r.strides[0], I = 0; I < s; I++) for (var S = R + I * r.strides[1], M = Math.floor(I * b), P = Math.floor(M - E / 2), B = 0; B < u; B++) for (var O = S + B * r.strides[2], U = Math.floor(B * _), G = Math.floor(U - C / 2), H = 0; H < l; H++) {
      for (var W = 0, q = 0; q < E; q++) {
        var z = q + P;
        if (!(z < 0 || z >= f)) {
          var J = R + z * t.strides[1], ie = z * x;
          if (I === Math.min(s - 1, o ? Math.round(ie) : Math.floor(ie))) for (var ce = 0; ce < C; ce++) {
            var me = ce + G;
            if (!(me < 0 || me >= d)) {
              var ve = J + me * t.strides[2], ye = me * w;
              B === Math.min(u - 1, o ? Math.round(ye) : Math.floor(ye)) && (W += v[ve + H]);
            }
          }
        }
      }
      p[O + H] = W;
    }
    return Vt(p, r.shape, r.dtype);
  }, e.prototype.batchNormalization = function(t, r, o, i, a, s) {
    $([t, r, o, a, s], "batchNorm");
    for (var u = this.readSync(t.dataId), l = this.readSync(r.dataId), c = this.readSync(o.dataId), f = a ? this.readSync(a.dataId) : new Float32Array([1]), d = s ? this.readSync(s.dataId) : new Float32Array([0]), p = new Float32Array(u.length), v = d.length, g = f.length, y = c.length, x = l.length, w = 0, b = 0, _ = 0, E = 0, C = 0; C < u.length; ++C) p[C] = d[w++] + (u[C] - l[b++]) * f[_++] / Math.sqrt(c[E++] + i), w >= v && (w = 0), b >= x && (b = 0), _ >= g && (_ = 0), E >= y && (E = 0);
    return Vt(p, t.shape);
  }, e.prototype.localResponseNormalization4D = function(t, r, o, i, a) {
    $(t, "localResponseNormalization4D");
    var s = t.shape[3], u = s - 1, l = this.readSync(t.dataId), c = t.size, f = new Float32Array(c);
    function d(y) {
      for (var x = y % s, w = y - x + Math.max(0, x - r), b = y - x + Math.min(x + r, u), _ = 0; w <= b; w++) {
        var E = l[w];
        _ += E * E;
      }
      return _;
    }
    for (var p = 0; p < c; p++) {
      var v = d(p), g = l[p] * Math.pow(o + i * v, -a);
      f[p] = g;
    }
    return Vt(f, t.shape);
  }, e.prototype.LRNGrad = function(t, r, o, i, a, s, u) {
    $(t, "LRNGrad");
    for (var l = t.shape[3], c = this.readSync(t.dataId), f = this.readSync(r.dataId), d = this.readSync(o.dataId), p = new Float32Array(t.size), v = t.size, g = 0; g < v; g++) {
      for (var y = g % l, x = g - y + Math.max(0, y - i), w = g - y + Math.min(l, y + i + 1), b = 0, _ = x; _ < w; _++) b += Math.pow(f[_], 2);
      for (b = s * b + a, _ = x; _ < w; _++) {
        var E = -2 * s * u * f[_] * d[g] / b;
        g === _ && (E += Math.pow(b, -u)), E *= c[g], p[_] += E;
      }
    }
    return Vt(p, t.shape);
  }, e.prototype.multinomial = function(t, r, o, i) {
    $(t, "multinomial");
    for (var a = r ? t : wr(t), s = a.shape[0], u = a.shape[1], l = Ge([s, o], "int32"), c = this.readSync(l.dataId), f = this.readSync(a.dataId), d = 0; d < s; ++d) {
      var p = d * u, v = new Float32Array(u - 1);
      v[0] = f[p];
      for (var g = 1; g < v.length; ++g) v[g] = v[g - 1] + f[p + g];
      for (var y = ru(i.toString()), x = d * o, w = 0; w < o; ++w) {
        var b = y();
        c[x + w] = v.length;
        for (var _ = 0; _ < v.length; _++) if (b < v[_]) {
          c[x + w] = _;
          break;
        }
      }
    }
    return l;
  }, e.prototype.oneHot = function(t, r, o, i) {
    $(t, "oneHot");
    var a = new Float32Array(t.size * r);
    a.fill(i);
    for (var s = this.readSync(t.dataId), u = 0; u < t.size; ++u) s[u] >= 0 && s[u] < r && (a[u * r + s[u]] = o);
    return Or(a, [t.size, r], "int32");
  }, e.prototype.nonMaxSuppression = function(t, r, o, i, a) {
    return $(t, "nonMaxSuppression"), Tf(this.readSync(t.dataId), this.readSync(r.dataId), o, i, a);
  }, e.prototype.fft = function(t) {
    return this.fftBatch(t, !1);
  }, e.prototype.ifft = function(t) {
    return this.fftBatch(t, !0);
  }, e.prototype.fftBatch = function(t, r) {
    for (var o = t.shape[0], i = t.shape[1], a = he(t.shape, "float32"), s = he(t.shape, "float32"), u = mn(t).as2D(o, i), l = $n(t).as2D(o, i), c = 0; c < o; c++) for (var f = u.slice([c, 0], [1, i]), d = l.slice([c, 0], [1, i]), p = Et(f, d), v = this.readSync(this.fftImpl(p, r).dataId), g = 0; g < i; g++) {
      var y = am(v, g);
      a.values[c * i + g] = y.real, s.values[c * i + g] = y.imag;
    }
    return Et(a.toTensor(), s.toTensor()).as2D(o, i);
  }, e.prototype.fftImpl = function(t, r) {
    var o = t.as1D(), i = o.size;
    if (this.isExponentOf2(i)) {
      var a = this.fftRadix2(o, i, r).as2D(t.shape[0], t.shape[1]);
      return r && (a = Et(mn(a).div(K(i)), $n(a).div(K(i)))), a;
    }
    var s = this.readSync(t.dataId), u = function(l) {
      for (var c = new Float32Array(l.length / 2), f = new Float32Array(l.length / 2), d = 0; d < l.length; d += 2) c[d / 2] = l[d], f[d / 2] = l[d + 1];
      return { real: c, imag: f };
    }(this.fourierTransformByMatmul(s, i, r));
    return Et(u.real, u.imag).as2D(t.shape[0], t.shape[1]);
  }, e.prototype.isExponentOf2 = function(t) {
    return (t & t - 1) == 0;
  }, e.prototype.fftRadix2 = function(t, r, o) {
    if (r === 1) return t;
    var i = this.readSync(t.dataId), a = r / 2, s = function(x) {
      for (var w = Math.ceil(x.length / 4), b = new Float32Array(w), _ = new Float32Array(w), E = 0; E < x.length; E += 4) b[Math.floor(E / 4)] = x[E], _[Math.floor(E / 4)] = x[E + 1];
      return { real: b, imag: _ };
    }(i), u = Et(s.real, s.imag).as1D(), l = function(x) {
      for (var w = Math.floor(x.length / 4), b = new Float32Array(w), _ = new Float32Array(w), E = 2; E < x.length; E += 4) b[Math.floor(E / 4)] = x[E], _[Math.floor(E / 4)] = x[E + 1];
      return { real: b, imag: _ };
    }(i), c = Et(l.real, l.imag).as1D();
    u = this.fftRadix2(u, a, o), c = this.fftRadix2(c, a, o);
    var f = function(x, w) {
      for (var b = new Float32Array(x / 2), _ = new Float32Array(x / 2), E = 0; E < Math.ceil(x / 2); E++) {
        var C = (w ? 2 : -2) * Math.PI * (E / x);
        b[E] = Math.cos(C), _[E] = Math.sin(C);
      }
      return { real: b, imag: _ };
    }(r, o), d = Et(f.real, f.imag).mul(c), p = u.add(d), v = u.sub(d), g = mn(p).concat(mn(v)), y = $n(p).concat($n(v));
    return Et(g, y).as1D();
  }, e.prototype.fourierTransformByMatmul = function(t, r, o) {
    for (var i = new Float32Array(2 * r), a = 0; a < r; a++) {
      for (var s = 0, u = 0, l = 0; l < r; l++) {
        var c = NT(a * l, r, o), f = am(t, l);
        s += f.real * c.real - f.imag * c.imag, u += f.real * c.imag + f.imag * c.real;
      }
      o && (s /= r, u /= r), PT(i, s, u, a);
    }
    return i;
  }, e.prototype.depthToSpace = function(t, r, o) {
    k(o === "NHWC", function() {
      return "Only NHWC dataFormat supported on CPU for depthToSpace. Got " + o;
    }), k(r > 1, function() {
      return "blockSize should be > 1 for depthToSpace, but was: " + r;
    });
    for (var i = t.shape[0], a = t.shape[1], s = t.shape[2], u = t.shape[3], l = a * r, c = s * r, f = u / (r * r), d = this.readSync(t.dataId), p = new Float32Array(i * l * c * f), v = 0, g = 0; g < i; ++g) for (var y = 0; y < l; ++y) for (var x = Math.floor(y / r), w = y % r, b = 0; b < c; ++b) for (var _ = Math.floor(b / r), E = (w * r + b % r) * f, C = 0; C < f; ++C) {
      var A = C + E + u * (_ + s * (x + a * g));
      p[v++] = d[A];
    }
    return Vt(p, [i, l, c, f]);
  }, e.prototype.broadcastedBinaryOp = function(t, r, o, i) {
    var a = xe(t.shape, r.shape), s = he(a, o), u = this.readSync(t.dataId), l = this.readSync(r.dataId), c = Nr(t.shape, a), f = Nr(r.shape, a), d = s.values;
    if (c.length + f.length === 0) for (var p = 0; p < d.length; ++p) d[p] = i(u[p % u.length], l[p % l.length]);
    else {
      var v = this.bufferSync(t), g = this.bufferSync(r), y = function(x) {
        var w = s.indexToLoc(x), b = w.slice(-t.rank);
        c.forEach(function(A) {
          return b[A] = 0;
        });
        var _ = v.locToIndex(b), E = w.slice(-r.rank);
        f.forEach(function(A) {
          return E[A] = 0;
        });
        var C = g.locToIndex(E);
        d[x] = i(u[_], l[C]);
      };
      for (p = 0; p < d.length; ++p) y(p);
    }
    return s.toTensor();
  }, e.prototype.broadcastedBinaryComplexOp = function(t, r, o) {
    var i = xe(t.shape, r.shape), a = he(i, "float32"), s = he(i, "float32"), u = this.readSync(t.dataId), l = this.readSync(r.dataId), c = Nr(t.shape, i), f = Nr(r.shape, i), d = a.values, p = s.values;
    if (c.length + f.length === 0) for (var v = 0; v < d.length; v++) {
      var g = v % u.length, y = v % l.length, x = o(u[2 * g], u[2 * g + 1], l[2 * y], l[2 * y + 1]);
      d[v] = x.real, p[v] = x.imag;
    }
    else {
      var w = this.bufferSync(this.data.get(t.dataId).complexTensors.real), b = this.bufferSync(this.data.get(r.dataId).complexTensors.real), _ = function(E) {
        var C = a.indexToLoc(E), A = C.slice(-t.rank);
        c.forEach(function(P) {
          return A[P] = 0;
        });
        var R = w.locToIndex(A), I = C.slice(-r.rank);
        f.forEach(function(P) {
          return I[P] = 0;
        });
        var S = b.locToIndex(I), M = o(u[2 * R], u[2 * R + 1], l[2 * S], l[2 * S + 1]);
        d[E] = M.real, p[E] = M.imag;
      };
      for (v = 0; v < d.length; v++) _(v);
    }
    return this.complex(a.toTensor(), s.toTensor());
  }, e.prototype.split = function(t, r, o) {
    return X1(t, r, o);
  }, e.prototype.dispose = function() {
  }, e.prototype.floatPrecision = function() {
    return 32;
  }, e.prototype.epsilon = function() {
    return 1e-7;
  }, e.prototype.cropAndResize = function(t, r, o, i, a, s) {
    for (var u = t.shape, l = u[0], c = u[1], f = u[2], d = u[3], p = r.shape[0], v = i[0], g = i[1], y = he([p, v, g, d], "float32"), x = this.readSync(r.dataId), w = this.readSync(o.dataId), b = this.readSync(t.dataId), _ = t.strides, E = y.strides, C = 0; C < p; C++) {
      var A = 4 * C, R = x[A], I = x[A + 1], S = x[A + 2], M = x[A + 3], P = w[C];
      if (!(P >= l)) for (var B = v > 1 ? (S - R) * (c - 1) / (v - 1) : 0, O = g > 1 ? (M - I) * (f - 1) / (g - 1) : 0, U = 0; U < v; U++) {
        var G = v > 1 ? R * (c - 1) + U * B : 0.5 * (R + S) * (c - 1);
        if (G < 0 || G > c - 1) for (var H = 0; H < g; H++) for (var W = 0; W < d; W++) {
          var q = W + H * E[2] + U * E[1] + C * E[0];
          y.values[q] = s;
        }
        else if (a === "bilinear") {
          var z = Math.floor(G), J = Math.ceil(G), ie = G - z;
          for (H = 0; H < g; H++)
            if ((be = g > 1 ? I * (f - 1) + H * O : 0.5 * (I + M) * (f - 1)) < 0 || be > f - 1) for (W = 0; W < d; W++)
              q = W + H * E[2] + U * E[1] + C * E[0], y.values[q] = s;
            else {
              var ce = Math.floor(be), me = Math.ceil(be), ve = be - ce;
              for (W = 0; W < d; W++) {
                var ye = b[q = W + ce * _[2] + z * _[1] + P * _[0]], Ce = b[q = W + me * _[2] + z * _[1] + P * _[0]], _e = b[q = W + ce * _[2] + J * _[1] + P * _[0]], Te = ye + (Ce - ye) * ve, rt = _e + (b[q = W + me * _[2] + J * _[1] + P * _[0]] - _e) * ve;
                q = W + H * E[2] + U * E[1] + C * E[0], y.values[q] = Te + (rt - Te) * ie;
              }
            }
        } else for (H = 0; H < g; ++H) {
          var be;
          if ((be = g > 1 ? I * (f - 1) + H * O : 0.5 * (I + M) * (f - 1)) < 0 || be > f - 1) for (W = 0; W < d; W++)
            q = W + H * E[2] + U * E[1] + C * E[0], y.values[q] = s;
          else {
            var Fe = Math.round(be), ke = Math.round(G);
            for (W = 0; W < d; W++) {
              var Ze = W + Fe * _[2] + ke * _[1] + P * _[0], ze = W + H * E[2] + U * E[1] + C * E[0];
              y.values[ze] = b[Ze];
            }
          }
        }
      }
    }
    return y.toTensor();
  }, e.prototype.sparseToDense = function(t, r, o, i) {
    var a = cs(0, t, o), s = a.sliceRank, u = a.numUpdates, l = a.sliceSize, c = a.strides, f = a.outputSize;
    return this.scatter(t, r, o, f, l, u, s, c, i, !1);
  }, e.prototype.gatherND = function(t, r) {
    var o = r.shape, i = o[o.length - 1], a = U1(t, r), s = a[0], u = a[1], l = a[2], c = a[3];
    if (u === 0) return Tt([], s, t.dtype);
    for (var f = new Zi([u, l], t.dtype), d = this.readSync(r.dataId), p = this.readSync(t.dataId), v = 0; v < u; v++) {
      for (var g = [], y = 0, x = 0; x < i; x++) {
        var w = d[v * i + x];
        y += w * c[x], g.push(w);
      }
      if (y < 0 || y >= t.size / l) throw new Error("Invalid indices: " + g + " does not index into " + t.shape);
      for (var b = 0; b < l; b++) f.values[v * l + b] = p[y * l + b];
    }
    return f.toTensor().reshape(s);
  }, e.prototype.scatterND = function(t, r, o) {
    var i = cs(0, t, o), a = i.sliceRank, s = i.numUpdates, u = i.sliceSize, l = i.strides, c = i.outputSize, f = K(0);
    return this.scatter(t, r, o, c, u, s, a, l, f, !0);
  }, e.prototype.fill = function(t, r, o) {
    var i = es(o = o || ua(r), ee(t));
    return i.fill(r), D.makeTensor(i, t, o, this);
  }, e.prototype.onesLike = function(t) {
    if (t.dtype === "string") throw new Error("onesLike is not supported for string tensors");
    return this.fill(t.shape, 1, t.dtype);
  }, e.prototype.zerosLike = function(t) {
    var r = es(t.dtype, ee(t.shape));
    return this.makeOutput(r, t.shape, t.dtype);
  }, e.prototype.linspace = function(t, r, o) {
    return K1(t, r, o);
  }, e.prototype.scatter = function(t, r, o, i, a, s, u, l, c, f) {
    var d = [i / a, a], p = this.readSync(t.dataId), v = this.readSync(r.dataId);
    if (i === 0) return Tt([], o, r.dtype);
    var g = new Zi(d, r.dtype);
    g.values.fill(this.readSync(c.dataId)[0]);
    for (var y = 0; y < s; y++) {
      for (var x = [], w = 0, b = 0; b < u; b++) {
        var _ = p[y * u + b];
        x.push(_), w += _ * l[b];
      }
      if (w < 0 || w >= i / a) throw new Error("Invalid indices: " + x + " does not index into " + o);
      for (var E = 0; E < a; E++) f ? g.values[w * a + E] += v[y * a + E] : g.values[w * a + E] = r.rank === 0 ? v[0] : v[y * a + E];
    }
    return g.toTensor().reshape(o);
  }, e;
}($1);
D.registerBackend("cpu", function() {
  return new ZA();
}, 1);
for (var tl = 0, Am = [{ kernelName: "NonMaxSuppressionV5", backendName: "cpu", kernelFunc: function(n) {
  var e = n.inputs, t = n.backend, r = n.attrs, o = e, i = o.boxes, a = o.scores, s = r, u = s.maxOutputSize, l = s.iouThreshold, c = s.scoreThreshold, f = s.softNmsSigma, d = t;
  $(i, "NonMaxSuppressionWithScore");
  var p = If(d.data.get(i.dataId).values, d.data.get(a.dataId).values, u, l, c, f);
  return [p.selectedIndices, p.selectedScores];
} }, { kernelName: "Square", backendName: "cpu", kernelFunc: function(n) {
  var e = n.inputs, t = n.backend, r = e.x, o = t;
  $(r, "square");
  for (var i = o.data.get(r.dataId).values, a = new Float32Array(i.length), s = 0; s < i.length; ++s) {
    var u = i[s];
    a[s] = u * u;
  }
  return { dataId: o.write(a, r.shape, r.dtype), shape: r.shape, dtype: r.dtype };
} }, { kernelName: ta, backendName: "cpu", kernelFunc: function(n) {
  var e = n.inputs, t = n.backend, r = e, o = r.a, i = r.b, a = t;
  $([o, i], ta);
  var s = a.data.get(o.dataId).values, u = a.data.get(i.dataId).values, l = function(d, p, v, g, y, x) {
    var w = xe(d, p), b = w.length, _ = Kn(w), E = Qi(y, ee(w)), C = d.length, A = p.length, R = Kn(d), I = Kn(p), S = Nr(d, w), M = Nr(p, w);
    if (S.length + M.length === 0) for (var P = 0; P < E.length; ++P) E[P] = x(v[P % v.length], g[P % g.length]);
    else {
      var B = function(O) {
        var U = u3(O, b, _), G = U.slice(-C);
        S.forEach(function(z) {
          return G[z] = 0;
        });
        var H = Qp(G, C, R), W = U.slice(-A);
        M.forEach(function(z) {
          return W[z] = 0;
        });
        var q = Qp(W, A, I);
        E[O] = x(v[H], g[q]);
      };
      for (P = 0; P < E.length; ++P) B(P);
    }
    return [E, w];
  }(o.shape, i.shape, s, u, o.dtype, function(d, p) {
    var v = d - p;
    return v * v;
  }), c = l[0], f = l[1];
  return { dataId: a.write(c, f, o.dtype), shape: f, dtype: o.dtype };
} }]; tl < Am.length; tl++)
  y1(Am[tl]);
var ko, jA = function(n) {
  this.variableNames = ["A"];
  var e = Rt(), t = n[0], r = n[1];
  this.outputShape = n, this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(` + r + ".0, " + t + `.0);

        vec4 values = ` + e.texture2D + `(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `;
}, eR = function(n) {
  this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0;
  var e = Rt(), t = n[0], r = n[1];
  this.outputShape = n, this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(` + r + ".0, " + t + `.0);
            vec4 values = ` + e.texture2D + `(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ` + e.output + ` = result;
      }
    `;
};
for (var nl = 0, Rm = [{ kernelName: "FromPixels", backendName: "webgl", kernelFunc: function(n) {
  var e = n.inputs, t = n.backend, r = n.attrs, o = e.pixels, i = r.numChannels, a = typeof HTMLVideoElement < "u" && o instanceof HTMLVideoElement, s = typeof HTMLImageElement < "u" && o instanceof HTMLImageElement, u = a ? [o.videoWidth, o.videoHeight] : [o.width, o.height], l = u[0], c = u[1], f = [c, l], d = [c, l, i];
  (s || a) && (ko == null && (ko = document.createElement("canvas").getContext("2d")), ko.canvas.width = l, ko.canvas.height = c, ko.drawImage(o, 0, 0, l, c), o = ko.canvas);
  var p = t.makeTensorInfo(f, "int32");
  t.texData.get(p.dataId).usage = en.PIXELS, t.gpgpu.uploadPixelDataToTexture(t.getTexture(p.dataId), o);
  var v = V().getBool("WEBGL_PACK") ? new eR(d) : new jA(d), g = t.runWebGLProgram(v, [p], "int32");
  return t.disposeData(p.dataId), g;
} }, { kernelName: "NonMaxSuppressionV5", backendName: "webgl", kernelFunc: function(n) {
  var e = n.inputs, t = n.backend, r = n.attrs;
  os("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
  var o = e, i = o.boxes, a = o.scores, s = r, u = s.maxOutputSize, l = s.iouThreshold, c = s.scoreThreshold, f = s.softNmsSigma, d = t, p = If(d.readSync(i.dataId), d.readSync(a.dataId), u, l, c, f);
  return [p.selectedIndices, p.selectedScores];
} }, { kernelName: "Square", backendName: "webgl", kernelFunc: function(n) {
  var e = n.inputs, t = n.backend, r = e.x, o = t, i = new pe(r.shape, "return x * x;");
  return o.runWebGLProgram(i, [r], r.dtype);
} }, { kernelName: ta, backendName: "webgl", kernelFunc: function(n) {
  var e = n.inputs, t = n.backend, r = e, o = r.a, i = r.b, a = t, s = V().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new sr("return (a - b) * (a - b);", o.shape, i.shape) : new et("return (a - b) * (a - b);", o.shape, i.shape);
  return a.compileAndRun(s, [o, i]);
} }]; nl < Rm.length; nl++)
  y1(Rm[nl]);
for (var rl = 0, km = [{ kernelName: "Square", gradFunc: function(n, e) {
  var t = e[0];
  return { x: function() {
    return n.mul(t.toFloat().mul(2));
  } };
} }, { kernelName: ta, gradFunc: function(n, e) {
  var t = e[0], r = e[1], o = K(2);
  return { a: function() {
    return Nt(n, Nt(o, vt(t, r)));
  }, b: function() {
    return Nt(n, Nt(o, vt(r, t)));
  } };
} }]; rl < km.length; rl++)
  QC(km[rl]);
var tR = function() {
  function n() {
  }
  return n.prototype.fetch = function(e, t) {
    return fetch(e, t);
  }, n.prototype.now = function() {
    return performance.now();
  }, n.prototype.encode = function(e, t) {
    if (t !== "utf-8" && t !== "utf8") throw new Error("Browser's encoder only supports utf-8, but got " + t);
    return this.textEncoder == null && (this.textEncoder = new TextEncoder()), this.textEncoder.encode(e);
  }, n.prototype.decode = function(e, t) {
    return new TextDecoder(t).decode(e);
  }, n;
}();
V().get("IS_BROWSER") && V().setPlatform("browser", new tR());
var ol, nR = function() {
  return require("node-fetch");
}, rR = function() {
  function n() {
    this.util = require("util"), this.textEncoder = new this.util.TextEncoder();
  }
  return n.prototype.fetch = function(e, t) {
    return V().global.fetch != null ? V().global.fetch(e, t) : (ol == null && (ol = nR()), ol(e, t));
  }, n.prototype.now = function() {
    var e = process.hrtime();
    return 1e3 * e[0] + e[1] / 1e6;
  }, n.prototype.encode = function(e, t) {
    if (t !== "utf-8" && t !== "utf8") throw new Error("Node built-in encoder only supports utf-8, but got " + t);
    return this.textEncoder.encode(e);
  }, n.prototype.decode = function(e, t) {
    return e.length === 0 ? "" : new this.util.TextDecoder(t).decode(e);
  }, n;
}();
V().get("IS_NODE") && V().setPlatform("node", new rR());
var tc = { float32: 4, int32: 4, uint16: 2, uint8: 1, bool: 1 }, gs = 4;
function G0(n, e) {
  for (var t = {}, r = 0, o = function(s) {
    var u = s.name, l = s.dtype, c = s.shape, f = ee(c), d = void 0;
    if ("quantization" in s) {
      var p = s.quantization;
      if (p.dtype !== "uint8" && p.dtype !== "uint16") throw new Error("Weight " + s.name + " has unknown quantization dtype " + p.dtype + ". Supported quantization dtypes are: 'uint8' and 'uint16'.");
      var v = tc[p.dtype], g = n.slice(r, r + f * v), y = p.dtype === "uint8" ? new Uint8Array(g) : new Uint16Array(g);
      if (l === "float32") d = Float32Array.from(y, function(C) {
        return C * p.scale + p.min;
      });
      else {
        if (l !== "int32") throw new Error("Unsupported dtype in weight '" + u + "': " + l);
        d = Int32Array.from(y, function(C) {
          return Math.round(C * p.scale + p.min);
        });
      }
      r += f * v;
    } else if (l === "string") {
      var x = ee(s.shape);
      d = [];
      for (var w = 0; w < x; w++) {
        var b = new Uint32Array(n.slice(r, r + gs))[0];
        r += gs;
        var _ = new Uint8Array(n.slice(r, r + b));
        d.push(_), r += b;
      }
    } else {
      var E = tc[l];
      if (g = n.slice(r, r + f * E), l === "float32") d = new Float32Array(g);
      else if (l === "int32") d = new Int32Array(g);
      else {
        if (l !== "bool") throw new Error("Unsupported dtype in weight '" + u + "': " + l);
        d = new Uint8Array(g);
      }
      r += f * E;
    }
    t[u] = Tt(d, c, l);
  }, i = 0, a = e; i < a.length; i++)
    o(a[i]);
  return t;
}
function oR(n) {
  if (n === null) throw new Error("Invalid input value: " + JSON.stringify(n));
  var e = 0, t = [];
  n.forEach(function(i) {
    if (e += i.byteLength, t.push(i.byteLength === i.buffer.byteLength ? i : new i.constructor(i)), !(i instanceof Float32Array || i instanceof Int32Array || i instanceof Uint8Array)) throw new Error("Unsupported TypedArray subtype: " + i.constructor.name);
  });
  var r = new Uint8Array(e), o = 0;
  return t.forEach(function(i) {
    r.set(new Uint8Array(i.buffer), o), o += i.byteLength;
  }), r.buffer;
}
var nc = typeof Buffer < "u" && (typeof Blob > "u" || typeof atob > "u" || typeof btoa > "u");
function Pm(n) {
  return nc ? Buffer.byteLength(n) : new Blob([n]).size;
}
function qf(n) {
  var e = 0;
  n.forEach(function(o) {
    e += o.byteLength;
  });
  var t = new Uint8Array(e), r = 0;
  return n.forEach(function(o) {
    t.set(new Uint8Array(o), r), r += o.byteLength;
  }), t.buffer;
}
function Nm(n) {
  for (n = n.trim(); n.endsWith("/"); ) n = n.slice(0, n.length - 1);
  var e = n.split("/");
  return e[e.length - 1];
}
function ma(n) {
  if (n.modelTopology instanceof ArrayBuffer) throw new Error("Expected JSON model topology, received ArrayBuffer.");
  return { dateSaved: /* @__PURE__ */ new Date(), modelTopologyType: "JSON", modelTopologyBytes: n.modelTopology == null ? 0 : Pm(JSON.stringify(n.modelTopology)), weightSpecsBytes: n.weightSpecs == null ? 0 : Pm(JSON.stringify(n.weightSpecs)), weightDataBytes: n.weightData == null ? 0 : n.weightData.byteLength };
}
var tn = function() {
  function n() {
    this.saveRouters = [], this.loadRouters = [];
  }
  return n.getInstance = function() {
    return n.instance == null && (n.instance = new n()), n.instance;
  }, n.registerSaveRouter = function(e) {
    n.getInstance().saveRouters.push(e);
  }, n.registerLoadRouter = function(e) {
    n.getInstance().loadRouters.push(e);
  }, n.getSaveHandlers = function(e) {
    return n.getHandlers(e, "save");
  }, n.getLoadHandlers = function(e, t) {
    return n.getHandlers(e, "load", t);
  }, n.getHandlers = function(e, t, r) {
    var o = [];
    return (t === "load" ? n.getInstance().loadRouters : n.getInstance().saveRouters).forEach(function(i) {
      var a = i(e, r);
      a !== null && o.push(a);
    }), o;
  }, n;
}(), Jo = "://", Ur = function() {
  function n() {
    this.managers = {};
  }
  return n.getInstance = function() {
    return n.instance == null && (n.instance = new n()), n.instance;
  }, n.registerManager = function(e, t) {
    k(e != null, function() {
      return "scheme must not be undefined or null.";
    }), e.endsWith(Jo) && (e = e.slice(0, e.indexOf(Jo))), k(e.length > 0, function() {
      return "scheme must not be an empty string.";
    });
    var r = n.getInstance();
    k(r.managers[e] == null, function() {
      return "A model store manager is already registered for scheme '" + e + "'.";
    }), r.managers[e] = t;
  }, n.getManager = function(e) {
    var t = this.getInstance().managers[e];
    if (t == null) throw new Error("Cannot find model manager for scheme '" + e + "'");
    return t;
  }, n.getSchemes = function() {
    return Object.keys(this.getInstance().managers);
  }, n;
}();
function $a(n) {
  if (n.indexOf(Jo) === -1) throw new Error("The url string provided does not contain a scheme. Supported schemes are: " + Ur.getSchemes().join(","));
  return { scheme: n.split(Jo)[0], path: n.split(Jo)[1] };
}
function Mm(n, e, t) {
  return t === void 0 && (t = !1), Z(this, void 0, void 0, function() {
    var r, o, i, a, s, u, l, c, f;
    return j(this, function(d) {
      switch (d.label) {
        case 0:
          return k(n !== e, function() {
            return "Old path and new path are the same: '" + n + "'";
          }), k((r = tn.getLoadHandlers(n)).length > 0, function() {
            return "Copying failed because no load handler is found for source URL " + n + ".";
          }), k(r.length < 2, function() {
            return "Copying failed because more than one (" + r.length + ") load handlers for source URL " + n + ".";
          }), o = r[0], k((i = tn.getSaveHandlers(e)).length > 0, function() {
            return "Copying failed because no save handler is found for destination URL " + e + ".";
          }), k(i.length < 2, function() {
            return "Copying failed because more than one (" + r.length + ") save handlers for destination URL " + e + ".";
          }), a = i[0], s = $a(n).scheme, u = $a(n).path, l = s === $a(n).scheme, [4, o.load()];
        case 1:
          return c = d.sent(), t && l ? [4, Ur.getManager(s).removeModel(u)] : [3, 3];
        case 2:
          d.sent(), d.label = 3;
        case 3:
          return [4, a.save(c)];
        case 4:
          return f = d.sent(), !t || l ? [3, 6] : [4, Ur.getManager(s).removeModel(u)];
        case 5:
          d.sent(), d.label = 6;
        case 6:
          return [2, f.modelArtifactsInfo];
      }
    });
  });
}
var so = "models_store", Mr = "model_info_store";
function W0() {
  if (!V().getBool("IS_BROWSER")) throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
  var n = window || self, e = n.indexedDB || n.mozIndexedDB || n.webkitIndexedDB || n.msIndexedDB || n.shimIndexedDB;
  if (e == null) throw new Error("The current browser does not appear to support IndexedDB.");
  return e;
}
function rc(n) {
  var e = n.result;
  e.createObjectStore(so, { keyPath: "modelPath" }), e.createObjectStore(Mr, { keyPath: "modelPath" });
}
var Xo = function() {
  function n(e) {
    if (this.indexedDB = W0(), e == null || !e) throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
    this.modelPath = e;
  }
  return n.prototype.save = function(e) {
    return Z(this, void 0, void 0, function() {
      return j(this, function(t) {
        if (e.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
        return [2, this.databaseAction(this.modelPath, e)];
      });
    });
  }, n.prototype.load = function() {
    return Z(this, void 0, void 0, function() {
      return j(this, function(e) {
        return [2, this.databaseAction(this.modelPath)];
      });
    });
  }, n.prototype.databaseAction = function(e, t) {
    var r = this;
    return new Promise(function(o, i) {
      var a = r.indexedDB.open("tensorflowjs", 1);
      a.onupgradeneeded = function() {
        return rc(a);
      }, a.onsuccess = function() {
        var s = a.result;
        if (t == null) {
          var u = s.transaction(so, "readonly"), l = u.objectStore(so).get(r.modelPath);
          l.onsuccess = function() {
            if (l.result == null) return s.close(), i(new Error("Cannot find model with path '" + r.modelPath + "' in IndexedDB."));
            o(l.result.modelArtifacts);
          }, l.onerror = function(g) {
            return s.close(), i(l.error);
          }, u.oncomplete = function() {
            return s.close();
          };
        } else {
          var c, f = ma(t), d = s.transaction(Mr, "readwrite"), p = d.objectStore(Mr), v = p.put({ modelPath: r.modelPath, modelArtifactsInfo: f });
          v.onsuccess = function() {
            var g = (c = s.transaction(so, "readwrite")).objectStore(so).put({ modelPath: r.modelPath, modelArtifacts: t, modelArtifactsInfo: f });
            g.onsuccess = function() {
              return o({ modelArtifactsInfo: f });
            }, g.onerror = function(y) {
              var x = (p = d.objectStore(Mr)).delete(r.modelPath);
              x.onsuccess = function() {
                return s.close(), i(g.error);
              }, x.onerror = function(w) {
                return s.close(), i(g.error);
              };
            };
          }, v.onerror = function(g) {
            return s.close(), i(v.error);
          }, d.oncomplete = function() {
            c == null ? s.close() : c.oncomplete = function() {
              return s.close();
            };
          };
        }
      }, a.onerror = function(s) {
        return i(a.error);
      };
    });
  }, n.URL_SCHEME = "indexeddb://", n;
}(), Dm = function(n) {
  return V().getBool("IS_BROWSER") && !Array.isArray(n) && n.startsWith(Xo.URL_SCHEME) ? (e = n.slice(Xo.URL_SCHEME.length), new Xo(e)) : null;
  var e;
};
tn.registerSaveRouter(Dm), tn.registerLoadRouter(Dm);
var iR = function() {
  function n() {
    this.indexedDB = W0();
  }
  return n.prototype.listModels = function() {
    return Z(this, void 0, void 0, function() {
      var e = this;
      return j(this, function(t) {
        return [2, new Promise(function(r, o) {
          var i = e.indexedDB.open("tensorflowjs", 1);
          i.onupgradeneeded = function() {
            return rc(i);
          }, i.onsuccess = function() {
            var a = i.result, s = a.transaction(Mr, "readonly"), u = s.objectStore(Mr).getAll();
            u.onsuccess = function() {
              for (var l = {}, c = 0, f = u.result; c < f.length; c++) {
                var d = f[c];
                l[d.modelPath] = d.modelArtifactsInfo;
              }
              r(l);
            }, u.onerror = function(l) {
              return a.close(), o(u.error);
            }, s.oncomplete = function() {
              return a.close();
            };
          }, i.onerror = function(a) {
            return o(i.error);
          };
        })];
      });
    });
  }, n.prototype.removeModel = function(e) {
    return Z(this, void 0, void 0, function() {
      var t = this;
      return j(this, function(r) {
        var o;
        return e = (o = e).startsWith(Xo.URL_SCHEME) ? o.slice(Xo.URL_SCHEME.length) : o, [2, new Promise(function(i, a) {
          var s = t.indexedDB.open("tensorflowjs", 1);
          s.onupgradeneeded = function() {
            return rc(s);
          }, s.onsuccess = function() {
            var u, l = s.result, c = l.transaction(Mr, "readwrite"), f = c.objectStore(Mr), d = f.get(e);
            d.onsuccess = function() {
              if (d.result == null) return l.close(), a(new Error("Cannot find model with path '" + e + "' in IndexedDB."));
              var p = f.delete(e), v = function() {
                var g = (u = l.transaction(so, "readwrite")).objectStore(so).delete(e);
                g.onsuccess = function() {
                  return i(d.result.modelArtifactsInfo);
                }, g.onerror = function(y) {
                  return a(d.error);
                };
              };
              p.onsuccess = v, p.onerror = function(g) {
                return v(), l.close(), a(d.error);
              };
            }, d.onerror = function(p) {
              return l.close(), a(d.error);
            }, c.oncomplete = function() {
              u == null ? l.close() : u.oncomplete = function() {
                return l.close();
              };
            };
          }, s.onerror = function(u) {
            return a(s.error);
          };
        })];
      });
    });
  }, n;
}();
if (V().getBool("IS_BROWSER")) try {
  Ur.registerManager(Xo.URL_SCHEME, new iR());
} catch {
}
var cr = "/", Lo = "tensorflowjs_models", H0 = "info", aR = "model_topology", sR = "weight_specs", uR = "weight_data", lR = "model_metadata";
function $0(n) {
  return { info: [Lo, n, H0].join(cr), topology: [Lo, n, aR].join(cr), weightSpecs: [Lo, n, sR].join(cr), weightData: [Lo, n, uR].join(cr), modelMetadata: [Lo, n, lR].join(cr) };
}
function cR(n) {
  var e = n.split(cr);
  if (e.length < 3) throw new Error("Invalid key format: " + n);
  return e.slice(1, e.length - 1).join(cr);
}
var Yo = function() {
  function n(e) {
    if (!V().getBool("IS_BROWSER") || typeof window > "u" || window.localStorage === void 0) throw new Error("The current environment does not support local storage.");
    if (this.LS = window.localStorage, e == null || !e) throw new Error("For local storage, modelPath must not be null, undefined or empty.");
    this.modelPath = e, this.keys = $0(this.modelPath);
  }
  return n.prototype.save = function(e) {
    return Z(this, void 0, void 0, function() {
      var t, r, o;
      return j(this, function(i) {
        if (e.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
        t = JSON.stringify(e.modelTopology), r = JSON.stringify(e.weightSpecs), o = ma(e);
        try {
          return this.LS.setItem(this.keys.info, JSON.stringify(o)), this.LS.setItem(this.keys.topology, t), this.LS.setItem(this.keys.weightSpecs, r), this.LS.setItem(this.keys.weightData, function(a) {
            if (nc) return Buffer.from(a).toString("base64");
            for (var s = new Uint8Array(a), u = "", l = 0, c = s.length; l < c; l++) u += String.fromCharCode(s[l]);
            return btoa(u);
          }(e.weightData)), this.LS.setItem(this.keys.modelMetadata, JSON.stringify({ format: e.format, generatedBy: e.generatedBy, convertedBy: e.convertedBy, userDefinedMetadata: e.userDefinedMetadata })), [2, { modelArtifactsInfo: o }];
        } catch {
          throw this.LS.removeItem(this.keys.info), this.LS.removeItem(this.keys.topology), this.LS.removeItem(this.keys.weightSpecs), this.LS.removeItem(this.keys.weightData), this.LS.removeItem(this.keys.modelMetadata), new Error("Failed to save model '" + this.modelPath + "' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=" + o.modelTopologyBytes + ", weightSpecsBytes=" + o.weightSpecsBytes + ", weightDataBytes=" + o.weightDataBytes + ".");
        }
        return [2];
      });
    });
  }, n.prototype.load = function() {
    return Z(this, void 0, void 0, function() {
      var e, t, r, o, i, a, s;
      return j(this, function(u) {
        if ((e = JSON.parse(this.LS.getItem(this.keys.info))) == null) throw new Error("In local storage, there is no model with name '" + this.modelPath + "'");
        if (e.modelTopologyType !== "JSON") throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
        if (t = {}, (r = JSON.parse(this.LS.getItem(this.keys.topology))) == null) throw new Error("In local storage, the topology of model '" + this.modelPath + "' is missing.");
        if (t.modelTopology = r, (o = JSON.parse(this.LS.getItem(this.keys.weightSpecs))) == null) throw new Error("In local storage, the weight specs of model '" + this.modelPath + "' are missing.");
        if (t.weightSpecs = o, (i = this.LS.getItem(this.keys.modelMetadata)) != null && (a = JSON.parse(i), t.format = a.format, t.generatedBy = a.generatedBy, t.convertedBy = a.convertedBy, t.userDefinedMetadata = a.userDefinedMetadata), (s = this.LS.getItem(this.keys.weightData)) == null) throw new Error("In local storage, the binary weight values of model '" + this.modelPath + "' are missing.");
        return t.weightData = function(l) {
          if (nc) {
            var c = Buffer.from(l, "base64");
            return c.buffer.slice(c.byteOffset, c.byteOffset + c.byteLength);
          }
          for (var f = atob(l), d = new Uint8Array(f.length), p = 0; p < f.length; ++p) d.set([f.charCodeAt(p)], p);
          return d.buffer;
        }(s), [2, t];
      });
    });
  }, n.URL_SCHEME = "localstorage://", n;
}(), Fm = function(n) {
  return V().getBool("IS_BROWSER") && !Array.isArray(n) && n.startsWith(Yo.URL_SCHEME) ? (e = n.slice(Yo.URL_SCHEME.length), new Yo(e)) : null;
  var e;
};
tn.registerSaveRouter(Fm), tn.registerLoadRouter(Fm);
var fR = function() {
  function n() {
    k(V().getBool("IS_BROWSER"), function() {
      return "Current environment is not a web browser";
    }), k(typeof window > "u" || window.localStorage !== void 0, function() {
      return "Current browser does not appear to support localStorage";
    }), this.LS = window.localStorage;
  }
  return n.prototype.listModels = function() {
    return Z(this, void 0, void 0, function() {
      var e, t, r, o, i, a;
      return j(this, function(s) {
        for (e = {}, t = Lo + cr, r = cr + H0, o = 0; o < this.LS.length; ++o) (i = this.LS.key(o)).startsWith(t) && i.endsWith(r) && (a = cR(i), e[a] = JSON.parse(this.LS.getItem(i)));
        return [2, e];
      });
    });
  }, n.prototype.removeModel = function(e) {
    return Z(this, void 0, void 0, function() {
      var t, r;
      return j(this, function(o) {
        var i;
        if (e = (i = e).startsWith(Yo.URL_SCHEME) ? i.slice(Yo.URL_SCHEME.length) : i, t = $0(e), this.LS.getItem(t.info) == null) throw new Error("Cannot find model at path '" + e + "'");
        return r = JSON.parse(this.LS.getItem(t.info)), this.LS.removeItem(t.info), this.LS.removeItem(t.topology), this.LS.removeItem(t.weightSpecs), this.LS.removeItem(t.weightData), [2, r];
      });
    });
  }, n;
}();
if (V().getBool("IS_BROWSER")) try {
  Ur.registerManager(Yo.URL_SCHEME, new fR());
} catch {
}
var dR = "model", hR = ".json", pR = ".weights.bin";
function Lm(n) {
  return new Promise(function(e) {
    return setTimeout(e);
  }).then(n);
}
var il = function() {
  function n(e) {
    if (!V().getBool("IS_BROWSER")) throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
    e.startsWith(n.URL_SCHEME) && (e = e.slice(n.URL_SCHEME.length)), e != null && e.length !== 0 || (e = dR), this.modelTopologyFileName = e + hR, this.weightDataFileName = e + pR;
  }
  return n.prototype.save = function(e) {
    return Z(this, void 0, void 0, function() {
      var t, r, o, i, a, s;
      return j(this, function(u) {
        switch (u.label) {
          case 0:
            if (typeof document > "u") throw new Error("Browser downloads are not supported in this environment since `document` is not present");
            if (t = window.URL.createObjectURL(new Blob([e.weightData], { type: "application/octet-stream" })), !(e.modelTopology instanceof ArrayBuffer)) return [3, 1];
            throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
          case 1:
            return r = [{ paths: ["./" + this.weightDataFileName], weights: e.weightSpecs }], o = { modelTopology: e.modelTopology, format: e.format, generatedBy: e.generatedBy, convertedBy: e.convertedBy, weightsManifest: r }, i = window.URL.createObjectURL(new Blob([JSON.stringify(o)], { type: "application/json" })), (a = this.jsonAnchor == null ? document.createElement("a") : this.jsonAnchor).download = this.modelTopologyFileName, a.href = i, [4, Lm(function() {
              return a.dispatchEvent(new MouseEvent("click"));
            })];
          case 2:
            return u.sent(), e.weightData == null ? [3, 4] : ((s = this.weightDataAnchor == null ? document.createElement("a") : this.weightDataAnchor).download = this.weightDataFileName, s.href = t, [4, Lm(function() {
              return s.dispatchEvent(new MouseEvent("click"));
            })]);
          case 3:
            u.sent(), u.label = 4;
          case 4:
            return [2, { modelArtifactsInfo: ma(e) }];
        }
      });
    });
  }, n.URL_SCHEME = "downloads://", n;
}(), mR = function() {
  function n(e) {
    if (e == null || e.length < 1) throw new Error("When calling browserFiles, at least 1 file is required, but received " + e);
    this.files = e;
  }
  return n.prototype.load = function() {
    return Z(this, void 0, void 0, function() {
      var e, t, r = this;
      return j(this, function(o) {
        return e = this.files[0], t = this.files.slice(1), [2, new Promise(function(i, a) {
          var s = new FileReader();
          s.onload = function(u) {
            var l = JSON.parse(u.target.result), c = l.modelTopology;
            if (c != null) {
              t.length === 0 && i({ modelTopology: c });
              var f = l.weightsManifest;
              if (f != null) {
                var d;
                try {
                  d = r.checkManifestAndWeightFiles(f, t);
                } catch (y) {
                  return void a(y);
                }
                var p = [], v = [], g = [];
                f.forEach(function(y) {
                  y.paths.forEach(function(x) {
                    v.push(x), g.push(null);
                  }), p.push.apply(p, y.weights);
                }), f.forEach(function(y) {
                  y.paths.forEach(function(x) {
                    var w = new FileReader();
                    w.onload = function(b) {
                      var _ = b.target.result, E = v.indexOf(x);
                      g[E] = _, g.indexOf(null) === -1 && i({ modelTopology: c, weightSpecs: p, weightData: qf(g), format: l.format, generatedBy: l.generatedBy, convertedBy: l.convertedBy, userDefinedMetadata: l.userDefinedMetadata });
                    }, w.onerror = function(b) {
                      return a("Failed to weights data from file of path '" + x + "'.");
                    }, w.readAsArrayBuffer(d[x]);
                  });
                });
              } else a(new Error("weightManifest field is missing from file " + e.name));
            } else a(new Error("modelTopology field is missing from file " + e.name));
          }, s.onerror = function(u) {
            return a("Failed to read model topology and weights manifest JSON from file '" + e.name + "'. BrowserFiles supports loading Keras-style tf.Model artifacts only.");
          }, s.readAsText(e);
        })];
      });
    });
  }, n.prototype.checkManifestAndWeightFiles = function(e, t) {
    for (var r = [], o = t.map(function(u) {
      return Nm(u.name);
    }), i = {}, a = 0, s = e; a < s.length; a++)
      s[a].paths.forEach(function(u) {
        var l = Nm(u);
        if (r.indexOf(l) !== -1) throw new Error("Duplicate file basename found in weights manifest: '" + l + "'");
        if (r.push(l), o.indexOf(l) === -1) throw new Error("Weight file with basename '" + l + "' is not provided.");
        i[u] = t[o.indexOf(l)];
      });
    if (r.length !== t.length) throw new Error("Mismatch in the number of files in weights manifest (" + r.length + ") and the number of weight files provided (" + t.length + ").");
    return i;
  }, n;
}();
function Bm(n, e, t, r) {
  (function(i) {
    k(i != null && Array.isArray(i) && i.length > 0, function() {
      return "promises must be a none empty array";
    });
  })(n), function(i, a) {
    k(i >= 0 && i <= 1, function() {
      return "Progress fraction must be in range [0, 1], but got startFraction " + i;
    }), k(a >= 0 && a <= 1, function() {
      return "Progress fraction must be in range [0, 1], but got endFraction " + a;
    }), k(a >= i, function() {
      return "startFraction must be no more than endFraction, but got startFraction " + i + " and endFraction " + a;
    });
  }(t = t ?? 0, r = r ?? 1);
  var o = 0;
  return Promise.all(n.map(function(i) {
    return i.then(function(a) {
      var s = t + ++o / n.length * (r - t);
      return e(s), a;
    }), i;
  }));
}
function q0(n, e) {
  return Z(this, void 0, void 0, function() {
    var t, r, o, i, a, s, u, l, c;
    return j(this, function(f) {
      switch (f.label) {
        case 0:
          return e == null && (e = {}), t = e.fetchFunc == null ? V().platform.fetch : e.fetchFunc, r = n.map(function(d) {
            return t(d, e.requestInit, { isBinary: !0 });
          }), o = 0, i = 0.5, e.onProgress != null ? [3, 2] : [4, Promise.all(r)];
        case 1:
          return a = f.sent(), [3, 4];
        case 2:
          return [4, Bm(r, e.onProgress, o, i)];
        case 3:
          a = f.sent(), f.label = 4;
        case 4:
          return s = a.map(function(d) {
            return d.arrayBuffer();
          }), u = 0.5, l = 1, e.onProgress != null ? [3, 6] : [4, Promise.all(s)];
        case 5:
          return c = f.sent(), [3, 8];
        case 6:
          return [4, Bm(s, e.onProgress, u, l)];
        case 7:
          c = f.sent(), f.label = 8;
        case 8:
          return [2, c];
      }
    });
  });
}
function Om(n) {
  var e = this;
  return function(t, r, o) {
    return r === void 0 && (r = ""), Z(e, void 0, void 0, function() {
      var i, a, s, u, l, c, f, d, p, v;
      return j(this, function(g) {
        switch (g.label) {
          case 0:
            if (i = t.map(function() {
              return !1;
            }), a = {}, s = o != null ? o.map(function() {
              return !1;
            }) : [], u = [], t.forEach(function(y, x) {
              var w = 0;
              y.weights.forEach(function(b) {
                var _ = "quantization" in b ? b.quantization.dtype : b.dtype, E = tc[_] * ee(b.shape), C = function() {
                  i[x] = !0, a[x] == null && (a[x] = []), a[x].push({ manifestEntry: b, groupOffset: w, sizeBytes: E });
                };
                o != null ? o.forEach(function(A, R) {
                  A === b.name && (C(), s[R] = !0);
                }) : C(), u.push(b.name), w += E;
              });
            }), !s.every(function(y) {
              return y;
            })) throw l = o.filter(function(y, x) {
              return !s[x];
            }), new Error("Could not find weights in manifest with names: " + l.join(", ") + `. 
Manifest JSON has weights with names: ` + u.join(", ") + ".");
            return c = i.reduce(function(y, x, w) {
              return x && y.push(w), y;
            }, []), f = [], c.forEach(function(y) {
              t[y].paths.forEach(function(x) {
                var w = r + (r.endsWith("/") ? "" : "/") + x;
                f.push(w);
              });
            }), [4, n(f)];
          case 1:
            return d = g.sent(), p = {}, v = 0, c.forEach(function(y) {
              for (var x = t[y].paths.length, w = 0, b = 0; b < x; b++) w += d[v + b].byteLength;
              for (var _ = new ArrayBuffer(w), E = new Uint8Array(_), C = 0, A = 0; A < x; A++) {
                var R = new Uint8Array(d[v + A]);
                E.set(R, C), C += R.byteLength;
              }
              a[y].forEach(function(I) {
                var S = G0(_.slice(I.groupOffset, I.groupOffset + I.sizeBytes), [I.manifestEntry]);
                for (var M in S) p[M] = S[M];
              }), v += x;
            }), [2, p];
        }
      });
    });
  };
}
tn.registerSaveRouter(function(n) {
  return V().getBool("IS_BROWSER") && !Array.isArray(n) && n.startsWith(il.URL_SCHEME) ? function(e) {
    return e === void 0 && (e = "model"), new il(e);
  }(n.slice(il.URL_SCHEME.length)) : null;
});
var z0 = function() {
  function n(e, t) {
    if (this.DEFAULT_METHOD = "POST", t == null && (t = {}), this.weightPathPrefix = t.weightPathPrefix, this.onProgress = t.onProgress, t.fetchFunc != null ? (k(typeof t.fetchFunc == "function", function() {
      return "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)";
    }), this.fetch = t.fetchFunc) : this.fetch = V().platform.fetch, k(e != null && e.length > 0, function() {
      return "URL path for http must not be null, undefined or empty.";
    }), Array.isArray(e) && k(e.length === 2, function() {
      return "URL paths for http must have a length of 2, (actual length is " + e.length + ").";
    }), this.path = e, t.requestInit != null && t.requestInit.body != null) throw new Error("requestInit is expected to have no pre-existing body, but has one.");
    this.requestInit = t.requestInit || {};
  }
  return n.prototype.save = function(e) {
    return Z(this, void 0, void 0, function() {
      var t, r, o, i;
      return j(this, function(a) {
        switch (a.label) {
          case 0:
            if (e.modelTopology instanceof ArrayBuffer) throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
            return (t = Object.assign({ method: this.DEFAULT_METHOD }, this.requestInit)).body = new FormData(), r = [{ paths: ["./model.weights.bin"], weights: e.weightSpecs }], o = { modelTopology: e.modelTopology, format: e.format, generatedBy: e.generatedBy, convertedBy: e.convertedBy, userDefinedMetadata: e.userDefinedMetadata, weightsManifest: r }, t.body.append("model.json", new Blob([JSON.stringify(o)], { type: "application/json" }), "model.json"), e.weightData != null && t.body.append("model.weights.bin", new Blob([e.weightData], { type: "application/octet-stream" }), "model.weights.bin"), [4, this.fetch(this.path, t)];
          case 1:
            if ((i = a.sent()).ok) return [2, { modelArtifactsInfo: ma(e), responses: [i] }];
            throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status " + i.status + ".");
        }
      });
    });
  }, n.prototype.load = function() {
    return Z(this, void 0, void 0, function() {
      var e, t, r, o, i, a, s, u, l, c, f, d;
      return j(this, function(p) {
        switch (p.label) {
          case 0:
            return [4, this.fetch(this.path, this.requestInit)];
          case 1:
            if (!(e = p.sent()).ok) throw new Error("Request to " + this.path + " failed with status code " + e.status + ". Please verify this URL points to the model JSON of the model to load.");
            p.label = 2;
          case 2:
            return p.trys.push([2, 4, , 5]), [4, e.json()];
          case 3:
            return t = p.sent(), [3, 5];
          case 4:
            throw p.sent(), r = "Failed to parse model JSON of response from " + this.path + ".", this.path.endsWith(".pb") ? r += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : r += " Please make sure the server is serving valid JSON for this request.", new Error(r);
          case 5:
            if (o = t.modelTopology, i = t.weightsManifest, a = t.generatedBy, s = t.convertedBy, u = t.format, l = t.userDefinedMetadata, o == null && i == null) throw new Error("The JSON from HTTP path " + this.path + " contains neither model topology or manifest for weights.");
            return i == null ? [3, 7] : [4, this.loadWeights(i)];
          case 6:
            d = p.sent(), c = d[0], f = d[1], p.label = 7;
          case 7:
            return [2, { modelTopology: o, weightSpecs: c, weightData: f, userDefinedMetadata: l, generatedBy: a, convertedBy: s, format: u }];
        }
      });
    });
  }, n.prototype.loadWeights = function(e) {
    return Z(this, void 0, void 0, function() {
      var t, r, o, i, a, s, u, l, c, f, d;
      return j(this, function(p) {
        switch (p.label) {
          case 0:
            for (t = Array.isArray(this.path) ? this.path[1] : this.path, r = function(v) {
              var g = v.lastIndexOf("/"), y = v.lastIndexOf("?"), x = v.substring(0, g), w = y > g ? v.substring(y) : "";
              return [x + "/", w];
            }(t), o = r[0], i = r[1], a = this.weightPathPrefix || o, s = [], u = 0, l = e; u < l.length; u++) c = l[u], s.push.apply(s, c.weights);
            return f = [], e.forEach(function(v) {
              v.paths.forEach(function(g) {
                f.push(a + g + i);
              });
            }), [4, q0(f, { requestInit: this.requestInit, fetchFunc: this.fetch, onProgress: this.onProgress })];
          case 1:
            return d = p.sent(), [2, [s, qf(d)]];
        }
      });
    });
  }, n.URL_SCHEME_REGEX = /^https?:\/\//, n;
}();
function oc(n) {
  return n.match(z0.URL_SCHEME_REGEX) != null;
}
var Um = function(n, e) {
  return typeof fetch > "u" ? null : (Array.isArray(n) ? n.every(function(t) {
    return oc(t);
  }) : oc(n)) ? ic(n, { onProgress: e }) : null;
};
function ic(n, e) {
  return new z0(n, e);
}
tn.registerSaveRouter(Um), tn.registerLoadRouter(Um);
var al = function() {
  function n(e) {
    this.modelArtifacts = e;
  }
  return n.prototype.load = function() {
    return Z(this, void 0, void 0, function() {
      return j(this, function(e) {
        return [2, this.modelArtifacts];
      });
    });
  }, n;
}(), vR = function() {
  function n(e) {
    this.saveHandler = e;
  }
  return n.prototype.save = function(e) {
    return Z(this, void 0, void 0, function() {
      return j(this, function(t) {
        return [2, this.saveHandler(e)];
      });
    });
  }, n;
}(), K0 = Object.freeze({ browserFiles: function(n) {
  return new mR(n);
}, browserHTTPRequest: function(n, e) {
  return ic(n, e);
}, concatenateArrayBuffers: qf, decodeWeights: G0, encodeWeights: function(n, e) {
  return Z(this, void 0, void 0, function() {
    var t, r, o, i, a, s = this;
    return j(this, function(u) {
      switch (u.label) {
        case 0:
          for (t = [], r = [], o = Array.isArray(n) ? n.map(function(l) {
            return l.name;
          }) : Object.keys(n), i = function(l) {
            var c = o[l], f = Array.isArray(n) ? n[l].tensor : n[c];
            if (f.dtype !== "float32" && f.dtype !== "int32" && f.dtype !== "bool" && f.dtype !== "string") throw new Error("Unsupported dtype in weight '" + c + "': " + f.dtype);
            var d = { name: c, shape: f.shape, dtype: f.dtype };
            if (f.dtype === "string") {
              var p = new Promise(function(v) {
                return Z(s, void 0, void 0, function() {
                  var g, y, x, w, b, _, E;
                  return j(this, function(C) {
                    switch (C.label) {
                      case 0:
                        return [4, f.bytes()];
                      case 1:
                        for (g = C.sent(), y = g.reduce(function(A, R) {
                          return A + R.length;
                        }, 0) + gs * g.length, x = new Uint8Array(y), w = 0, b = 0; b < g.length; b++) _ = g[b], E = new Uint8Array(new Uint32Array([_.length]).buffer), x.set(E, w), w += gs, x.set(_, w), w += _.length;
                        return v(x), [2];
                    }
                  });
                });
              });
              r.push(p);
            } else r.push(f.data());
            e != null && (d.group = e), t.push(d);
          }, a = 0; a < o.length; ++a) i(a);
          return [4, Promise.all(r)];
        case 1:
          return [2, { data: oR(u.sent()), specs: t }];
      }
    });
  });
}, fromMemory: function(n, e, t, r) {
  return arguments.length === 1 ? n.modelTopology != null || n.weightSpecs != null ? new al(n) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new al({ modelTopology: n })) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new al({ modelTopology: n, weightSpecs: e, weightData: t, trainingConfig: r }));
}, getLoadHandlers: function(n, e) {
  return tn.getLoadHandlers(n, e);
}, getModelArtifactsInfoForJSON: ma, getSaveHandlers: function(n) {
  return tn.getSaveHandlers(n);
}, http: ic, isHTTPScheme: oc, loadWeights: function(n, e, t, r) {
  return e === void 0 && (e = ""), Z(this, void 0, void 0, function() {
    return j(this, function(o) {
      return [2, Om(function(i) {
        return q0(i, { requestInit: r });
      })(n, e, t)];
    });
  });
}, registerLoadRouter: function(n) {
  return tn.registerLoadRouter(n);
}, registerSaveRouter: function(n) {
  return tn.registerSaveRouter(n);
}, weightsLoaderFactory: Om, withSaveHandler: function(n) {
  return new vR(n);
}, copyModel: function(n, e) {
  return Z(this, void 0, void 0, function() {
    return j(this, function(t) {
      return [2, Mm(n, e, !1)];
    });
  });
}, listModels: function() {
  return Z(this, void 0, void 0, function() {
    var n, e, t, r, o, i, a;
    return j(this, function(s) {
      switch (s.label) {
        case 0:
          n = Ur.getSchemes(), e = {}, t = 0, r = n, s.label = 1;
        case 1:
          return t < r.length ? (o = r[t], [4, Ur.getManager(o).listModels()]) : [3, 4];
        case 2:
          for (a in i = s.sent()) e[o + Jo + a] = i[a];
          s.label = 3;
        case 3:
          return t++, [3, 1];
        case 4:
          return [2, e];
      }
    });
  });
}, moveModel: function(n, e) {
  return Z(this, void 0, void 0, function() {
    return j(this, function(t) {
      return [2, Mm(n, e, !0)];
    });
  });
}, removeModel: function(n) {
  return Z(this, void 0, void 0, function() {
    var e;
    return j(this, function(t) {
      return e = $a(n), [2, Ur.getManager(e.scheme).removeModel(e.path)];
    });
  });
} }), Po;
N({ confusionMatrix_: function(n, e, t) {
  var r = T(n, "labels", "confusionMatrix"), o = T(e, "predictions", "confusionMatrix");
  k(t == null || t > 0 && Number.isInteger(t), function() {
    return "If provided, numClasses must be a positive integer, but got " + t;
  }), k(r.rank === 1, function() {
    return "Expected the rank of labels to be 1, but got " + r.rank;
  }), k(o.rank === 1, function() {
    return "Expected the rank of predictions to be 1, but got " + o.rank;
  }), k(r.shape[0] === o.shape[0], function() {
    return "Mismatch in the number of examples: " + r.shape[0] + " vs. " + o.shape[0] + ". Labels and predictions should have the same number of elements.";
  }), k(t > 0 && Number.isInteger(t), function() {
    return "numClasses is required to be a positive integer, but got " + t;
  });
  var i = Yl(r.asType("int32"), t), a = Yl(o.asType("int32"), t);
  return i.transpose().matMul(a).asType("int32");
} });
var gR = N({ fromPixels_: function(n, e) {
  if (e === void 0 && (e = 3), e > 4) throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
  if (n == null) throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
  var t = !1, r = !1, o = !1, i = !1, a = !1;
  if (n.data instanceof Uint8Array) t = !0;
  else if (typeof ImageData < "u" && n instanceof ImageData) r = !0;
  else if (typeof HTMLVideoElement < "u" && n instanceof HTMLVideoElement) o = !0;
  else if (typeof HTMLImageElement < "u" && n instanceof HTMLImageElement) i = !0;
  else {
    if (n.getContext == null) throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was " + n.constructor.name);
    a = !0;
  }
  if (o && o && n.readyState < 2)
    throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");
  if (g1("FromPixels", D.backendName) != null) return D.runKernel("FromPixels", { pixels: n }, { numChannels: e });
  var s, u, l = o ? [n.videoWidth, n.videoHeight] : [n.width, n.height], c = l[0], f = l[1];
  if (a ? s = n.getContext("2d").getImageData(0, 0, c, f).data : r || t ? s = n.data : (i || o) && (Po == null && (Po = document.createElement("canvas").getContext("2d")), Po.canvas.width = c, Po.canvas.height = f, Po.drawImage(n, 0, 0, c, f), s = Po.getImageData(0, 0, c, f).data), e === 4) u = new Int32Array(s);
  else {
    var d = c * f;
    u = new Int32Array(d * e);
    for (var p = 0; p < d; p++) for (var v = 0; v < e; ++v) u[p * e + v] = s[4 * p + v];
  }
  return wf(u, [f, c, e], "int32");
} }), zf = Object.freeze({ toPixels: function(n, e) {
  return Z(this, void 0, void 0, function() {
    var t, r, o, i, a, s, u, l, c, f, d, p, v, g, y, x, w, b, _, E, C, A, R;
    return j(this, function(I) {
      switch (I.label) {
        case 0:
          if (t = T(n, "img", "toPixels"), n instanceof Je || (t = t.toInt()), t.rank !== 2 && t.rank !== 3) throw new Error("toPixels only supports rank 2 or 3 tensors, got rank " + t.rank + ".");
          if (r = t.shape.slice(0, 2), o = r[0], i = r[1], (a = t.rank === 2 ? 1 : t.shape[2]) > 4 || a === 2) throw new Error("toPixels only supports depth of size 1, 3 or 4 but got " + a);
          return [4, t.data()];
        case 1:
          return s = I.sent(), u = t.min(), l = t.max(), [4, Promise.all([u.data(), l.data()])];
        case 2:
          if (c = I.sent(), f = c[0], d = c[1], p = f[0], v = d[0], u.dispose(), l.dispose(), t.dtype === "float32") {
            if (p < 0 || v > 1) throw new Error("Tensor values for a float32 Tensor must be in the range [0 - 1] but got range [" + p + " - " + v + "].");
          } else {
            if (t.dtype !== "int32") throw new Error("Unsupported type for toPixels: " + t.dtype + ". Please use float32 or int32 tensors.");
            if (p < 0 || v > 255) throw new Error("Tensor values for a int32 Tensor must be in the range [0 - 255] but got range [" + p + " - " + v + "].");
          }
          for (g = t.dtype === "float32" ? 255 : 1, y = new Uint8ClampedArray(i * o * 4), x = 0; x < o * i; ++x) w = void 0, b = void 0, _ = void 0, E = void 0, a === 1 ? (w = s[x] * g, b = s[x] * g, _ = s[x] * g, E = 255) : a === 3 ? (w = s[3 * x] * g, b = s[3 * x + 1] * g, _ = s[3 * x + 2] * g, E = 255) : a === 4 && (w = s[4 * x] * g, b = s[4 * x + 1] * g, _ = s[4 * x + 2] * g, E = s[4 * x + 3] * g), y[(C = 4 * x) + 0] = Math.round(w), y[C + 1] = Math.round(b), y[C + 2] = Math.round(_), y[C + 3] = Math.round(E);
          return e != null && (e.width = i, e.height = o, A = e.getContext("2d"), R = new ImageData(y, i, o), A.putImageData(R, 0, 0)), t !== n && t.dispose(), [2, y];
      }
    });
  });
}, fromPixels: gR }), yR = function() {
  function n() {
  }
  return n.prototype.getClassName = function() {
    return this.constructor.className;
  }, n.fromConfig = function(e, t) {
    return new e(t);
  }, n;
}(), xR = function() {
  function n() {
    this.classNameMap = {};
  }
  return n.getMap = function() {
    return n.instance == null && (n.instance = new n()), n.instance;
  }, n.register = function(e) {
    n.getMap().classNameMap[e.className] = [e, e.fromConfig];
  }, n;
}();
function bo(n) {
  k(n.className != null, function() {
    return "Class being registered does not have the static className property defined.";
  }), k(typeof n.className == "string", function() {
    return "className is required to be a string, but got type " + typeof n.className;
  }), k(n.className.length > 0, function() {
    return "Class being registered has an empty-string as its className, which is disallowed.";
  }), xR.register(n);
}
var Eo = function(n) {
  function e() {
    return n !== null && n.apply(this, arguments) || this;
  }
  return Pn(e, n), e.prototype.minimize = function(t, r, o) {
    r === void 0 && (r = !1);
    var i = this.computeGradients(t, o), a = i.value, s = i.grads;
    if (o != null) {
      var u = o.map(function(l) {
        return { name: l.name, tensor: s[l.name] };
      });
      this.applyGradients(u);
    } else this.applyGradients(s);
    return Ht(s), r ? a : (a.dispose(), null);
  }, Object.defineProperty(e.prototype, "iterations", { get: function() {
    return this.iterations_ == null && (this.iterations_ = 0), this.iterations_;
  }, enumerable: !0, configurable: !0 }), e.prototype.incrementIterations = function() {
    this.iterations_ = this.iterations + 1;
  }, e.prototype.computeGradients = function(t, r) {
    return RT(t, r);
  }, e.prototype.dispose = function() {
    this.iterations_ != null && Ht(this.iterations_);
  }, e.prototype.saveIterations = function() {
    return Z(this, void 0, void 0, function() {
      return j(this, function(t) {
        return this.iterations_ == null && (this.iterations_ = 0), [2, { name: "iter", tensor: K(this.iterations_, "int32") }];
      });
    });
  }, e.prototype.getWeights = function() {
    return Z(this, void 0, void 0, function() {
      return j(this, function(t) {
        throw new Error("getWeights() is not implemented for this optimizer yet.");
      });
    });
  }, e.prototype.setWeights = function(t) {
    return Z(this, void 0, void 0, function() {
      return j(this, function(r) {
        throw new Error("setWeights() is not implemented for this optimizer class " + this.getClassName());
      });
    });
  }, e.prototype.extractIterations = function(t) {
    return Z(this, void 0, void 0, function() {
      var r;
      return j(this, function(o) {
        switch (o.label) {
          case 0:
            return r = this, [4, t[0].tensor.data()];
          case 1:
            return r.iterations_ = o.sent()[0], [2, t.slice(1)];
        }
      });
    });
  }, e;
}(yR);
Object.defineProperty(Eo, Symbol.hasInstance, { value: function(n) {
  return n.minimize != null && n.computeGradients != null && n.applyGradients != null;
} });
var wR = function(n) {
  function e(t, r, o) {
    o === void 0 && (o = null);
    var i = n.call(this) || this;
    return i.learningRate = t, i.rho = r, i.epsilon = o, i.accumulatedGrads = [], i.accumulatedUpdates = [], o == null && (i.epsilon = D.backend.epsilon()), i;
  }
  return Pn(e, n), e.prototype.applyGradients = function(t) {
    var r = this;
    (Array.isArray(t) ? t.map(function(o) {
      return o.name;
    }) : Object.keys(t)).forEach(function(o, i) {
      var a = D.registeredVariables[o];
      r.accumulatedGrads[i] == null && (r.accumulatedGrads[i] = { originalName: o + "/accum_grad", variable: X(function() {
        return Ie(a).variable(!1);
      }) }), r.accumulatedUpdates[i] == null && (r.accumulatedUpdates[i] = { originalName: o + "/accum_var", variable: X(function() {
        return Ie(a).variable(!1);
      }) });
      var s = Array.isArray(t) ? t[i].tensor : t[o];
      if (s != null) {
        var u = r.accumulatedGrads[i].variable, l = r.accumulatedUpdates[i].variable;
        X(function() {
          var c = u.mul(r.rho).add(s.square().mul(1 - r.rho)), f = l.add(r.epsilon).sqrt().div(u.add(r.epsilon).sqrt()).mul(s), d = l.mul(r.rho).add(f.square().mul(1 - r.rho));
          u.assign(c), l.assign(d);
          var p = f.mul(-r.learningRate).add(a);
          a.assign(p);
        });
      }
    }), this.incrementIterations();
  }, e.prototype.dispose = function() {
    this.accumulatedUpdates != null && (Ht(this.accumulatedGrads.map(function(t) {
      return t.variable;
    })), Ht(this.accumulatedUpdates.map(function(t) {
      return t.variable;
    })));
  }, e.prototype.getWeights = function() {
    return Z(this, void 0, void 0, function() {
      var t;
      return j(this, function(r) {
        switch (r.label) {
          case 0:
            return t = this.accumulatedGrads.concat(this.accumulatedUpdates), [4, this.saveIterations()];
          case 1:
            return [2, [r.sent()].concat(t.map(function(o) {
              return { name: o.originalName, tensor: o.variable };
            }))];
        }
      });
    });
  }, e.prototype.setWeights = function(t) {
    return Z(this, void 0, void 0, function() {
      var r;
      return j(this, function(o) {
        switch (o.label) {
          case 0:
            return [4, this.extractIterations(t)];
          case 1:
            return t = o.sent(), r = t.length / 2, this.accumulatedGrads = t.slice(0, r).map(function(i) {
              return { originalName: i.name, variable: i.tensor.variable(!1) };
            }), this.accumulatedUpdates = t.slice(r, 2 * r).map(function(i) {
              return { originalName: i.name, variable: i.tensor.variable(!1) };
            }), [2];
        }
      });
    });
  }, e.prototype.getConfig = function() {
    return { learningRate: this.learningRate, rho: this.rho, epsilon: this.epsilon };
  }, e.fromConfig = function(t, r) {
    return new t(r.learningRate, r.rho, r.epsilon);
  }, e.className = "Adadelta", e;
}(Eo);
bo(wR);
var _R = function(n) {
  function e(t, r) {
    r === void 0 && (r = 0.1);
    var o = n.call(this) || this;
    return o.learningRate = t, o.initialAccumulatorValue = r, o.accumulatedGrads = [], o;
  }
  return Pn(e, n), e.prototype.applyGradients = function(t) {
    var r = this;
    (Array.isArray(t) ? t.map(function(o) {
      return o.name;
    }) : Object.keys(t)).forEach(function(o, i) {
      var a = D.registeredVariables[o];
      r.accumulatedGrads[i] == null && (r.accumulatedGrads[i] = { originalName: o + "/accumulator", variable: X(function() {
        return Jn(a.shape, r.initialAccumulatorValue).variable(!1);
      }) });
      var s = Array.isArray(t) ? t[i].tensor : t[o];
      if (s != null) {
        var u = r.accumulatedGrads[i].variable;
        X(function() {
          var l = u.add(s.square());
          u.assign(l);
          var c = s.div(l.add(D.backend.epsilon()).sqrt()).mul(-r.learningRate).add(a);
          a.assign(c);
        });
      }
    }), this.incrementIterations();
  }, e.prototype.dispose = function() {
    this.accumulatedGrads != null && Ht(this.accumulatedGrads.map(function(t) {
      return t.variable;
    }));
  }, e.prototype.getWeights = function() {
    return Z(this, void 0, void 0, function() {
      return j(this, function(t) {
        switch (t.label) {
          case 0:
            return [4, this.saveIterations()];
          case 1:
            return [2, [t.sent()].concat(this.accumulatedGrads.map(function(r) {
              return { name: r.originalName, tensor: r.variable };
            }))];
        }
      });
    });
  }, e.prototype.setWeights = function(t) {
    return Z(this, void 0, void 0, function() {
      return j(this, function(r) {
        switch (r.label) {
          case 0:
            return [4, this.extractIterations(t)];
          case 1:
            return t = r.sent(), this.accumulatedGrads = t.map(function(o) {
              return { originalName: o.name, variable: o.tensor.variable(!1) };
            }), [2];
        }
      });
    });
  }, e.prototype.getConfig = function() {
    return { learningRate: this.learningRate, initialAccumulatorValue: this.initialAccumulatorValue };
  }, e.fromConfig = function(t, r) {
    return new t(r.learningRate, r.initialAccumulatorValue);
  }, e.className = "Adagrad", e;
}(Eo);
bo(_R);
var bR = function(n) {
  function e(t, r, o, i) {
    i === void 0 && (i = null);
    var a = n.call(this) || this;
    return a.learningRate = t, a.beta1 = r, a.beta2 = o, a.epsilon = i, a.accumulatedFirstMoment = [], a.accumulatedSecondMoment = [], X(function() {
      a.accBeta1 = K(r).variable(), a.accBeta2 = K(o).variable();
    }), i == null && (a.epsilon = D.backend.epsilon()), a;
  }
  return Pn(e, n), e.prototype.applyGradients = function(t) {
    var r = this, o = Array.isArray(t) ? t.map(function(i) {
      return i.name;
    }) : Object.keys(t);
    X(function() {
      var i = vt(1, r.accBeta1), a = vt(1, r.accBeta2);
      o.forEach(function(s, u) {
        var l = D.registeredVariables[s];
        r.accumulatedFirstMoment[u] == null && (r.accumulatedFirstMoment[u] = { originalName: s + "/m", variable: X(function() {
          return Ie(l).variable(!1);
        }) }), r.accumulatedSecondMoment[u] == null && (r.accumulatedSecondMoment[u] = { originalName: s + "/v", variable: X(function() {
          return Ie(l).variable(!1);
        }) });
        var c = Array.isArray(t) ? t[u].tensor : t[s];
        if (c != null) {
          var f = r.accumulatedFirstMoment[u].variable, d = r.accumulatedSecondMoment[u].variable, p = f.mul(r.beta1).add(c.mul(1 - r.beta1)), v = d.mul(r.beta2).add(c.square().mul(1 - r.beta2)), g = p.div(i), y = v.div(a);
          f.assign(p), d.assign(v);
          var x = g.div(y.sqrt().add(r.epsilon)).mul(-r.learningRate).add(l);
          l.assign(x);
        }
      }), r.accBeta1.assign(r.accBeta1.mul(r.beta1)), r.accBeta2.assign(r.accBeta2.mul(r.beta2));
    }), this.incrementIterations();
  }, e.prototype.dispose = function() {
    this.accBeta1.dispose(), this.accBeta2.dispose(), this.accumulatedFirstMoment != null && Ht(this.accumulatedFirstMoment.map(function(t) {
      return t.variable;
    })), this.accumulatedSecondMoment != null && Ht(this.accumulatedSecondMoment.map(function(t) {
      return t.variable;
    }));
  }, e.prototype.getWeights = function() {
    return Z(this, void 0, void 0, function() {
      var t;
      return j(this, function(r) {
        switch (r.label) {
          case 0:
            return t = this.accumulatedFirstMoment.concat(this.accumulatedSecondMoment), [4, this.saveIterations()];
          case 1:
            return [2, [r.sent()].concat(t.map(function(o) {
              return { name: o.originalName, tensor: o.variable };
            }))];
        }
      });
    });
  }, e.prototype.setWeights = function(t) {
    return Z(this, void 0, void 0, function() {
      var r, o = this;
      return j(this, function(i) {
        switch (i.label) {
          case 0:
            return [4, this.extractIterations(t)];
          case 1:
            return t = i.sent(), X(function() {
              o.accBeta1.assign(ms(o.beta1, o.iterations_ + 1)), o.accBeta2.assign(ms(o.beta2, o.iterations_ + 1));
            }), r = t.length / 2, this.accumulatedFirstMoment = t.slice(0, r).map(function(a) {
              return { originalName: a.name, variable: a.tensor.variable(!1) };
            }), this.accumulatedSecondMoment = t.slice(r, 2 * r).map(function(a) {
              return { originalName: a.name, variable: a.tensor.variable(!1) };
            }), [2];
        }
      });
    });
  }, e.prototype.getConfig = function() {
    return { learningRate: this.learningRate, beta1: this.beta1, beta2: this.beta2, epsilon: this.epsilon };
  }, e.fromConfig = function(t, r) {
    return new t(r.learningRate, r.beta1, r.beta2, r.epsilon);
  }, e.className = "Adam", e;
}(Eo);
bo(bR);
var ER = function(n) {
  function e(t, r, o, i, a) {
    i === void 0 && (i = null), a === void 0 && (a = 0);
    var s = n.call(this) || this;
    return s.learningRate = t, s.beta1 = r, s.beta2 = o, s.epsilon = i, s.decay = a, s.accumulatedFirstMoment = [], s.accumulatedWeightedInfNorm = [], X(function() {
      s.iteration = K(0).variable(), s.accBeta1 = K(r).variable();
    }), i == null && (s.epsilon = D.backend.epsilon()), s;
  }
  return Pn(e, n), e.prototype.applyGradients = function(t) {
    var r = this, o = Array.isArray(t) ? t.map(function(i) {
      return i.name;
    }) : Object.keys(t);
    X(function() {
      var i = vt(1, r.accBeta1), a = En(-r.learningRate, r.iteration.mul(r.decay).add(1));
      o.forEach(function(s, u) {
        var l = D.registeredVariables[s];
        r.accumulatedFirstMoment[u] == null && (r.accumulatedFirstMoment[u] = { originalName: s + "/m", variable: Ie(l).variable(!1) }), r.accumulatedWeightedInfNorm[u] == null && (r.accumulatedWeightedInfNorm[u] = { originalName: s + "/v", variable: Ie(l).variable(!1) });
        var c = Array.isArray(t) ? t[u].tensor : t[s];
        if (c != null) {
          var f = r.accumulatedFirstMoment[u].variable, d = r.accumulatedWeightedInfNorm[u].variable, p = f.mul(r.beta1).add(c.mul(1 - r.beta1)), v = d.mul(r.beta2), g = c.abs(), y = v.maximum(g);
          f.assign(p), d.assign(y);
          var x = a.div(i).mul(p.div(y.add(r.epsilon))).add(l);
          l.assign(x);
        }
      }), r.iteration.assign(r.iteration.add(1)), r.accBeta1.assign(r.accBeta1.mul(r.beta1));
    }), this.incrementIterations();
  }, e.prototype.dispose = function() {
    this.accBeta1.dispose(), this.iteration.dispose(), this.accumulatedFirstMoment != null && Ht(this.accumulatedFirstMoment.map(function(t) {
      return t.variable;
    })), this.accumulatedWeightedInfNorm != null && Ht(this.accumulatedWeightedInfNorm.map(function(t) {
      return t.variable;
    }));
  }, e.prototype.getWeights = function() {
    return Z(this, void 0, void 0, function() {
      return j(this, function(t) {
        throw new Error("getWeights() is not implemented for Adamax yet.");
      });
    });
  }, e.prototype.setWeights = function(t) {
    return Z(this, void 0, void 0, function() {
      return j(this, function(r) {
        throw new Error("setWeights() is not implemented for Adamax yet.");
      });
    });
  }, e.prototype.getConfig = function() {
    return { learningRate: this.learningRate, beta1: this.beta1, beta2: this.beta2, epsilon: this.epsilon, decay: this.decay };
  }, e.fromConfig = function(t, r) {
    return new t(r.learningRate, r.beta1, r.beta2, r.epsilon, r.decay);
  }, e.className = "Adamax", e;
}(Eo);
bo(ER);
var J0 = function(n) {
  function e(t) {
    var r = n.call(this) || this;
    return r.learningRate = t, r.setLearningRate(t), r;
  }
  return Pn(e, n), e.prototype.applyGradients = function(t) {
    var r = this;
    (Array.isArray(t) ? t.map(function(o) {
      return o.name;
    }) : Object.keys(t)).forEach(function(o, i) {
      var a = Array.isArray(t) ? t[i].tensor : t[o];
      if (a != null) {
        var s = D.registeredVariables[o];
        X(function() {
          var u = r.c.mul(a).add(s);
          s.assign(u);
        });
      }
    }), this.incrementIterations();
  }, e.prototype.setLearningRate = function(t) {
    this.learningRate = t, this.c != null && this.c.dispose(), this.c = H3(K(-t));
  }, e.prototype.dispose = function() {
    this.c.dispose();
  }, e.prototype.getWeights = function() {
    return Z(this, void 0, void 0, function() {
      return j(this, function(t) {
        switch (t.label) {
          case 0:
            return [4, this.saveIterations()];
          case 1:
            return [2, [t.sent()]];
        }
      });
    });
  }, e.prototype.setWeights = function(t) {
    return Z(this, void 0, void 0, function() {
      return j(this, function(r) {
        switch (r.label) {
          case 0:
            return [4, this.extractIterations(t)];
          case 1:
            if ((t = r.sent()).length !== 0) throw new Error("SGD optimizer does not have settable weights.");
            return [2];
        }
      });
    });
  }, e.prototype.getConfig = function() {
    return { learningRate: this.learningRate };
  }, e.fromConfig = function(t, r) {
    return new t(r.learningRate);
  }, e.className = "SGD", e;
}(Eo);
bo(J0);
var CR = function(n) {
  function e(t, r, o) {
    o === void 0 && (o = !1);
    var i = n.call(this, t) || this;
    return i.learningRate = t, i.momentum = r, i.useNesterov = o, i.accumulations = [], i.m = K(i.momentum), i;
  }
  return Pn(e, n), e.prototype.applyGradients = function(t) {
    var r = this;
    (Array.isArray(t) ? t.map(function(o) {
      return o.name;
    }) : Object.keys(t)).forEach(function(o, i) {
      var a = D.registeredVariables[o];
      r.accumulations[i] == null && (r.accumulations[i] = { originalName: o + "/momentum", variable: X(function() {
        return Ie(a).variable(!1);
      }) });
      var s = r.accumulations[i].variable, u = Array.isArray(t) ? t[i].tensor : t[o];
      u != null && X(function() {
        var l, c = r.m.mul(s).add(u);
        l = r.useNesterov ? r.c.mul(u.add(c.mul(r.m))).add(a) : r.c.mul(c).add(a), s.assign(c), a.assign(l);
      });
    }), this.incrementIterations();
  }, e.prototype.dispose = function() {
    this.m.dispose(), this.accumulations != null && Ht(this.accumulations.map(function(t) {
      return t.variable;
    }));
  }, e.prototype.setMomentum = function(t) {
    this.momentum = t;
  }, e.prototype.getWeights = function() {
    return Z(this, void 0, void 0, function() {
      return j(this, function(t) {
        switch (t.label) {
          case 0:
            return [4, this.saveIterations()];
          case 1:
            return [2, [t.sent()].concat(this.accumulations.map(function(r) {
              return { name: r.originalName, tensor: r.variable };
            }))];
        }
      });
    });
  }, e.prototype.setWeights = function(t) {
    return Z(this, void 0, void 0, function() {
      return j(this, function(r) {
        switch (r.label) {
          case 0:
            return [4, this.extractIterations(t)];
          case 1:
            return t = r.sent(), this.accumulations = t.map(function(o) {
              return { originalName: o.name, variable: o.tensor.variable(!1) };
            }), [2];
        }
      });
    });
  }, e.prototype.getConfig = function() {
    return { learningRate: this.learningRate, momentum: this.momentum, useNesterov: this.useNesterov };
  }, e.fromConfig = function(t, r) {
    return new t(r.learningRate, r.momentum, r.useNesterov);
  }, e.className = "Momentum", e;
}(J0);
bo(CR);
var TR = function(n) {
  function e(t, r, o, i, a) {
    r === void 0 && (r = 0.9), o === void 0 && (o = 0), i === void 0 && (i = null), a === void 0 && (a = !1);
    var s = n.call(this) || this;
    if (s.learningRate = t, s.decay = r, s.momentum = o, s.epsilon = i, s.accumulatedMeanSquares = [], s.accumulatedMoments = [], s.accumulatedMeanGrads = [], s.centered = a, i == null && (s.epsilon = D.backend.epsilon()), t == null) throw new Error("learningRate for RMSPropOptimizer must be defined.");
    return s;
  }
  return Pn(e, n), e.prototype.applyGradients = function(t) {
    var r = this;
    (Array.isArray(t) ? t.map(function(o) {
      return o.name;
    }) : Object.keys(t)).forEach(function(o, i) {
      var a = D.registeredVariables[o];
      r.accumulatedMeanSquares[i] == null && (r.accumulatedMeanSquares[i] = { originalName: o + "/rms", variable: X(function() {
        return Ie(a).variable(!1);
      }) }), r.accumulatedMoments[i] == null && (r.accumulatedMoments[i] = { originalName: o + "/momentum", variable: X(function() {
        return Ie(a).variable(!1);
      }) }), r.accumulatedMeanGrads[i] == null && r.centered && (r.accumulatedMeanGrads[i] = { originalName: o + "/mg", variable: X(function() {
        return Ie(a).variable(!1);
      }) });
      var s = Array.isArray(t) ? t[i].tensor : t[o];
      if (s != null) {
        var u = r.accumulatedMeanSquares[i].variable, l = r.accumulatedMoments[i].variable;
        X(function() {
          var c = u.mul(r.decay).add(s.square().mul(1 - r.decay));
          if (r.centered) {
            var f = r.accumulatedMeanGrads[i].variable, d = f.mul(r.decay).add(s.mul(1 - r.decay)), p = l.mul(r.momentum).add(s.mul(r.learningRate).div(c.sub(d.square().add(r.epsilon)).sqrt()));
            u.assign(c), f.assign(d), l.assign(p);
            var v = a.sub(p);
            a.assign(v);
          } else {
            var g = u.mul(r.decay).add(s.square().mul(1 - r.decay));
            p = l.mul(r.momentum).add(s.mul(r.learningRate).div(g.add(r.epsilon).sqrt())), u.assign(g), l.assign(p), v = a.sub(p), a.assign(v);
          }
        });
      }
    }), this.incrementIterations();
  }, e.prototype.dispose = function() {
    this.accumulatedMeanSquares != null && Ht(this.accumulatedMeanSquares.map(function(t) {
      return t.variable;
    })), this.accumulatedMeanGrads != null && this.centered && Ht(this.accumulatedMeanGrads.map(function(t) {
      return t.variable;
    })), this.accumulatedMoments != null && Ht(this.accumulatedMoments.map(function(t) {
      return t.variable;
    }));
  }, e.prototype.getWeights = function() {
    return Z(this, void 0, void 0, function() {
      var t;
      return j(this, function(r) {
        switch (r.label) {
          case 0:
            return t = this.accumulatedMeanSquares.concat(this.accumulatedMoments), this.centered && t.push.apply(t, this.accumulatedMeanGrads), [4, this.saveIterations()];
          case 1:
            return [2, [r.sent()].concat(t.map(function(o) {
              return { name: o.originalName, tensor: o.variable };
            }))];
        }
      });
    });
  }, e.prototype.setWeights = function(t) {
    return Z(this, void 0, void 0, function() {
      var r;
      return j(this, function(o) {
        switch (o.label) {
          case 0:
            return [4, this.extractIterations(t)];
          case 1:
            return t = o.sent(), r = this.centered ? t.length / 3 : t.length / 2, this.accumulatedMeanSquares = t.slice(0, r).map(function(i) {
              return { originalName: i.name, variable: i.tensor.variable(!1) };
            }), this.accumulatedMoments = t.slice(r, 2 * r).map(function(i) {
              return { originalName: i.name, variable: i.tensor.variable(!1) };
            }), this.centered && (this.accumulatedMeanGrads = t.slice(2 * r, 3 * r).map(function(i) {
              return { originalName: i.name, variable: i.tensor.variable(!1) };
            })), [2];
        }
      });
    });
  }, e.prototype.getConfig = function() {
    return { learningRate: this.learningRate, decay: this.decay, momentum: this.momentum, epsilon: this.epsilon, centered: this.centered };
  }, e.fromConfig = function(t, r) {
    return new t(r.learningRate, r.decay, r.momentum, r.epsilon, r.centered);
  }, e.className = "RMSProp", e;
}(Eo);
bo(TR);
Je.prototype.squaredDifference = function(n) {
  return l0(this, n);
}, L = QA;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var ac = function(n, e) {
  return ac = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, r) {
    t.__proto__ = r;
  } || function(t, r) {
    for (var o in r) r.hasOwnProperty(o) && (t[o] = r[o]);
  }, ac(n, e);
};
function de(n, e) {
  ac(n, e);
  function t() {
    this.constructor = n;
  }
  n.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var At = function() {
  return At = Object.assign || function(e) {
    for (var t, r = 1, o = arguments.length; r < o; r++) {
      t = arguments[r];
      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
    }
    return e;
  }, At.apply(this, arguments);
};
function re(n, e, t, r) {
  function o(i) {
    return i instanceof t ? i : new t(function(a) {
      a(i);
    });
  }
  return new (t || (t = Promise))(function(i, a) {
    function s(c) {
      try {
        l(r.next(c));
      } catch (f) {
        a(f);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (f) {
        a(f);
      }
    }
    function l(c) {
      c.done ? i(c.value) : o(c.value).then(s, u);
    }
    l((r = r.apply(n, [])).next());
  });
}
function oe(n, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, o, i, a;
  return a = { next: s(0), throw: s(1), return: s(2) }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
    return this;
  }), a;
  function s(l) {
    return function(c) {
      return u([l, c]);
    };
  }
  function u(l) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; t; ) try {
      if (r = 1, o && (i = l[0] & 2 ? o.return : l[0] ? o.throw || ((i = o.return) && i.call(o), 0) : o.next) && !(i = i.call(o, l[1])).done) return i;
      switch (o = 0, i && (l = [l[0] & 2, i.value]), l[0]) {
        case 0:
        case 1:
          i = l;
          break;
        case 4:
          return t.label++, { value: l[1], done: !1 };
        case 5:
          t.label++, o = l[1], l = [0];
          continue;
        case 7:
          l = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (l[0] === 6 || l[0] === 2)) {
            t = 0;
            continue;
          }
          if (l[0] === 3 && (!i || l[1] > i[0] && l[1] < i[3])) {
            t.label = l[1];
            break;
          }
          if (l[0] === 6 && t.label < i[1]) {
            t.label = i[1], i = l;
            break;
          }
          if (i && t.label < i[2]) {
            t.label = i[2], t.ops.push(l);
            break;
          }
          i[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      l = e.call(n, t);
    } catch (c) {
      l = [6, c], o = 0;
    } finally {
      r = i = 0;
    }
    if (l[0] & 5) throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}
function Hi() {
  for (var n = 0, e = 0, t = arguments.length; e < t; e++) n += arguments[e].length;
  for (var r = Array(n), o = 0, e = 0; e < t; e++)
    for (var i = arguments[e], a = 0, s = i.length; a < s; a++, o++)
      r[o] = i[a];
  return r;
}
var Qo = (
  /** @class */
  function() {
    function n(e, t) {
      if (!lo(e) || !lo(t))
        throw new Error("Dimensions.constructor - expected width and height to be valid numbers, instead have " + JSON.stringify({ width: e, height: t }));
      this._width = e, this._height = t;
    }
    return Object.defineProperty(n.prototype, "width", {
      get: function() {
        return this._width;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "height", {
      get: function() {
        return this._height;
      },
      enumerable: !0,
      configurable: !0
    }), n.prototype.reverse = function() {
      return new n(1 / this.width, 1 / this.height);
    }, n;
  }()
);
function fu(n, e) {
  return n instanceof Je && n.shape.length === e;
}
function IR(n) {
  return fu(n, 2);
}
function du(n) {
  return fu(n, 3);
}
function Vr(n) {
  return fu(n, 4);
}
function SR(n) {
  return n % 1 !== 0;
}
function Vm(n) {
  return n % 2 === 0;
}
function AR(n, e) {
  e === void 0 && (e = 2);
  var t = Math.pow(10, e);
  return Math.floor(n * t) / t;
}
function Gm(n) {
  return n && n.width && n.height;
}
function RR(n, e) {
  var t = n.width, r = n.height, o = e / Math.max(r, t);
  return new Qo(Math.round(t * o), Math.round(r * o));
}
function Kf(n) {
  return n.reduce(function(e, t) {
    return e.add(t);
  }, new Pe(0, 0)).div(new Pe(n.length, n.length));
}
function na(n, e, t) {
  return Array(n).fill(0).map(function(r, o) {
    return e + o * t;
  });
}
function lo(n) {
  return !!n && n !== 1 / 0 && n !== -1 / 0 && !isNaN(n) || n === 0;
}
function Wm(n) {
  return lo(n) && 0 <= n && n <= 1;
}
var Pe = (
  /** @class */
  function() {
    function n(e, t) {
      this._x = e, this._y = t;
    }
    return Object.defineProperty(n.prototype, "x", {
      get: function() {
        return this._x;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "y", {
      get: function() {
        return this._y;
      },
      enumerable: !0,
      configurable: !0
    }), n.prototype.add = function(e) {
      return new n(this.x + e.x, this.y + e.y);
    }, n.prototype.sub = function(e) {
      return new n(this.x - e.x, this.y - e.y);
    }, n.prototype.mul = function(e) {
      return new n(this.x * e.x, this.y * e.y);
    }, n.prototype.div = function(e) {
      return new n(this.x / e.x, this.y / e.y);
    }, n.prototype.abs = function() {
      return new n(Math.abs(this.x), Math.abs(this.y));
    }, n.prototype.magnitude = function() {
      return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));
    }, n.prototype.floor = function() {
      return new n(Math.floor(this.x), Math.floor(this.y));
    }, n;
  }()
), $r = (
  /** @class */
  function() {
    function n(e, t) {
      t === void 0 && (t = !0);
      var r = e || {}, o = [r.left, r.top, r.right, r.bottom].every(lo), i = [r.x, r.y, r.width, r.height].every(lo);
      if (!i && !o)
        throw new Error("Box.constructor - expected box to be IBoundingBox | IRect, instead have " + JSON.stringify(r));
      var a = i ? [r.x, r.y, r.width, r.height] : [r.left, r.top, r.right - r.left, r.bottom - r.top], s = a[0], u = a[1], l = a[2], c = a[3];
      n.assertIsValidBox({ x: s, y: u, width: l, height: c }, "Box.constructor", t), this._x = s, this._y = u, this._width = l, this._height = c;
    }
    return n.isRect = function(e) {
      return !!e && [e.x, e.y, e.width, e.height].every(lo);
    }, n.assertIsValidBox = function(e, t, r) {
      if (r === void 0 && (r = !1), !n.isRect(e))
        throw new Error(t + " - invalid box: " + JSON.stringify(e) + ", expected object with properties x, y, width, height");
      if (!r && (e.width < 0 || e.height < 0))
        throw new Error(t + " - width (" + e.width + ") and height (" + e.height + ") must be positive numbers");
    }, Object.defineProperty(n.prototype, "x", {
      get: function() {
        return this._x;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "y", {
      get: function() {
        return this._y;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "width", {
      get: function() {
        return this._width;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "height", {
      get: function() {
        return this._height;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "left", {
      get: function() {
        return this.x;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "top", {
      get: function() {
        return this.y;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "right", {
      get: function() {
        return this.x + this.width;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "bottom", {
      get: function() {
        return this.y + this.height;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "area", {
      get: function() {
        return this.width * this.height;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "topLeft", {
      get: function() {
        return new Pe(this.left, this.top);
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "topRight", {
      get: function() {
        return new Pe(this.right, this.top);
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "bottomLeft", {
      get: function() {
        return new Pe(this.left, this.bottom);
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "bottomRight", {
      get: function() {
        return new Pe(this.right, this.bottom);
      },
      enumerable: !0,
      configurable: !0
    }), n.prototype.round = function() {
      var e = [this.x, this.y, this.width, this.height].map(function(a) {
        return Math.round(a);
      }), t = e[0], r = e[1], o = e[2], i = e[3];
      return new n({ x: t, y: r, width: o, height: i });
    }, n.prototype.floor = function() {
      var e = [this.x, this.y, this.width, this.height].map(function(a) {
        return Math.floor(a);
      }), t = e[0], r = e[1], o = e[2], i = e[3];
      return new n({ x: t, y: r, width: o, height: i });
    }, n.prototype.toSquare = function() {
      var e = this, t = e.x, r = e.y, o = e.width, i = e.height, a = Math.abs(o - i);
      return o < i && (t -= a / 2, o += a), i < o && (r -= a / 2, i += a), new n({ x: t, y: r, width: o, height: i });
    }, n.prototype.rescale = function(e) {
      var t = Gm(e) ? e.width : e, r = Gm(e) ? e.height : e;
      return new n({
        x: this.x * t,
        y: this.y * r,
        width: this.width * t,
        height: this.height * r
      });
    }, n.prototype.pad = function(e, t) {
      var r = [
        this.x - e / 2,
        this.y - t / 2,
        this.width + e,
        this.height + t
      ], o = r[0], i = r[1], a = r[2], s = r[3];
      return new n({ x: o, y: i, width: a, height: s });
    }, n.prototype.clipAtImageBorders = function(e, t) {
      var r = this, o = r.x, i = r.y, a = r.right, s = r.bottom, u = Math.max(o, 0), l = Math.max(i, 0), c = a - u, f = s - l, d = Math.min(c, e - u), p = Math.min(f, t - l);
      return new n({ x: u, y: l, width: d, height: p }).floor();
    }, n.prototype.shift = function(e, t) {
      var r = this, o = r.width, i = r.height, a = this.x + e, s = this.y + t;
      return new n({ x: a, y: s, width: o, height: i });
    }, n.prototype.padAtBorders = function(e, t) {
      var r = this.width + 1, o = this.height + 1, i = 1, a = 1, s = r, u = o, l = this.left, c = this.top, f = this.right, d = this.bottom;
      return f > t && (s = -f + t + r, f = t), d > e && (u = -d + e + o, d = e), l < 1 && (u = 2 - l, l = 1), c < 1 && (u = 2 - c, c = 1), { dy: a, edy: u, dx: i, edx: s, y: c, ey: d, x: l, ex: f, w: r, h: o };
    }, n.prototype.calibrate = function(e) {
      return new n({
        left: this.left + e.left * this.width,
        top: this.top + e.top * this.height,
        right: this.right + e.right * this.width,
        bottom: this.bottom + e.bottom * this.height
      }).toSquare().round();
    }, n;
  }()
), hu = (
  /** @class */
  function(n) {
    de(e, n);
    function e(t, r, o, i, a) {
      return a === void 0 && (a = !1), n.call(this, { left: t, top: r, right: o, bottom: i }, a) || this;
    }
    return e;
  }($r)
), X0 = (
  /** @class */
  function() {
    function n(e, t, r, o, i) {
      this._imageDims = new Qo(i.width, i.height), this._score = e, this._classScore = t, this._className = r, this._box = new $r(o).rescale(this._imageDims);
    }
    return Object.defineProperty(n.prototype, "score", {
      get: function() {
        return this._score;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "classScore", {
      get: function() {
        return this._classScore;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "className", {
      get: function() {
        return this._className;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "box", {
      get: function() {
        return this._box;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "imageDims", {
      get: function() {
        return this._imageDims;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "imageWidth", {
      get: function() {
        return this.imageDims.width;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "imageHeight", {
      get: function() {
        return this.imageDims.height;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "relativeBox", {
      get: function() {
        return new $r(this._box).rescale(this.imageDims.reverse());
      },
      enumerable: !0,
      configurable: !0
    }), n.prototype.forSize = function(e, t) {
      return new n(this.score, this.classScore, this.className, this.relativeBox, { width: e, height: t });
    }, n;
  }()
), nr = (
  /** @class */
  function(n) {
    de(e, n);
    function e(t, r, o) {
      return n.call(this, t, t, "", r, o) || this;
    }
    return e.prototype.forSize = function(t, r) {
      var o = n.prototype.forSize.call(this, t, r), i = o.score, a = o.relativeBox, s = o.imageDims;
      return new e(i, a, s);
    }, e;
  }(X0)
);
function kR(n, e, t) {
  t === void 0 && (t = !0);
  var r = Math.max(0, Math.min(n.right, e.right) - Math.max(n.left, e.left)), o = Math.max(0, Math.min(n.bottom, e.bottom) - Math.max(n.top, e.top)), i = r * o;
  return t ? i / (n.area + e.area - i) : i / Math.min(n.area, e.area);
}
function PR(n) {
  var e = n.map(function(s) {
    return s.x;
  }), t = n.map(function(s) {
    return s.y;
  }), r = e.reduce(function(s, u) {
    return u < s ? u : s;
  }, 1 / 0), o = t.reduce(function(s, u) {
    return u < s ? u : s;
  }, 1 / 0), i = e.reduce(function(s, u) {
    return s < u ? u : s;
  }, 0), a = t.reduce(function(s, u) {
    return s < u ? u : s;
  }, 0);
  return new hu(r, o, i, a);
}
function ra(n, e, t, r) {
  r === void 0 && (r = !0);
  for (var o = e.map(function(s, u) {
    return { score: s, boxIndex: u };
  }).sort(function(s, u) {
    return s.score - u.score;
  }).map(function(s) {
    return s.boxIndex;
  }), i = [], a = function() {
    var s = o.pop();
    i.push(s);
    for (var u = o, l = [], c = 0; c < u.length; c++) {
      var f = u[c], d = n[s], p = n[f];
      l.push(kR(d, p, r));
    }
    o = o.filter(function(v, g) {
      return l[g] <= t;
    });
  }; o.length > 0; )
    a();
  return i;
}
function va(n, e) {
  return X(function() {
    var t = e[0], r = e[1], o = e[2], i = Jn(Hi(n.shape.slice(0, 3), [1]), t), a = Jn(Hi(n.shape.slice(0, 3), [1]), r), s = Jn(Hi(n.shape.slice(0, 3), [1]), o), u = ht([i, a, s], 3);
    return vt(n, u);
  });
}
function NR(n, e) {
  return e === void 0 && (e = !1), X(function() {
    var t = n.shape.slice(1), r = t[0], o = t[1];
    if (r === o)
      return n;
    var i = Math.abs(r - o), a = Math.round(i * (e ? 0.5 : 1)), s = r > o ? 2 : 1, u = function(p) {
      var v = n.shape.slice();
      return v[s] = p, Jn(v, 0);
    }, l = u(a), c = i - l.shape[s], f = e && c ? u(c) : null, d = [
      f,
      n,
      l
    ].filter(function(p) {
      return !!p;
    }).map(function(p) {
      return p.toFloat();
    });
    return ht(d, s);
  });
}
function sl(n) {
  return 1 / (1 + Math.exp(-n));
}
var Jf = (
  /** @class */
  function(n) {
    de(e, n);
    function e(t, r, o, i, a) {
      return a === void 0 && (a = !1), n.call(this, { x: t, y: r, width: o, height: i }, a) || this;
    }
    return e;
  }($r)
), MR = 0.5, DR = 0.43, FR = 0.45, ys = (
  /** @class */
  function() {
    function n(e, t, r) {
      r === void 0 && (r = new Pe(0, 0));
      var o = t.width, i = t.height;
      this._imgDims = new Qo(o, i), this._shift = r, this._positions = e.map(function(a) {
        return a.mul(new Pe(o, i)).add(r);
      });
    }
    return Object.defineProperty(n.prototype, "shift", {
      get: function() {
        return new Pe(this._shift.x, this._shift.y);
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "imageWidth", {
      get: function() {
        return this._imgDims.width;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "imageHeight", {
      get: function() {
        return this._imgDims.height;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "positions", {
      get: function() {
        return this._positions;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "relativePositions", {
      get: function() {
        var e = this;
        return this._positions.map(function(t) {
          return t.sub(e._shift).div(new Pe(e.imageWidth, e.imageHeight));
        });
      },
      enumerable: !0,
      configurable: !0
    }), n.prototype.forSize = function(e, t) {
      return new this.constructor(this.relativePositions, { width: e, height: t });
    }, n.prototype.shiftBy = function(e, t) {
      return new this.constructor(this.relativePositions, this._imgDims, new Pe(e, t));
    }, n.prototype.shiftByPoint = function(e) {
      return this.shiftBy(e.x, e.y);
    }, n.prototype.align = function(e, t) {
      if (t === void 0 && (t = {}), e) {
        var r = e instanceof nr ? e.box.floor() : new $r(e);
        return this.shiftBy(r.x, r.y).align(null, t);
      }
      var o = Object.assign({}, { useDlibAlignment: !1, minBoxPadding: 0.2 }, t), i = o.useDlibAlignment, a = o.minBoxPadding;
      return i ? this.alignDlib() : this.alignMinBbox(a);
    }, n.prototype.alignDlib = function() {
      var e = this.getRefPointsForAlignment(), t = e[0], r = e[1], o = e[2], i = function(f) {
        return o.sub(f).magnitude();
      }, a = (i(t) + i(r)) / 2, s = Math.floor(a / FR), u = Kf(e), l = Math.floor(Math.max(0, u.x - MR * s)), c = Math.floor(Math.max(0, u.y - DR * s));
      return new Jf(l, c, Math.min(s, this.imageWidth + l), Math.min(s, this.imageHeight + c));
    }, n.prototype.alignMinBbox = function(e) {
      var t = PR(this.positions);
      return t.pad(t.width * e, t.height * e);
    }, n.prototype.getRefPointsForAlignment = function() {
      throw new Error("getRefPointsForAlignment not implemented by base class");
    }, n;
  }()
), LR = (
  /** @class */
  function(n) {
    de(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.getRefPointsForAlignment = function() {
      var t = this.positions;
      return [
        t[0],
        t[1],
        Kf([t[3], t[4]])
      ];
    }, e;
  }(ys)
), BR = (
  /** @class */
  function(n) {
    de(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.getJawOutline = function() {
      return this.positions.slice(0, 17);
    }, e.prototype.getLeftEyeBrow = function() {
      return this.positions.slice(17, 22);
    }, e.prototype.getRightEyeBrow = function() {
      return this.positions.slice(22, 27);
    }, e.prototype.getNose = function() {
      return this.positions.slice(27, 36);
    }, e.prototype.getLeftEye = function() {
      return this.positions.slice(36, 42);
    }, e.prototype.getRightEye = function() {
      return this.positions.slice(42, 48);
    }, e.prototype.getMouth = function() {
      return this.positions.slice(48, 68);
    }, e.prototype.getRefPointsForAlignment = function() {
      return [
        this.getLeftEye(),
        this.getRightEye(),
        this.getMouth()
      ].map(Kf);
    }, e;
  }(ys)
), Hm = (
  /** @class */
  function() {
    function n(e, t) {
      this._label = e, this._distance = t;
    }
    return Object.defineProperty(n.prototype, "label", {
      get: function() {
        return this._label;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "distance", {
      get: function() {
        return this._distance;
      },
      enumerable: !0,
      configurable: !0
    }), n.prototype.toString = function(e) {
      return e === void 0 && (e = !0), "" + this.label + (e ? " (" + AR(this.distance) + ")" : "");
    }, n;
  }()
), $m = (
  /** @class */
  function(n) {
    de(e, n);
    function e(t, r) {
      var o = n.call(this, t) || this;
      return o._label = r, o;
    }
    return e.assertIsValidLabeledBox = function(t, r) {
      if ($r.assertIsValidBox(t, r), !lo(t.label))
        throw new Error(r + " - expected property label (" + t.label + ") to be a number");
    }, Object.defineProperty(e.prototype, "label", {
      get: function() {
        return this._label;
      },
      enumerable: !0,
      configurable: !0
    }), e;
  }($r)
), Na = (
  /** @class */
  function() {
    function n(e, t) {
      if (typeof e != "string")
        throw new Error("LabeledFaceDescriptors - constructor expected label to be a string");
      if (!Array.isArray(t) || t.some(function(r) {
        return !(r instanceof Float32Array);
      }))
        throw new Error("LabeledFaceDescriptors - constructor expected descriptors to be an array of Float32Array");
      this._label = e, this._descriptors = t;
    }
    return Object.defineProperty(n.prototype, "label", {
      get: function() {
        return this._label;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "descriptors", {
      get: function() {
        return this._descriptors;
      },
      enumerable: !0,
      configurable: !0
    }), n.prototype.toJSON = function() {
      return {
        label: this.label,
        descriptors: this.descriptors.map(function(e) {
          return Array.from(e);
        })
      };
    }, n.fromJSON = function(e) {
      var t = e.descriptors.map(function(r) {
        return new Float32Array(r);
      });
      return new n(e.label, t);
    }, n;
  }()
);
(function(n) {
  de(e, n);
  function e(t, r, o, i) {
    var a = n.call(this, t, r) || this;
    return a._score = o, a._classScore = i, a;
  }
  return e.assertIsValidPredictedBox = function(t, r) {
    if ($m.assertIsValidLabeledBox(t, r), !Wm(t.score) || !Wm(t.classScore))
      throw new Error(r + " - expected properties score (" + t.score + ") and (" + t.classScore + ") to be a number between [0, 1]");
  }, Object.defineProperty(e.prototype, "score", {
    get: function() {
      return this._score;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(e.prototype, "classScore", {
    get: function() {
      return this._classScore;
    },
    enumerable: !0,
    configurable: !0
  }), e;
})($m);
function OR(n) {
  return n.detection instanceof nr;
}
function Xf(n, e) {
  var t = { detection: e };
  return Object.assign({}, n, t);
}
function Y0() {
  var n = window.fetch || function() {
    throw new Error("fetch - missing fetch implementation for browser environment");
  }, e = function() {
    throw new Error("readFile - filesystem not available for browser environment");
  };
  return {
    Canvas: HTMLCanvasElement,
    CanvasRenderingContext2D,
    Image: HTMLImageElement,
    ImageData,
    Video: HTMLVideoElement,
    createCanvasElement: function() {
      return document.createElement("canvas");
    },
    createImageElement: function() {
      return document.createElement("img");
    },
    fetch: n,
    readFile: e
  };
}
function Q0(n) {
  var e = "";
  if (!n)
    try {
      n = require("fs");
    } catch (r) {
      e = r.toString();
    }
  var t = n ? function(r) {
    return new Promise(function(o, i) {
      n.readFile(r, function(a, s) {
        return a ? i(a) : o(s);
      });
    });
  } : function() {
    throw new Error("readFile - failed to require fs in nodejs environment with error: " + e);
  };
  return {
    readFile: t
  };
}
function Z0() {
  var n = global.Canvas || global.HTMLCanvasElement, e = global.Image || global.HTMLImageElement, t = function() {
    if (n)
      return new n();
    throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment");
  }, r = function() {
    if (e)
      return new e();
    throw new Error("createImageElement - missing Image implementation for nodejs environment");
  }, o = global.fetch || function() {
    throw new Error("fetch - missing fetch implementation for nodejs environment");
  }, i = Q0();
  return At({
    Canvas: n || /** @class */
    /* @__PURE__ */ function() {
      function a() {
      }
      return a;
    }(),
    CanvasRenderingContext2D: global.CanvasRenderingContext2D || /** @class */
    /* @__PURE__ */ function() {
      function a() {
      }
      return a;
    }(),
    Image: e || /** @class */
    /* @__PURE__ */ function() {
      function a() {
      }
      return a;
    }(),
    ImageData: global.ImageData || /** @class */
    /* @__PURE__ */ function() {
      function a() {
      }
      return a;
    }(),
    Video: global.HTMLVideoElement || /** @class */
    /* @__PURE__ */ function() {
      function a() {
      }
      return a;
    }(),
    createCanvasElement: t,
    createImageElement: r,
    fetch: o
  }, i);
}
function j0() {
  return typeof window == "object" && typeof document < "u" && typeof HTMLImageElement < "u" && typeof HTMLCanvasElement < "u" && typeof HTMLVideoElement < "u" && typeof ImageData < "u" && typeof CanvasRenderingContext2D < "u";
}
function ey() {
  return typeof global == "object" && typeof require == "function" && typeof module < "u" && typeof process < "u" && !!process.version;
}
var ft;
function UR() {
  if (!ft)
    throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");
  return ft;
}
function sc(n) {
  ft = n;
}
function Yf() {
  j0() && sc(Y0()), ey() && sc(Z0());
}
function VR(n) {
  if (ft || Yf(), !ft)
    throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");
  var e = n.Canvas, t = e === void 0 ? ft.Canvas : e, r = n.Image, o = r === void 0 ? ft.Image : r;
  ft.Canvas = t, ft.Image = o, ft.createCanvasElement = n.createCanvasElement || function() {
    return new t();
  }, ft.createImageElement = n.createImageElement || function() {
    return new o();
  }, ft.ImageData = n.ImageData || ft.ImageData, ft.Video = n.Video || ft.Video, ft.fetch = n.fetch || ft.fetch, ft.readFile = n.readFile || ft.readFile;
}
var Dt = {
  getEnv: UR,
  setEnv: sc,
  initialize: Yf,
  createBrowserEnv: Y0,
  createFileSystem: Q0,
  createNodejsEnv: Z0,
  monkeyPatch: VR,
  isBrowser: j0,
  isNodejs: ey
};
Yf();
function ty(n) {
  return !Dt.isNodejs() && typeof n == "string" ? document.getElementById(n) : n;
}
function vo(n) {
  var e = Dt.getEnv(), t = e.Canvas, r = e.CanvasRenderingContext2D;
  if (n instanceof r)
    return n;
  var o = ty(n);
  if (!(o instanceof t))
    throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");
  var i = o.getContext("2d");
  if (!i)
    throw new Error("resolveContext2d - canvas 2d context is null");
  return i;
}
var qm;
(function(n) {
  n.TOP_LEFT = "TOP_LEFT", n.TOP_RIGHT = "TOP_RIGHT", n.BOTTOM_LEFT = "BOTTOM_LEFT", n.BOTTOM_RIGHT = "BOTTOM_RIGHT";
})(qm || (qm = {}));
function ny(n) {
  var e = Dt.getEnv(), t = e.Image, r = e.Video;
  return n instanceof t && n.complete || n instanceof r && n.readyState >= 3;
}
function GR(n) {
  return new Promise(function(e, t) {
    if (n instanceof Dt.getEnv().Canvas || ny(n))
      return e();
    function r(i) {
      i.currentTarget && (i.currentTarget.removeEventListener("load", r), i.currentTarget.removeEventListener("error", o), e(i));
    }
    function o(i) {
      i.currentTarget && (i.currentTarget.removeEventListener("load", r), i.currentTarget.removeEventListener("error", o), t(i));
    }
    n.addEventListener("load", r), n.addEventListener("error", o);
  });
}
function ry(n) {
  var e = Dt.getEnv(), t = e.Image, r = e.Video;
  return n instanceof t ? new Qo(n.naturalWidth, n.naturalHeight) : n instanceof r ? new Qo(n.videoWidth, n.videoHeight) : new Qo(n.width, n.height);
}
function pu(n) {
  var e = n.width, t = n.height, r = Dt.getEnv().createCanvasElement, o = r();
  return o.width = e, o.height = t, o;
}
function Qf(n, e) {
  var t = Dt.getEnv().ImageData;
  if (!(n instanceof t) && !ny(n))
    throw new Error("createCanvasFromMedia - media has not finished loading yet");
  var r = ry(n), o = r.width, i = r.height, a = pu({ width: o, height: i });
  return n instanceof t ? vo(a).putImageData(n, 0, 0) : vo(a).drawImage(n, 0, 0, o, i), a;
}
function WR(n, e) {
  return re(this, void 0, void 0, function() {
    var t, r, o, i, a, s;
    return oe(this, function(u) {
      switch (u.label) {
        case 0:
          return t = Dt.getEnv().createCanvasElement(), r = n.shape.slice(Vr(n) ? 1 : 0), o = r[0], i = r[1], a = r[2], s = X(function() {
            return n.as3D(o, i, a).toInt();
          }), [4, zf.toPixels(s, t)];
        case 1:
          return u.sent(), s.dispose(), [2, t];
      }
    });
  });
}
function zm(n) {
  var e = Dt.getEnv(), t = e.Image, r = e.Canvas, o = e.Video;
  return n instanceof t || n instanceof r || n instanceof o;
}
function HR(n, e, t) {
  t === void 0 && (t = !1);
  var r = Dt.getEnv(), o = r.Image, i = r.Canvas;
  if (!(n instanceof o || n instanceof i))
    throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");
  var a = ry(n), s = e / Math.max(a.height, a.width), u = s * a.width, l = s * a.height, c = pu({ width: e, height: e }), f = n instanceof i ? n : Qf(n), d = Math.abs(u - l) / 2, p = t && u < l ? d : 0, v = t && l < u ? d : 0;
  return vo(c).drawImage(f, p, v, u, l), c;
}
var xs = (
  /** @class */
  function() {
    function n(e, t) {
      var r = this;
      if (t === void 0 && (t = !1), this._imageTensors = [], this._canvases = [], this._treatAsBatchInput = !1, this._inputDimensions = [], !Array.isArray(e))
        throw new Error("NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have " + e);
      this._treatAsBatchInput = t, this._batchSize = e.length, e.forEach(function(o, i) {
        if (du(o)) {
          r._imageTensors[i] = o, r._inputDimensions[i] = o.shape;
          return;
        }
        if (Vr(o)) {
          var a = o.shape[0];
          if (a !== 1)
            throw new Error("NetInput - tf.Tensor4D with batchSize " + a + " passed, but not supported in input array");
          r._imageTensors[i] = o, r._inputDimensions[i] = o.shape.slice(1);
          return;
        }
        var s = o instanceof Dt.getEnv().Canvas ? o : Qf(o);
        r._canvases[i] = s, r._inputDimensions[i] = [s.height, s.width, 3];
      });
    }
    return Object.defineProperty(n.prototype, "imageTensors", {
      get: function() {
        return this._imageTensors;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "canvases", {
      get: function() {
        return this._canvases;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "isBatchInput", {
      get: function() {
        return this.batchSize > 1 || this._treatAsBatchInput;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "batchSize", {
      get: function() {
        return this._batchSize;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "inputDimensions", {
      get: function() {
        return this._inputDimensions;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "inputSize", {
      get: function() {
        return this._inputSize;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "reshapedInputDimensions", {
      get: function() {
        var e = this;
        return na(this.batchSize, 0, 1).map(function(t, r) {
          return e.getReshapedInputDimensions(r);
        });
      },
      enumerable: !0,
      configurable: !0
    }), n.prototype.getInput = function(e) {
      return this.canvases[e] || this.imageTensors[e];
    }, n.prototype.getInputDimensions = function(e) {
      return this._inputDimensions[e];
    }, n.prototype.getInputHeight = function(e) {
      return this._inputDimensions[e][0];
    }, n.prototype.getInputWidth = function(e) {
      return this._inputDimensions[e][1];
    }, n.prototype.getReshapedInputDimensions = function(e) {
      if (typeof this.inputSize != "number")
        throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");
      var t = this.getInputWidth(e), r = this.getInputHeight(e);
      return RR({ width: t, height: r }, this.inputSize);
    }, n.prototype.toBatchTensor = function(e, t) {
      var r = this;
      return t === void 0 && (t = !0), this._inputSize = e, X(function() {
        var o = na(r.batchSize, 0, 1).map(function(a) {
          var s = r.getInput(a);
          if (s instanceof Je) {
            var u = Vr(s) ? s : s.expandDims();
            return u = NR(u, t), (u.shape[1] !== e || u.shape[2] !== e) && (u = Vf.resizeBilinear(u, [e, e])), u.as3D(e, e, 3);
          }
          if (s instanceof Dt.getEnv().Canvas)
            return zf.fromPixels(HR(s, e, t));
          throw new Error("toBatchTensor - at batchIdx " + a + ", expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have " + s);
        }), i = on(o.map(function(a) {
          return a.toFloat();
        })).as4D(r.batchSize, e, e, 3);
        return i;
      });
    }, n;
  }()
);
function bt(n) {
  return re(this, void 0, void 0, function() {
    var e, t, r;
    return oe(this, function(o) {
      switch (o.label) {
        case 0:
          if (n instanceof xs)
            return [2, n];
          if (e = Array.isArray(n) ? n : [n], !e.length)
            throw new Error("toNetInput - empty array passed as input");
          return t = function(i) {
            return Array.isArray(n) ? " at input index " + i + ":" : "";
          }, r = e.map(ty), r.forEach(function(i, a) {
            if (!zm(i) && !du(i) && !Vr(i))
              throw typeof e[a] == "string" ? new Error("toNetInput -" + t(a) + " string passed, but could not resolve HTMLElement for element id " + e[a]) : new Error("toNetInput -" + t(a) + " expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id");
            if (Vr(i)) {
              var s = i.shape[0];
              if (s !== 1)
                throw new Error("toNetInput -" + t(a) + " tf.Tensor4D with batchSize " + s + " passed, but not supported in input array");
            }
          }), [4, Promise.all(r.map(function(i) {
            return zm(i) && GR(i);
          }))];
        case 1:
          return o.sent(), [2, new xs(r, Array.isArray(n))];
      }
    });
  });
}
function Zf(n, e) {
  return re(this, void 0, void 0, function() {
    var t, r, o, i, a, s, u;
    return oe(this, function(l) {
      switch (l.label) {
        case 0:
          return t = Dt.getEnv().Canvas, r = n, n instanceof t ? [3, 5] : [4, bt(n)];
        case 1:
          if (o = l.sent(), o.batchSize > 1)
            throw new Error("extractFaces - batchSize > 1 not supported");
          return i = o.getInput(0), i instanceof t ? (a = i, [3, 4]) : [3, 2];
        case 2:
          return [4, WR(i)];
        case 3:
          a = l.sent(), l.label = 4;
        case 4:
          r = a, l.label = 5;
        case 5:
          return s = vo(r), u = e.map(function(c) {
            return c instanceof nr ? c.forSize(r.width, r.height).box.floor() : c;
          }).map(function(c) {
            return c.clipAtImageBorders(r.width, r.height);
          }), [2, u.map(function(c) {
            var f = c.x, d = c.y, p = c.width, v = c.height, g = pu({ width: p, height: v });
            return vo(g).putImageData(s.getImageData(f, d, p, v), 0, 0), g;
          })];
      }
    });
  });
}
function jf(n, e) {
  return re(this, void 0, void 0, function() {
    return oe(this, function(t) {
      if (!du(n) && !Vr(n))
        throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");
      if (Vr(n) && n.shape[0] > 1)
        throw new Error("extractFaceTensors - batchSize > 1 not supported");
      return [2, X(function() {
        var r = n.shape.slice(Vr(n) ? 1 : 0), o = r[0], i = r[1], a = r[2], s = e.map(function(l) {
          return l instanceof nr ? l.forSize(i, o).box : l;
        }).map(function(l) {
          return l.clipAtImageBorders(i, o);
        }), u = s.map(function(l) {
          var c = l.x, f = l.y, d = l.width, p = l.height;
          return k0(n.as3D(o, i, a), [f, c, 0], [p, d, a]);
        });
        return u;
      })];
    });
  });
}
function $R(n, e) {
  return re(this, void 0, void 0, function() {
    var t, r;
    return oe(this, function(o) {
      switch (o.label) {
        case 0:
          return t = Dt.getEnv().fetch, [4, t(n, e)];
        case 1:
          if (r = o.sent(), !(r.status < 400))
            throw new Error("failed to fetch: (" + r.status + ") " + r.statusText + ", from url: " + r.url);
          return [2, r];
      }
    });
  });
}
function qR(n) {
  return re(this, void 0, void 0, function() {
    return oe(this, function(e) {
      switch (e.label) {
        case 0:
          return [4, $R(n)];
        case 1:
          return [2, e.sent().json()];
      }
    });
  });
}
function oy(n, e) {
  var t = e + "-weights_manifest.json";
  if (!n)
    return {
      modelBaseUri: "",
      manifestUri: t
    };
  if (n === "/")
    return {
      modelBaseUri: "/",
      manifestUri: "/" + t
    };
  var r = n.startsWith("http://") ? "http://" : n.startsWith("https://") ? "https://" : "";
  n = n.replace(r, "");
  var o = n.split("/").filter(function(s) {
    return s;
  }), i = n.endsWith(".json") ? o[o.length - 1] : t, a = r + (n.endsWith(".json") ? o.slice(0, o.length - 1) : o).join("/");
  return a = n.startsWith("/") ? "/" + a : a, {
    modelBaseUri: a,
    manifestUri: a === "/" ? "/" + i : a + "/" + i
  };
}
function zR(n, e) {
  return re(this, void 0, void 0, function() {
    var t, r, o, i;
    return oe(this, function(a) {
      switch (a.label) {
        case 0:
          return t = oy(n, e), r = t.manifestUri, o = t.modelBaseUri, [4, qR(r)];
        case 1:
          return i = a.sent(), [2, K0.loadWeights(i, o)];
      }
    });
  });
}
var br = (
  /** @class */
  function() {
    function n(e) {
      this._name = e, this._params = void 0, this._paramMappings = [];
    }
    return Object.defineProperty(n.prototype, "params", {
      get: function() {
        return this._params;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "paramMappings", {
      get: function() {
        return this._paramMappings;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "isLoaded", {
      get: function() {
        return !!this.params;
      },
      enumerable: !0,
      configurable: !0
    }), n.prototype.getParamFromPath = function(e) {
      var t = this.traversePropertyPath(e), r = t.obj, o = t.objProp;
      return r[o];
    }, n.prototype.reassignParamFromPath = function(e, t) {
      var r = this.traversePropertyPath(e), o = r.obj, i = r.objProp;
      o[i].dispose(), o[i] = t;
    }, n.prototype.getParamList = function() {
      var e = this;
      return this._paramMappings.map(function(t) {
        var r = t.paramPath;
        return {
          path: r,
          tensor: e.getParamFromPath(r)
        };
      });
    }, n.prototype.getTrainableParams = function() {
      return this.getParamList().filter(function(e) {
        return e.tensor instanceof fi;
      });
    }, n.prototype.getFrozenParams = function() {
      return this.getParamList().filter(function(e) {
        return !(e.tensor instanceof fi);
      });
    }, n.prototype.variable = function() {
      var e = this;
      this.getFrozenParams().forEach(function(t) {
        var r = t.path, o = t.tensor;
        e.reassignParamFromPath(r, o.variable());
      });
    }, n.prototype.freeze = function() {
      var e = this;
      this.getTrainableParams().forEach(function(t) {
        var r = t.path, o = t.tensor, i = Tt(o.dataSync());
        o.dispose(), e.reassignParamFromPath(r, i);
      });
    }, n.prototype.dispose = function(e) {
      e === void 0 && (e = !0), this.getParamList().forEach(function(t) {
        if (e && t.tensor.isDisposed)
          throw new Error("param tensor has already been disposed for path " + t.path);
        t.tensor.dispose();
      }), this._params = void 0;
    }, n.prototype.serializeParams = function() {
      return new Float32Array(this.getParamList().map(function(e) {
        var t = e.tensor;
        return Array.from(t.dataSync());
      }).reduce(function(e, t) {
        return e.concat(t);
      }));
    }, n.prototype.load = function(e) {
      return re(this, void 0, void 0, function() {
        return oe(this, function(t) {
          switch (t.label) {
            case 0:
              return e instanceof Float32Array ? (this.extractWeights(e), [
                2
                /*return*/
              ]) : [4, this.loadFromUri(e)];
            case 1:
              return t.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, n.prototype.loadFromUri = function(e) {
      return re(this, void 0, void 0, function() {
        var t;
        return oe(this, function(r) {
          switch (r.label) {
            case 0:
              if (e && typeof e != "string")
                throw new Error(this._name + ".loadFromUri - expected model uri");
              return [4, zR(e, this.getDefaultModelName())];
            case 1:
              return t = r.sent(), this.loadFromWeightMap(t), [
                2
                /*return*/
              ];
          }
        });
      });
    }, n.prototype.loadFromDisk = function(e) {
      return re(this, void 0, void 0, function() {
        var t, r, o, i, a, s, u, l, c, f;
        return oe(this, function(d) {
          switch (d.label) {
            case 0:
              if (e && typeof e != "string")
                throw new Error(this._name + ".loadFromDisk - expected model file path");
              return t = Dt.getEnv().readFile, r = oy(e, this.getDefaultModelName()), o = r.manifestUri, i = r.modelBaseUri, a = function(p) {
                return Promise.all(p.map(function(v) {
                  return t(v).then(function(g) {
                    return g.buffer;
                  });
                }));
              }, s = K0.weightsLoaderFactory(a), c = (l = JSON).parse, [4, t(o)];
            case 1:
              return u = c.apply(l, [d.sent().toString()]), [4, s(u, i)];
            case 2:
              return f = d.sent(), this.loadFromWeightMap(f), [
                2
                /*return*/
              ];
          }
        });
      });
    }, n.prototype.loadFromWeightMap = function(e) {
      var t = this.extractParamsFromWeigthMap(e), r = t.paramMappings, o = t.params;
      this._paramMappings = r, this._params = o;
    }, n.prototype.extractWeights = function(e) {
      var t = this.extractParams(e), r = t.paramMappings, o = t.params;
      this._paramMappings = r, this._params = o;
    }, n.prototype.traversePropertyPath = function(e) {
      if (!this.params)
        throw new Error("traversePropertyPath - model has no loaded params");
      var t = e.split("/").reduce(function(i, a) {
        if (!i.nextObj.hasOwnProperty(a))
          throw new Error("traversePropertyPath - object does not have property " + a + ", for path " + e);
        return { obj: i.nextObj, objProp: a, nextObj: i.nextObj[a] };
      }, { nextObj: this.params }), r = t.obj, o = t.objProp;
      if (!r || !o || !(r[o] instanceof Je))
        throw new Error("traversePropertyPath - parameter is not a tensor, for path " + e);
      return { obj: r, objProp: o };
    }, n;
  }()
);
function nn(n, e, t) {
  return X(function() {
    var r = Ff(n, e.depthwise_filter, e.pointwise_filter, t, "same");
    return r = ge(r, e.bias), r;
  });
}
function ul(n, e, t) {
  return t === void 0 && (t = !1), X(function() {
    var r = Xe(t ? ge(bn(n, e.conv0.filters, [2, 2], "same"), e.conv0.bias) : nn(n, e.conv0, [2, 2])), o = nn(r, e.conv1, [1, 1]), i = Xe(ge(r, o)), a = nn(i, e.conv2, [1, 1]);
    return Xe(ge(r, ge(o, a)));
  });
}
function Ma(n, e, t, r) {
  return t === void 0 && (t = !1), r === void 0 && (r = !0), X(function() {
    var o = Xe(t ? ge(bn(n, e.conv0.filters, r ? [2, 2] : [1, 1], "same"), e.conv0.bias) : nn(n, e.conv0, r ? [2, 2] : [1, 1])), i = nn(o, e.conv1, [1, 1]), a = Xe(ge(o, i)), s = nn(a, e.conv2, [1, 1]), u = Xe(ge(o, ge(i, s))), l = nn(u, e.conv3, [1, 1]);
    return Xe(ge(o, ge(i, ge(s, l))));
  });
}
function Tn(n, e, t, r) {
  return t === void 0 && (t = "same"), r === void 0 && (r = !1), X(function() {
    var o = ge(bn(n, e.filters, [1, 1], t), e.bias);
    return r ? Xe(o) : o;
  });
}
function Er(n, e) {
  Object.keys(n).forEach(function(t) {
    e.some(function(r) {
      return r.originalPath === t;
    }) || n[t].dispose();
  });
}
function mu(n, e) {
  return function(t, r, o, i) {
    var a = Vt(n(t * r * o * o), [o, o, t, r]), s = ut(n(r));
    return e.push({ paramPath: i + "/filters" }, { paramPath: i + "/bias" }), { filters: a, bias: s };
  };
}
function ed(n, e) {
  return function(t, r, o) {
    var i = Or(n(t * r), [t, r]), a = ut(n(r));
    return e.push({ paramPath: o + "/weights" }, { paramPath: o + "/bias" }), {
      weights: i,
      bias: a
    };
  };
}
var iy = (
  /** @class */
  /* @__PURE__ */ function() {
    function n(e, t, r) {
      this.depthwise_filter = e, this.pointwise_filter = t, this.bias = r;
    }
    return n;
  }()
);
function td(n, e) {
  return function(t, r, o) {
    var i = Vt(n(9 * t), [3, 3, t, 1]), a = Vt(n(t * r), [1, 1, t, r]), s = ut(n(r));
    return e.push({ paramPath: o + "/depthwise_filter" }, { paramPath: o + "/pointwise_filter" }, { paramPath: o + "/bias" }), new iy(i, a, s);
  };
}
function nd(n) {
  return function(e) {
    var t = n(e + "/depthwise_filter", 4), r = n(e + "/pointwise_filter", 4), o = n(e + "/bias", 1);
    return new iy(t, r, o);
  };
}
function Qr(n, e) {
  return function(t, r, o) {
    var i = n[t];
    if (!fu(i, r))
      throw new Error("expected weightMap[" + t + "] to be a Tensor" + r + "D, instead have " + i);
    return e.push({ originalPath: t, paramPath: o || t }), i;
  };
}
function Cr(n) {
  var e = n;
  function t(o) {
    var i = e.slice(0, o);
    return e = e.slice(o), i;
  }
  function r() {
    return e;
  }
  return {
    extractWeights: t,
    getRemainingWeights: r
  };
}
function ay(n, e) {
  var t = mu(n, e), r = td(n, e);
  function o(a, s, u, l) {
    l === void 0 && (l = !1);
    var c = l ? t(a, s, 3, u + "/conv0") : r(a, s, u + "/conv0"), f = r(s, s, u + "/conv1"), d = r(s, s, u + "/conv2");
    return { conv0: c, conv1: f, conv2: d };
  }
  function i(a, s, u, l) {
    l === void 0 && (l = !1);
    var c = o(a, s, u, l), f = c.conv0, d = c.conv1, p = c.conv2, v = r(s, s, u + "/conv3");
    return { conv0: f, conv1: d, conv2: p, conv3: v };
  }
  return {
    extractDenseBlock3Params: o,
    extractDenseBlock4Params: i
  };
}
function KR(n) {
  var e = [], t = Cr(n), r = t.extractWeights, o = t.getRemainingWeights, i = ay(r, e).extractDenseBlock4Params, a = i(3, 32, "dense0", !0), s = i(32, 64, "dense1"), u = i(64, 128, "dense2"), l = i(128, 256, "dense3");
  if (o().length !== 0)
    throw new Error("weights remaing after extract: " + o().length);
  return {
    paramMappings: e,
    params: { dense0: a, dense1: s, dense2: u, dense3: l }
  };
}
function sy(n) {
  return function(e) {
    var t = n(e + "/filters", 4), r = n(e + "/bias", 1);
    return { filters: t, bias: r };
  };
}
function uy(n, e) {
  var t = Qr(n, e), r = sy(t), o = nd(t);
  function i(s, u) {
    u === void 0 && (u = !1);
    var l = u ? r(s + "/conv0") : o(s + "/conv0"), c = o(s + "/conv1"), f = o(s + "/conv2");
    return { conv0: l, conv1: c, conv2: f };
  }
  function a(s, u) {
    u === void 0 && (u = !1);
    var l = u ? r(s + "/conv0") : o(s + "/conv0"), c = o(s + "/conv1"), f = o(s + "/conv2"), d = o(s + "/conv3");
    return { conv0: l, conv1: c, conv2: f, conv3: d };
  }
  return {
    extractDenseBlock3Params: i,
    extractDenseBlock4Params: a
  };
}
function JR(n) {
  var e = [], t = uy(n, e).extractDenseBlock4Params, r = {
    dense0: t("dense0", !0),
    dense1: t("dense1"),
    dense2: t("dense2"),
    dense3: t("dense3")
  };
  return Er(n, e), { params: r, paramMappings: e };
}
var ly = (
  /** @class */
  function(n) {
    de(e, n);
    function e() {
      return n.call(this, "FaceFeatureExtractor") || this;
    }
    return e.prototype.forwardInput = function(t) {
      var r = this.params;
      if (!r)
        throw new Error("FaceFeatureExtractor - load model before inference");
      return X(function() {
        var o = t.toBatchTensor(112, !0), i = [122.782, 117.001, 104.298], a = va(o, i).div(K(255)), s = Ma(a, r.dense0, !0);
        return s = Ma(s, r.dense1), s = Ma(s, r.dense2), s = Ma(s, r.dense3), s = pa(s, [7, 7], [2, 2], "valid"), s;
      });
    }, e.prototype.forward = function(t) {
      return re(this, void 0, void 0, function() {
        var r;
        return oe(this, function(o) {
          switch (o.label) {
            case 0:
              return r = this.forwardInput, [4, bt(t)];
            case 1:
              return [2, r.apply(this, [o.sent()])];
          }
        });
      });
    }, e.prototype.getDefaultModelName = function() {
      return "face_feature_extractor_model";
    }, e.prototype.extractParamsFromWeigthMap = function(t) {
      return JR(t);
    }, e.prototype.extractParams = function(t) {
      return KR(t);
    }, e;
  }(br)
);
function qn(n, e) {
  return X(function() {
    return ge(uu(n, e.weights), e.bias);
  });
}
function XR(n, e, t) {
  var r = [], o = Cr(n), i = o.extractWeights, a = o.getRemainingWeights, s = ed(i, r), u = s(e, t, "fc");
  if (a().length !== 0)
    throw new Error("weights remaing after extract: " + a().length);
  return {
    paramMappings: r,
    params: { fc: u }
  };
}
function YR(n) {
  var e = [], t = Qr(n, e);
  function r(i) {
    var a = t(i + "/weights", 2), s = t(i + "/bias", 1);
    return { weights: a, bias: s };
  }
  var o = {
    fc: r("fc")
  };
  return Er(n, e), { params: o, paramMappings: e };
}
function cy(n) {
  var e = {}, t = {};
  return Object.keys(n).forEach(function(r) {
    var o = r.startsWith("fc") ? t : e;
    o[r] = n[r];
  }), { featureExtractorMap: e, classifierMap: t };
}
var fy = (
  /** @class */
  function(n) {
    de(e, n);
    function e(t, r) {
      var o = n.call(this, t) || this;
      return o._faceFeatureExtractor = r, o;
    }
    return Object.defineProperty(e.prototype, "faceFeatureExtractor", {
      get: function() {
        return this._faceFeatureExtractor;
      },
      enumerable: !0,
      configurable: !0
    }), e.prototype.runNet = function(t) {
      var r = this, o = this.params;
      if (!o)
        throw new Error(this._name + " - load model before inference");
      return X(function() {
        var i = t instanceof xs ? r.faceFeatureExtractor.forwardInput(t) : t;
        return qn(i.as2D(i.shape[0], -1), o.fc);
      });
    }, e.prototype.dispose = function(t) {
      t === void 0 && (t = !0), this.faceFeatureExtractor.dispose(t), n.prototype.dispose.call(this, t);
    }, e.prototype.loadClassifierParams = function(t) {
      var r = this.extractClassifierParams(t), o = r.params, i = r.paramMappings;
      this._params = o, this._paramMappings = i;
    }, e.prototype.extractClassifierParams = function(t) {
      return XR(t, this.getClassifierChannelsIn(), this.getClassifierChannelsOut());
    }, e.prototype.extractParamsFromWeigthMap = function(t) {
      var r = cy(t), o = r.featureExtractorMap, i = r.classifierMap;
      return this.faceFeatureExtractor.loadFromWeightMap(o), YR(i);
    }, e.prototype.extractParams = function(t) {
      var r = this.getClassifierChannelsIn(), o = this.getClassifierChannelsOut(), i = o * r + o, a = t.slice(0, t.length - i), s = t.slice(t.length - i);
      return this.faceFeatureExtractor.extractWeights(a), this.extractClassifierParams(s);
    }, e;
  }(br)
), Km = ["neutral", "happy", "sad", "angry", "fearful", "disgusted", "surprised"], QR = (
  /** @class */
  function() {
    function n(e) {
      var t = this;
      if (e.length !== 7)
        throw new Error("FaceExpressions.constructor - expected probabilities.length to be 7, have: " + e.length);
      Km.forEach(function(r, o) {
        t[r] = e[o];
      });
    }
    return n.prototype.asSortedArray = function() {
      var e = this;
      return Km.map(function(t) {
        return { expression: t, probability: e[t] };
      }).sort(function(t, r) {
        return r.probability - t.probability;
      });
    }, n;
  }()
), ZR = (
  /** @class */
  function(n) {
    de(e, n);
    function e(t) {
      return t === void 0 && (t = new ly()), n.call(this, "FaceExpressionNet", t) || this;
    }
    return e.prototype.forwardInput = function(t) {
      var r = this;
      return X(function() {
        return wr(r.runNet(t));
      });
    }, e.prototype.forward = function(t) {
      return re(this, void 0, void 0, function() {
        var r;
        return oe(this, function(o) {
          switch (o.label) {
            case 0:
              return r = this.forwardInput, [4, bt(t)];
            case 1:
              return [2, r.apply(this, [o.sent()])];
          }
        });
      });
    }, e.prototype.predictExpressions = function(t) {
      return re(this, void 0, void 0, function() {
        var r, o, i, a, s = this;
        return oe(this, function(u) {
          switch (u.label) {
            case 0:
              return [4, bt(t)];
            case 1:
              return r = u.sent(), [4, this.forwardInput(r)];
            case 2:
              return o = u.sent(), [4, Promise.all(pt(o).map(function(l) {
                return re(s, void 0, void 0, function() {
                  var c;
                  return oe(this, function(f) {
                    switch (f.label) {
                      case 0:
                        return [4, l.data()];
                      case 1:
                        return c = f.sent(), l.dispose(), [2, c];
                    }
                  });
                });
              }))];
            case 3:
              return i = u.sent(), o.dispose(), a = i.map(function(l) {
                return new QR(l);
              }), [2, r.isBatchInput ? a : a[0]];
          }
        });
      });
    }, e.prototype.getDefaultModelName = function() {
      return "face_expression_model";
    }, e.prototype.getClassifierChannelsIn = function() {
      return 256;
    }, e.prototype.getClassifierChannelsOut = function() {
      return 7;
    }, e;
  }(fy)
);
function dy(n, e) {
  var t = { expressions: e };
  return Object.assign({}, n, t);
}
function jR(n) {
  return OR(n) && n.landmarks instanceof ys && n.unshiftedLandmarks instanceof ys && n.alignedRect instanceof nr;
}
function rd(n, e) {
  var t = n.detection.box, r = e.shiftBy(t.x, t.y), o = r.align(), i = n.detection.imageDims, a = new nr(n.detection.score, o.rescale(i.reverse()), i), s = {
    landmarks: r,
    unshiftedLandmarks: e,
    alignedRect: a
  };
  return Object.assign({}, n, s);
}
function ek(n, e) {
  var t = mu(n, e), r = td(n, e);
  function o(a, s, u) {
    var l = r(a, s, u + "/separable_conv0"), c = r(s, s, u + "/separable_conv1"), f = t(a, s, 1, u + "/expansion_conv");
    return { separable_conv0: l, separable_conv1: c, expansion_conv: f };
  }
  function i(a, s) {
    var u = r(a, a, s + "/separable_conv0"), l = r(a, a, s + "/separable_conv1"), c = r(a, a, s + "/separable_conv2");
    return { separable_conv0: u, separable_conv1: l, separable_conv2: c };
  }
  return {
    extractConvParams: t,
    extractSeparableConvParams: r,
    extractReductionBlockParams: o,
    extractMainBlockParams: i
  };
}
function tk(n, e) {
  var t = [], r = Cr(n), o = r.extractWeights, i = r.getRemainingWeights, a = ek(o, t), s = a.extractConvParams, u = a.extractSeparableConvParams, l = a.extractReductionBlockParams, c = a.extractMainBlockParams, f = s(3, 32, 3, "entry_flow/conv_in"), d = l(32, 64, "entry_flow/reduction_block_0"), p = l(64, 128, "entry_flow/reduction_block_1"), v = {
    conv_in: f,
    reduction_block_0: d,
    reduction_block_1: p
  }, g = {};
  na(e, 0, 1).forEach(function(b) {
    g["main_block_" + b] = c(128, "middle_flow/main_block_" + b);
  });
  var y = l(128, 256, "exit_flow/reduction_block"), x = u(256, 512, "exit_flow/separable_conv"), w = {
    reduction_block: y,
    separable_conv: x
  };
  if (i().length !== 0)
    throw new Error("weights remaing after extract: " + i().length);
  return {
    paramMappings: t,
    params: { entry_flow: v, middle_flow: g, exit_flow: w }
  };
}
function nk(n, e) {
  var t = Qr(n, e), r = sy(t), o = nd(t);
  function i(s) {
    var u = o(s + "/separable_conv0"), l = o(s + "/separable_conv1"), c = r(s + "/expansion_conv");
    return { separable_conv0: u, separable_conv1: l, expansion_conv: c };
  }
  function a(s) {
    var u = o(s + "/separable_conv0"), l = o(s + "/separable_conv1"), c = o(s + "/separable_conv2");
    return { separable_conv0: u, separable_conv1: l, separable_conv2: c };
  }
  return {
    extractConvParams: r,
    extractSeparableConvParams: o,
    extractReductionBlockParams: i,
    extractMainBlockParams: a
  };
}
function rk(n, e) {
  var t = [], r = nk(n, t), o = r.extractConvParams, i = r.extractSeparableConvParams, a = r.extractReductionBlockParams, s = r.extractMainBlockParams, u = o("entry_flow/conv_in"), l = a("entry_flow/reduction_block_0"), c = a("entry_flow/reduction_block_1"), f = {
    conv_in: u,
    reduction_block_0: l,
    reduction_block_1: c
  }, d = {};
  na(e, 0, 1).forEach(function(y) {
    d["main_block_" + y] = s("middle_flow/main_block_" + y);
  });
  var p = a("exit_flow/reduction_block"), v = i("exit_flow/separable_conv"), g = {
    reduction_block: p,
    separable_conv: v
  };
  return Er(n, t), { params: { entry_flow: f, middle_flow: d, exit_flow: g }, paramMappings: t };
}
function hy(n, e, t) {
  return ge(bn(n, e.filters, t, "same"), e.bias);
}
function ll(n, e, t) {
  t === void 0 && (t = !0);
  var r = t ? Xe(n) : n;
  return r = nn(r, e.separable_conv0, [1, 1]), r = nn(Xe(r), e.separable_conv1, [1, 1]), r = wt(r, [3, 3], [2, 2], "same"), r = ge(r, hy(n, e.expansion_conv, [2, 2])), r;
}
function ok(n, e) {
  var t = nn(Xe(n), e.separable_conv0, [1, 1]);
  return t = nn(Xe(t), e.separable_conv1, [1, 1]), t = nn(Xe(t), e.separable_conv2, [1, 1]), t = ge(t, n), t;
}
var ik = (
  /** @class */
  function(n) {
    de(e, n);
    function e(t) {
      var r = n.call(this, "TinyXception") || this;
      return r._numMainBlocks = t, r;
    }
    return e.prototype.forwardInput = function(t) {
      var r = this, o = this.params;
      if (!o)
        throw new Error("TinyXception - load model before inference");
      return X(function() {
        var i = t.toBatchTensor(112, !0), a = [122.782, 117.001, 104.298], s = va(i, a).div(K(256)), u = Xe(hy(s, o.entry_flow.conv_in, [2, 2]));
        return u = ll(u, o.entry_flow.reduction_block_0, !1), u = ll(u, o.entry_flow.reduction_block_1), na(r._numMainBlocks, 0, 1).forEach(function(l) {
          u = ok(u, o.middle_flow["main_block_" + l]);
        }), u = ll(u, o.exit_flow.reduction_block), u = Xe(nn(u, o.exit_flow.separable_conv, [1, 1])), u;
      });
    }, e.prototype.forward = function(t) {
      return re(this, void 0, void 0, function() {
        var r;
        return oe(this, function(o) {
          switch (o.label) {
            case 0:
              return r = this.forwardInput, [4, bt(t)];
            case 1:
              return [2, r.apply(this, [o.sent()])];
          }
        });
      });
    }, e.prototype.getDefaultModelName = function() {
      return "tiny_xception_model";
    }, e.prototype.extractParamsFromWeigthMap = function(t) {
      return rk(t, this._numMainBlocks);
    }, e.prototype.extractParams = function(t) {
      return tk(t, this._numMainBlocks);
    }, e;
  }(br)
);
function ak(n) {
  var e = [], t = Cr(n), r = t.extractWeights, o = t.getRemainingWeights, i = ed(r, e), a = i(512, 1, "fc/age"), s = i(512, 2, "fc/gender");
  if (o().length !== 0)
    throw new Error("weights remaing after extract: " + o().length);
  return {
    paramMappings: e,
    params: { fc: { age: a, gender: s } }
  };
}
function sk(n) {
  var e = [], t = Qr(n, e);
  function r(i) {
    var a = t(i + "/weights", 2), s = t(i + "/bias", 1);
    return { weights: a, bias: s };
  }
  var o = {
    fc: {
      age: r("fc/age"),
      gender: r("fc/gender")
    }
  };
  return Er(n, e), { params: o, paramMappings: e };
}
var ws;
(function(n) {
  n.FEMALE = "female", n.MALE = "male";
})(ws || (ws = {}));
var uk = (
  /** @class */
  function(n) {
    de(e, n);
    function e(t) {
      t === void 0 && (t = new ik(2));
      var r = n.call(this, "AgeGenderNet") || this;
      return r._faceFeatureExtractor = t, r;
    }
    return Object.defineProperty(e.prototype, "faceFeatureExtractor", {
      get: function() {
        return this._faceFeatureExtractor;
      },
      enumerable: !0,
      configurable: !0
    }), e.prototype.runNet = function(t) {
      var r = this, o = this.params;
      if (!o)
        throw new Error(this._name + " - load model before inference");
      return X(function() {
        var i = t instanceof xs ? r.faceFeatureExtractor.forwardInput(t) : t, a = pa(i, [7, 7], [2, 2], "valid").as2D(i.shape[0], -1), s = qn(a, o.fc.age).as1D(), u = qn(a, o.fc.gender);
        return { age: s, gender: u };
      });
    }, e.prototype.forwardInput = function(t) {
      var r = this;
      return X(function() {
        var o = r.runNet(t), i = o.age, a = o.gender;
        return { age: i, gender: wr(a) };
      });
    }, e.prototype.forward = function(t) {
      return re(this, void 0, void 0, function() {
        var r;
        return oe(this, function(o) {
          switch (o.label) {
            case 0:
              return r = this.forwardInput, [4, bt(t)];
            case 1:
              return [2, r.apply(this, [o.sent()])];
          }
        });
      });
    }, e.prototype.predictAgeAndGender = function(t) {
      return re(this, void 0, void 0, function() {
        var r, o, i, a, s, u, l = this;
        return oe(this, function(c) {
          switch (c.label) {
            case 0:
              return [4, bt(t)];
            case 1:
              return r = c.sent(), [4, this.forwardInput(r)];
            case 2:
              return o = c.sent(), i = pt(o.age), a = pt(o.gender), s = i.map(function(f, d) {
                return {
                  ageTensor: f,
                  genderTensor: a[d]
                };
              }), [4, Promise.all(s.map(function(f) {
                var d = f.ageTensor, p = f.genderTensor;
                return re(l, void 0, void 0, function() {
                  var v, g, y, x, w;
                  return oe(this, function(b) {
                    switch (b.label) {
                      case 0:
                        return [4, d.data()];
                      case 1:
                        return v = b.sent()[0], [4, p.data()];
                      case 2:
                        return g = b.sent()[0], y = g > 0.5, x = y ? ws.MALE : ws.FEMALE, w = y ? g : 1 - g, d.dispose(), p.dispose(), [2, { age: v, gender: x, genderProbability: w }];
                    }
                  });
                });
              }))];
            case 3:
              return u = c.sent(), o.age.dispose(), o.gender.dispose(), [2, r.isBatchInput ? u : u[0]];
          }
        });
      });
    }, e.prototype.getDefaultModelName = function() {
      return "age_gender_model";
    }, e.prototype.dispose = function(t) {
      t === void 0 && (t = !0), this.faceFeatureExtractor.dispose(t), n.prototype.dispose.call(this, t);
    }, e.prototype.loadClassifierParams = function(t) {
      var r = this.extractClassifierParams(t), o = r.params, i = r.paramMappings;
      this._params = o, this._paramMappings = i;
    }, e.prototype.extractClassifierParams = function(t) {
      return ak(t);
    }, e.prototype.extractParamsFromWeigthMap = function(t) {
      var r = cy(t), o = r.featureExtractorMap, i = r.classifierMap;
      return this.faceFeatureExtractor.loadFromWeightMap(o), sk(i);
    }, e.prototype.extractParams = function(t) {
      var r = 1539, o = t.slice(0, t.length - r), i = t.slice(t.length - r);
      return this.faceFeatureExtractor.extractWeights(o), this.extractClassifierParams(i);
    }, e;
  }(br)
), py = (
  /** @class */
  function(n) {
    de(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.postProcess = function(t, r, o) {
      var i = o.map(function(s) {
        var u = s.width, l = s.height, c = r / Math.max(l, u);
        return {
          width: u * c,
          height: l * c
        };
      }), a = i.length;
      return X(function() {
        var s = function(d, p) {
          return on([
            Jn([68], d),
            Jn([68], p)
          ], 1).as2D(1, 136).as1D();
        }, u = function(d, p) {
          var v = i[d], g = v.width, y = v.height;
          return p(g, y) ? Math.abs(g - y) / 2 : 0;
        }, l = function(d) {
          return u(d, function(p, v) {
            return p < v;
          });
        }, c = function(d) {
          return u(d, function(p, v) {
            return v < p;
          });
        }, f = t.mul(Jn([a, 136], r)).sub(on(Array.from(Array(a), function(d, p) {
          return s(l(p), c(p));
        }))).div(on(Array.from(Array(a), function(d, p) {
          return s(i[p].width, i[p].height);
        })));
        return f;
      });
    }, e.prototype.forwardInput = function(t) {
      var r = this;
      return X(function() {
        var o = r.runNet(t);
        return r.postProcess(o, t.inputSize, t.inputDimensions.map(function(i) {
          var a = i[0], s = i[1];
          return { height: a, width: s };
        }));
      });
    }, e.prototype.forward = function(t) {
      return re(this, void 0, void 0, function() {
        var r;
        return oe(this, function(o) {
          switch (o.label) {
            case 0:
              return r = this.forwardInput, [4, bt(t)];
            case 1:
              return [2, r.apply(this, [o.sent()])];
          }
        });
      });
    }, e.prototype.detectLandmarks = function(t) {
      return re(this, void 0, void 0, function() {
        var r, o, i, a = this;
        return oe(this, function(s) {
          switch (s.label) {
            case 0:
              return [4, bt(t)];
            case 1:
              return r = s.sent(), o = X(function() {
                return pt(a.forwardInput(r));
              }), [4, Promise.all(o.map(function(u, l) {
                return re(a, void 0, void 0, function() {
                  var c, f, d, p, v;
                  return oe(this, function(g) {
                    switch (g.label) {
                      case 0:
                        return d = (f = Array).from, [4, u.data()];
                      case 1:
                        return c = d.apply(f, [g.sent()]), p = c.filter(function(y, x) {
                          return Vm(x);
                        }), v = c.filter(function(y, x) {
                          return !Vm(x);
                        }), [2, new BR(Array(68).fill(0).map(function(y, x) {
                          return new Pe(p[x], v[x]);
                        }), {
                          height: r.getInputHeight(l),
                          width: r.getInputWidth(l)
                        })];
                    }
                  });
                });
              }))];
            case 2:
              return i = s.sent(), o.forEach(function(u) {
                return u.dispose();
              }), [2, r.isBatchInput ? i : i[0]];
          }
        });
      });
    }, e.prototype.getClassifierChannelsOut = function() {
      return 136;
    }, e;
  }(fy)
), my = (
  /** @class */
  function(n) {
    de(e, n);
    function e(t) {
      return t === void 0 && (t = new ly()), n.call(this, "FaceLandmark68Net", t) || this;
    }
    return e.prototype.getDefaultModelName = function() {
      return "face_landmark_68_model";
    }, e.prototype.getClassifierChannelsIn = function() {
      return 256;
    }, e;
  }(py)
);
function lk(n) {
  var e = [], t = uy(n, e).extractDenseBlock3Params, r = {
    dense0: t("dense0", !0),
    dense1: t("dense1"),
    dense2: t("dense2")
  };
  return Er(n, e), { params: r, paramMappings: e };
}
function ck(n) {
  var e = [], t = Cr(n), r = t.extractWeights, o = t.getRemainingWeights, i = ay(r, e).extractDenseBlock3Params, a = i(3, 32, "dense0", !0), s = i(32, 64, "dense1"), u = i(64, 128, "dense2");
  if (o().length !== 0)
    throw new Error("weights remaing after extract: " + o().length);
  return {
    paramMappings: e,
    params: { dense0: a, dense1: s, dense2: u }
  };
}
var fk = (
  /** @class */
  function(n) {
    de(e, n);
    function e() {
      return n.call(this, "TinyFaceFeatureExtractor") || this;
    }
    return e.prototype.forwardInput = function(t) {
      var r = this.params;
      if (!r)
        throw new Error("TinyFaceFeatureExtractor - load model before inference");
      return X(function() {
        var o = t.toBatchTensor(112, !0), i = [122.782, 117.001, 104.298], a = va(o, i).div(K(255)), s = ul(a, r.dense0, !0);
        return s = ul(s, r.dense1), s = ul(s, r.dense2), s = pa(s, [14, 14], [2, 2], "valid"), s;
      });
    }, e.prototype.forward = function(t) {
      return re(this, void 0, void 0, function() {
        var r;
        return oe(this, function(o) {
          switch (o.label) {
            case 0:
              return r = this.forwardInput, [4, bt(t)];
            case 1:
              return [2, r.apply(this, [o.sent()])];
          }
        });
      });
    }, e.prototype.getDefaultModelName = function() {
      return "face_feature_extractor_tiny_model";
    }, e.prototype.extractParamsFromWeigthMap = function(t) {
      return lk(t);
    }, e.prototype.extractParams = function(t) {
      return ck(t);
    }, e;
  }(br)
), dk = (
  /** @class */
  function(n) {
    de(e, n);
    function e(t) {
      return t === void 0 && (t = new fk()), n.call(this, "FaceLandmark68TinyNet", t) || this;
    }
    return e.prototype.getDefaultModelName = function() {
      return "face_landmark_68_tiny_model";
    }, e.prototype.getClassifierChannelsIn = function() {
      return 128;
    }, e;
  }(py)
);
(function(n) {
  de(e, n);
  function e() {
    return n !== null && n.apply(this, arguments) || this;
  }
  return e;
})(my);
function hk(n, e) {
  return ge(Nt(n, e.weights), e.biases);
}
function od(n, e, t, r, o) {
  o === void 0 && (o = "same");
  var i = e.conv, a = i.filters, s = i.bias, u = bn(n, a, t, o);
  return u = ge(u, s), u = hk(u, e.scale), r ? Xe(u) : u;
}
function pk(n, e) {
  return od(n, e, [1, 1], !0);
}
function vy(n, e) {
  return od(n, e, [1, 1], !1);
}
function gy(n, e) {
  return od(n, e, [2, 2], !0, "valid");
}
function mk(n, e) {
  function t(s, u, l) {
    var c = n(s), f = c.length / (u * l * l);
    if (SR(f))
      throw new Error("depth has to be an integer: " + f + ", weights.length: " + c.length + ", numFilters: " + u + ", filterSize: " + l);
    return X(function() {
      return Hr(Vt(c, [u, f, l, l]), [2, 3, 1, 0]);
    });
  }
  function r(s, u, l, c) {
    var f = t(s, u, l), d = ut(n(u));
    return e.push({ paramPath: c + "/filters" }, { paramPath: c + "/bias" }), { filters: f, bias: d };
  }
  function o(s, u) {
    var l = ut(n(s)), c = ut(n(s));
    return e.push({ paramPath: u + "/weights" }, { paramPath: u + "/biases" }), {
      weights: l,
      biases: c
    };
  }
  function i(s, u, l, c) {
    var f = r(s, u, l, c + "/conv"), d = o(u, c + "/scale");
    return { conv: f, scale: d };
  }
  function a(s, u, l, c, f) {
    f === void 0 && (f = !1);
    var d = i((f ? 0.5 : 1) * s, u, l, c + "/conv1"), p = i(s, u, l, c + "/conv2");
    return { conv1: d, conv2: p };
  }
  return {
    extractConvLayerParams: i,
    extractResidualLayerParams: a
  };
}
function vk(n) {
  var e = Cr(n), t = e.extractWeights, r = e.getRemainingWeights, o = [], i = mk(t, o), a = i.extractConvLayerParams, s = i.extractResidualLayerParams, u = a(4704, 32, 7, "conv32_down"), l = s(9216, 32, 3, "conv32_1"), c = s(9216, 32, 3, "conv32_2"), f = s(9216, 32, 3, "conv32_3"), d = s(36864, 64, 3, "conv64_down", !0), p = s(36864, 64, 3, "conv64_1"), v = s(36864, 64, 3, "conv64_2"), g = s(36864, 64, 3, "conv64_3"), y = s(147456, 128, 3, "conv128_down", !0), x = s(147456, 128, 3, "conv128_1"), w = s(147456, 128, 3, "conv128_2"), b = s(589824, 256, 3, "conv256_down", !0), _ = s(589824, 256, 3, "conv256_1"), E = s(589824, 256, 3, "conv256_2"), C = s(589824, 256, 3, "conv256_down_out"), A = X(function() {
    return Hr(Or(t(256 * 128), [128, 256]), [1, 0]);
  });
  if (o.push({ paramPath: "fc" }), r().length !== 0)
    throw new Error("weights remaing after extract: " + r().length);
  var R = {
    conv32_down: u,
    conv32_1: l,
    conv32_2: c,
    conv32_3: f,
    conv64_down: d,
    conv64_1: p,
    conv64_2: v,
    conv64_3: g,
    conv128_down: y,
    conv128_1: x,
    conv128_2: w,
    conv256_down: b,
    conv256_1: _,
    conv256_2: E,
    conv256_down_out: C,
    fc: A
  };
  return { params: R, paramMappings: o };
}
function gk(n, e) {
  var t = Qr(n, e);
  function r(a) {
    var s = t(a + "/scale/weights", 1), u = t(a + "/scale/biases", 1);
    return { weights: s, biases: u };
  }
  function o(a) {
    var s = t(a + "/conv/filters", 4), u = t(a + "/conv/bias", 1), l = r(a);
    return { conv: { filters: s, bias: u }, scale: l };
  }
  function i(a) {
    return {
      conv1: o(a + "/conv1"),
      conv2: o(a + "/conv2")
    };
  }
  return {
    extractConvLayerParams: o,
    extractResidualLayerParams: i
  };
}
function yk(n) {
  var e = [], t = gk(n, e), r = t.extractConvLayerParams, o = t.extractResidualLayerParams, i = r("conv32_down"), a = o("conv32_1"), s = o("conv32_2"), u = o("conv32_3"), l = o("conv64_down"), c = o("conv64_1"), f = o("conv64_2"), d = o("conv64_3"), p = o("conv128_down"), v = o("conv128_1"), g = o("conv128_2"), y = o("conv256_down"), x = o("conv256_1"), w = o("conv256_2"), b = o("conv256_down_out"), _ = n.fc;
  if (e.push({ originalPath: "fc", paramPath: "fc" }), !IR(_))
    throw new Error("expected weightMap[fc] to be a Tensor2D, instead have " + _);
  var E = {
    conv32_down: i,
    conv32_1: a,
    conv32_2: s,
    conv32_3: u,
    conv64_down: l,
    conv64_1: c,
    conv64_2: f,
    conv64_3: d,
    conv128_down: p,
    conv128_1: v,
    conv128_2: g,
    conv256_down: y,
    conv256_1: x,
    conv256_2: w,
    conv256_down_out: b,
    fc: _
  };
  return Er(n, e), { params: E, paramMappings: e };
}
function Un(n, e) {
  var t = pk(n, e.conv1);
  return t = vy(t, e.conv2), t = ge(t, n), t = Xe(t), t;
}
function Da(n, e) {
  var t = gy(n, e.conv1);
  t = vy(t, e.conv2);
  var r = pa(n, 2, 2, "valid"), o = Ge(r.shape), i = r.shape[3] !== t.shape[3], a = r.shape[1] !== t.shape[1] || r.shape[2] !== t.shape[2];
  if (a) {
    var s = Hi(t.shape);
    s[1] = 1;
    var u = Ge(s);
    t = ht([t, u], 1);
    var l = Hi(t.shape);
    l[2] = 1;
    var c = Ge(l);
    t = ht([t, c], 2);
  }
  return r = i ? ht([r, o], 3) : r, t = ge(r, t), t = Xe(t), t;
}
var xk = (
  /** @class */
  function(n) {
    de(e, n);
    function e() {
      return n.call(this, "FaceRecognitionNet") || this;
    }
    return e.prototype.forwardInput = function(t) {
      var r = this.params;
      if (!r)
        throw new Error("FaceRecognitionNet - load model before inference");
      return X(function() {
        var o = t.toBatchTensor(150, !0).toFloat(), i = [122.782, 117.001, 104.298], a = va(o, i).div(K(256)), s = gy(a, r.conv32_down);
        s = wt(s, 3, 2, "valid"), s = Un(s, r.conv32_1), s = Un(s, r.conv32_2), s = Un(s, r.conv32_3), s = Da(s, r.conv64_down), s = Un(s, r.conv64_1), s = Un(s, r.conv64_2), s = Un(s, r.conv64_3), s = Da(s, r.conv128_down), s = Un(s, r.conv128_1), s = Un(s, r.conv128_2), s = Da(s, r.conv256_down), s = Un(s, r.conv256_1), s = Un(s, r.conv256_2), s = Da(s, r.conv256_down_out);
        var u = s.mean([1, 2]), l = uu(u, r.fc);
        return l;
      });
    }, e.prototype.forward = function(t) {
      return re(this, void 0, void 0, function() {
        var r;
        return oe(this, function(o) {
          switch (o.label) {
            case 0:
              return r = this.forwardInput, [4, bt(t)];
            case 1:
              return [2, r.apply(this, [o.sent()])];
          }
        });
      });
    }, e.prototype.computeFaceDescriptor = function(t) {
      return re(this, void 0, void 0, function() {
        var r, o, i, a = this;
        return oe(this, function(s) {
          switch (s.label) {
            case 0:
              return [4, bt(t)];
            case 1:
              return r = s.sent(), o = X(function() {
                return pt(a.forwardInput(r));
              }), [4, Promise.all(o.map(function(u) {
                return u.data();
              }))];
            case 2:
              return i = s.sent(), o.forEach(function(u) {
                return u.dispose();
              }), [2, r.isBatchInput ? i : i[0]];
          }
        });
      });
    }, e.prototype.getDefaultModelName = function() {
      return "face_recognition_model";
    }, e.prototype.extractParamsFromWeigthMap = function(t) {
      return yk(t);
    }, e.prototype.extractParams = function(t) {
      return vk(t);
    }, e;
  }(br)
);
function yy(n, e) {
  var t = { descriptor: e };
  return Object.assign({}, n, t);
}
function xy(n, e) {
  var t = { age: e };
  return Object.assign({}, n, t);
}
function wy(n, e, t) {
  var r = { gender: e, genderProbability: t };
  return Object.assign({}, n, r);
}
var _y = (
  /** @class */
  function() {
    function n(e) {
      var t = e === void 0 ? {} : e, r = t.minFaceSize, o = t.scaleFactor, i = t.maxNumScales, a = t.scoreThresholds, s = t.scaleSteps;
      if (this._name = "MtcnnOptions", this._minFaceSize = r || 20, this._scaleFactor = o || 0.709, this._maxNumScales = i || 10, this._scoreThresholds = a || [0.6, 0.7, 0.7], this._scaleSteps = s, typeof this._minFaceSize != "number" || this._minFaceSize < 0)
        throw new Error(this._name + " - expected minFaceSize to be a number > 0");
      if (typeof this._scaleFactor != "number" || this._scaleFactor <= 0 || this._scaleFactor >= 1)
        throw new Error(this._name + " - expected scaleFactor to be a number between 0 and 1");
      if (typeof this._maxNumScales != "number" || this._maxNumScales < 0)
        throw new Error(this._name + " - expected maxNumScales to be a number > 0");
      if (!Array.isArray(this._scoreThresholds) || this._scoreThresholds.length !== 3 || this._scoreThresholds.some(function(u) {
        return typeof u != "number";
      }))
        throw new Error(this._name + " - expected scoreThresholds to be an array of numbers of length 3");
      if (this._scaleSteps && (!Array.isArray(this._scaleSteps) || this._scaleSteps.some(function(u) {
        return typeof u != "number";
      })))
        throw new Error(this._name + " - expected scaleSteps to be an array of numbers");
    }
    return Object.defineProperty(n.prototype, "minFaceSize", {
      get: function() {
        return this._minFaceSize;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "scaleFactor", {
      get: function() {
        return this._scaleFactor;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "maxNumScales", {
      get: function() {
        return this._maxNumScales;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "scoreThresholds", {
      get: function() {
        return this._scoreThresholds;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "scaleSteps", {
      get: function() {
        return this._scaleSteps;
      },
      enumerable: !0,
      configurable: !0
    }), n;
  }()
);
function wk(n, e) {
  function t(u, l) {
    var c = Vt(n(9 * u), [3, 3, u, 1]), f = ut(n(u)), d = ut(n(u)), p = ut(n(u)), v = ut(n(u));
    return e.push({ paramPath: l + "/filters" }, { paramPath: l + "/batch_norm_scale" }, { paramPath: l + "/batch_norm_offset" }, { paramPath: l + "/batch_norm_mean" }, { paramPath: l + "/batch_norm_variance" }), {
      filters: c,
      batch_norm_scale: f,
      batch_norm_offset: d,
      batch_norm_mean: p,
      batch_norm_variance: v
    };
  }
  function r(u, l, c, f, d) {
    var p = Vt(n(u * l * c * c), [c, c, u, l]), v = ut(n(l));
    return e.push({ paramPath: f + "/filters" }, { paramPath: f + "/" + (d ? "batch_norm_offset" : "bias") }), { filters: p, bias: v };
  }
  function o(u, l, c, f) {
    var d = r(u, l, c, f, !0), p = d.filters, v = d.bias;
    return {
      filters: p,
      batch_norm_offset: v
    };
  }
  function i(u, l, c) {
    var f = t(u, c + "/depthwise_conv"), d = o(u, l, 1, c + "/pointwise_conv");
    return { depthwise_conv: f, pointwise_conv: d };
  }
  function a() {
    var u = o(3, 32, 3, "mobilenetv1/conv_0"), l = i(32, 64, "mobilenetv1/conv_1"), c = i(64, 128, "mobilenetv1/conv_2"), f = i(128, 128, "mobilenetv1/conv_3"), d = i(128, 256, "mobilenetv1/conv_4"), p = i(256, 256, "mobilenetv1/conv_5"), v = i(256, 512, "mobilenetv1/conv_6"), g = i(512, 512, "mobilenetv1/conv_7"), y = i(512, 512, "mobilenetv1/conv_8"), x = i(512, 512, "mobilenetv1/conv_9"), w = i(512, 512, "mobilenetv1/conv_10"), b = i(512, 512, "mobilenetv1/conv_11"), _ = i(512, 1024, "mobilenetv1/conv_12"), E = i(1024, 1024, "mobilenetv1/conv_13");
    return {
      conv_0: u,
      conv_1: l,
      conv_2: c,
      conv_3: f,
      conv_4: d,
      conv_5: p,
      conv_6: v,
      conv_7: g,
      conv_8: y,
      conv_9: x,
      conv_10: w,
      conv_11: b,
      conv_12: _,
      conv_13: E
    };
  }
  function s() {
    var u = o(1024, 256, 1, "prediction_layer/conv_0"), l = o(256, 512, 3, "prediction_layer/conv_1"), c = o(512, 128, 1, "prediction_layer/conv_2"), f = o(128, 256, 3, "prediction_layer/conv_3"), d = o(256, 128, 1, "prediction_layer/conv_4"), p = o(128, 256, 3, "prediction_layer/conv_5"), v = o(256, 64, 1, "prediction_layer/conv_6"), g = o(64, 128, 3, "prediction_layer/conv_7"), y = r(512, 12, 1, "prediction_layer/box_predictor_0/box_encoding_predictor"), x = r(512, 9, 1, "prediction_layer/box_predictor_0/class_predictor"), w = r(1024, 24, 1, "prediction_layer/box_predictor_1/box_encoding_predictor"), b = r(1024, 18, 1, "prediction_layer/box_predictor_1/class_predictor"), _ = r(512, 24, 1, "prediction_layer/box_predictor_2/box_encoding_predictor"), E = r(512, 18, 1, "prediction_layer/box_predictor_2/class_predictor"), C = r(256, 24, 1, "prediction_layer/box_predictor_3/box_encoding_predictor"), A = r(256, 18, 1, "prediction_layer/box_predictor_3/class_predictor"), R = r(256, 24, 1, "prediction_layer/box_predictor_4/box_encoding_predictor"), I = r(256, 18, 1, "prediction_layer/box_predictor_4/class_predictor"), S = r(128, 24, 1, "prediction_layer/box_predictor_5/box_encoding_predictor"), M = r(128, 18, 1, "prediction_layer/box_predictor_5/class_predictor"), P = {
      box_encoding_predictor: y,
      class_predictor: x
    }, B = {
      box_encoding_predictor: w,
      class_predictor: b
    }, O = {
      box_encoding_predictor: _,
      class_predictor: E
    }, U = {
      box_encoding_predictor: C,
      class_predictor: A
    }, G = {
      box_encoding_predictor: R,
      class_predictor: I
    }, H = {
      box_encoding_predictor: S,
      class_predictor: M
    };
    return {
      conv_0: u,
      conv_1: l,
      conv_2: c,
      conv_3: f,
      conv_4: d,
      conv_5: p,
      conv_6: v,
      conv_7: g,
      box_predictor_0: P,
      box_predictor_1: B,
      box_predictor_2: O,
      box_predictor_3: U,
      box_predictor_4: G,
      box_predictor_5: H
    };
  }
  return {
    extractMobilenetV1Params: a,
    extractPredictionLayerParams: s
  };
}
function _k(n) {
  var e = [], t = Cr(n), r = t.extractWeights, o = t.getRemainingWeights, i = wk(r, e), a = i.extractMobilenetV1Params, s = i.extractPredictionLayerParams, u = a(), l = s(), c = wf(r(5118 * 4), [1, 5118, 4]), f = {
    extra_dim: c
  };
  if (e.push({ paramPath: "output_layer/extra_dim" }), o().length !== 0)
    throw new Error("weights remaing after extract: " + o().length);
  return {
    params: {
      mobilenetv1: u,
      prediction_layer: l,
      output_layer: f
    },
    paramMappings: e
  };
}
function bk(n, e) {
  var t = Qr(n, e);
  function r(l, c, f) {
    var d = t(l + "/Conv2d_" + c + "_pointwise/weights", 4, f + "/filters"), p = t(l + "/Conv2d_" + c + "_pointwise/convolution_bn_offset", 1, f + "/batch_norm_offset");
    return { filters: d, batch_norm_offset: p };
  }
  function o(l) {
    var c = "mobilenetv1/conv_" + l, f = "MobilenetV1/Conv2d_" + l + "_depthwise", d = c + "/depthwise_conv", p = c + "/pointwise_conv", v = t(f + "/depthwise_weights", 4, d + "/filters"), g = t(f + "/BatchNorm/gamma", 1, d + "/batch_norm_scale"), y = t(f + "/BatchNorm/beta", 1, d + "/batch_norm_offset"), x = t(f + "/BatchNorm/moving_mean", 1, d + "/batch_norm_mean"), w = t(f + "/BatchNorm/moving_variance", 1, d + "/batch_norm_variance");
    return {
      depthwise_conv: {
        filters: v,
        batch_norm_scale: g,
        batch_norm_offset: y,
        batch_norm_mean: x,
        batch_norm_variance: w
      },
      pointwise_conv: r("MobilenetV1", l, p)
    };
  }
  function i() {
    return {
      conv_0: r("MobilenetV1", 0, "mobilenetv1/conv_0"),
      conv_1: o(1),
      conv_2: o(2),
      conv_3: o(3),
      conv_4: o(4),
      conv_5: o(5),
      conv_6: o(6),
      conv_7: o(7),
      conv_8: o(8),
      conv_9: o(9),
      conv_10: o(10),
      conv_11: o(11),
      conv_12: o(12),
      conv_13: o(13)
    };
  }
  function a(l, c) {
    var f = t(l + "/weights", 4, c + "/filters"), d = t(l + "/biases", 1, c + "/bias");
    return { filters: f, bias: d };
  }
  function s(l) {
    var c = a("Prediction/BoxPredictor_" + l + "/BoxEncodingPredictor", "prediction_layer/box_predictor_" + l + "/box_encoding_predictor"), f = a("Prediction/BoxPredictor_" + l + "/ClassPredictor", "prediction_layer/box_predictor_" + l + "/class_predictor");
    return { box_encoding_predictor: c, class_predictor: f };
  }
  function u() {
    return {
      conv_0: r("Prediction", 0, "prediction_layer/conv_0"),
      conv_1: r("Prediction", 1, "prediction_layer/conv_1"),
      conv_2: r("Prediction", 2, "prediction_layer/conv_2"),
      conv_3: r("Prediction", 3, "prediction_layer/conv_3"),
      conv_4: r("Prediction", 4, "prediction_layer/conv_4"),
      conv_5: r("Prediction", 5, "prediction_layer/conv_5"),
      conv_6: r("Prediction", 6, "prediction_layer/conv_6"),
      conv_7: r("Prediction", 7, "prediction_layer/conv_7"),
      box_predictor_0: s(0),
      box_predictor_1: s(1),
      box_predictor_2: s(2),
      box_predictor_3: s(3),
      box_predictor_4: s(4),
      box_predictor_5: s(5)
    };
  }
  return {
    extractMobilenetV1Params: i,
    extractPredictionLayerParams: u
  };
}
function Ek(n) {
  var e = [], t = bk(n, e), r = t.extractMobilenetV1Params, o = t.extractPredictionLayerParams, i = n["Output/extra_dim"];
  if (e.push({ originalPath: "Output/extra_dim", paramPath: "output_layer/extra_dim" }), !du(i))
    throw new Error("expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have " + i);
  var a = {
    mobilenetv1: r(),
    prediction_layer: o(),
    output_layer: {
      extra_dim: i
    }
  };
  return Er(n, e), { params: a, paramMappings: e };
}
function Vn(n, e, t) {
  return X(function() {
    var r = bn(n, e.filters, t, "same");
    return r = ge(r, e.batch_norm_offset), Pf(r, 0, 6);
  });
}
var Ck = 0.0010000000474974513;
function Tk(n, e, t) {
  return X(function() {
    var r = su(n, e.filters, t, "same");
    return r = m0(r, e.batch_norm_mean, e.batch_norm_variance, e.batch_norm_offset, e.batch_norm_scale, Ck), Pf(r, 0, 6);
  });
}
function Ik(n) {
  return [2, 4, 6, 12].some(function(e) {
    return e === n;
  }) ? [2, 2] : [1, 1];
}
function Sk(n, e) {
  return X(function() {
    var t = null, r = Vn(n, e.conv_0, [2, 2]), o = [
      e.conv_1,
      e.conv_2,
      e.conv_3,
      e.conv_4,
      e.conv_5,
      e.conv_6,
      e.conv_7,
      e.conv_8,
      e.conv_9,
      e.conv_10,
      e.conv_11,
      e.conv_12,
      e.conv_13
    ];
    if (o.forEach(function(i, a) {
      var s = a + 1, u = Ik(s);
      r = Tk(r, i.depthwise_conv, u), r = Vn(r, i.pointwise_conv, [1, 1]), s === 11 && (t = r);
    }), t === null)
      throw new Error("mobileNetV1 - output of conv layer 11 is null");
    return {
      out: r,
      conv11: t
    };
  });
}
function Ak(n, e, t, r, o) {
  var i = n.shape[0], a = Math.min(t, i), s = e.map(function(c, f) {
    return { score: c, boxIndex: f };
  }).filter(function(c) {
    return c.score > o;
  }).sort(function(c, f) {
    return f.score - c.score;
  }), u = function(c) {
    return c <= r ? 1 : 0;
  }, l = [];
  return s.forEach(function(c) {
    if (!(l.length >= a)) {
      for (var f = c.score, d = l.length - 1; d >= 0; --d) {
        var p = Rk(n, c.boxIndex, l[d]);
        if (p !== 0 && (c.score *= u(p), c.score <= o))
          break;
      }
      f === c.score && l.push(c.boxIndex);
    }
  }), l;
}
function Rk(n, e, t) {
  var r = n.arraySync(), o = Math.min(r[e][0], r[e][2]), i = Math.min(r[e][1], r[e][3]), a = Math.max(r[e][0], r[e][2]), s = Math.max(r[e][1], r[e][3]), u = Math.min(r[t][0], r[t][2]), l = Math.min(r[t][1], r[t][3]), c = Math.max(r[t][0], r[t][2]), f = Math.max(r[t][1], r[t][3]), d = (a - o) * (s - i), p = (c - u) * (f - l);
  if (d <= 0 || p <= 0)
    return 0;
  var v = Math.max(o, u), g = Math.max(i, l), y = Math.min(a, c), x = Math.min(s, f), w = Math.max(y - v, 0) * Math.max(x - g, 0);
  return w / (d + p - w);
}
function kk(n) {
  var e = pt(Hr(n, [1, 0])), t = [
    vt(e[2], e[0]),
    vt(e[3], e[1])
  ], r = [
    ge(e[0], En(t[0], K(2))),
    ge(e[1], En(t[1], K(2)))
  ];
  return {
    sizes: t,
    centers: r
  };
}
function Pk(n, e) {
  var t = kk(n), r = t.sizes, o = t.centers, i = pt(Hr(e, [1, 0])), a = En(Nt(ec(En(i[2], K(5))), r[0]), K(2)), s = ge(Nt(En(i[0], K(10)), r[0]), o[0]), u = En(Nt(ec(En(i[3], K(5))), r[1]), K(2)), l = ge(Nt(En(i[1], K(10)), r[1]), o[1]);
  return Hr(on([
    vt(s, a),
    vt(l, u),
    ge(s, a),
    ge(l, u)
  ]), [1, 0]);
}
function Nk(n, e, t) {
  return X(function() {
    var r = n.shape[0], o = Pk(Cn(zo(t.extra_dim, [r, 1, 1]), [-1, 4]), Cn(n, [-1, 4]));
    o = Cn(o, [r, o.shape[0] / r, 4]);
    var i = f0(Qn(e, [0, 0, 1], [-1, -1, -1])), a = Qn(i, [0, 0, 0], [-1, -1, 1]);
    a = Cn(a, [r, a.shape[1]]);
    var s = pt(o), u = pt(a);
    return {
      boxes: s,
      scores: u
    };
  });
}
function No(n, e) {
  return X(function() {
    var t = n.shape[0], r = Cn(Tn(n, e.box_encoding_predictor), [t, -1, 1, 4]), o = Cn(Tn(n, e.class_predictor), [t, -1, 3]);
    return {
      boxPredictionEncoding: r,
      classPrediction: o
    };
  });
}
function Mk(n, e, t) {
  return X(function() {
    var r = Vn(n, t.conv_0, [1, 1]), o = Vn(r, t.conv_1, [2, 2]), i = Vn(o, t.conv_2, [1, 1]), a = Vn(i, t.conv_3, [2, 2]), s = Vn(a, t.conv_4, [1, 1]), u = Vn(s, t.conv_5, [2, 2]), l = Vn(u, t.conv_6, [1, 1]), c = Vn(l, t.conv_7, [2, 2]), f = No(e, t.box_predictor_0), d = No(n, t.box_predictor_1), p = No(o, t.box_predictor_2), v = No(a, t.box_predictor_3), g = No(u, t.box_predictor_4), y = No(c, t.box_predictor_5), x = ht([
      f.boxPredictionEncoding,
      d.boxPredictionEncoding,
      p.boxPredictionEncoding,
      v.boxPredictionEncoding,
      g.boxPredictionEncoding,
      y.boxPredictionEncoding
    ], 1), w = ht([
      f.classPrediction,
      d.classPrediction,
      p.classPrediction,
      v.classPrediction,
      g.classPrediction,
      y.classPrediction
    ], 1);
    return {
      boxPredictions: x,
      classPredictions: w
    };
  });
}
var vu = (
  /** @class */
  function() {
    function n(e) {
      var t = e === void 0 ? {} : e, r = t.minConfidence, o = t.maxResults;
      if (this._name = "SsdMobilenetv1Options", this._minConfidence = r || 0.5, this._maxResults = o || 100, typeof this._minConfidence != "number" || this._minConfidence <= 0 || this._minConfidence >= 1)
        throw new Error(this._name + " - expected minConfidence to be a number between 0 and 1");
      if (typeof this._maxResults != "number")
        throw new Error(this._name + " - expected maxResults to be a number");
    }
    return Object.defineProperty(n.prototype, "minConfidence", {
      get: function() {
        return this._minConfidence;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "maxResults", {
      get: function() {
        return this._maxResults;
      },
      enumerable: !0,
      configurable: !0
    }), n;
  }()
), by = (
  /** @class */
  function(n) {
    de(e, n);
    function e() {
      return n.call(this, "SsdMobilenetv1") || this;
    }
    return e.prototype.forwardInput = function(t) {
      var r = this.params;
      if (!r)
        throw new Error("SsdMobilenetv1 - load model before inference");
      return X(function() {
        var o = t.toBatchTensor(512, !1).toFloat(), i = vt(Nt(o, K(0.007843137718737125)), K(1)), a = Sk(i, r.mobilenetv1), s = Mk(a.out, a.conv11, r.prediction_layer), u = s.boxPredictions, l = s.classPredictions;
        return Nk(u, l, r.output_layer);
      });
    }, e.prototype.forward = function(t) {
      return re(this, void 0, void 0, function() {
        var r;
        return oe(this, function(o) {
          switch (o.label) {
            case 0:
              return r = this.forwardInput, [4, bt(t)];
            case 1:
              return [2, r.apply(this, [o.sent()])];
          }
        });
      });
    }, e.prototype.locateFaces = function(t, r) {
      return r === void 0 && (r = {}), re(this, void 0, void 0, function() {
        var o, i, a, s, u, l, c, f, d, p, v, g, y, x, w, b, _, E, C, A, R;
        return oe(this, function(I) {
          switch (I.label) {
            case 0:
              return o = new vu(r), i = o.maxResults, a = o.minConfidence, [4, bt(t)];
            case 1:
              for (s = I.sent(), u = this.forwardInput(s), l = u.boxes, c = u.scores, f = l[0], d = c[0], p = 1; p < l.length; p++)
                l[p].dispose(), c[p].dispose();
              return y = (g = Array).from, [4, d.data()];
            case 2:
              return v = y.apply(g, [I.sent()]), x = 0.5, w = Ak(f, v, i, x, a), b = s.getReshapedInputDimensions(0), _ = s.inputSize, E = _ / b.width, C = _ / b.height, A = f.arraySync(), R = w.map(function(S) {
                var M = [
                  Math.max(0, A[S][0]),
                  Math.min(1, A[S][2])
                ].map(function(H) {
                  return H * C;
                }), P = M[0], B = M[1], O = [
                  Math.max(0, A[S][1]),
                  Math.min(1, A[S][3])
                ].map(function(H) {
                  return H * E;
                }), U = O[0], G = O[1];
                return new nr(v[S], new Jf(U, P, G - U, B - P), {
                  height: s.getInputHeight(0),
                  width: s.getInputWidth(0)
                });
              }), f.dispose(), d.dispose(), [2, R];
          }
        });
      });
    }, e.prototype.getDefaultModelName = function() {
      return "ssd_mobilenetv1_model";
    }, e.prototype.extractParamsFromWeigthMap = function(t) {
      return Ek(t);
    }, e.prototype.extractParams = function(t) {
      return _k(t);
    }, e;
  }(br)
);
(function(n) {
  de(e, n);
  function e() {
    return n !== null && n.apply(this, arguments) || this;
  }
  return e;
})(by);
var Dk = 0.4, Fk = [
  new Pe(0.738768, 0.874946),
  new Pe(2.42204, 2.65704),
  new Pe(4.30971, 7.04493),
  new Pe(10.246, 4.59428),
  new Pe(12.6868, 11.8741)
], Lk = [
  new Pe(1.603231, 2.094468),
  new Pe(6.041143, 7.080126),
  new Pe(2.882459, 3.518061),
  new Pe(4.266906, 5.178857),
  new Pe(9.041765, 10.66308)
], Bk = [117.001, 114.697, 97.404], Ok = "tiny_yolov2_model", Uk = "tiny_yolov2_separable_conv_model", Fa = function(n) {
  return typeof n == "number";
};
function Vk(n) {
  if (!n)
    throw new Error("invalid config: " + n);
  if (typeof n.withSeparableConvs != "boolean")
    throw new Error("config.withSeparableConvs has to be a boolean, have: " + n.withSeparableConvs);
  if (!Fa(n.iouThreshold) || n.iouThreshold < 0 || n.iouThreshold > 1)
    throw new Error("config.iouThreshold has to be a number between [0, 1], have: " + n.iouThreshold);
  if (!Array.isArray(n.classes) || !n.classes.length || !n.classes.every(function(e) {
    return typeof e == "string";
  }))
    throw new Error("config.classes has to be an array class names: string[], have: " + JSON.stringify(n.classes));
  if (!Array.isArray(n.anchors) || !n.anchors.length || !n.anchors.map(function(e) {
    return e || {};
  }).every(function(e) {
    return Fa(e.x) && Fa(e.y);
  }))
    throw new Error("config.anchors has to be an array of { x: number, y: number }, have: " + JSON.stringify(n.anchors));
  if (n.meanRgb && (!Array.isArray(n.meanRgb) || n.meanRgb.length !== 3 || !n.meanRgb.every(Fa)))
    throw new Error("config.meanRgb has to be an array of shape [number, number, number], have: " + JSON.stringify(n.meanRgb));
}
function id(n) {
  return X(function() {
    var e = Nt(n, K(0.10000000149011612));
    return ge(Xe(vt(n, e)), e);
  });
}
function Sr(n, e) {
  return X(function() {
    var t = wo(n, [[0, 0], [1, 1], [1, 1], [0, 0]]);
    return t = bn(t, e.conv.filters, [1, 1], "valid"), t = vt(t, e.bn.sub), t = Nt(t, e.bn.truediv), t = ge(t, e.conv.bias), id(t);
  });
}
function Ar(n, e) {
  return X(function() {
    var t = wo(n, [[0, 0], [1, 1], [1, 1], [0, 0]]);
    return t = Ff(t, e.depthwise_filter, e.pointwise_filter, [1, 1], "valid"), t = ge(t, e.bias), id(t);
  });
}
function Gk(n, e) {
  var t = mu(n, e);
  function r(a, s) {
    var u = ut(n(a)), l = ut(n(a));
    return e.push({ paramPath: s + "/sub" }, { paramPath: s + "/truediv" }), { sub: u, truediv: l };
  }
  function o(a, s, u) {
    var l = t(a, s, 3, u + "/conv"), c = r(s, u + "/bn");
    return { conv: l, bn: c };
  }
  var i = td(n, e);
  return {
    extractConvParams: t,
    extractConvWithBatchNormParams: o,
    extractSeparableConvParams: i
  };
}
function Wk(n, e, t, r) {
  var o = Cr(n), i = o.extractWeights, a = o.getRemainingWeights, s = [], u = Gk(i, s), l = u.extractConvParams, c = u.extractConvWithBatchNormParams, f = u.extractSeparableConvParams, d;
  if (e.withSeparableConvs) {
    var p = r[0], v = r[1], g = r[2], y = r[3], x = r[4], w = r[5], b = r[6], _ = r[7], E = r[8], C = e.isFirstLayerConv2d ? l(p, v, 3, "conv0") : f(p, v, "conv0"), A = f(v, g, "conv1"), R = f(g, y, "conv2"), I = f(y, x, "conv3"), S = f(x, w, "conv4"), M = f(w, b, "conv5"), P = _ ? f(b, _, "conv6") : void 0, B = E ? f(_, E, "conv7") : void 0, O = l(E || _ || b, 5 * t, 1, "conv8");
    d = { conv0: C, conv1: A, conv2: R, conv3: I, conv4: S, conv5: M, conv6: P, conv7: B, conv8: O };
  } else {
    var p = r[0], v = r[1], g = r[2], y = r[3], x = r[4], w = r[5], b = r[6], _ = r[7], E = r[8], C = c(p, v, "conv0"), A = c(v, g, "conv1"), R = c(g, y, "conv2"), I = c(y, x, "conv3"), S = c(x, w, "conv4"), M = c(w, b, "conv5"), P = c(b, _, "conv6"), B = c(_, E, "conv7"), O = l(E, 5 * t, 1, "conv8");
    d = { conv0: C, conv1: A, conv2: R, conv3: I, conv4: S, conv5: M, conv6: P, conv7: B, conv8: O };
  }
  if (a().length !== 0)
    throw new Error("weights remaing after extract: " + a().length);
  return { params: d, paramMappings: s };
}
function Hk(n, e) {
  var t = Qr(n, e);
  function r(s) {
    var u = t(s + "/sub", 1), l = t(s + "/truediv", 1);
    return { sub: u, truediv: l };
  }
  function o(s) {
    var u = t(s + "/filters", 4), l = t(s + "/bias", 1);
    return { filters: u, bias: l };
  }
  function i(s) {
    var u = o(s + "/conv"), l = r(s + "/bn");
    return { conv: u, bn: l };
  }
  var a = nd(t);
  return {
    extractConvParams: o,
    extractConvWithBatchNormParams: i,
    extractSeparableConvParams: a
  };
}
function $k(n, e) {
  var t = [], r = Hk(n, t), o = r.extractConvParams, i = r.extractConvWithBatchNormParams, a = r.extractSeparableConvParams, s;
  if (e.withSeparableConvs) {
    var u = e.filterSizes && e.filterSizes.length || 9;
    s = {
      conv0: e.isFirstLayerConv2d ? o("conv0") : a("conv0"),
      conv1: a("conv1"),
      conv2: a("conv2"),
      conv3: a("conv3"),
      conv4: a("conv4"),
      conv5: a("conv5"),
      conv6: u > 7 ? a("conv6") : void 0,
      conv7: u > 8 ? a("conv7") : void 0,
      conv8: o("conv8")
    };
  } else
    s = {
      conv0: i("conv0"),
      conv1: i("conv1"),
      conv2: i("conv2"),
      conv3: i("conv3"),
      conv4: i("conv4"),
      conv5: i("conv5"),
      conv6: i("conv6"),
      conv7: i("conv7"),
      conv8: o("conv8")
    };
  return Er(n, t), { params: s, paramMappings: t };
}
var Jm;
(function(n) {
  n[n.XS = 224] = "XS", n[n.SM = 320] = "SM", n[n.MD = 416] = "MD", n[n.LG = 608] = "LG";
})(Jm || (Jm = {}));
var ad = (
  /** @class */
  function() {
    function n(e) {
      var t = e === void 0 ? {} : e, r = t.inputSize, o = t.scoreThreshold;
      if (this._name = "TinyYolov2Options", this._inputSize = r || 416, this._scoreThreshold = o || 0.5, typeof this._inputSize != "number" || this._inputSize % 32 !== 0)
        throw new Error(this._name + " - expected inputSize to be a number divisible by 32");
      if (typeof this._scoreThreshold != "number" || this._scoreThreshold <= 0 || this._scoreThreshold >= 1)
        throw new Error(this._name + " - expected scoreThreshold to be a number between 0 and 1");
    }
    return Object.defineProperty(n.prototype, "inputSize", {
      get: function() {
        return this._inputSize;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(n.prototype, "scoreThreshold", {
      get: function() {
        return this._scoreThreshold;
      },
      enumerable: !0,
      configurable: !0
    }), n;
  }()
), Ey = (
  /** @class */
  function(n) {
    de(e, n);
    function e(t) {
      var r = n.call(this, "TinyYolov2") || this;
      return Vk(t), r._config = t, r;
    }
    return Object.defineProperty(e.prototype, "config", {
      get: function() {
        return this._config;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "withClassScores", {
      get: function() {
        return this.config.withClassScores || this.config.classes.length > 1;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "boxEncodingSize", {
      get: function() {
        return 5 + (this.withClassScores ? this.config.classes.length : 0);
      },
      enumerable: !0,
      configurable: !0
    }), e.prototype.runTinyYolov2 = function(t, r) {
      var o = Sr(t, r.conv0);
      return o = wt(o, [2, 2], [2, 2], "same"), o = Sr(o, r.conv1), o = wt(o, [2, 2], [2, 2], "same"), o = Sr(o, r.conv2), o = wt(o, [2, 2], [2, 2], "same"), o = Sr(o, r.conv3), o = wt(o, [2, 2], [2, 2], "same"), o = Sr(o, r.conv4), o = wt(o, [2, 2], [2, 2], "same"), o = Sr(o, r.conv5), o = wt(o, [2, 2], [1, 1], "same"), o = Sr(o, r.conv6), o = Sr(o, r.conv7), Tn(o, r.conv8, "valid", !1);
    }, e.prototype.runMobilenet = function(t, r) {
      var o = this.config.isFirstLayerConv2d ? id(Tn(t, r.conv0, "valid", !1)) : Ar(t, r.conv0);
      return o = wt(o, [2, 2], [2, 2], "same"), o = Ar(o, r.conv1), o = wt(o, [2, 2], [2, 2], "same"), o = Ar(o, r.conv2), o = wt(o, [2, 2], [2, 2], "same"), o = Ar(o, r.conv3), o = wt(o, [2, 2], [2, 2], "same"), o = Ar(o, r.conv4), o = wt(o, [2, 2], [2, 2], "same"), o = Ar(o, r.conv5), o = wt(o, [2, 2], [1, 1], "same"), o = r.conv6 ? Ar(o, r.conv6) : o, o = r.conv7 ? Ar(o, r.conv7) : o, Tn(o, r.conv8, "valid", !1);
    }, e.prototype.forwardInput = function(t, r) {
      var o = this, i = this.params;
      if (!i)
        throw new Error("TinyYolov2 - load model before inference");
      return X(function() {
        var a = t.toBatchTensor(r, !1).toFloat();
        return a = o.config.meanRgb ? va(a, o.config.meanRgb) : a, a = a.div(K(256)), o.config.withSeparableConvs ? o.runMobilenet(a, i) : o.runTinyYolov2(a, i);
      });
    }, e.prototype.forward = function(t, r) {
      return re(this, void 0, void 0, function() {
        var o;
        return oe(this, function(i) {
          switch (i.label) {
            case 0:
              return o = this.forwardInput, [4, bt(t)];
            case 1:
              return [4, o.apply(this, [i.sent(), r])];
            case 2:
              return [2, i.sent()];
          }
        });
      });
    }, e.prototype.detect = function(t, r) {
      return r === void 0 && (r = {}), re(this, void 0, void 0, function() {
        var o, i, a, s, u, l, c, f, d, p, v, g, y, x, w = this;
        return oe(this, function(b) {
          switch (b.label) {
            case 0:
              return o = new ad(r), i = o.inputSize, a = o.scoreThreshold, [4, bt(t)];
            case 1:
              return s = b.sent(), [4, this.forwardInput(s, i)];
            case 2:
              return u = b.sent(), l = X(function() {
                return pt(u)[0].expandDims();
              }), c = {
                width: s.getInputWidth(0),
                height: s.getInputHeight(0)
              }, [4, this.extractBoxes(l, s.getReshapedInputDimensions(0), a)];
            case 3:
              return f = b.sent(), u.dispose(), l.dispose(), d = f.map(function(_) {
                return _.box;
              }), p = f.map(function(_) {
                return _.score;
              }), v = f.map(function(_) {
                return _.classScore;
              }), g = f.map(function(_) {
                return w.config.classes[_.label];
              }), y = ra(d.map(function(_) {
                return _.rescale(i);
              }), p, this.config.iouThreshold, !0), x = y.map(function(_) {
                return new X0(p[_], v[_], g[_], d[_], c);
              }), [2, x];
          }
        });
      });
    }, e.prototype.getDefaultModelName = function() {
      return "";
    }, e.prototype.extractParamsFromWeigthMap = function(t) {
      return $k(t, this.config);
    }, e.prototype.extractParams = function(t) {
      var r = this.config.filterSizes || e.DEFAULT_FILTER_SIZES, o = r ? r.length : void 0;
      if (o !== 7 && o !== 8 && o !== 9)
        throw new Error("TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found " + o + " filterSizes in config");
      return Wk(t, this.config, this.boxEncodingSize, r);
    }, e.prototype.extractBoxes = function(t, r, o) {
      return re(this, void 0, void 0, function() {
        var i, a, s, u, l, c, f, d, p, v, g, y, x, w, b, _, E, C, A, R, I, S, M, P, B, O, U, G, H, W = this;
        return oe(this, function(q) {
          switch (q.label) {
            case 0:
              return i = r.width, a = r.height, s = Math.max(i, a), u = s / i, l = s / a, c = t.shape[1], f = this.config.anchors.length, d = X(function() {
                var z = t.reshape([c, c, f, W.boxEncodingSize]), J = z.slice([0, 0, 0, 0], [c, c, f, 4]), ie = z.slice([0, 0, 0, 4], [c, c, f, 1]), ce = W.withClassScores ? wr(z.slice([0, 0, 0, 5], [c, c, f, W.config.classes.length]), 3) : K(0);
                return [J, ie, ce];
              }), p = d[0], v = d[1], g = d[2], y = [], [4, v.array()];
            case 1:
              return x = q.sent(), [4, p.array()];
            case 2:
              w = q.sent(), b = 0, q.label = 3;
            case 3:
              if (!(b < c)) return [3, 12];
              _ = 0, q.label = 4;
            case 4:
              if (!(_ < c)) return [3, 11];
              E = 0, q.label = 5;
            case 5:
              return E < f ? (C = sl(x[b][_][E][0]), !o || C > o ? (A = (_ + sl(w[b][_][E][0])) / c * u, R = (b + sl(w[b][_][E][1])) / c * l, I = Math.exp(w[b][_][E][2]) * this.config.anchors[E].x / c * u, S = Math.exp(w[b][_][E][3]) * this.config.anchors[E].y / c * l, M = A - I / 2, P = R - S / 2, B = { row: b, col: _, anchor: E }, this.withClassScores ? [4, this.extractPredictedClass(g, B)] : [3, 7]) : [3, 9]) : [3, 10];
            case 6:
              return H = q.sent(), [3, 8];
            case 7:
              H = { classScore: 1, label: 0 }, q.label = 8;
            case 8:
              O = H, U = O.classScore, G = O.label, y.push(At({ box: new hu(M, P, M + I, P + S), score: C, classScore: C * U, label: G }, B)), q.label = 9;
            case 9:
              return E++, [3, 5];
            case 10:
              return _++, [3, 4];
            case 11:
              return b++, [3, 3];
            case 12:
              return p.dispose(), v.dispose(), g.dispose(), [2, y];
          }
        });
      });
    }, e.prototype.extractPredictedClass = function(t, r) {
      return re(this, void 0, void 0, function() {
        var o, i, a, s;
        return oe(this, function(u) {
          switch (u.label) {
            case 0:
              return o = r.row, i = r.col, a = r.anchor, [4, t.array()];
            case 1:
              return s = u.sent(), [2, Array(this.config.classes.length).fill(0).map(function(l, c) {
                return s[o][i][a][c];
              }).map(function(l, c) {
                return {
                  classScore: l,
                  label: c
                };
              }).reduce(function(l, c) {
                return l.classScore > c.classScore ? l : c;
              })];
          }
        });
      });
    }, e.DEFAULT_FILTER_SIZES = [
      3,
      16,
      32,
      64,
      128,
      256,
      512,
      1024,
      1024
    ], e;
  }(br)
), qk = (
  /** @class */
  function(n) {
    de(e, n);
    function e(t) {
      t === void 0 && (t = !0);
      var r = this, o = Object.assign({}, {
        withSeparableConvs: t,
        iouThreshold: Dk,
        classes: ["face"]
      }, t ? {
        anchors: Lk,
        meanRgb: Bk
      } : {
        anchors: Fk,
        withClassScores: !0
      });
      return r = n.call(this, o) || this, r;
    }
    return Object.defineProperty(e.prototype, "withSeparableConvs", {
      get: function() {
        return this.config.withSeparableConvs;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "anchors", {
      get: function() {
        return this.config.anchors;
      },
      enumerable: !0,
      configurable: !0
    }), e.prototype.locateFaces = function(t, r) {
      return re(this, void 0, void 0, function() {
        var o;
        return oe(this, function(i) {
          switch (i.label) {
            case 0:
              return [4, this.detect(t, r)];
            case 1:
              return o = i.sent(), [2, o.map(function(a) {
                return new nr(a.score, a.relativeBox, { width: a.imageWidth, height: a.imageHeight });
              })];
          }
        });
      });
    }, e.prototype.getDefaultModelName = function() {
      return this.withSeparableConvs ? Uk : Ok;
    }, e.prototype.extractParamsFromWeigthMap = function(t) {
      return n.prototype.extractParamsFromWeigthMap.call(this, t);
    }, e;
  }(Ey)
), Cy = (
  /** @class */
  function(n) {
    de(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t._name = "TinyFaceDetectorOptions", t;
    }
    return e;
  }(ad)
), ga = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.then = function(e) {
      return re(this, void 0, void 0, function() {
        var t;
        return oe(this, function(r) {
          switch (r.label) {
            case 0:
              return t = e, [4, this.run()];
            case 1:
              return [2, t.apply(void 0, [r.sent()])];
          }
        });
      });
    }, n.prototype.run = function() {
      return re(this, void 0, void 0, function() {
        return oe(this, function(e) {
          throw new Error("ComposableTask - run is not implemented");
        });
      });
    }, n;
  }()
);
function gu(n, e, t, r, o) {
  return o === void 0 && (o = function(i) {
    var a = i.alignedRect;
    return a;
  }), re(this, void 0, void 0, function() {
    var i, a, s, u, l;
    return oe(this, function(c) {
      switch (c.label) {
        case 0:
          return i = n.map(function(f) {
            return jR(f) ? o(f) : f.detection;
          }), s = r, s ? [3, 5] : e instanceof Je ? [4, jf(e, i)] : [3, 2];
        case 1:
          return u = c.sent(), [3, 4];
        case 2:
          return [4, Zf(e, i)];
        case 3:
          u = c.sent(), c.label = 4;
        case 4:
          s = u, c.label = 5;
        case 5:
          return a = s, [4, t(a)];
        case 6:
          return l = c.sent(), a.forEach(function(f) {
            return f instanceof Je && f.dispose();
          }), [2, l];
      }
    });
  });
}
function sd(n, e, t, r, o) {
  return re(this, void 0, void 0, function() {
    var i = this;
    return oe(this, function(a) {
      return [2, gu([n], e, function(s) {
        return re(i, void 0, void 0, function() {
          return oe(this, function(u) {
            return [2, t(s[0])];
          });
        });
      }, r, o)];
    });
  });
}
function zk(n) {
  return X(function() {
    return on(pt(n, 3).reverse(), 3);
  });
}
var La = 2, _s = 12;
function Kk(n, e) {
  var t = mu(n, e), r = ed(n, e);
  function o(l, c) {
    var f = ut(n(l));
    return e.push({ paramPath: c }), f;
  }
  function i(l, c, f) {
    f === void 0 && (f = !1);
    var d = t(l[0], l[1], 3, c + "/conv1"), p = o(l[1], c + "/prelu1_alpha"), v = t(l[1], l[2], 3, c + "/conv2"), g = o(l[2], c + "/prelu2_alpha"), y = t(l[2], l[3], f ? 2 : 3, c + "/conv3"), x = o(l[3], c + "/prelu3_alpha");
    return { conv1: d, prelu1_alpha: p, conv2: v, prelu2_alpha: g, conv3: y, prelu3_alpha: x };
  }
  function a() {
    var l = i([3, 10, 16, 32], "pnet"), c = t(32, 2, 1, "pnet/conv4_1"), f = t(32, 4, 1, "pnet/conv4_2");
    return At(At({}, l), { conv4_1: c, conv4_2: f });
  }
  function s() {
    var l = i([3, 28, 48, 64], "rnet", !0), c = r(576, 128, "rnet/fc1"), f = o(128, "rnet/prelu4_alpha"), d = r(128, 2, "rnet/fc2_1"), p = r(128, 4, "rnet/fc2_2");
    return At(At({}, l), { fc1: c, prelu4_alpha: f, fc2_1: d, fc2_2: p });
  }
  function u() {
    var l = i([3, 32, 64, 64], "onet"), c = t(64, 128, 2, "onet/conv4"), f = o(128, "onet/prelu4_alpha"), d = r(1152, 256, "onet/fc1"), p = o(256, "onet/prelu5_alpha"), v = r(256, 2, "onet/fc2_1"), g = r(256, 4, "onet/fc2_2"), y = r(256, 10, "onet/fc2_3");
    return At(At({}, l), { conv4: c, prelu4_alpha: f, fc1: d, prelu5_alpha: p, fc2_1: v, fc2_2: g, fc2_3: y });
  }
  return {
    extractPNetParams: a,
    extractRNetParams: s,
    extractONetParams: u
  };
}
function Jk(n) {
  var e = Cr(n), t = e.extractWeights, r = e.getRemainingWeights, o = [], i = Kk(t, o), a = i.extractPNetParams, s = i.extractRNetParams, u = i.extractONetParams, l = a(), c = s(), f = u();
  if (r().length !== 0)
    throw new Error("weights remaing after extract: " + r().length);
  return { params: { pnet: l, rnet: c, onet: f }, paramMappings: o };
}
function Xk(n, e) {
  var t = Qr(n, e);
  function r(c) {
    var f = t(c + "/weights", 4, c + "/filters"), d = t(c + "/bias", 1);
    return { filters: f, bias: d };
  }
  function o(c) {
    var f = t(c + "/weights", 2), d = t(c + "/bias", 1);
    return { weights: f, bias: d };
  }
  function i(c) {
    return t(c, 1);
  }
  function a(c) {
    var f = r(c + "/conv1"), d = i(c + "/prelu1_alpha"), p = r(c + "/conv2"), v = i(c + "/prelu2_alpha"), g = r(c + "/conv3"), y = i(c + "/prelu3_alpha");
    return { conv1: f, prelu1_alpha: d, conv2: p, prelu2_alpha: v, conv3: g, prelu3_alpha: y };
  }
  function s() {
    var c = a("pnet"), f = r("pnet/conv4_1"), d = r("pnet/conv4_2");
    return At(At({}, c), { conv4_1: f, conv4_2: d });
  }
  function u() {
    var c = a("rnet"), f = o("rnet/fc1"), d = i("rnet/prelu4_alpha"), p = o("rnet/fc2_1"), v = o("rnet/fc2_2");
    return At(At({}, c), { fc1: f, prelu4_alpha: d, fc2_1: p, fc2_2: v });
  }
  function l() {
    var c = a("onet"), f = r("onet/conv4"), d = i("onet/prelu4_alpha"), p = o("onet/fc1"), v = i("onet/prelu5_alpha"), g = o("onet/fc2_1"), y = o("onet/fc2_2"), x = o("onet/fc2_3");
    return At(At({}, c), { conv4: f, prelu4_alpha: d, fc1: p, prelu5_alpha: v, fc2_1: g, fc2_2: y, fc2_3: x });
  }
  return {
    extractPNetParams: s,
    extractRNetParams: u,
    extractONetParams: l
  };
}
function Yk(n) {
  var e = [], t = Xk(n, e), r = t.extractPNetParams, o = t.extractRNetParams, i = t.extractONetParams, a = r(), s = o(), u = i();
  return Er(n, e), { params: { pnet: a, rnet: s, onet: u }, paramMappings: e };
}
function uc(n, e) {
  var t = e[0], r = e[1];
  return {
    height: Math.floor(t * n),
    width: Math.floor(r * n)
  };
}
function Qk(n, e, t) {
  for (var r = t[0], o = t[1], i = _s / n, a = [], s = Math.min(r, o) * i, u = 0; s >= 12; )
    a.push(i * Math.pow(e, u)), s = s * e, u += 1;
  return a;
}
var ud = (
  /** @class */
  function(n) {
    de(e, n);
    function e(t, r, o, i) {
      return n.call(this, { left: t, top: r, right: o, bottom: i }, !0) || this;
    }
    return e;
  }($r)
);
function Ty(n) {
  return X(function() {
    return Nt(vt(n, K(127.5)), K(78125e-7));
  });
}
function Zo(n, e) {
  return X(function() {
    return ge(Xe(n), Nt(e, ps(Xe(ps(n)))));
  });
}
function ld(n, e, t) {
  return t === void 0 && (t = !1), X(function() {
    var r = Tn(n, e.conv1, "valid");
    return r = Zo(r, e.prelu1_alpha), r = wt(r, t ? [2, 2] : [3, 3], [2, 2], "same"), r = Tn(r, e.conv2, "valid"), r = Zo(r, e.prelu2_alpha), r = t ? r : wt(r, [3, 3], [2, 2], "valid"), r = Tn(r, e.conv3, "valid"), r = Zo(r, e.prelu3_alpha), r;
  });
}
function Zk(n, e) {
  return X(function() {
    var t = ld(n, e, !0), r = Tn(t, e.conv4_1, "valid"), o = pn(lu(r, 3), 3), i = wr(vt(r, o), 3), a = Tn(t, e.conv4_2, "valid");
    return { prob: i, regions: a };
  });
}
function jk(n, e) {
  return X(function() {
    var t = uc(e, n.shape.slice(1)), r = t.height, o = t.width, i = Vf.resizeBilinear(n, [r, o]), a = Ty(i);
    return Hr(a, [0, 2, 1, 3]);
  });
}
function eP(n, e, t, r) {
  for (var o = [], i = n.arraySync(), a = 0; a < n.shape[0]; a++)
    for (var s = 0; s < n.shape[1]; s++)
      i[a][s] >= r && o.push(new Pe(s, a));
  var u = o.map(function(l) {
    var c = new hu(Math.round((l.y * La + 1) / t), Math.round((l.x * La + 1) / t), Math.round((l.y * La + _s) / t), Math.round((l.x * La + _s) / t)), f = i[l.y][l.x], d = e.arraySync(), p = new ud(d[l.y][l.x][0], d[l.y][l.x][1], d[l.y][l.x][2], d[l.y][l.x][3]);
    return {
      cell: c,
      score: f,
      region: p
    };
  });
  return u;
}
function tP(n, e, t, r, o) {
  o.stage1 = [];
  var i = e.map(function(d) {
    return X(function() {
      var p = { scale: d }, v = jk(n, d), g = Date.now(), y = Zk(v, r), x = y.prob, w = y.regions;
      p.pnet = Date.now() - g;
      var b = pt(pt(x, 3)[1])[0], _ = pt(w)[0];
      return {
        scoresTensor: b,
        regionsTensor: _,
        scale: d,
        statsForScale: p
      };
    });
  }), a = i.map(function(d) {
    var p = d.scoresTensor, v = d.regionsTensor, g = d.scale, y = d.statsForScale, x = eP(p, v, g, t);
    if (p.dispose(), v.dispose(), !x.length)
      return o.stage1.push(y), [];
    var w = Date.now(), b = ra(x.map(function(_) {
      return _.cell;
    }), x.map(function(_) {
      return _.score;
    }), 0.5);
    return y.nms = Date.now() - w, y.numBoxes = b.length, o.stage1.push(y), b.map(function(_) {
      return x[_];
    });
  }), s = a.reduce(function(d, p) {
    return d.concat(p);
  }, []), u = [], l = [];
  if (s.length > 0) {
    var c = Date.now(), f = ra(s.map(function(d) {
      return d.cell;
    }), s.map(function(d) {
      return d.score;
    }), 0.7);
    o.stage1_nms = Date.now() - c, l = f.map(function(d) {
      return s[d].score;
    }), u = f.map(function(d) {
      return s[d];
    }).map(function(d) {
      var p = d.cell, v = d.region;
      return new hu(p.left + v.left * p.width, p.top + v.top * p.height, p.right + v.right * p.width, p.bottom + v.bottom * p.height).toSquare().round();
    });
  }
  return {
    boxes: u,
    scores: l
  };
}
function Iy(n, e, t) {
  var r = t.width, o = t.height;
  return re(this, void 0, void 0, function() {
    var i, a, s, u = this;
    return oe(this, function(l) {
      switch (l.label) {
        case 0:
          return i = vo(n), [4, Promise.all(e.map(function(c) {
            return re(u, void 0, void 0, function() {
              var f, d, p, v, g, y, x, w;
              return oe(this, function(b) {
                return f = c.padAtBorders(n.height, n.width), d = f.y, p = f.ey, v = f.x, g = f.ex, y = v - 1, x = d - 1, w = i.getImageData(y, x, g - y, p - x), [2, Dt.isNodejs() ? Qf(w) : createImageBitmap(w)];
              });
            });
          }))];
        case 1:
          return a = l.sent(), s = [], a.forEach(function(c) {
            var f = pu({ width: r, height: o }), d = vo(f);
            d.drawImage(c, 0, 0, r, o);
            for (var p = d.getImageData(0, 0, r, o).data, v = [], g = 0; g < p.length; g += 4)
              v.push(p[g + 2]), v.push(p[g + 1]), v.push(p[g]);
            s.push(v);
          }), [2, s.map(function(c) {
            var f = X(function() {
              var d = Hr(Vt(c, [1, r, o, 3]), [0, 2, 1, 3]).toFloat();
              return Ty(d);
            });
            return f;
          })];
      }
    });
  });
}
function nP(n, e) {
  return X(function() {
    var t = ld(n, e), r = Cn(t, [t.shape[0], e.fc1.weights.shape[0]]), o = qn(r, e.fc1), i = Zo(o, e.prelu4_alpha), a = qn(i, e.fc2_1), s = pn(lu(a, 1), 1), u = wr(vt(a, s), 1), l = qn(i, e.fc2_2), c = pt(u, 1)[1];
    return { scores: c, regions: l };
  });
}
function rP(n, e, t, r, o) {
  return re(this, void 0, void 0, function() {
    var i, a, s, u, l, c, f, d, p, v, g, y, x, w;
    return oe(this, function(b) {
      switch (b.label) {
        case 0:
          return i = Date.now(), [4, Iy(n, e, { width: 24, height: 24 })];
        case 1:
          return a = b.sent(), o.stage2_extractImagePatches = Date.now() - i, i = Date.now(), s = a.map(function(_) {
            var E = nP(_, r);
            return _.dispose(), E;
          }), o.stage2_rnet = Date.now() - i, u = s.length > 1 ? ht(s.map(function(_) {
            return _.scores;
          })) : s[0].scores, f = (c = Array).from, [4, u.data()];
        case 2:
          return l = f.apply(c, [b.sent()]), u.dispose(), d = l.map(function(_, E) {
            return { score: _, idx: E };
          }).filter(function(_) {
            return _.score > t;
          }).map(function(_) {
            var E = _.idx;
            return E;
          }), p = d.map(function(_) {
            return e[_];
          }), v = d.map(function(_) {
            return l[_];
          }), g = [], y = [], p.length > 0 && (i = Date.now(), x = ra(p, v, 0.7), o.stage2_nms = Date.now() - i, w = x.map(function(_) {
            var E = s[d[_]].regions.arraySync();
            return new ud(E[0][0], E[0][1], E[0][2], E[0][3]);
          }), y = x.map(function(_) {
            return v[_];
          }), g = x.map(function(_, E) {
            return p[_].calibrate(w[E]);
          })), s.forEach(function(_) {
            _.regions.dispose(), _.scores.dispose();
          }), [2, {
            boxes: g,
            scores: y
          }];
      }
    });
  });
}
function oP(n, e) {
  return X(function() {
    var t = ld(n, e);
    t = wt(t, [2, 2], [2, 2], "same"), t = Tn(t, e.conv4, "valid"), t = Zo(t, e.prelu4_alpha);
    var r = Cn(t, [t.shape[0], e.fc1.weights.shape[0]]), o = qn(r, e.fc1), i = Zo(o, e.prelu5_alpha), a = qn(i, e.fc2_1), s = pn(lu(a, 1), 1), u = wr(vt(a, s), 1), l = qn(i, e.fc2_2), c = qn(i, e.fc2_3), f = pt(u, 1)[1];
    return { scores: f, regions: l, points: c };
  });
}
function iP(n, e, t, r, o) {
  return re(this, void 0, void 0, function() {
    var i, a, s, u, l, c, f, d, p, v, g, y, x, w, b;
    return oe(this, function(_) {
      switch (_.label) {
        case 0:
          return i = Date.now(), [4, Iy(n, e, { width: 48, height: 48 })];
        case 1:
          return a = _.sent(), o.stage3_extractImagePatches = Date.now() - i, i = Date.now(), s = a.map(function(E) {
            var C = oP(E, r);
            return E.dispose(), C;
          }), o.stage3_onet = Date.now() - i, u = s.length > 1 ? ht(s.map(function(E) {
            return E.scores;
          })) : s[0].scores, f = (c = Array).from, [4, u.data()];
        case 2:
          return l = f.apply(c, [_.sent()]), u.dispose(), d = l.map(function(E, C) {
            return { score: E, idx: C };
          }).filter(function(E) {
            return E.score > t;
          }).map(function(E) {
            var C = E.idx;
            return C;
          }), p = d.map(function(E) {
            var C = s[E].regions.arraySync();
            return new ud(C[0][0], C[0][1], C[0][2], C[0][3]);
          }), v = d.map(function(E, C) {
            return e[E].calibrate(p[C]);
          }), g = d.map(function(E) {
            return l[E];
          }), y = [], x = [], w = [], v.length > 0 && (i = Date.now(), b = ra(v, g, 0.7, !1), o.stage3_nms = Date.now() - i, y = b.map(function(E) {
            return v[E];
          }), x = b.map(function(E) {
            return g[E];
          }), w = b.map(function(E, C) {
            return Array(5).fill(0).map(function(A, R) {
              var I = s[E].points.arraySync();
              return new Pe(I[0][R] * (y[C].width + 1) + y[C].left, I[0][R + 5] * (y[C].height + 1) + y[C].top);
            });
          })), s.forEach(function(E) {
            E.regions.dispose(), E.scores.dispose(), E.points.dispose();
          }), [2, {
            boxes: y,
            scores: x,
            points: w
          }];
      }
    });
  });
}
var aP = (
  /** @class */
  function(n) {
    de(e, n);
    function e() {
      return n.call(this, "Mtcnn") || this;
    }
    return e.prototype.load = function(t) {
      return re(this, void 0, void 0, function() {
        return oe(this, function(r) {
          return console.warn("mtcnn is deprecated and will be removed soon"), [2, n.prototype.load.call(this, t)];
        });
      });
    }, e.prototype.loadFromDisk = function(t) {
      return re(this, void 0, void 0, function() {
        return oe(this, function(r) {
          return console.warn("mtcnn is deprecated and will be removed soon"), [2, n.prototype.loadFromDisk.call(this, t)];
        });
      });
    }, e.prototype.forwardInput = function(t, r) {
      return r === void 0 && (r = {}), re(this, void 0, void 0, function() {
        var o, i, a, s, u, l, c, f, d, p, v, g, y, x, w, b, _, E, C, A, R;
        return oe(this, function(I) {
          switch (I.label) {
            case 0:
              if (o = this.params, !o)
                throw new Error("Mtcnn - load model before inference");
              if (i = t.canvases[0], !i)
                throw new Error("Mtcnn - inputCanvas is not defined, note that passing tensors into Mtcnn.forwardInput is not supported yet.");
              return a = {}, s = Date.now(), u = X(function() {
                return zk(pn(zf.fromPixels(i)).toFloat());
              }), l = function(S) {
                return u.dispose(), a.total = Date.now() - s, S;
              }, c = u.shape.slice(1), f = c[0], d = c[1], p = new _y(r), v = p.minFaceSize, g = p.scaleFactor, y = p.maxNumScales, x = p.scoreThresholds, w = p.scaleSteps, b = (w || Qk(v, g, [f, d])).filter(function(S) {
                var M = uc(S, [f, d]);
                return Math.min(M.width, M.height) > _s;
              }).slice(0, y), a.scales = b, a.pyramid = b.map(function(S) {
                return uc(S, [f, d]);
              }), _ = Date.now(), [4, tP(u, b, x[0], o.pnet, a)];
            case 1:
              return E = I.sent(), a.total_stage1 = Date.now() - _, E.boxes.length ? (a.stage2_numInputBoxes = E.boxes.length, _ = Date.now(), [4, rP(i, E.boxes, x[1], o.rnet, a)]) : [2, l({ results: [], stats: a })];
            case 2:
              return C = I.sent(), a.total_stage2 = Date.now() - _, C.boxes.length ? (a.stage3_numInputBoxes = C.boxes.length, _ = Date.now(), [4, iP(i, C.boxes, x[2], o.onet, a)]) : [2, l({ results: [], stats: a })];
            case 3:
              return A = I.sent(), a.total_stage3 = Date.now() - _, R = A.boxes.map(function(S, M) {
                return rd(Xf({}, new nr(A.scores[M], new Jf(S.left / d, S.top / f, S.width / d, S.height / f), {
                  height: f,
                  width: d
                })), new LR(A.points[M].map(function(P) {
                  return P.sub(new Pe(S.left, S.top)).div(new Pe(S.width, S.height));
                }), { width: S.width, height: S.height }));
              }), [2, l({ results: R, stats: a })];
          }
        });
      });
    }, e.prototype.forward = function(t, r) {
      return r === void 0 && (r = {}), re(this, void 0, void 0, function() {
        var o;
        return oe(this, function(i) {
          switch (i.label) {
            case 0:
              return o = this.forwardInput, [4, bt(t)];
            case 1:
              return [4, o.apply(this, [
                i.sent(),
                r
              ])];
            case 2:
              return [2, i.sent().results];
          }
        });
      });
    }, e.prototype.forwardWithStats = function(t, r) {
      return r === void 0 && (r = {}), re(this, void 0, void 0, function() {
        var o;
        return oe(this, function(i) {
          switch (i.label) {
            case 0:
              return o = this.forwardInput, [4, bt(t)];
            case 1:
              return [2, o.apply(this, [
                i.sent(),
                r
              ])];
          }
        });
      });
    }, e.prototype.getDefaultModelName = function() {
      return "mtcnn_model";
    }, e.prototype.extractParamsFromWeigthMap = function(t) {
      return Yk(t);
    }, e.prototype.extractParams = function(t) {
      return Jk(t);
    }, e;
  }(br)
), sP = 0.4, uP = [
  new Pe(1.603231, 2.094468),
  new Pe(6.041143, 7.080126),
  new Pe(2.882459, 3.518061),
  new Pe(4.266906, 5.178857),
  new Pe(9.041765, 10.66308)
], lP = [117.001, 114.697, 97.404], cP = (
  /** @class */
  function(n) {
    de(e, n);
    function e() {
      var t = this, r = {
        withSeparableConvs: !0,
        iouThreshold: sP,
        classes: ["face"],
        anchors: uP,
        meanRgb: lP,
        isFirstLayerConv2d: !0,
        filterSizes: [3, 16, 32, 64, 128, 256, 512]
      };
      return t = n.call(this, r) || this, t;
    }
    return Object.defineProperty(e.prototype, "anchors", {
      get: function() {
        return this.config.anchors;
      },
      enumerable: !0,
      configurable: !0
    }), e.prototype.locateFaces = function(t, r) {
      return re(this, void 0, void 0, function() {
        var o;
        return oe(this, function(i) {
          switch (i.label) {
            case 0:
              return [4, this.detect(t, r)];
            case 1:
              return o = i.sent(), [2, o.map(function(a) {
                return new nr(a.score, a.relativeBox, { width: a.imageWidth, height: a.imageHeight });
              })];
          }
        });
      });
    }, e.prototype.getDefaultModelName = function() {
      return "tiny_face_detector_model";
    }, e.prototype.extractParamsFromWeigthMap = function(t) {
      return n.prototype.extractParamsFromWeigthMap.call(this, t);
    }, e;
  }(Ey)
), Mt = {
  ssdMobilenetv1: new by(),
  tinyFaceDetector: new cP(),
  tinyYolov2: new qk(),
  mtcnn: new aP(),
  faceLandmark68Net: new my(),
  faceLandmark68TinyNet: new dk(),
  faceRecognitionNet: new xk(),
  faceExpressionNet: new ZR(),
  ageGenderNet: new uk()
}, Sy = (
  /** @class */
  function(n) {
    de(e, n);
    function e(t, r, o) {
      var i = n.call(this) || this;
      return i.parentTask = t, i.input = r, i.extractedFaces = o, i;
    }
    return e;
  }(ga)
), cd = (
  /** @class */
  function(n) {
    de(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.run = function() {
      return re(this, void 0, void 0, function() {
        var t, r, o = this;
        return oe(this, function(i) {
          switch (i.label) {
            case 0:
              return [4, this.parentTask];
            case 1:
              return t = i.sent(), [4, gu(t, this.input, function(a) {
                return re(o, void 0, void 0, function() {
                  return oe(this, function(s) {
                    switch (s.label) {
                      case 0:
                        return [4, Promise.all(a.map(function(u) {
                          return Mt.faceExpressionNet.predictExpressions(u);
                        }))];
                      case 1:
                        return [2, s.sent()];
                    }
                  });
                });
              }, this.extractedFaces)];
            case 2:
              return r = i.sent(), [2, t.map(function(a, s) {
                return dy(a, r[s]);
              })];
          }
        });
      });
    }, e.prototype.withAgeAndGender = function() {
      return new pd(this, this.input);
    }, e;
  }(Sy)
), fd = (
  /** @class */
  function(n) {
    de(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.run = function() {
      return re(this, void 0, void 0, function() {
        var t, r;
        return oe(this, function(o) {
          switch (o.label) {
            case 0:
              return [4, this.parentTask];
            case 1:
              return t = o.sent(), t ? [4, sd(t, this.input, function(i) {
                return Mt.faceExpressionNet.predictExpressions(i);
              }, this.extractedFaces)] : [
                2
                /*return*/
              ];
            case 2:
              return r = o.sent(), [2, dy(t, r)];
          }
        });
      });
    }, e.prototype.withAgeAndGender = function() {
      return new md(this, this.input);
    }, e;
  }(Sy)
), dd = (
  /** @class */
  function(n) {
    de(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.withAgeAndGender = function() {
      return new vd(this, this.input);
    }, e.prototype.withFaceDescriptors = function() {
      return new yd(this, this.input);
    }, e;
  }(cd)
), hd = (
  /** @class */
  function(n) {
    de(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.withAgeAndGender = function() {
      return new gd(this, this.input);
    }, e.prototype.withFaceDescriptor = function() {
      return new xd(this, this.input);
    }, e;
  }(fd)
), Ay = (
  /** @class */
  function(n) {
    de(e, n);
    function e(t, r, o) {
      var i = n.call(this) || this;
      return i.parentTask = t, i.input = r, i.extractedFaces = o, i;
    }
    return e;
  }(ga)
), pd = (
  /** @class */
  function(n) {
    de(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.run = function() {
      return re(this, void 0, void 0, function() {
        var t, r, o = this;
        return oe(this, function(i) {
          switch (i.label) {
            case 0:
              return [4, this.parentTask];
            case 1:
              return t = i.sent(), [4, gu(t, this.input, function(a) {
                return re(o, void 0, void 0, function() {
                  return oe(this, function(s) {
                    switch (s.label) {
                      case 0:
                        return [4, Promise.all(a.map(function(u) {
                          return Mt.ageGenderNet.predictAgeAndGender(u);
                        }))];
                      case 1:
                        return [2, s.sent()];
                    }
                  });
                });
              }, this.extractedFaces)];
            case 2:
              return r = i.sent(), [2, t.map(function(a, s) {
                var u = r[s], l = u.age, c = u.gender, f = u.genderProbability;
                return xy(wy(a, c, f), l);
              })];
          }
        });
      });
    }, e.prototype.withFaceExpressions = function() {
      return new cd(this, this.input);
    }, e;
  }(Ay)
), md = (
  /** @class */
  function(n) {
    de(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.run = function() {
      return re(this, void 0, void 0, function() {
        var t, r, o, i, a;
        return oe(this, function(s) {
          switch (s.label) {
            case 0:
              return [4, this.parentTask];
            case 1:
              return t = s.sent(), t ? [4, sd(t, this.input, function(u) {
                return Mt.ageGenderNet.predictAgeAndGender(u);
              }, this.extractedFaces)] : [
                2
                /*return*/
              ];
            case 2:
              return r = s.sent(), o = r.age, i = r.gender, a = r.genderProbability, [2, xy(wy(t, i, a), o)];
          }
        });
      });
    }, e.prototype.withFaceExpressions = function() {
      return new fd(this, this.input);
    }, e;
  }(Ay)
), vd = (
  /** @class */
  function(n) {
    de(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.withFaceExpressions = function() {
      return new dd(this, this.input);
    }, e.prototype.withFaceDescriptors = function() {
      return new yd(this, this.input);
    }, e;
  }(pd)
), gd = (
  /** @class */
  function(n) {
    de(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.withFaceExpressions = function() {
      return new hd(this, this.input);
    }, e.prototype.withFaceDescriptor = function() {
      return new xd(this, this.input);
    }, e;
  }(md)
), Ry = (
  /** @class */
  function(n) {
    de(e, n);
    function e(t, r) {
      var o = n.call(this) || this;
      return o.parentTask = t, o.input = r, o;
    }
    return e;
  }(ga)
), yd = (
  /** @class */
  function(n) {
    de(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.run = function() {
      return re(this, void 0, void 0, function() {
        var t, r;
        return oe(this, function(o) {
          switch (o.label) {
            case 0:
              return [4, this.parentTask];
            case 1:
              return t = o.sent(), [4, gu(t, this.input, function(i) {
                return Promise.all(i.map(function(a) {
                  return Mt.faceRecognitionNet.computeFaceDescriptor(a);
                }));
              }, null, function(i) {
                return i.landmarks.align(null, { useDlibAlignment: !0 });
              })];
            case 2:
              return r = o.sent(), [2, r.map(function(i, a) {
                return yy(t[a], i);
              })];
          }
        });
      });
    }, e.prototype.withFaceExpressions = function() {
      return new dd(this, this.input);
    }, e.prototype.withAgeAndGender = function() {
      return new vd(this, this.input);
    }, e;
  }(Ry)
), xd = (
  /** @class */
  function(n) {
    de(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.run = function() {
      return re(this, void 0, void 0, function() {
        var t, r;
        return oe(this, function(o) {
          switch (o.label) {
            case 0:
              return [4, this.parentTask];
            case 1:
              return t = o.sent(), t ? [4, sd(t, this.input, function(i) {
                return Mt.faceRecognitionNet.computeFaceDescriptor(i);
              }, null, function(i) {
                return i.landmarks.align(null, { useDlibAlignment: !0 });
              })] : [
                2
                /*return*/
              ];
            case 2:
              return r = o.sent(), [2, yy(t, r)];
          }
        });
      });
    }, e.prototype.withFaceExpressions = function() {
      return new hd(this, this.input);
    }, e.prototype.withAgeAndGender = function() {
      return new gd(this, this.input);
    }, e;
  }(Ry)
), ky = (
  /** @class */
  function(n) {
    de(e, n);
    function e(t, r, o) {
      var i = n.call(this) || this;
      return i.parentTask = t, i.input = r, i.useTinyLandmarkNet = o, i;
    }
    return Object.defineProperty(e.prototype, "landmarkNet", {
      get: function() {
        return this.useTinyLandmarkNet ? Mt.faceLandmark68TinyNet : Mt.faceLandmark68Net;
      },
      enumerable: !0,
      configurable: !0
    }), e;
  }(ga)
), fP = (
  /** @class */
  function(n) {
    de(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.run = function() {
      return re(this, void 0, void 0, function() {
        var t, r, o, i, a, s = this;
        return oe(this, function(u) {
          switch (u.label) {
            case 0:
              return [4, this.parentTask];
            case 1:
              return t = u.sent(), r = t.map(function(l) {
                return l.detection;
              }), this.input instanceof Je ? [4, jf(this.input, r)] : [3, 3];
            case 2:
              return i = u.sent(), [3, 5];
            case 3:
              return [4, Zf(this.input, r)];
            case 4:
              i = u.sent(), u.label = 5;
            case 5:
              return o = i, [4, Promise.all(o.map(function(l) {
                return s.landmarkNet.detectLandmarks(l);
              }))];
            case 6:
              return a = u.sent(), o.forEach(function(l) {
                return l instanceof Je && l.dispose();
              }), [2, t.map(function(l, c) {
                return rd(l, a[c]);
              })];
          }
        });
      });
    }, e.prototype.withFaceExpressions = function() {
      return new dd(this, this.input);
    }, e.prototype.withAgeAndGender = function() {
      return new vd(this, this.input);
    }, e.prototype.withFaceDescriptors = function() {
      return new yd(this, this.input);
    }, e;
  }(ky)
), dP = (
  /** @class */
  function(n) {
    de(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.run = function() {
      return re(this, void 0, void 0, function() {
        var t, r, o, i, a;
        return oe(this, function(s) {
          switch (s.label) {
            case 0:
              return [4, this.parentTask];
            case 1:
              return t = s.sent(), t ? (r = t.detection, this.input instanceof Je ? [4, jf(this.input, [r])] : [3, 3]) : [
                2
                /*return*/
              ];
            case 2:
              return i = s.sent(), [3, 5];
            case 3:
              return [4, Zf(this.input, [r])];
            case 4:
              i = s.sent(), s.label = 5;
            case 5:
              return o = i, [4, this.landmarkNet.detectLandmarks(o[0])];
            case 6:
              return a = s.sent(), o.forEach(function(u) {
                return u instanceof Je && u.dispose();
              }), [2, rd(t, a)];
          }
        });
      });
    }, e.prototype.withFaceExpressions = function() {
      return new hd(this, this.input);
    }, e.prototype.withAgeAndGender = function() {
      return new gd(this, this.input);
    }, e.prototype.withFaceDescriptor = function() {
      return new xd(this, this.input);
    }, e;
  }(ky)
), Py = (
  /** @class */
  function(n) {
    de(e, n);
    function e(t, r) {
      r === void 0 && (r = new vu());
      var o = n.call(this) || this;
      return o.input = t, o.options = r, o;
    }
    return e;
  }(ga)
), Ny = (
  /** @class */
  function(n) {
    de(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.run = function() {
      return re(this, void 0, void 0, function() {
        var t, r, o, i;
        return oe(this, function(a) {
          switch (a.label) {
            case 0:
              return t = this, r = t.input, o = t.options, o instanceof _y ? [4, Mt.mtcnn.forward(r, o)] : [3, 2];
            case 1:
              return [2, a.sent().map(function(s) {
                return s.detection;
              })];
            case 2:
              if (i = o instanceof Cy ? function(s) {
                return Mt.tinyFaceDetector.locateFaces(s, o);
              } : o instanceof vu ? function(s) {
                return Mt.ssdMobilenetv1.locateFaces(s, o);
              } : o instanceof ad ? function(s) {
                return Mt.tinyYolov2.locateFaces(s, o);
              } : null, !i)
                throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | MtcnnOptions | TinyYolov2Options");
              return [2, i(r)];
          }
        });
      });
    }, e.prototype.runAndExtendWithFaceDetections = function() {
      var t = this;
      return new Promise(function(r) {
        return re(t, void 0, void 0, function() {
          var o;
          return oe(this, function(i) {
            switch (i.label) {
              case 0:
                return [4, this.run()];
              case 1:
                return o = i.sent(), [2, r(o.map(function(a) {
                  return Xf({}, a);
                }))];
            }
          });
        });
      });
    }, e.prototype.withFaceLandmarks = function(t) {
      return t === void 0 && (t = !1), new fP(this.runAndExtendWithFaceDetections(), this.input, t);
    }, e.prototype.withFaceExpressions = function() {
      return new cd(this.runAndExtendWithFaceDetections(), this.input);
    }, e.prototype.withAgeAndGender = function() {
      return new pd(this.runAndExtendWithFaceDetections(), this.input);
    }, e;
  }(Py)
);
(function(n) {
  de(e, n);
  function e() {
    return n !== null && n.apply(this, arguments) || this;
  }
  return e.prototype.run = function() {
    return re(this, void 0, void 0, function() {
      var t, r;
      return oe(this, function(o) {
        switch (o.label) {
          case 0:
            return [4, new Ny(this.input, this.options)];
          case 1:
            return t = o.sent(), r = t[0], t.forEach(function(i) {
              i.score > r.score && (r = i);
            }), [2, r];
        }
      });
    });
  }, e.prototype.runAndExtendWithFaceDetection = function() {
    var t = this;
    return new Promise(function(r) {
      return re(t, void 0, void 0, function() {
        var o;
        return oe(this, function(i) {
          switch (i.label) {
            case 0:
              return [4, this.run()];
            case 1:
              return o = i.sent(), [2, r(o ? Xf({}, o) : void 0)];
          }
        });
      });
    });
  }, e.prototype.withFaceLandmarks = function(t) {
    return t === void 0 && (t = !1), new dP(this.runAndExtendWithFaceDetection(), this.input, t);
  }, e.prototype.withFaceExpressions = function() {
    return new fd(this.runAndExtendWithFaceDetection(), this.input);
  }, e.prototype.withAgeAndGender = function() {
    return new md(this.runAndExtendWithFaceDetection(), this.input);
  }, e;
})(Py);
function hP(n, e) {
  return e === void 0 && (e = new vu()), new Ny(n, e);
}
function pP(n, e) {
  if (n.length !== e.length)
    throw new Error("euclideanDistance: arr1.length !== arr2.length");
  var t = Array.from(n), r = Array.from(e);
  return Math.sqrt(t.map(function(o, i) {
    return o - r[i];
  }).reduce(function(o, i) {
    return o + Math.pow(i, 2);
  }, 0));
}
(function() {
  function n(e, t) {
    t === void 0 && (t = 0.6), this._distanceThreshold = t;
    var r = Array.isArray(e) ? e : [e];
    if (!r.length)
      throw new Error("FaceRecognizer.constructor - expected atleast one input");
    var o = 1, i = function() {
      return "person " + o++;
    };
    this._labeledDescriptors = r.map(function(a) {
      if (a instanceof Na)
        return a;
      if (a instanceof Float32Array)
        return new Na(i(), [a]);
      if (a.descriptor && a.descriptor instanceof Float32Array)
        return new Na(i(), [a.descriptor]);
      throw new Error("FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>");
    });
  }
  return Object.defineProperty(n.prototype, "labeledDescriptors", {
    get: function() {
      return this._labeledDescriptors;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(n.prototype, "distanceThreshold", {
    get: function() {
      return this._distanceThreshold;
    },
    enumerable: !0,
    configurable: !0
  }), n.prototype.computeMeanDistance = function(e, t) {
    return t.map(function(r) {
      return pP(r, e);
    }).reduce(function(r, o) {
      return r + o;
    }, 0) / (t.length || 1);
  }, n.prototype.matchDescriptor = function(e) {
    var t = this;
    return this.labeledDescriptors.map(function(r) {
      var o = r.descriptors, i = r.label;
      return new Hm(i, t.computeMeanDistance(e, o));
    }).reduce(function(r, o) {
      return r.distance < o.distance ? r : o;
    });
  }, n.prototype.findBestMatch = function(e) {
    var t = this.matchDescriptor(e);
    return t.distance < this.distanceThreshold ? t : new Hm("unknown", t.distance);
  }, n.prototype.toJSON = function() {
    return {
      distanceThreshold: this.distanceThreshold,
      labeledDescriptors: this.labeledDescriptors.map(function(e) {
        return e.toJSON();
      })
    };
  }, n.fromJSON = function(e) {
    var t = e.labeledDescriptors.map(function(r) {
      return Na.fromJSON(r);
    });
    return new n(t, e.distanceThreshold);
  }, n;
})();
class mP {
  constructor() {
    this.cam = null, this.faceApiLoaded = !1, this.faceRecognitionReady = !1, this.currentFaces = [], this.hasExpressionModel = !1, this.hasAgeGenderModel = !1, this.ageHistory = [], this.AGE_SMOOTHING_WINDOW_MS = 3e3, this.tinyFaceDetectorOptions = new Cy({
      inputSize: 512,
      // Higher resolution for better accuracy (320, 416, 512, 608)
      scoreThreshold: 0.5
      // Detection confidence threshold
    }), this.processedFacesArray = [], this.landmarkPositionsArray = [], this.expressionKeys = ["happy", "sad", "angry", "fearful", "disgusted", "surprised", "neutral"], this.sensitivity = 0.3, this.previousFaceData = null, this.MAX_CHANGE_THRESHOLD = 0.05, this.MIN_CHANGE_THRESHOLD = 2e-3, this.changeScoreHistory = [], this.CHANGE_SCORE_HISTORY_SIZE = 5;
  }
  async init(e) {
    if (!e) {
      console.log("CamFace error: must pass cam reference");
      return;
    }
    this.cam = e, await this.loadFaceApiModels();
  }
  async loadFaceApiModels() {
    var e, t, r, o, i, a;
    if (!this.faceApiLoaded)
      try {
        (e = this.cam) != null && e.verboseLogging && console.log("[FACE] Loading face-api.js models...");
        const s = [
          "/models/",
          // Local models (served from public/models/ by Vite)
          "https://cdn.jsdelivr.net/gh/justadudewhohacks/face-api.js/weights/",
          // GitHub-based CDN (works for all models)
          "https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/weights/",
          "https://unpkg.com/face-api.js@0.22.2/weights/"
        ], u = [
          { net: Mt.tinyFaceDetector, name: "tinyFaceDetector" },
          { net: Mt.faceLandmark68Net, name: "faceLandmark68Net" }
        ], l = [
          { net: Mt.faceExpressionNet, name: "faceExpressionNet", flag: "hasExpressionModel" },
          { net: Mt.ageGenderNet, name: "ageGenderNet", flag: "hasAgeGenderModel" }
        ];
        let c = !1;
        for (const d of s)
          try {
            await Promise.all(u.map((p) => p.net.loadFromUri(d))), (t = this.cam) != null && t.verboseLogging && console.log(`[FACE] Core models loaded from: ${d}`), c = !0;
            break;
          } catch {
            (r = this.cam) != null && r.verboseLogging && console.warn(`[FACE] Failed to load core models from ${d}, trying next...`);
            continue;
          }
        if (!c)
          throw new Error("Failed to load core models from all sources");
        this.faceApiLoaded = !0, this.faceRecognitionReady = !0;
        for (const d of s)
          for (const p of l)
            if (!this[p.flag])
              try {
                await p.net.loadFromUri(d), this[p.flag] = !0, (o = this.cam) != null && o.verboseLogging && console.log(`[FACE] ${p.name} loaded from: ${d}`);
              } catch {
              }
        const f = l.filter((d) => this[d.flag]).map((d) => d.name);
        (i = this.cam) != null && i.verboseLogging && (f.length > 0 ? console.log(`[FACE] Optional models loaded: ${f.join(", ")}`) : console.log("[FACE] Optional models (expressions, age/gender) not available"));
      } catch (s) {
        console.error("[FACE] Error loading face-api.js models:", s), (a = this.cam) != null && a.verboseLogging && (console.warn("[FACE] Face detection will be disabled. Models need to be downloaded."), console.warn("[FACE] Download models from: https://github.com/justadudewhohacks/face-api.js/tree/master/weights"), console.warn("[FACE] Place them in a /models/ directory or host on a CDN"));
      }
  }
  // Calculate smoothed age from history (per face index)
  getSmoothedAge(e, t, r) {
    if (t == null) return null;
    let o = this.ageHistory[e];
    o || (o = [], this.ageHistory[e] = o), o.push({ timestamp: r, age: t });
    const i = r - this.AGE_SMOOTHING_WINDOW_MS;
    let a = 0;
    const s = o.length;
    for (let c = 0; c < s; c++)
      if (o[c].timestamp >= i) {
        a = c;
        break;
      }
    if (a > 0) {
      const c = s - a;
      for (let f = 0; f < c; f++)
        o[f] = o[a + f];
      o.length = c;
    }
    const u = o.length;
    if (u === 0) return t;
    let l = 0;
    for (let c = 0; c < u; c++)
      l += o[c].age;
    return l / u;
  }
  // Process faces in current frame
  async processFaces() {
    const e = this.cam, t = e.video, r = e.canvas;
    if (!(!this.faceRecognitionReady || !t || !r))
      try {
        let o = hP(t, this.tinyFaceDetectorOptions).withFaceLandmarks();
        this.hasExpressionModel && (o = o.withFaceExpressions()), this.hasAgeGenderModel && (o = o.withAgeAndGender());
        const i = await o, a = this.processedFacesArray;
        a.length = 0;
        const s = this.expressionKeys, u = Date.now();
        for (let c = 0, f = i.length; c < f; c++) {
          const d = i[c], p = d.detection.box, v = d.landmarks, g = d.expressions;
          let y = null, x = null;
          if (g) {
            y = {
              happy: g.happy,
              sad: g.sad,
              angry: g.angry,
              fearful: g.fearful,
              disgusted: g.disgusted,
              surprised: g.surprised,
              neutral: g.neutral
            };
            let A = -1;
            for (let R = 0, I = s.length; R < I; R++) {
              const S = s[R], M = y[S];
              M > A && (A = M, x = S);
            }
          }
          const w = d.age || null, b = d.gender || null, _ = w !== null ? this.getSmoothedAge(c, w, u) : null, E = v.positions, C = this.landmarkPositionsArray;
          C.length = 0;
          for (let A = 0, R = E.length; A < R; A++) {
            const I = E[A];
            C.push({ x: I.x, y: I.y });
          }
          a.push({
            boundingBox: {
              x: p.x,
              y: p.y,
              width: p.width,
              height: p.height
            },
            landmarks: C.slice(),
            // Create copy for this face
            expressions: y,
            dominantExpression: x,
            age: _,
            gender: b
          });
        }
        const l = e.eventTarget;
        if (l) {
          if (this.previousFaceData !== null && a.length > 0) {
            const c = this.previousFaceData.length > 0 ? this.previousFaceData[0] : null, f = a[0];
            if (c && f) {
              const d = this.calculateFaceChange(c, f);
              this.changeScoreHistory.push(d), this.changeScoreHistory.length > this.CHANGE_SCORE_HISTORY_SIZE && this.changeScoreHistory.shift();
              let p = 0;
              for (let g = 0, y = this.changeScoreHistory.length; g < y; g++)
                p += this.changeScoreHistory[g];
              p /= this.changeScoreHistory.length;
              const v = this.getChangeThreshold();
              p >= v && l.dispatchEvent(new CustomEvent("facechanged", {
                detail: {
                  changeScore: p,
                  threshold: v,
                  previousFace: c,
                  currentFace: f
                }
              }));
            }
          }
          a.length > 0 ? this.previousFaceData = a.map((c) => ({
            boundingBox: {
              x: c.boundingBox.x,
              y: c.boundingBox.y,
              width: c.boundingBox.width,
              height: c.boundingBox.height
            },
            expressions: c.expressions ? { ...c.expressions } : null,
            dominantExpression: c.dominantExpression
          })) : this.previousFaceData = null;
        }
        this.currentFaces = a, a.length > 0 && l && l.dispatchEvent(new CustomEvent("facesDetected", {
          detail: { faces: a }
        }));
      } catch (o) {
        console.error("[FACE] Error processing faces:", o);
      }
  }
  getCurrentFaces() {
    return this.currentFaces;
  }
  // Set sensitivity (0.0 to 1.0)
  setSensitivity(e) {
    this.sensitivity = Math.max(0, Math.min(1, e));
  }
  // Calculate change score between two face states
  // Returns a value between 0 and 1+ (can exceed 1 for very large changes)
  calculateFaceChange(e, t) {
    if (!e || !t) return 1;
    let r = 0, o = 0;
    const i = 0.4, a = e.boundingBox, s = t.boundingBox, u = a.x + a.width * 0.5, l = a.y + a.height * 0.5, c = s.x + s.width * 0.5, f = s.y + s.height * 0.5, d = (a.width + a.height + s.width + s.height) * 0.25;
    if (d > 0) {
      const y = (c - u) / d, x = (f - l) / d, w = Math.sqrt(y * y + x * x);
      r += w * i;
    }
    const p = 0.2, v = a.width * a.height, g = s.width * s.height;
    if (v > 0) {
      const y = g / v, x = Math.abs(Math.log(y));
      r += x * p;
    }
    if (o += i + p, e.expressions && t.expressions && this.hasExpressionModel) {
      let x = 0;
      for (let w = 0, b = this.expressionKeys.length; w < b; w++) {
        const _ = this.expressionKeys[w], E = e.expressions[_] || 0, C = t.expressions[_] || 0;
        x += Math.abs(C - E);
      }
      x /= this.expressionKeys.length, r += x * 0.4, o += 0.4;
    }
    return o > 0 && (r /= o), r;
  }
  // Get current change threshold based on sensitivity
  getChangeThreshold() {
    return this.MAX_CHANGE_THRESHOLD - this.sensitivity * (this.MAX_CHANGE_THRESHOLD - this.MIN_CHANGE_THRESHOLD);
  }
  disconnect() {
    this.faceApiLoaded = !1, this.faceRecognitionReady = !1, this.currentFaces = [], this.processedFacesArray.length = 0, this.landmarkPositionsArray.length = 0, this.ageHistory = [], this.previousFaceData = null, this.changeScoreHistory = [];
  }
}
class VN {
  constructor() {
    this.client = null, this.session = null, this.video = null, this.mediaStream = null, this.canvas = null, this.ctx = null, this.faceProcessingInterval = null, this.isRecording = !1, this.setupComplete = !1, this.accumulatedTextParts = [], this.currentTurnActive = !1, this.eventTarget = new EventTarget(), this.face = null, this.skeletal = null, this.framesPerTurn = 1, this.frameCount = 0, this.pendingFrames = [], this.model = "gemini-live-2.5-flash-preview", this.cooldownMs = 2e3, this.lastFrameSendTime = 0, this.verboseLogging = !1, this.pendingApiKey = null, this.pendingHttpOptions = null, this.regexPatterns = {
      jsonExtract: /\{[\s\S]*\}/,
      transcript: /Transcript:\s*(.+?)(?:\n|Analysis:|Emoji:|$)/is,
      analysis: /Analysis:\s*(.+?)(?:\n\s*Emoji:|$)/is,
      tone: /Tone:\s*(.+?)(?:\n\s*Emoji:|$)/is,
      emoji: /Emoji:\s*([^\s\n]+)/i,
      emojiFallback: /[\u{1F300}-\u{1F9FF}\u{1F600}-\u{1F64F}\u{1F680}-\u{1F6FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}\u{1F1E0}-\u{1F1FF}\u{1F900}-\u{1F9FF}\u{1FA00}-\u{1FA6F}\u{1FA70}-\u{1FAFF}]/u,
      transcriptRemove: /Transcript:.*?(?=Analysis:|Emoji:|$)/is,
      toneRemove: /Transcript:.*?(?=Tone:|Emoji:|$)/is,
      emojiRemove: /Emoji:\s*.*/i
    }, this.reusablePartsArray = [];
  }
  async init(e) {
    const { apiKey: t, httpOptions: r } = e, o = t.startsWith("auth_tokens/"), i = o ? "v1alpha" : (r == null ? void 0 : r.apiVersion) || "v1beta";
    this.verboseLogging && console.log(`[CAM] API Version: ${i}`);
    const a = {
      ...r,
      apiVersion: i
    };
    o && i !== "v1alpha" && this.verboseLogging && console.warn("[CAM] Warning: Ephemeral tokens require v1alpha API version"), this.pendingApiKey = t, this.pendingHttpOptions = a, this.verboseLogging && console.log("[CAM] Config stored. Call start() to connect to Gemini API."), this.canvas = document.createElement("canvas"), this.ctx = this.canvas.getContext("2d"), this.face = new mP(), this.face.init(this), this.addEventListener("facechanged", (s) => {
      this.handleChangeEvent("face");
    }), this.addEventListener("skeletonchanged", (s) => {
      this.handleChangeEvent("skeleton");
    }), await this.startWebcam();
  }
  start() {
    if (!this.pendingApiKey) {
      this.verboseLogging && console.warn("[CAM] No pending config. Call init() first.");
      return;
    }
    this.connect(this.pendingApiKey, this.pendingHttpOptions);
  }
  async connect(e, t) {
    try {
      this.client = new wE({
        apiKey: e,
        httpOptions: t
      });
      const r = {
        responseModalities: [$i.TEXT],
        systemInstruction: {
          parts: [{
            text: `You are a real-time visual analyzer named Uni. When you see video frames, describe what you observe and provide analysis.

CRITICAL: You MUST respond with ONLY valid JSON. No text before or after. No markdown. No code blocks. Just the raw JSON object.

Required JSON format (EXACTLY these fields, nothing else):
{
  "transcript": "concise description of what you see in the frame, highlighting number of people, style of dress, colors",
  "analysis": "brief content analysis of people only (not environment) 1-2 sentences about the actions, expressions or poses",
  "sentiment": "very short sentiment analysis of the visual content",
  "tone": "a concise description of the mood or atmosphere",
  "emoji": "single emoji representing the visual content or emotion",
  "confidence": 0.85
}

Example response:
{"transcript": "A person sitting at a desk looking at a computer", "analysis": "Someone appears focused and engaged in work, likely in an office or study environment", "sentiment": "neutral", "tone": "Professional and concentrated atmosphere", "emoji": "", "confidence": 0.9}

Remember: Return ONLY the JSON object. No other text.`
          }]
        }
      };
      this.verboseLogging && (console.log("[CAM.GEMINI] Config:", r), console.log("[CAM.GEMINI] Response modalities:", r.responseModalities)), this.session = await this.client.live.connect({
        model: this.model,
        callbacks: {
          onopen: () => {
            this.verboseLogging && console.log("[CAM.GEMINI] Connected to Gemini Live"), e && (localStorage.setItem("apiKey", e), this.verboseLogging && console.log("[STORAGE] Saved API key to localStorage")), this.waitForVideoReady().then(() => {
              this.setupComplete = !0, this.verboseLogging && console.log("[CAM] SETUP COMPLETE"), this.video ? (this.isRecording = !0, this.verboseLogging && console.log("[CAM] Ready to send frames to Gemini on face/skeleton changes")) : console.error("[CAM] RACE CONDITION: NO VIDEO after waitForVideoReady() succeeded", {
                videoExists: !!this.video,
                setupComplete: this.setupComplete,
                mediaStreamExists: !!this.mediaStream
              });
            }).catch((o) => {
              console.error("[CAM] RACE CONDITION: Error waiting for video:", o.message, {
                error: o,
                videoExists: !!this.video,
                mediaStreamExists: !!this.mediaStream,
                setupComplete: this.setupComplete
              });
            });
          },
          onmessage: async (o) => {
            this.verboseLogging && console.log("[CAM.GEMINI] Message received:", o), this.handleGeminiResponse(o);
          },
          onerror: (o) => {
            console.error("[CAM.GEMINI] Error:", o);
          },
          onclose: (o) => {
            this.verboseLogging && (console.log("[CAM.GEMINI] Connection closed:", o), console.log("[CAM.GEMINI] Close reason:", o.reason)), this.isRecording = !1, this.setupComplete && this.disconnect();
          }
        },
        config: r
      });
    } catch (r) {
      console.error("Connection error:", r);
    }
  }
  async startWebcam() {
    try {
      this.verboseLogging && console.log("[CAM] Requesting webcam access..."), this.mediaStream = await navigator.mediaDevices.getUserMedia({
        video: {
          width: { ideal: 1280 },
          height: { ideal: 720 },
          facingMode: "user"
        }
      }), this.verboseLogging && console.log("[CAM] Webcam access granted"), this.video = document.createElement("video"), this.video.srcObject = this.mediaStream, this.video.playsInline = !0, this.video.muted = !0, await new Promise((e) => {
        this.video.onloadedmetadata = () => {
          this.canvas.width = this.video.videoWidth || 1280, this.canvas.height = this.video.videoHeight || 720, this.verboseLogging && console.log("[CAM] Video dimensions:", this.canvas.width, "x", this.canvas.height), e();
        };
      }), await this.video.play(), this.skeletal = new KC(), this.skeletal.init(this), this.startFaceProcessingLoop(), this.verboseLogging && console.log("[CAM] Webcam started for visualization");
    } catch (e) {
      console.error("[CAM] Error:", e);
    }
  }
  startFaceProcessingLoop() {
    const e = () => {
      this.face && this.face.faceRecognitionReady && this.video && this.canvas && this.video.readyState === this.video.HAVE_ENOUGH_DATA && (this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height), this.face.processFaces().catch((t) => {
        console.error("[FACE] Error in face processing:", t);
      })), this.faceProcessingInterval = setTimeout(e, 100);
    };
    e();
  }
  // Handle change events from face or skeleton modules
  handleChangeEvent(e) {
    if (this.verboseLogging && console.log(`[CAM] ${e.toUpperCase()} change event received`), !this.isRecording || !this.setupComplete || !this.session || !this.video) {
      this.verboseLogging && console.log(`[CAM] ${e.toUpperCase()} change ignored - not ready (isRecording: ${this.isRecording}, setupComplete: ${this.setupComplete}, session: ${!!this.session}, video: ${!!this.video})`);
      return;
    }
    const r = Date.now() - this.lastFrameSendTime;
    if (r < this.cooldownMs) {
      if (this.verboseLogging) {
        const o = this.cooldownMs - r;
        console.log(`[CAM] ${e.toUpperCase()} change ignored - cooldown active (${o.toFixed(0)}ms remaining)`);
      }
      return;
    }
    this.verboseLogging && (console.log("IS RECORDING: " + this.isRecording), console.log(`[CAM] ${e.toUpperCase()} change triggered frame send`)), this.captureAndSendFrame();
  }
  captureAndSendFrame() {
    if (!(!this.isRecording || !this.setupComplete || !this.session || !this.video) && this.video.readyState === this.video.HAVE_ENOUGH_DATA && this.video.videoWidth > 0 && this.video.videoHeight > 0) {
      this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height), this.face && this.face.faceRecognitionReady && this.face.processFaces().catch((e) => {
        console.error("[FACE] Error in face processing:", e);
      });
      try {
        const e = this.canvas.toDataURL("image/jpeg", 0.85), t = e.indexOf(","), r = t >= 0 ? e.substring(t + 1) : e;
        if (this.frameCount++, this.pendingFrames.push({
          inlineData: {
            data: r,
            mimeType: "image/jpeg"
          }
        }), this.frameCount >= this.framesPerTurn)
          try {
            this.session.sendClientContent({
              turns: [{
                role: "user",
                parts: this.pendingFrames
              }],
              turnComplete: !0
            }), this.lastFrameSendTime = Date.now(), this.pendingFrames.length = 0, this.frameCount = 0;
          } catch (o) {
            console.error("[CAM] Error sending frames:", o), this.pendingFrames.length = 0, this.frameCount = 0, o.message && o.message.includes("CLOSED") && (this.isRecording = !1);
          }
      } catch (e) {
        console.error("[CAM] Error sending video frame:", e), e.message && e.message.includes("CLOSED") && (this.isRecording = !1);
      }
    }
  }
  handleGeminiResponse(e) {
    var t, r, o;
    this.verboseLogging && console.log(e);
    try {
      if (this.verboseLogging && (console.log("[CAM.GEMINI] Processing message:", e), e.serverContent && console.log("[CAM.GEMINI] serverContent:", e.serverContent)), ((t = e.serverContent) == null ? void 0 : t.interrupted) && this.verboseLogging && console.log("[CAM.GEMINI] User interrupted"), (r = e.serverContent) != null && r.modelTurn) {
        this.currentTurnActive || (this.currentTurnActive = !0, this.verboseLogging && console.log("[CAM.GEMINI] Model turn started"));
        const a = e.serverContent.modelTurn.parts;
        if (this.verboseLogging && console.log("[CAM.GEMINI] Parts:", a), a && a.length > 0)
          for (const s of a)
            this.verboseLogging && console.log("[CAM.GEMINI] Part:", s, "Has text:", !!s.text, "Has audio:", !!s.inlineData), s.text && (this.verboseLogging && console.log("[CAM.GEMINI] Found text:", s.text), this.accumulatedTextParts.push(s.text));
      }
      if ((o = e.serverContent) != null && o.turnComplete) {
        this.currentTurnActive = !1;
        const a = this.accumulatedTextParts.length > 0 ? this.accumulatedTextParts.join("") : "";
        if (this.verboseLogging && (console.log("[CAM.GEMINI] Turn complete - processing full response"), console.log("[CAM.GEMINI] Accumulated text so far:", a)), a && a.trim().length > 0) {
          const s = this.parseResponse(a);
          if (s) {
            const { transcript: u, analysis: l, tone: c, emoji: f, confidence: d, sentiment: p } = s;
            u && l && this.emitPercept({ transcript: u, analysis: l, tone: c, emoji: f, sentiment: p, confidence: d });
          }
        } else
          this.verboseLogging && console.log("[CAM.GEMINI] Turn complete but no text received");
        this.accumulatedTextParts.length = 0;
      }
    } catch (i) {
      console.error("[CAM.GEMINI] Error processing response:", i, "Message:", e), this.accumulatedTextParts.length = 0, this.currentTurnActive = !1;
    }
  }
  // Parse response - normalize Gemini's actual response format
  // Handles variations: transcription vs transcript, nested analysis objects, etc.
  parseResponse(e) {
    var a, s, u, l, c, f, d;
    const t = e.trim();
    try {
      let p;
      try {
        p = JSON.parse(t);
      } catch {
        const C = e.match(this.regexPatterns.jsonExtract);
        if (C)
          p = JSON.parse(C[0]);
        else
          throw new Error("No JSON found");
      }
      const v = p.transcript || p.transcription || null;
      let g = null;
      if (typeof p.analysis == "string")
        g = p.analysis;
      else if (typeof p.analysis == "object" && p.analysis !== null) {
        const E = p.analysis;
        E.uni_personal_reaction ? g = E.uni_personal_reaction : E.response_suggestion ? g = E.response_suggestion : (this.reusablePartsArray.length = 0, (a = E.sentiment) != null && a.overall && this.reusablePartsArray.push(`Sentiment: ${E.sentiment.overall}`), E.tone && this.reusablePartsArray.push(`Tone: ${E.tone}`), E.emotion_detected && this.reusablePartsArray.push(`Emotion: ${E.emotion_detected}`), g = this.reusablePartsArray.length > 0 ? this.reusablePartsArray.join(". ") : JSON.stringify(E));
      }
      let y = null;
      typeof p.sentiment == "string" ? y = p.sentiment : (s = p.sentiment) != null && s.overall ? y = p.sentiment.overall : (l = (u = p.analysis) == null ? void 0 : u.sentiment) != null && l.overall && (y = p.analysis.sentiment.overall);
      let x = null;
      typeof p.tone == "string" ? x = p.tone : (c = p.tone) != null && c.overall ? x = p.tone.overall : (d = (f = p.analysis) == null ? void 0 : f.tone) != null && d.overall && (x = p.analysis.tone.overall);
      const w = p.emoji || null;
      let b = p.confidence;
      typeof b == "string" && (b = parseFloat(b)), (isNaN(b) || b === null || b === void 0) && (b = null);
      const _ = {
        transcript: v,
        analysis: g,
        sentiment: y,
        tone: x,
        emoji: w || "",
        confidence: b
      };
      if (v || g)
        return _;
    } catch (p) {
      this.verboseLogging && console.log("[CAM.GEMINI] JSON parse failed, using regex fallback:", p.message);
    }
    const r = this.extractTranscript(e), o = this.extractAnalysis(e);
    this.extractTone(e);
    const i = this.extractEmoji(e);
    return r || o ? { transcript: r, analysis: o, emoji: i } : null;
  }
  extractTranscript(e) {
    const t = e.match(this.regexPatterns.transcript);
    return t && t[1] ? t[1].trim() : null;
  }
  extractAnalysis(e) {
    const t = e.match(this.regexPatterns.analysis);
    return t && t[1] ? t[1].trim() : e.replace(this.regexPatterns.transcriptRemove, "").replace(this.regexPatterns.emojiRemove, "").trim();
  }
  extractTone(e) {
    const t = e.match(this.regexPatterns.tone);
    return t && t[1] ? t[1].trim() : e.replace(this.regexPatterns.toneRemove, "").replace(this.regexPatterns.emojiRemove, "").trim();
  }
  extractEmoji(e) {
    const t = e.match(this.regexPatterns.emoji);
    if (t && t[1])
      return this.verboseLogging && console.log("[EMOJI] Matched from pattern:", t[1]), t[1].substring(0, 2);
    const r = e.match(this.regexPatterns.emojiFallback);
    return r ? r[0] : "";
  }
  emitPercept(e) {
    this.eventTarget.dispatchEvent(new CustomEvent("percept", { detail: e }));
  }
  addEventListener(e, t) {
    this.eventTarget.addEventListener(e, t);
  }
  removeEventListener(e, t) {
    this.eventTarget.removeEventListener(e, t);
  }
  // Getter methods for visualizer access
  getCurrentFaces() {
    return this.face ? this.face.getCurrentFaces() : [];
  }
  getKnownFaces() {
    return this.face ? this.face.getKnownFaces() : [];
  }
  getFaceData(e) {
    return this.face ? this.face.getFaceData(e) : null;
  }
  // Getter methods for skeletal data
  getCurrentPoseLandmarks() {
    return this.skeletal ? this.skeletal.getCurrentPoseLandmarks() : null;
  }
  getSkeletalLandmarkVisibility(e) {
    return this.skeletal ? this.skeletal.getLandmarkVisibility(e) : 1;
  }
  // Set verbose logging flag
  setVerboseLogging(e) {
    this.verboseLogging = e;
  }
  // Wait for video to be ready before enabling recording
  async waitForVideoReady() {
    var i, a, s, u, l, c, f;
    const r = Date.now();
    for (console.log("[CAM] Waiting for video to be ready...", {
      videoExists: !!this.video,
      videoReadyState: (i = this.video) == null ? void 0 : i.readyState,
      videoWidth: (a = this.video) == null ? void 0 : a.videoWidth,
      videoHeight: (s = this.video) == null ? void 0 : s.videoHeight
    }); Date.now() - r < 5e3; ) {
      if (this.video && this.video.readyState >= this.video.HAVE_METADATA && this.video.videoWidth > 0 && this.video.videoHeight > 0) {
        this.verboseLogging && console.log("[CAM] Video is ready");
        return;
      }
      await new Promise((d) => setTimeout(d, 100));
    }
    const o = Date.now() - r;
    throw console.error("[CAM] RACE CONDITION: Video not ready within timeout period", {
      elapsedMs: o,
      videoExists: !!this.video,
      videoReadyState: (u = this.video) == null ? void 0 : u.readyState,
      videoWidth: (l = this.video) == null ? void 0 : l.videoWidth,
      videoHeight: (c = this.video) == null ? void 0 : c.videoHeight,
      mediaStreamExists: !!this.mediaStream,
      mediaStreamActive: (f = this.mediaStream) == null ? void 0 : f.active,
      setupComplete: this.setupComplete,
      isRecording: this.isRecording
    }), new Error("Video not ready within timeout period");
  }
  disconnect() {
    this.faceProcessingInterval && (clearTimeout(this.faceProcessingInterval), this.faceProcessingInterval = null), this.mediaStream && (this.mediaStream.getTracks().forEach((e) => e.stop()), this.mediaStream = null), this.video && (this.video.pause(), this.video.srcObject = null, this.video = null), this.canvas && (this.canvas = null, this.ctx = null), this.session && (this.session.close(), this.session = null), this.client = null, this.face && (this.face.disconnect(), this.face = null), this.skeletal && (this.skeletal.disconnect(), this.skeletal = null), this.isRecording = !1, this.setupComplete = !1, this.accumulatedTextParts.length = 0, this.currentTurnActive = !1, this.frameCount = 0, this.pendingFrames.length = 0, this.lastFrameSendTime = 0;
  }
}
export {
  VN as Cam,
  mP as CamFace,
  KC as CamSkeletal
};
